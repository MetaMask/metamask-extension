import type { Options } from 'yargs';
import yargs from 'yargs/yargs';
import { Browsers, type Browser, type Manifest } from './helpers';

type Optionses = { [key: string]: Options };
type OptionsKeys = keyof Omit<
  ReturnType<typeof getOptions>,
  'add_feature' | 'omit_feature'
>;

// `envOptions` is a separate object because it is used multiple times
const envOptions = {
  env: {
    alias: 'e',
    array: false,
    default: 'development' as const,
    description:
      'Enables/disables production optimizations or development hints.',
    choices: ['development', 'production'] as const,
    group: 'Build options:',
  },
  // `as const` makes it easier for developers to see the values of the type
  // when hovering over it in their IDE. `satisfies Options` enables type
  // checking, without loosing the `const` property of the values, which is
  // necessary for yargs to infer the final types
} as const satisfies Optionses;

// TODO: get these `build-type` types working without having to use `as` here.
const { loadBuildTypesConfig } = require('../development/lib/build-type') as {
  loadBuildTypesConfig: () => {
    features: { [x: string]: unknown };
    buildTypes: { [x: string]: { features: string[] } };
  };
};

/**
 * Yargs doesn't support comma-separated arrays, e.g.,
 * `program --multi one,two,three --multi four`, this function gives us the
 * ability to "coerce" the CSV string into an array, so the result will now be:
 * `{ multi: ['one', 'two', 'three', 'four'] }`.
 *
 * Note: CSV parsing is a naive string-split-on-comma approach, this isn't a
 * full CSV parser.
 *
 * @param array
 */
function parseArrayOptionAsCsv<T extends string = string>(
  array: string[],
): T[] {
  return array.flatMap<T>((value) => value.split(',') as T[]);
}

/**
 * Parses the given args from `argv` and returns whether or not the build is
 * for production.
 *
 * @param argv
 * @param envOptions
 * @param options
 * @returns
 */
function getIsProduction(argv: string[], options: typeof envOptions): boolean {
  const { env } = yargs()
    .help(false)
    .version(false)
    .showHelpOnFail(false)
    .options(options)
    .parseSync(argv);
  return env === 'production';
}

/**
 * Parses an array of command line arguments into a structured format.
 *
 * @param argv - An array of command line arguments, excluding the program
 * executable and file name. Typically used as
 * `parseArgv(process.argv.slice(2))`.
 * @returns An object representing the parsed arguments.
 */
export const parseArgv = (argv: string[]) => {
  const { features: allFeatures, buildTypes } = loadBuildTypesConfig();
  const allBuildTypeNames = Object.keys(buildTypes);
  const allFeatureNames = Object.keys(allFeatures);

  // peek ahead at the args to determine if we're in a production environment as
  // some defaults are different for production vs development.
  const isProduction = getIsProduction(argv, envOptions);

  const options = getOptions(isProduction, allBuildTypeNames, allFeatureNames);
  const args = generateCli(options, 'yarn webpack').parseSync(argv);
  // the properties $0, _, a, o, etc. are added by yargs, but we don't need to
  // return them to the caller, so we omit them here
  const { $0, _, a, o, add_feature: add, omit_feature: omit, ...config } = args;

  // set up feature flags
  const active = new Set<string>();
  const defaultFeaturesForBuildType = buildTypes[config.type]?.features ?? [];
  const setActive = (f: string) => omit.includes(f) || active.add(f);
  [defaultFeaturesForBuildType, add].forEach((a) => a.forEach(setActive));

  return {
    features: {
      active,
      all: new Set(allFeatureNames),
    },
    // narrow the `config` type to only the options we're returning
    config: config as {
      [key in OptionsKeys]: (typeof config)[key];
    },
  };
};

/**
 * Generates a yargs instance for parsing CLI arguments.
 *
 * @param argv
 * @param options
 * @param command
 * @param name
 */
export function generateCli<
  T extends Optionses = ReturnType<typeof getOptions>,
>(options: T, name: string) {
  const cli = yargs()
    // Ensure unrecognized commands/options are reported as errors.
    .strict()
    // use the scriptName in `--help` output
    .scriptName(name)
    // wrap output at a maximum of 120 characters or `process.stdout.columns`
    .wrap(Math.min(120, process.stdout.columns))
    // enable the `--config` command, which allows the user to specify a custom
    // config file containing webpack options
    .config()
    // enable ENV parsing, which allows the user to specify webpack options via
    // environment variables prefixed with `BUNDLE_`
    // TODO: choose a better name than `BUNDLE` (it looks like `MM` is already being used in CI for ✨something✨)
    .env('BUNDLE')
    // enable the `completion` command, which outputs a bash completion script
    .completion(
      'completion',
      'Enable bash/zsh completions; concat the script generated by running this command to your .bashrc or .bash_profile',
    )
    .example(
      '$0 --env development --browser brave --browser chrome --zip',
      'Builds the extension for development for Chrome & Brave; generate zip files for both',
    )
    .example(
      '$0 completion',
      `Generates a bash completion script for the \`${name}\` command`,
    )
    .options(options)
  return cli;
}

function getOptions(
  isProduction: boolean,
  buildTypes: string[],
  allFeatures: string[],
) {
  const securityDesc = "If `env` is 'production', `true`, otherwise `false`";
  return {
    ...envOptions,
    watch: {
      alias: 'w',
      array: false,
      default: false,
      description: 'Build then watch for files changes',
      group: 'Developer assistance:',
      type: 'boolean',
    },
    cache: {
      alias: 'c',
      array: false,
      default: true,
      description: 'Cache build for faster rebuilds',
      group: 'Developer assistance:',
      type: 'boolean',
    },
    progress: {
      alias: 'p',
      array: false,
      default: true,
      description: 'Show build progress',
      group: 'Developer assistance:',
      type: 'boolean',
    },
    devtool: {
      alias: 'd',
      array: false,
      default: isProduction ? 'hidden-source-map' : 'source-map',
      defaultDescription:
        "If `env` is 'production', 'hidden-source-map', otherwise 'source-map'",
      description: 'Sourcemap type to generate',
      choices: ['none', 'source-map', 'hidden-source-map'] as const,
      group: 'Developer assistance:',
      type: 'string',
    },
    zip: {
      alias: 'z',
      array: false,
      default: false,
      description: 'Generate a zip file of the build',
      group: 'Build options:',
      type: 'boolean',
    },
    minify: {
      alias: 'm',
      array: false,
      default: isProduction,
      defaultDescription: "If `env` is 'production', `true`, otherwise `false`",
      description: 'Minify the output',
      group: 'Build options:',
      type: 'boolean',
    },
    browser: {
      alias: 'b',
      array: true,
      choices: ['all', ...Browsers],
      coerce: (array: string[]) => {
        const browsers = parseArrayOptionAsCsv<Browser | 'all'>(array);
        const set = new Set(browsers);
        return set.has('all') ? [...Browsers] : [...set];
      },
      default: 'chrome',
      description: 'Browsers to build for',
      group: 'Build options:',
      type: 'string',
    },
    manifest_version: {
      alias: 'v',
      array: false,
      choices: [2, 3] as Manifest['manifest_version'][],
      default: 2 as Manifest['manifest_version'],
      description: "Changes manifest.json format to the given version's schema",
      group: 'Build options:',
      type: 'number',
    },
    type: {
      alias: 't',
      array: false,
      choices: ['none', ...buildTypes],
      default: 'main' as const,
      description: 'Configure features for the build (main, beta, etc)',
      group: 'Build options:',
      type: 'string',
    },
    add_feature: {
      alias: 'a',
      array: true,
      choices: allFeatures,
      coerce: parseArrayOptionAsCsv,
      default: [] as typeof allFeatures,
      description: 'Add features not be included in the selected build `type`',
      group: 'Build options:',
      type: 'string',
    },
    omit_feature: {
      alias: 'o',
      array: true,
      choices: allFeatures,
      coerce: parseArrayOptionAsCsv,
      default: [] as typeof allFeatures,
      description: 'Omit features included in the selected build `type`',
      group: 'Build options:',
      type: 'string',
    },
    lavamoat: {
      alias: 'l',
      array: false,
      default: isProduction,
      defaultDescription: securityDesc,
      description: 'Apply LavaMoat to the build assets',
      group: 'Security:',
      type: 'boolean',
    },
    snow: {
      alias: 's',
      array: false,
      default: isProduction,
      defaultDescription: securityDesc,
      description: 'Apply Snow to the build assets',
      group: 'Security:',
      type: 'boolean',
    },
  } as const satisfies Optionses;
}
