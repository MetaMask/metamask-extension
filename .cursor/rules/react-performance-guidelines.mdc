---
description: Project Guidelines for React Performance Optimization
globs: *.tsx,*.jsx,ui/components/**/*,ui/pages/**/*,ui/hooks/**/*
alwaysApply: false
---

# React Performance Optimization Guidelines

Guidelines for optimizing React component performance in MetaMask Extension.

---

## Understanding React's Render Cycle

React's rendering process has three steps:
1. **Trigger** - Initial render or state update
2. **Render** - React calls components to determine what to display
3. **Commit** - React updates the DOM with minimal necessary changes

**Key Insight:** React only changes the DOM if there's a difference between renders. The rendering process is recursive - when a component updates, all its children re-render by default, which can cause performance issues in large component trees.

Reference: [React: Render and Commit](https://react.dev/learn/render-and-commit)

---

## Core Principles

### 1. Keep Components Pure

**Rendering must always be a pure calculation:**
- Same inputs → same output (deterministic)
- No side effects during render
- No mutation of external state

```typescript
❌ WRONG: Impure component
let count = 0;

const ImpureComponent = ({ multiplier }: Props) => {
  count++; // Side effect during render
  return <div>{count * multiplier}</div>;
};

✅ CORRECT: Pure component
const PureComponent = ({ multiplier, count }: Props) => {
  return <div>{count * multiplier}</div>;
};
```

### 2. Don't Optimize Prematurely

- Profile first, optimize second
- Focus on components that actually cause performance issues
- Use React DevTools Profiler to identify bottlenecks
- Measure before and after optimization

---

## Preventing Unnecessary Re-renders

### Use React.memo for Expensive Components

Wrap components in `React.memo` to skip re-renders when props haven't changed.

```typescript
❌ WRONG: Component re-renders even when props are the same
const TokenListItem = ({ token, onSelect }: TokenListItemProps) => {
  return (
    <div onClick={() => onSelect(token)}>
      {token.symbol} - {token.balance}
    </div>
  );
};

✅ CORRECT: Memoized component
const TokenListItem = React.memo(({ token, onSelect }: TokenListItemProps) => {
  return (
    <div onClick={() => onSelect(token)}>
      {token.symbol} - {token.balance}
    </div>
  );
});

// Or with custom comparison
const TokenListItem = React.memo(
  ({ token, onSelect }: TokenListItemProps) => {
    return (
      <div onClick={() => onSelect(token)}>
        {token.symbol} - {token.balance}
      </div>
    );
  },
  (prevProps, nextProps) => {
    // Return true if props are equal (skip re-render)
    return prevProps.token.address === nextProps.token.address &&
           prevProps.token.balance === nextProps.token.balance;
  }
);
```

**When to use React.memo:**
- ✅ Component renders often with same props
- ✅ Component is expensive to render (complex calculations, large lists)
- ✅ Component is in the middle of a frequently updating tree
- ❌ Props change frequently
- ❌ Component is already fast to render

### Use useMemo for Expensive Calculations

Memoize expensive computations so they only run when dependencies change.

```typescript
❌ WRONG: Expensive calculation runs on every render
const TokenList = ({ tokens }: TokenListProps) => {
  // This sorts on EVERY render, even if tokens haven't changed
  const sortedTokens = tokens
    .slice()
    .sort((a, b) => parseFloat(b.balance) - parseFloat(a.balance));

  return (
    <div>
      {sortedTokens.map(token => (
        <TokenItem key={token.address} token={token} />
      ))}
    </div>
  );
};

✅ CORRECT: Memoized calculation
const TokenList = ({ tokens }: TokenListProps) => {
  const sortedTokens = useMemo(() => {
    return tokens
      .slice()
      .sort((a, b) => parseFloat(b.balance) - parseFloat(a.balance));
  }, [tokens]); // Only re-sort when tokens array changes

  return (
    <div>
      {sortedTokens.map(token => (
        <TokenItem key={token.address} token={token} />
      ))}
    </div>
  );
};
```

**When to use useMemo:**
- ✅ Expensive calculations (sorting, filtering large arrays)
- ✅ Creating objects/arrays passed as props to memoized children
- ✅ Dependencies change infrequently
- ❌ Simple calculations (accessing properties, basic math)
- ❌ Dependencies change on every render

### Use useCallback for Stable Function References

Memoize callback functions to prevent child components from re-rendering.

```typescript
❌ WRONG: New function created on every render
const TokenList = ({ tokens, onTokenSelect }: TokenListProps) => {
  // New function reference on every render → children always re-render
  const handleSelect = (tokenAddress: string) => {
    onTokenSelect(tokenAddress);
    trackEvent('token_selected');
  };

  return (
    <div>
      {tokens.map(token => (
        <TokenItem
          key={token.address}
          token={token}
          onSelect={handleSelect} // Different reference each time!
        />
      ))}
    </div>
  );
};

✅ CORRECT: Memoized callback
const TokenList = ({ tokens, onTokenSelect }: TokenListProps) => {
  const handleSelect = useCallback((tokenAddress: string) => {
    onTokenSelect(tokenAddress);
    trackEvent('token_selected');
  }, [onTokenSelect]); // Only recreate if onTokenSelect changes

  return (
    <div>
      {tokens.map(token => (
        <TokenItem
          key={token.address}
          token={token}
          onSelect={handleSelect} // Same reference!
        />
      ))}
    </div>
  );
};
```

**When to use useCallback:**
- ✅ Function passed to memoized child components
- ✅ Function used as useEffect dependency
- ✅ Function passed to many children
- ❌ Function not passed as prop
- ❌ Function dependencies change frequently

---

## Avoiding Inline Objects and Functions

### Don't Create Objects/Arrays in JSX

```typescript
❌ WRONG: New object created on every render
const TokenDisplay = ({ token }: TokenDisplayProps) => {
  return (
    <TokenCard
      token={token}
      style={{ padding: 16, margin: 8 }} // New object each render!
      options={{ showBalance: true, showIcon: true }} // New object each render!
    />
  );
};

✅ CORRECT: Define outside component or use useMemo
const TOKEN_CARD_STYLE = { padding: 16, margin: 8 };
const DEFAULT_OPTIONS = { showBalance: true, showIcon: true };

const TokenDisplay = ({ token }: TokenDisplayProps) => {
  return (
    <TokenCard
      token={token}
      style={TOKEN_CARD_STYLE}
      options={DEFAULT_OPTIONS}
    />
  );
};

// Or if dynamic:
const TokenDisplay = ({ token, showIcon }: TokenDisplayProps) => {
  const options = useMemo(() => ({
    showBalance: true,
    showIcon
  }), [showIcon]);

  return <TokenCard token={token} options={options} />;
};
```

### Don't Define Functions in JSX

```typescript
❌ WRONG: New function on every render
const TokenList = ({ tokens }: TokenListProps) => {
  return (
    <div>
      {tokens.map(token => (
        <TokenItem
          key={token.address}
          token={token}
          onClick={() => handleClick(token.address)} // New function!
        />
      ))}
    </div>
  );
};

✅ CORRECT: Define handler outside JSX
const TokenList = ({ tokens }: TokenListProps) => {
  const handleClick = useCallback((address: string) => {
    // Handle click
  }, []);

  return (
    <div>
      {tokens.map(token => (
        <TokenItem
          key={token.address}
          token={token}
          onClick={handleClick}
          address={token.address} // Pass address as prop
        />
      ))}
    </div>
  );
};
```

---

## Optimizing Lists and Large Datasets

### Use Proper Keys

```typescript
❌ WRONG: Using array index as key
const TokenList = ({ tokens }: TokenListProps) => {
  return (
    <div>
      {tokens.map((token, index) => (
        <TokenItem key={index} token={token} /> // Bad if list can reorder!
      ))}
    </div>
  );
};

✅ CORRECT: Use unique, stable identifiers
const TokenList = ({ tokens }: TokenListProps) => {
  return (
    <div>
      {tokens.map(token => (
        <TokenItem key={token.address} token={token} />
      ))}
    </div>
  );
};
```

**Key rules:**
- ✅ Use unique IDs from data (address, id, uuid)
- ✅ Keys must be stable across re-renders
- ⚠️ Only use index if list never reorders and items don't have IDs
- ❌ Never use random values or `Math.random()`

### Virtualize Long Lists

For lists with 100+ items, use virtualization to only render visible items.

```typescript
❌ WRONG: Rendering 1000+ items at once
const TransactionList = ({ transactions }: TransactionListProps) => {
  return (
    <div className="transaction-list">
      {transactions.map(tx => (
        <TransactionItem key={tx.hash} transaction={tx} />
      ))}
    </div>
  );
};

✅ CORRECT: Use virtualization library
import { FixedSizeList } from 'react-window';

const TransactionList = ({ transactions }: TransactionListProps) => {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>
      <TransactionItem transaction={transactions[index]} />
    </div>
  );

  return (
    <FixedSizeList
      height={600}
      itemCount={transactions.length}
      itemSize={80}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
};
```

**Recommended libraries:**
- `react-window` - Lightweight, recommended for most use cases
- `react-virtualized` - More features, larger bundle size

### Pagination and Infinite Scroll

For very large datasets, load data in chunks.

```typescript
✅ GOOD: Paginated data loading
const TransactionList = () => {
  const [page, setPage] = useState(1);
  const { transactions, hasMore, isLoading } = useTransactionsPaginated(page);

  const loadMore = useCallback(() => {
    if (!isLoading && hasMore) {
      setPage(p => p + 1);
    }
  }, [isLoading, hasMore]);

  return (
    <div>
      {transactions.map(tx => (
        <TransactionItem key={tx.hash} transaction={tx} />
      ))}
      {hasMore && (
        <button onClick={loadMore} disabled={isLoading}>
          Load More
        </button>
      )}
    </div>
  );
};
```

---

## Code Splitting and Lazy Loading

### Use React.lazy for Route-Based Splitting

```typescript
❌ WRONG: Import all pages upfront
import Settings from './pages/Settings';
import Tokens from './pages/Tokens';
import Activity from './pages/Activity';

const App = () => {
  return (
    <Routes>
      <Route path="/settings" element={<Settings />} />
      <Route path="/tokens" element={<Tokens />} />
      <Route path="/activity" element={<Activity />} />
    </Routes>
  );
};

✅ CORRECT: Lazy load pages
import { lazy, Suspense } from 'react';

const Settings = lazy(() => import('./pages/Settings'));
const Tokens = lazy(() => import('./pages/Tokens'));
const Activity = lazy(() => import('./pages/Activity'));

const App = () => {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Routes>
        <Route path="/settings" element={<Settings />} />
        <Route path="/tokens" element={<Tokens />} />
        <Route path="/activity" element={<Activity />} />
      </Routes>
    </Suspense>
  );
};
```

### Lazy Load Heavy Components

```typescript
✅ GOOD: Lazy load modals and heavy components
const QRCodeScanner = lazy(() => import('./components/QRCodeScanner'));

const SendToken = () => {
  const [showScanner, setShowScanner] = useState(false);

  return (
    <div>
      <input placeholder="Recipient address" />
      <button onClick={() => setShowScanner(true)}>
        Scan QR Code
      </button>

      {showScanner && (
        <Suspense fallback={<div>Loading scanner...</div>}>
          <QRCodeScanner onScan={handleScan} />
        </Suspense>
      )}
    </div>
  );
};
```

---

## State Management Optimization

### Split State to Minimize Re-renders

```typescript
❌ WRONG: Single state object causes re-renders
const TokenSwap = () => {
  const [formState, setFormState] = useState({
    fromToken: null,
    toToken: null,
    amount: '',
    slippage: 0.5,
    isLoading: false,
  });

  // Any change to formState re-renders everything!
  const updateAmount = (amount: string) => {
    setFormState(prev => ({ ...prev, amount }));
  };

  return (
    <>
      <TokenSelector value={formState.fromToken} />
      <AmountInput value={formState.amount} onChange={updateAmount} />
      <SlippageSettings value={formState.slippage} />
    </>
  );
};

✅ CORRECT: Split state by update frequency
const TokenSwap = () => {
  const [fromToken, setFromToken] = useState(null);
  const [toToken, setToToken] = useState(null);
  const [amount, setAmount] = useState(''); // Updated frequently
  const [slippage, setSlippage] = useState(0.5); // Updated rarely
  const [isLoading, setIsLoading] = useState(false);

  return (
    <>
      <TokenSelector value={fromToken} onChange={setFromToken} />
      <AmountInput value={amount} onChange={setAmount} />
      <SlippageSettings value={slippage} onChange={setSlippage} />
    </>
  );
};
```

### Use Context Sparingly

```typescript
❌ WRONG: Single large context causes all consumers to re-render
const AppContext = createContext({
  user: null,
  tokens: [],
  transactions: [],
  settings: {},
  // ... many more properties
});

// Every component using this context re-renders when ANY value changes!

✅ CORRECT: Split contexts by concern and update frequency
const UserContext = createContext(null);
const TokensContext = createContext([]);
const SettingsContext = createContext({});

// Only components using specific context re-render
```

### Optimize Context with useMemo

```typescript
✅ GOOD: Memoize context value
const ThemeProvider = ({ children }: ThemeProviderProps) => {
  const [theme, setTheme] = useState('light');

  // Without useMemo, new object created on every render
  const value = useMemo(() => ({
    theme,
    setTheme,
  }), [theme]);

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
};
```

---

## Component Composition Patterns

### Use Component Composition to Prevent Re-renders

```typescript
❌ WRONG: Children re-render when parent state changes
const Dashboard = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>
        Count: {count}
      </button>
      <ExpensiveChart /> {/* Re-renders unnecessarily! */}
      <ExpensiveTable /> {/* Re-renders unnecessarily! */}
    </div>
  );
};

✅ CORRECT: Move state down
const Dashboard = () => {
  return (
    <div>
      <Counter /> {/* Only this re-renders */}
      <ExpensiveChart />
      <ExpensiveTable />
    </div>
  );
};

const Counter = () => {
  const [count, setCount] = useState(0);
  return (
    <button onClick={() => setCount(c => c + 1)}>
      Count: {count}
    </button>
  );
};

✅ ALSO CORRECT: Pass children as props
const Dashboard = ({ children }: { children: React.ReactNode }) => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>
        Count: {count}
      </button>
      {children} {/* Children don't re-render! */}
    </div>
  );
};

// Usage:
<Dashboard>
  <ExpensiveChart />
  <ExpensiveTable />
</Dashboard>
```

---

## useEffect Optimization

### Don't Overuse useEffect

Many operations don't need effects. See: [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)

```typescript
❌ WRONG: Using effect for derived state
const TokenDisplay = ({ token }: TokenDisplayProps) => {
  const [displayName, setDisplayName] = useState('');

  useEffect(() => {
    setDisplayName(`${token.symbol} (${token.name})`);
  }, [token]);

  return <div>{displayName}</div>;
};

✅ CORRECT: Calculate during render
const TokenDisplay = ({ token }: TokenDisplayProps) => {
  const displayName = `${token.symbol} (${token.name})`;
  return <div>{displayName}</div>;
};
```

### Minimize useEffect Dependencies

```typescript
❌ WRONG: Too many dependencies
const TokenBalance = ({ address, network, refreshInterval }: Props) => {
  const [balance, setBalance] = useState('0');

  useEffect(() => {
    const fetch = async () => {
      const result = await fetchBalance(address, network);
      setBalance(result);
    };

    fetch();
    const interval = setInterval(fetch, refreshInterval);
    return () => clearInterval(interval);
  }, [address, network, refreshInterval]); // Effect runs too often

  return <div>{balance}</div>;
};

✅ CORRECT: Reduce dependencies
const TokenBalance = ({ address, network, refreshInterval = 10000 }: Props) => {
  const [balance, setBalance] = useState('0');

  useEffect(() => {
    const fetch = async () => {
      const result = await fetchBalance(address, network);
      setBalance(result);
    };

    fetch();
    const interval = setInterval(fetch, refreshInterval);
    return () => clearInterval(interval);
  }, [address, network]); // refreshInterval moved to default param

  return <div>{balance}</div>;
};
```

---

## Profiling and Measurement

### Use React DevTools Profiler

1. Install React DevTools browser extension
2. Open DevTools → Profiler tab
3. Click record, perform actions, stop recording
4. Analyze flame graph for slow components
5. Look for:
   - Components taking long to render
   - Components re-rendering unnecessarily
   - Deep component trees

### Use Performance API

```typescript
✅ GOOD: Measure performance programmatically
const ExpensiveComponent = () => {
  useEffect(() => {
    performance.mark('expensive-render-start');

    return () => {
      performance.mark('expensive-render-end');
      performance.measure(
        'expensive-render',
        'expensive-render-start',
        'expensive-render-end'
      );

      const measure = performance.getEntriesByName('expensive-render')[0];
      console.log(`Render took ${measure.duration}ms`);
    };
  });

  // Component logic
};
```

### Log Render Reasons in Development

```typescript
✅ GOOD: Debug why component renders (development only)
const TokenListItem = ({ token, onSelect }: TokenListItemProps) => {
  if (process.env.NODE_ENV === 'development') {
    console.log('TokenListItem render:', token.address);
  }

  return (
    <div onClick={() => onSelect(token)}>
      {token.symbol}
    </div>
  );
};

// Or use React DevTools "Highlight updates when components render"
```

---

## Performance Checklist

Before considering a component optimized:

### Measurement
- [ ] Profiled with React DevTools Profiler
- [ ] Identified actual bottleneck (not premature optimization)
- [ ] Measured before and after optimization
- [ ] Verified improvement in real-world usage

### Component Structure
- [ ] Component is pure (no side effects during render)
- [ ] State is split appropriately (by update frequency)
- [ ] Large components broken into smaller sub-components
- [ ] Heavy components lazy loaded when possible

### Memoization
- [ ] Expensive components wrapped in React.memo
- [ ] Expensive calculations use useMemo
- [ ] Callbacks passed to children use useCallback
- [ ] No inline objects/functions in JSX
- [ ] Context values are memoized

### Lists
- [ ] Lists use stable, unique keys (not array index unless static)
- [ ] Large lists (100+ items) use virtualization
- [ ] Very large datasets use pagination/infinite scroll

### Effects
- [ ] No unnecessary useEffect (prefer calculation during render)
- [ ] Effect dependencies minimized
- [ ] Effects properly cleaned up

### Code Splitting
- [ ] Routes are lazy loaded
- [ ] Heavy components are lazy loaded
- [ ] Suspense boundaries in appropriate places

---

## Common Performance Anti-Patterns

### ❌ Anti-Pattern: Premature Optimization

```typescript
// Don't do this unless you have measured a performance problem!
const TinyComponent = React.memo(({ value }: { value: string }) => {
  return <span>{value}</span>; // Too simple to benefit from memo
});
```

**Solution:** Profile first, optimize what matters.

### ❌ Anti-Pattern: Memoizing Everything

```typescript
// This is overkill and adds unnecessary complexity
const SimpleComponent = React.memo(() => {
  const value1 = useMemo(() => prop1 + prop2, [prop1, prop2]);
  const value2 = useMemo(() => prop3 * 2, [prop3]);
  const handler = useCallback(() => {}, []);

  return <div onClick={handler}>{value1} {value2}</div>;
});
```

**Solution:** Only memoize expensive operations or when passing to memoized children.

### ❌ Anti-Pattern: Wrong Dependencies in useMemo/useCallback

```typescript
const TokenList = ({ tokens, filter }: TokenListProps) => {
  // Dependencies are wrong - should include filter!
  const filteredTokens = useMemo(() => {
    return tokens.filter(token => token.symbol.includes(filter));
  }, [tokens]); // Missing filter dependency!

  return <div>...</div>;
};
```

**Solution:** Always include all dependencies. Use ESLint rule `react-hooks/exhaustive-deps`.

### ❌ Anti-Pattern: Using Index as Key for Dynamic Lists

```typescript
const TokenList = ({ tokens }: TokenListProps) => {
  // If tokens can be reordered/filtered, this breaks React's reconciliation
  return (
    <div>
      {tokens.map((token, index) => (
        <TokenItem key={index} token={token} />
      ))}
    </div>
  );
};
```

**Solution:** Use unique, stable identifiers from data.

---

## Resources

- [React: Render and Commit](https://react.dev/learn/render-and-commit)
- [React: You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)
- [React DevTools Profiler](https://react.dev/learn/react-developer-tools)
- [react-window](https://github.com/bvaughn/react-window)
- [Web Vitals](https://web.dev/vitals/)

---

## Summary

**Key Takeaways:**
1. **Profile before optimizing** - Don't guess, measure
2. **Keep components pure** - Same inputs = same outputs
3. **Use memoization judiciously** - React.memo, useMemo, useCallback for expensive operations
4. **Avoid inline objects/functions** - Create stable references
5. **Split state appropriately** - By update frequency and concern
6. **Virtualize large lists** - Render only visible items
7. **Lazy load heavy components** - Code split by route and feature
8. **Optimize context usage** - Split contexts and memoize values
9. **Use proper keys** - Unique, stable identifiers for lists
10. **Don't overuse effects** - Calculate during render when possible

**Remember:** React is fast by default. Only optimize components that cause measurable performance issues in production usage.
