name: Tag Release Branch

on:
  workflow_dispatch:
    inputs:
      release-version:
        description: 'Release version (e.g., 12.0.0)'
        required: true
        type: string
      release-branch:
        description: 'Release branch name (e.g., Version-v12.0.0)'
        required: false
        type: string
      target-branch:
        description: 'Target branch for the merge PR (master or stable)'
        required: true
        type: choice
        options:
          - master
          - stable
        default: master
      force-retag:
        description: 'Force re-tag if tag already exists (only if no GitHub release)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write
  statuses: write

jobs:
  tag-release-branch:
    name: Tag Release Branch HEAD
    runs-on: ubuntu-latest
    # Restrict to users with write access (release team members)
    if: github.actor != 'dependabot[bot]' && github.actor != 'github-actions[bot]'
    outputs:
      release-branch: ${{ steps.determine-branch.outputs.branch }}
      tag-name: ${{ steps.tag-release.outputs.tag }}
      tag-sha: ${{ steps.tag-release.outputs.sha }}
    steps:
      - name: Determine release branch
        id: determine-branch
        env:
          VERSION: ${{ inputs.release-version }}
          PROVIDED_BRANCH: ${{ inputs.release-branch }}
        run: |
          # Validate version format to prevent injection
          if ! [[ "${VERSION}" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$ ]]; then
            echo "::error::Invalid version format. Expected: X.Y.Z or X.Y.Z-suffix"
            exit 1
          fi

          # If branch not provided, construct it from version
          if [[ -z "${PROVIDED_BRANCH}" ]]; then
            BRANCH="Version-v${VERSION}"
          else
            # Sanitize branch name to prevent command injection
            if ! [[ "${PROVIDED_BRANCH}" =~ ^[a-zA-Z0-9/_.-]+$ ]]; then
              echo "::error::Invalid branch name. Only alphanumeric, /, _, ., and - characters allowed"
              exit 1
            fi
            # Prevent directory traversal
            if [[ "${PROVIDED_BRANCH}" == *".."* ]]; then
              echo "::error::Branch name cannot contain directory traversal patterns"
              exit 1
            fi
            BRANCH="${PROVIDED_BRANCH}"
          fi

          echo "branch=${BRANCH}" >> "${GITHUB_OUTPUT}"
          echo "Using release branch: ${BRANCH}"

      - name: Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.determine-branch.outputs.branch }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify branch has successful builds
        env:
          BRANCH_NAME: ${{ steps.determine-branch.outputs.branch }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Checking build status for branch: ${BRANCH_NAME}"

          # Get the most recent workflow runs for this branch
          LATEST_RUNS=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/runs?branch=${BRANCH_NAME}&status=completed&per_page=10" \
            --jq '.workflow_runs[]')

          # Check if there's at least one successful build
          if echo "${LATEST_RUNS}" | jq -e 'select(.conclusion == "success")' > /dev/null 2>&1; then
            echo "âœ… Found successful builds on ${BRANCH_NAME}"
          else
            echo "::warning::No recent successful builds found on ${BRANCH_NAME}. Please verify build status before proceeding."
          fi

      - name: Handle existing tag
        id: check-existing-tag
        env:
          VERSION: ${{ inputs.release-version }}
          FORCE_RETAG: ${{ inputs.force-retag }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME="v${VERSION}"

          # Check if tag already exists
          if git rev-parse "${TAG_NAME}" >/dev/null 2>&1; then
            echo "Tag ${TAG_NAME} already exists"

            # Check if there's a GitHub release for this tag
            if gh release view "${TAG_NAME}" >/dev/null 2>&1; then
              echo "::error::Tag ${TAG_NAME} has an associated GitHub release and cannot be moved."
              echo "::error::This release appears to be finalized. Create a new patch version instead."
              exit 1
            fi

            # Get existing tag SHA and current HEAD SHA
            TAG_SHA=$(git rev-parse "${TAG_NAME}")
            HEAD_SHA=$(git rev-parse HEAD)

            if [[ "${TAG_SHA}" == "${HEAD_SHA}" ]]; then
              echo "âœ… Tag already points to current HEAD. No action needed."
              echo "needs_retag=false" >> "${GITHUB_OUTPUT}"
            elif [[ "${FORCE_RETAG}" == "true" ]]; then
              echo "âš ï¸ Tag exists at different commit. Force re-tag is enabled."
              echo "Will move tag from ${TAG_SHA:0:7} to ${HEAD_SHA:0:7}"

              # Delete the old tag (local and remote)
              git tag -d "${TAG_NAME}"
              git push origin ":refs/tags/${TAG_NAME}"

              echo "needs_retag=true" >> "${GITHUB_OUTPUT}"
              echo "âœ… Old tag deleted. Will create new tag at HEAD."
            else
              echo "::error::Tag ${TAG_NAME} exists but not at HEAD."
              echo "::error::To move the tag, run this workflow again with 'Force re-tag' enabled."
              # Log full details only to GitHub logs, not to error output
              echo "Debug: Tag is at ${TAG_SHA:0:7}, HEAD is at ${HEAD_SHA:0:7}" >&2
              exit 1
            fi
          else
            echo "Tag does not exist yet. Will create it."
            echo "needs_retag=true" >> "${GITHUB_OUTPUT}"
          fi

      - name: Create or update release tag
        id: tag-release
        if: steps.check-existing-tag.outputs.needs_retag != 'false'
        env:
          VERSION: ${{ inputs.release-version }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME="v${VERSION}"

          # Configure git
          git config user.email "metamaskbot@users.noreply.github.com"
          git config user.name "MetaMask Bot"

          # Get the current SHA
          SHA=$(git rev-parse HEAD)

          # Create annotated tag at HEAD
          git tag -a "${TAG_NAME}" -m "Release ${VERSION}"

          # Push the tag
          git push origin "${TAG_NAME}"

          echo "tag=${TAG_NAME}" >> "${GITHUB_OUTPUT}"
          echo "sha=${SHA}" >> "${GITHUB_OUTPUT}"
          echo "âœ… Created and pushed tag: ${TAG_NAME} at ${SHA}"

      - name: Set output for existing tag
        id: existing-tag-output
        if: steps.check-existing-tag.outputs.needs_retag == 'false'
        env:
          VERSION: ${{ inputs.release-version }}
        run: |
          TAG_NAME="v${VERSION}"
          SHA=$(git rev-parse HEAD)
          echo "tag=${TAG_NAME}" >> "${GITHUB_OUTPUT}"
          echo "sha=${SHA}" >> "${GITHUB_OUTPUT}"

      - name: Set status check on release branch
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_SHA: ${{ steps.tag-release.outputs.sha || steps.existing-tag-output.outputs.sha }}
          TAG_NAME: ${{ steps.tag-release.outputs.tag || steps.existing-tag-output.outputs.tag }}
        run: |
          # Set a successful status check to indicate the release has been tagged
          gh api \
            --method POST \
            -H "Accept: application/vnd.github.v3+json" \
            /repos/${{ github.repository }}/statuses/${TAG_SHA} \
            -f state='success' \
            -f target_url="${{ github.server_url }}/${{ github.repository }}/releases/tag/${TAG_NAME}" \
            -f description='Release has been tagged' \
            -f context='release/tagged'

      - name: Create or update merge PR
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_BRANCH: ${{ steps.determine-branch.outputs.branch }}
          VERSION: ${{ inputs.release-version }}
          TARGET_BRANCH: ${{ inputs.target-branch }}
          TAG_NAME: ${{ steps.tag-release.outputs.tag || steps.existing-tag-output.outputs.tag }}
          TAG_SHA: ${{ steps.tag-release.outputs.sha || steps.existing-tag-output.outputs.sha }}
        run: |
          # Check if PR already exists
          EXISTING_PR=$(gh pr list --base "${TARGET_BRANCH}" --head "${RELEASE_BRANCH}" --json number --jq '.[0].number' || echo "")

          if [[ -n "${EXISTING_PR}" ]]; then
            echo "PR already exists: #${EXISTING_PR}"

            # Add label to indicate it's been tagged
            gh pr edit "${EXISTING_PR}" --add-label "release-tagged" || true

            # Escape variables for markdown safety
            ESCAPED_TAG_NAME=$(printf '%s' "${TAG_NAME}" | sed 's/[[\*_`~#]/\\&/g')
            ESCAPED_BRANCH=$(printf '%s' "${RELEASE_BRANCH}" | sed 's/[[\*_`~#]/\\&/g')
            ESCAPED_TARGET=$(printf '%s' "${TARGET_BRANCH}" | sed 's/[[\*_`~#]/\\&/g')

            # Update the PR description to note that it's been tagged
            gh pr edit "${EXISTING_PR}" \
              --body "## Release Information

              - **Version**: \`${ESCAPED_TAG_NAME}\`
              - **Release Branch**: \`${ESCAPED_BRANCH}\`
              - **Tag SHA**: \`${TAG_SHA}\`
              - **Target Branch**: \`${ESCAPED_TARGET}\`

              ## âœ… Release Status

              This release has been **tagged** at commit ${TAG_SHA:0:7}.

              The tag \`${TAG_NAME}\` has been created on the release branch HEAD.

              ## âš ï¸ Merge Instructions

              **REQUIRED**: This PR must be merged using a **merge commit** (NOT squash and merge).

              **IMPORTANT**: The release has already been tagged. DO NOT create another tag after merge.

              After merging:
              1. The tagged commit will be part of ${TARGET_BRANCH} history
              2. The publish-release workflow will trigger
              3. GitHub release will be created from the existing tagged commit
              4. Sentry artifacts will be uploaded

              ## Checklist

              - [x] Release branch created
              - [x] Version bumped
              - [x] Changelog updated
              - [x] QA testing completed
              - [x] **Release tagged at branch HEAD** âœ…
              - [ ] Ready to merge to ${TARGET_BRANCH}"

            echo "Updated PR #${EXISTING_PR} with tag information"
          else
            # Escape variables for markdown safety
            ESCAPED_TAG_NAME=$(printf '%s' "${TAG_NAME}" | sed 's/[[\*_`~#]/\\&/g')
            ESCAPED_BRANCH=$(printf '%s' "${RELEASE_BRANCH}" | sed 's/[[\*_`~#]/\\&/g')
            ESCAPED_TARGET=$(printf '%s' "${TARGET_BRANCH}" | sed 's/[[\*_`~#]/\\&/g')

            # Create new PR with label indicating it's been tagged
            PR_URL=$(gh pr create \
              --title "Release: v${VERSION} to ${TARGET_BRANCH}" \
              --body "## Release Information

              - **Version**: \`${ESCAPED_TAG_NAME}\`
              - **Release Branch**: \`${ESCAPED_BRANCH}\`
              - **Tag SHA**: \`${TAG_SHA}\`
              - **Target Branch**: \`${ESCAPED_TARGET}\`

              ## âœ… Release Status

              This release has been **tagged** at commit ${TAG_SHA:0:7}.

              The tag \`${TAG_NAME}\` has been created on the release branch HEAD.

              ## âš ï¸ Merge Instructions

              **REQUIRED**: This PR must be merged using a **merge commit** (NOT squash and merge).

              **IMPORTANT**: The release has already been tagged. DO NOT create another tag after merge.

              After merging:
              1. The tagged commit will be part of ${TARGET_BRANCH} history
              2. The publish-release workflow will trigger
              3. GitHub release will be created from the existing tagged commit
              4. Sentry artifacts will be uploaded

              ## Checklist

              - [x] Release branch created
              - [x] Version bumped
              - [x] Changelog updated
              - [x] QA testing completed
              - [x] **Release tagged at branch HEAD** âœ…
              - [ ] Ready to merge to ${TARGET_BRANCH}" \
              --base "${TARGET_BRANCH}" \
              --head "${RELEASE_BRANCH}" \
              --label "release-${VERSION}" \
              --label "release-tagged")

            PR_NUMBER=$(echo "${PR_URL}" | grep -oE '[0-9]+$')
            echo "Created PR #${PR_NUMBER} with release-tagged label"
          fi

      - name: Output summary
        env:
          VERSION: ${{ inputs.release-version }}
          RELEASE_BRANCH: ${{ steps.determine-branch.outputs.branch }}
          TARGET_BRANCH: ${{ inputs.target-branch }}
          TAG_NAME: ${{ steps.tag-release.outputs.tag || steps.existing-tag-output.outputs.tag }}
          TAG_SHA: ${{ steps.tag-release.outputs.sha || steps.existing-tag-output.outputs.sha }}
          FORCE_RETAG: ${{ inputs.force-retag }}
        run: |
          echo "## ðŸ“‹ Release Summary" >> "${GITHUB_STEP_SUMMARY}"
          echo "" >> "${GITHUB_STEP_SUMMARY}"
          echo "### Release Details" >> "${GITHUB_STEP_SUMMARY}"
          echo "- **Version**: ${TAG_NAME}" >> "${GITHUB_STEP_SUMMARY}"
          echo "- **Release Branch**: ${RELEASE_BRANCH}" >> "${GITHUB_STEP_SUMMARY}"
          echo "- **Target Branch**: ${TARGET_BRANCH}" >> "${GITHUB_STEP_SUMMARY}"
          echo "- **Tag SHA**: \`${TAG_SHA}\`" >> "${GITHUB_STEP_SUMMARY}"

          if [[ "${FORCE_RETAG}" == "true" ]]; then
            echo "- **Action**: Tag was moved to new HEAD" >> "${GITHUB_STEP_SUMMARY}"
          fi

          echo "" >> "${GITHUB_STEP_SUMMARY}"
          echo "### âœ… Completed Actions" >> "${GITHUB_STEP_SUMMARY}"
          echo "1. Tagged release branch HEAD with ${TAG_NAME}" >> "${GITHUB_STEP_SUMMARY}"
          echo "2. Created/updated PR to merge ${RELEASE_BRANCH} â†’ ${TARGET_BRANCH}" >> "${GITHUB_STEP_SUMMARY}"
          echo "" >> "${GITHUB_STEP_SUMMARY}"
          echo "### ðŸ“ Next Steps" >> "${GITHUB_STEP_SUMMARY}"
          echo "1. Review and approve the merge PR" >> "${GITHUB_STEP_SUMMARY}"
          echo "2. **Merge using a merge commit** (NOT squash and merge)" >> "${GITHUB_STEP_SUMMARY}"
          echo "3. The publish-release workflow will automatically:" >> "${GITHUB_STEP_SUMMARY}"
          echo "   - Create GitHub release from the tagged commit" >> "${GITHUB_STEP_SUMMARY}"
          echo "   - Upload artifacts to Sentry" >> "${GITHUB_STEP_SUMMARY}"
          echo "   - Complete post-release tasks" >> "${GITHUB_STEP_SUMMARY}"
