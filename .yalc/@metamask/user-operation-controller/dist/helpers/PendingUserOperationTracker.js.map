{"version":3,"file":"PendingUserOperationTracker.js","sourceRoot":"","sources":["../../src/helpers/PendingUserOperationTracker.ts"],"names":[],"mappings":"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","sourcesContent":["import { query } from '@metamask/controller-utils';\nimport EthQuery from '@metamask/eth-query';\nimport type { NetworkClient, Provider } from '@metamask/network-controller';\nimport { BlockTrackerPollingControllerOnly } from '@metamask/polling-controller';\nimport type { Json } from '@metamask/utils';\nimport { createModuleLogger } from '@metamask/utils';\nimport EventEmitter from 'events';\n\nimport { projectLogger } from '../logger';\nimport type { UserOperationMetadata, UserOperationReceipt } from '../types';\nimport { UserOperationStatus } from '../types';\nimport type { UserOperationControllerMessenger } from '../UserOperationController';\nimport { Bundler } from './Bundler';\n\nconst log = createModuleLogger(projectLogger, 'pending-user-operations');\n\ntype Events = {\n  'user-operation-confirmed': [metadata: UserOperationMetadata];\n  'user-operation-failed': [txMeta: UserOperationMetadata, error: Error];\n  'user-operation-updated': [txMeta: UserOperationMetadata];\n};\n\nexport type PendingUserOperationTrackerEventEmitter = EventEmitter & {\n  on<T extends keyof Events>(\n    eventName: T,\n    listener: (...args: Events[T]) => void,\n  ): PendingUserOperationTrackerEventEmitter;\n\n  once<T extends keyof Events>(\n    eventName: T,\n    listener: (...args: Events[T]) => void,\n  ): PendingUserOperationTrackerEventEmitter;\n\n  emit<T extends keyof Events>(eventName: T, ...args: Events[T]): boolean;\n};\n\n/**\n * A helper class to periodically query the bundlers\n * and update the status of any submitted user operations.\n */\nexport class PendingUserOperationTracker extends BlockTrackerPollingControllerOnly {\n  hub: PendingUserOperationTrackerEventEmitter;\n\n  #getUserOperations: () => UserOperationMetadata[];\n\n  #messenger: UserOperationControllerMessenger;\n\n  constructor({\n    getUserOperations,\n    messenger,\n  }: {\n    getUserOperations: () => UserOperationMetadata[];\n    messenger: UserOperationControllerMessenger;\n  }) {\n    super();\n\n    this.hub = new EventEmitter() as PendingUserOperationTrackerEventEmitter;\n\n    this.#getUserOperations = getUserOperations;\n    this.#messenger = messenger;\n  }\n\n  async _executePoll(networkClientId: string, _options: Json) {\n    try {\n      const { blockTracker, configuration, provider } =\n        this._getNetworkClientById(networkClientId) as NetworkClient;\n\n      log('Polling', {\n        blockNumber: blockTracker.getCurrentBlock(),\n        chainId: configuration.chainId,\n      });\n\n      await this.#checkUserOperations(configuration.chainId, provider);\n    } catch (error) {\n      /* istanbul ignore next */\n      log('Failed to check user operations', error);\n    }\n  }\n\n  _getNetworkClientById(networkClientId: string): NetworkClient | undefined {\n    return this.#messenger.call(\n      'NetworkController:getNetworkClientById',\n      networkClientId,\n    );\n  }\n\n  async #checkUserOperations(chainId: string, provider: Provider) {\n    const pendingUserOperations = this.#getPendingUserOperations().filter(\n      (metadata) => metadata.chainId === chainId,\n    );\n\n    if (!pendingUserOperations.length) {\n      log('No pending user operations to check');\n      return;\n    }\n\n    log('Found pending user operations to check', {\n      count: pendingUserOperations.length,\n      ids: pendingUserOperations.map((userOperation) => userOperation.id),\n    });\n\n    await Promise.all(\n      pendingUserOperations.map((userOperation) =>\n        this.#checkUserOperation(userOperation, provider),\n      ),\n    );\n  }\n\n  async #checkUserOperation(\n    metadata: UserOperationMetadata,\n    provider: Provider,\n  ) {\n    const { bundlerUrl, hash, id } = metadata;\n\n    if (!hash || !bundlerUrl) {\n      log('Skipping user operation as missing hash or bundler', id);\n      return;\n    }\n\n    try {\n      const receipt = await this.#getUserOperationReceipt(hash, bundlerUrl);\n      const isSuccess = receipt?.success;\n\n      if (receipt && !isSuccess) {\n        this.#onUserOperationFailed(metadata, receipt);\n        return;\n      }\n\n      if (isSuccess) {\n        await this.#onUserOperationConfirmed(metadata, receipt, provider);\n        return;\n      }\n\n      log('No receipt found for user operation', { id, hash });\n    } catch (error) {\n      log('Failed to check user operation', id, error);\n    }\n  }\n\n  async #onUserOperationConfirmed(\n    metadata: UserOperationMetadata,\n    receipt: UserOperationReceipt,\n    provider: Provider,\n  ) {\n    const { id } = metadata;\n\n    const {\n      actualGasCost,\n      actualGasUsed,\n      receipt: { blockHash, transactionHash },\n    } = receipt;\n\n    log('User operation confirmed', id, transactionHash);\n\n    const { baseFeePerGas } = await query(\n      new EthQuery(provider),\n      'getBlockByHash',\n      [blockHash, false],\n    );\n\n    metadata.actualGasCost = actualGasCost;\n    metadata.actualGasUsed = actualGasUsed;\n    metadata.baseFeePerGas = baseFeePerGas;\n    metadata.status = UserOperationStatus.Confirmed;\n    metadata.transactionHash = transactionHash;\n\n    this.#updateUserOperation(metadata);\n\n    this.hub.emit('user-operation-confirmed', metadata);\n  }\n\n  #onUserOperationFailed(\n    metadata: UserOperationMetadata,\n    _receipt: UserOperationReceipt,\n  ) {\n    const { id } = metadata;\n\n    log('User operation failed', id);\n\n    metadata.status = UserOperationStatus.Failed;\n\n    this.#updateUserOperation(metadata);\n\n    this.hub.emit(\n      'user-operation-failed',\n      metadata,\n      new Error('User operation receipt has failed status'),\n    );\n  }\n\n  #getPendingUserOperations(): UserOperationMetadata[] {\n    return this.#getUserOperations().filter(\n      (userOperation) => userOperation.status === UserOperationStatus.Submitted,\n    );\n  }\n\n  #updateUserOperation(metadata: UserOperationMetadata) {\n    this.hub.emit('user-operation-updated', metadata);\n  }\n\n  async #getUserOperationReceipt(\n    hash: string,\n    bundlerUrl: string,\n  ): Promise<UserOperationReceipt | undefined> {\n    const bundler = new Bundler(bundlerUrl);\n    return bundler.getUserOperationReceipt(hash);\n  }\n}\n"]}