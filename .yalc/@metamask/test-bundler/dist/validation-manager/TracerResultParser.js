"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tracerResultParser = void 0;
const contracts_1 = require("@account-abstraction/contracts");
const debug_1 = __importDefault(require("debug"));
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const util_1 = require("util");
const utils_2 = require("../utils");
const debug = (0, debug_1.default)('aa.handler.opcodes');
const abi = Object.values([
    ...contracts_1.SenderCreator__factory.abi,
    ...contracts_1.IEntryPoint__factory.abi,
    ...contracts_1.IPaymaster__factory.abi,
].reduce((set, entry) => {
    const key = `${entry.name}(${entry.inputs.map((i) => i.type).join(',')})`;
    // console.log('key=', key, keccak256(Buffer.from(key)).slice(0,10))
    return Object.assign(Object.assign({}, set), { [key]: entry });
}, {}));
/**
 * parse all call operation in the trace.
 * notes:
 * - entries are ordered by the return (so nested call appears before its outer call
 * - last entry is top-level return from "simulateValidation". it as ret and rettype, but no type or address
 * @param tracerResults
 * @param abi
 */
function parseCallStack(tracerResults) {
    const xfaces = new utils_1.Interface(abi);
    /**
     *
     * @param x
     * @param def
     */
    function callCatch(x, def) {
        try {
            return x();
        }
        catch (_a) {
            return def;
        }
    }
    const out = [];
    const stack = [];
    tracerResults.calls
        .filter((x) => !x.type.startsWith('depth'))
        .forEach((c) => {
        var _a, _b;
        if (c.type.match(/REVERT|RETURN/) != null) {
            const top = (_a = stack.splice(-1)[0]) !== null && _a !== void 0 ? _a : {
                type: 'top',
                method: 'validateUserOp',
            };
            const returnData = c.data;
            if (top.type.match(/CREATE/) != null) {
                out.push({
                    to: top.to,
                    from: top.from,
                    type: top.type,
                    method: '',
                    return: `len=${returnData.length}`,
                });
            }
            else {
                const method = callCatch(() => xfaces.getFunction(top.method), top.method);
                if (c.type === 'REVERT') {
                    const parsedError = callCatch(() => xfaces.parseError(returnData), returnData);
                    out.push({
                        to: top.to,
                        from: top.from,
                        type: top.type,
                        method: method.name,
                        value: top.value,
                        revert: parsedError,
                    });
                }
                else {
                    const ret = callCatch(() => xfaces.decodeFunctionResult(method, returnData), returnData);
                    out.push({
                        to: top.to,
                        from: top.from,
                        type: top.type,
                        value: top.value,
                        method: (_b = method.name) !== null && _b !== void 0 ? _b : method,
                        return: ret,
                    });
                }
            }
        }
        else {
            stack.push(c);
        }
    });
    // TODO: verify that stack is empty at the end.
    return out;
}
/**
 * slots associated with each entity.
 * keccak( A || ...) is associated with "A"
 * removed rule: keccak( ... || ASSOC ) (for a previously associated hash) is also associated with "A"
 *
 * @param stakeInfoEntities - stake info for (factory, account, paymaster). factory and paymaster can be null.
 * @param keccak - array of buffers that were given to keccak in the transaction
 */
function parseEntitySlots(stakeInfoEntities, keccak) {
    // for each entity (sender, factory, paymaster), hold the valid slot addresses
    // valid: the slot was generated by keccak(entity || ...)
    const entitySlots = {};
    keccak.forEach((k) => {
        Object.values(stakeInfoEntities).forEach((info) => {
            var _a;
            const addr = (_a = info === null || info === void 0 ? void 0 : info.addr) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (addr == null) {
                return;
            }
            const addrPadded = (0, utils_2.toBytes32)(addr);
            if (entitySlots[addr] == null) {
                entitySlots[addr] = new Set();
            }
            const currentEntitySlots = entitySlots[addr];
            // valid slot: the slot was generated by keccak(entityAddr || ...)
            if (k.startsWith(addrPadded)) {
                // console.log('added mapping (balance) slot', value)
                currentEntitySlots.add((0, utils_1.keccak256)(k));
            }
            // disabled 2nd rule: .. or by keccak( ... || OWN) where OWN is previous allowed slot
            // if (k.length === 130 && currentEntitySlots.has(k.slice(-64))) {
            //   // console.log('added double-mapping (allowance) slot', value)
            //   currentEntitySlots.add(value)
            // }
        });
    });
    return entitySlots;
}
// method-signature for calls from entryPoint
const callsFromEntryPointMethodSigs = {
    factory: contracts_1.SenderCreator__factory.createInterface().getSighash('createSender'),
    account: contracts_1.IAccount__factory.createInterface().getSighash('validateUserOp'),
    paymaster: contracts_1.IPaymaster__factory.createInterface().getSighash('validatePaymasterUserOp'),
};
/**
 * parse collected simulation traces and revert if they break our rules
 * @param userOp - the userOperation that was used in this simulation
 * @param tracerResults - the tracer return value
 * @param validationResult - output from simulateValidation
 * @param entryPoint - the entryPoint that hosted the "simulatedValidation" traced call.
 * @returns list of contract addresses referenced by this UserOp
 */
function tracerResultParser(userOp, tracerResults, validationResult, entryPoint) {
    debug('=== simulation result:', (0, util_1.inspect)(tracerResults, true, 10, true));
    // todo: block access to no-code addresses (might need update to tracer)
    const entryPointAddress = entryPoint.address.toLowerCase();
    // opcodes from [OP-011]
    const bannedOpCodes = new Set([
        'GASPRICE',
        'GASLIMIT',
        'DIFFICULTY',
        'TIMESTAMP',
        'BASEFEE',
        'BLOCKHASH',
        'NUMBER',
        'SELFBALANCE',
        'BALANCE',
        'ORIGIN',
        'GAS',
        'CREATE',
        'COINBASE',
        'SELFDESTRUCT',
        'RANDOM',
        'PREVRANDAO',
        'INVALID',
    ]);
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    if (Object.values(tracerResults.callsFromEntryPoint).length < 1) {
        throw new Error('Unexpected traceCall result: no calls from entrypoint.');
    }
    const callStack = parseCallStack(tracerResults);
    // [OP-052], [OP-053]
    const callInfoEntryPoint = callStack.find((call) => call.to === entryPointAddress &&
        call.from !== entryPointAddress &&
        call.method !== '0x' &&
        call.method !== 'depositTo');
    // [OP-054]
    (0, utils_2.requireCond)(callInfoEntryPoint == null, `illegal call into EntryPoint during validation ${callInfoEntryPoint === null || callInfoEntryPoint === void 0 ? void 0 : callInfoEntryPoint.method}`, utils_2.ValidationErrors.OpcodeValidation);
    // [OP-061]
    const illegalNonZeroValueCall = callStack.find((call) => { var _a; return call.to !== entryPointAddress && !ethers_1.BigNumber.from((_a = call.value) !== null && _a !== void 0 ? _a : 0).eq(0); });
    (0, utils_2.requireCond)(illegalNonZeroValueCall == null, 'May not may CALL with value', utils_2.ValidationErrors.OpcodeValidation);
    const sender = userOp.sender.toLowerCase();
    // stake info per "number" level (factory, sender, paymaster)
    // we only use stake info if we notice a memory reference that require stake
    const stakeInfoEntities = {
        factory: validationResult.factoryInfo,
        account: validationResult.senderInfo,
        paymaster: validationResult.paymasterInfo,
    };
    const entitySlots = parseEntitySlots(stakeInfoEntities, tracerResults.keccak);
    Object.entries(stakeInfoEntities).forEach(([entityTitle, entStakes]) => {
        var _a, _b, _c, _d;
        const entityAddr = ((_a = entStakes === null || entStakes === void 0 ? void 0 : entStakes.addr) !== null && _a !== void 0 ? _a : '').toLowerCase();
        const currentNumLevel = tracerResults.callsFromEntryPoint.find((info) => info.topLevelMethodSig === callsFromEntryPointMethodSigs[entityTitle]);
        if (currentNumLevel == null) {
            if (entityTitle === 'account') {
                // should never happen... only factory, paymaster are optional.
                throw new Error('missing trace into validateUserOp');
            }
            return;
        }
        const { opcodes } = currentNumLevel;
        const { access } = currentNumLevel;
        // [OP-020]
        (0, utils_2.requireCond)(!((_b = currentNumLevel.oog) !== null && _b !== void 0 ? _b : false), `${entityTitle} internally reverts on oog`, utils_2.ValidationErrors.OpcodeValidation);
        // opcodes from [OP-011]
        Object.keys(opcodes).forEach((opcode) => (0, utils_2.requireCond)(!bannedOpCodes.has(opcode), `${entityTitle} uses banned opcode: ${opcode}`, utils_2.ValidationErrors.OpcodeValidation));
        // [OP-031]
        if (entityTitle === 'factory') {
            (0, utils_2.requireCond)(((_c = opcodes.CREATE2) !== null && _c !== void 0 ? _c : 0) <= 1, `${entityTitle} with too many CREATE2`, utils_2.ValidationErrors.OpcodeValidation);
        }
        else {
            (0, utils_2.requireCond)(opcodes.CREATE2 == null, `${entityTitle} uses banned opcode: CREATE2`, utils_2.ValidationErrors.OpcodeValidation);
        }
        Object.entries(access).forEach(([addr, { reads, writes }]) => {
            // testing read/write access on contract "addr"
            if (addr === sender) {
                // allowed to access sender's storage
                // [STO-010]
                return;
            }
            if (addr === entryPointAddress) {
                // ignore storage access on entryPoint (balance/deposit of entities.
                // we block them on method calls: only allowed to deposit, never to read
                return;
            }
            // return true if the given slot is associated with the given address, given the known keccak operations:
            // @param slot the SLOAD/SSTORE slot address we're testing
            // @param addr - the address we try to check for association with
            // @param reverseKeccak - a mapping we built for keccak values that contained the address
            /**
             *
             * @param slot
             * @param addr
             */
            function associatedWith(slot, addr, entitySlots) {
                const addrPadded = (0, utils_1.hexZeroPad)(addr, 32).toLowerCase();
                if (slot === addrPadded) {
                    return true;
                }
                const k = entitySlots[addr];
                if (k == null) {
                    return false;
                }
                const slotN = ethers_1.BigNumber.from(slot);
                // scan all slot entries to check of the given slot is within a structure, starting at that offset.
                // assume a maximum size on a (static) structure size.
                for (const k1 of k.keys()) {
                    const kn = ethers_1.BigNumber.from(k1);
                    if (slotN.gte(kn) && slotN.lt(kn.add(128))) {
                        return true;
                    }
                }
                return false;
            }
            debug('dump keccak calculations and reads', {
                entityTitle,
                entityAddr,
                k: (0, utils_2.mapOf)(tracerResults.keccak, (k) => (0, utils_1.keccak256)(k)),
                reads,
            });
            // scan all slots. find a referenced slot
            // at the end of the scan, we will check if the entity has stake, and report that slot if not.
            let requireStakeSlot;
            [...Object.keys(writes), ...Object.keys(reads)].forEach((slot) => {
                // slot associated with sender is allowed (e.g. token.balanceOf(sender)
                // but during initial UserOp (where there is an initCode), it is allowed only for staked entity
                if (associatedWith(slot, sender, entitySlots)) {
                    if (userOp.initCode.length > 2) {
                        // special case: account.validateUserOp is allowed to use assoc storage if factory is staked.
                        // [STO-022], [STO-021]
                        if (!(entityAddr === sender && isStaked(stakeInfoEntities.factory))) {
                            requireStakeSlot = slot;
                        }
                    }
                }
                else if (associatedWith(slot, entityAddr, entitySlots)) {
                    // [STO-032]
                    // accessing a slot associated with entityAddr (e.g. token.balanceOf(paymaster)
                    requireStakeSlot = slot;
                }
                else if (addr === entityAddr) {
                    // [STO-031]
                    // accessing storage member of entity itself requires stake.
                    requireStakeSlot = slot;
                }
                else if (writes[slot] == null) {
                    // [STO-033]: staked entity have read-only access to any storage in non-entity contract.
                    requireStakeSlot = slot;
                }
                else {
                    // accessing arbitrary storage of another contract is not allowed
                    const readWrite = Object.keys(writes).includes(addr)
                        ? 'write to'
                        : 'read from';
                    (0, utils_2.requireCond)(false, `${entityTitle} has forbidden ${readWrite} ${nameAddr(addr, entityTitle)} slot ${slot}`, utils_2.ValidationErrors.OpcodeValidation, { [entityTitle]: entStakes === null || entStakes === void 0 ? void 0 : entStakes.addr });
                }
            });
            // if addr is current account/paymaster/factory, then return that title
            // otherwise, return addr as-is
            /**
             *
             * @param addr
             * @param currentEntity
             */
            function nameAddr(addr, currentEntity) {
                var _a;
                const [title] = (_a = Object.entries(stakeInfoEntities).find(([title, info]) => (info === null || info === void 0 ? void 0 : info.addr.toLowerCase()) === addr.toLowerCase())) !== null && _a !== void 0 ? _a : [];
                return title !== null && title !== void 0 ? title : addr;
            }
            requireCondAndStake(requireStakeSlot != null, entStakes, `unstaked ${entityTitle} accessed ${nameAddr(addr, entityTitle)} slot ${requireStakeSlot}`);
        });
        // [EREP-050]
        if (entityTitle === 'paymaster') {
            const validatePaymasterUserOp = callStack.find((call) => call.method === 'validatePaymasterUserOp' && call.to === entityAddr);
            const context = (_d = validatePaymasterUserOp === null || validatePaymasterUserOp === void 0 ? void 0 : validatePaymasterUserOp.return) === null || _d === void 0 ? void 0 : _d.context;
            requireCondAndStake(context != null && context !== '0x', entStakes, 'unstaked paymaster must not return context');
        }
        // check if the given entity is staked
        /**
         *
         * @param entStake
         */
        function isStaked(entStake) {
            return (entStake != null &&
                ethers_1.BigNumber.from(1).lte(entStake.stake) &&
                ethers_1.BigNumber.from(1).lte(entStake.unstakeDelaySec));
        }
        // helper method: if condition is true, then entity must be staked.
        /**
         *
         * @param cond
         * @param entStake
         * @param failureMessage
         */
        function requireCondAndStake(cond, entStake, failureMessage) {
            if (!cond) {
                return;
            }
            if (entStake == null) {
                throw new Error(`internal: ${entityTitle} not in userOp, but has storage accesses in ${JSON.stringify(access)}`);
            }
            (0, utils_2.requireCond)(isStaked(entStake), failureMessage, utils_2.ValidationErrors.OpcodeValidation, { [entityTitle]: entStakes === null || entStakes === void 0 ? void 0 : entStakes.addr });
            // TODO: check real minimum stake values
        }
        // the only contract we allow to access before its deployment is the "sender" itself, which gets created.
        let illegalZeroCodeAccess;
        for (const addr of Object.keys(currentNumLevel.contractSize)) {
            // [OP-042]
            if (addr !== sender &&
                currentNumLevel.contractSize[addr].contractSize <= 2) {
                illegalZeroCodeAccess = currentNumLevel.contractSize[addr];
                illegalZeroCodeAccess.address = addr;
                break;
            }
        }
        // [OP-041]
        (0, utils_2.requireCond)(illegalZeroCodeAccess == null, `${entityTitle} accesses un-deployed contract address ${illegalZeroCodeAccess === null || illegalZeroCodeAccess === void 0 ? void 0 : illegalZeroCodeAccess.address} with opcode ${illegalZeroCodeAccess === null || illegalZeroCodeAccess === void 0 ? void 0 : illegalZeroCodeAccess.opcode}`, utils_2.ValidationErrors.OpcodeValidation);
        let illegalEntryPointCodeAccess;
        for (const addr of Object.keys(currentNumLevel.extCodeAccessInfo)) {
            if (addr === entryPointAddress) {
                illegalEntryPointCodeAccess = currentNumLevel.extCodeAccessInfo[addr];
                break;
            }
        }
        (0, utils_2.requireCond)(illegalEntryPointCodeAccess == null, `${entityTitle} accesses EntryPoint contract address ${entryPointAddress} with opcode ${illegalEntryPointCodeAccess}`, utils_2.ValidationErrors.OpcodeValidation);
    });
    // return list of contract addresses by this UserOp. already known not to contain zero-sized addresses.
    const addresses = tracerResults.callsFromEntryPoint.flatMap((level) => Object.keys(level.contractSize));
    const storageMap = {};
    tracerResults.callsFromEntryPoint.forEach((level) => {
        Object.keys(level.access).forEach((addr) => {
            var _a;
            storageMap[addr] = (_a = storageMap[addr]) !== null && _a !== void 0 ? _a : level.access[addr].reads;
        });
    });
    return [addresses, storageMap];
}
exports.tracerResultParser = tracerResultParser;
//# sourceMappingURL=TracerResultParser.js.map