diff --git a/dist/assetsUtil.cjs b/dist/assetsUtil.cjs
index b3db76c39d78362273ff081d8c8efe30040ffc28..cab60d3a8541ad0459112638f027c7e303b68b1e 100644
--- a/dist/assetsUtil.cjs
+++ b/dist/assetsUtil.cjs
@@ -3,6 +3,7 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
 Object.defineProperty(exports, "__esModule", { value: true });
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }
 exports.accountAddressToCaipReference = exports.getKeyByValue = exports.fetchTokenContractExchangeRates = exports.reduceInBatchesSerially = exports.divideIntoBatches = exports.ethersBigNumberToBN = exports.addUrlProtocolPrefix = exports.getFormattedIpfsUrl = exports.getIpfsCIDv1AndPath = exports.removeIpfsProtocolPrefix = exports.isTokenListSupportedForNetwork = exports.isTokenDetectionSupportedForNetwork = exports.SupportedStakedBalanceNetworks = exports.SupportedTokenDetectionNetworks = exports.formatIconUrlWithProxy = exports.formatAggregatorNames = exports.hasNewCollectionFields = exports.compareNftMetadata = exports.TOKEN_PRICES_BATCH_SIZE = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
 const utils_1 = require("@metamask/utils");
@@ -240,7 +241,12 @@ async function getIpfsCIDv1AndPath(ipfsUrl) {
     const index = url.indexOf('/');
     const cid = index !== -1 ? url.substring(0, index) : url;
     const path = index !== -1 ? url.substring(index) : undefined;
-    const { CID } = await import("multiformats");
+    // Dynamic import is used here in `core` for CJS compatbility, because 'multiformats' is ESM-
+    // only. However, dynamic import is not supported by LavaMoat.
+    // See here for details: https://github.com/MetaMask/metamask-extension/pull/27629#discussion_r1791797810
+    // TODO: Attempt deleting this patch after migrating to Webpack, which may support dynamic
+    // import with LavaMoat.
+    const { CID } = _interopRequireWildcard(require("multiformats"));
     // We want to ensure that the CID is v1 (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats)
     // because most cid v0s appear to be incompatible with IPFS subdomains
     return {
diff --git a/dist/TokenBalancesController.cjs b/dist/TokenBalancesController.cjs
index 5648453743177ab4753694c3a71a78e3eb74af3b..cc4ba8b0a9f4ed8649da6fa66bc88a9f2c9e0b65 100644
--- a/dist/TokenBalancesController.cjs
+++ b/dist/TokenBalancesController.cjs
@@ -10,7 +10,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
     return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
 };
-var _TokenBalancesController_instances, _TokenBalancesController_queryAllAccounts, _TokenBalancesController_accountsApiChainIds, _TokenBalancesController_balanceFetchers, _TokenBalancesController_allTokens, _TokenBalancesController_detectedTokens, _TokenBalancesController_defaultInterval, _TokenBalancesController_chainPollingConfig, _TokenBalancesController_intervalPollingTimers, _TokenBalancesController_isControllerPollingActive, _TokenBalancesController_requestedChainIds, _TokenBalancesController_chainIdsWithTokens, _TokenBalancesController_getProvider, _TokenBalancesController_getNetworkClient, _TokenBalancesController_createAccountsApiFetcher, _TokenBalancesController_startIntervalGroupPolling, _TokenBalancesController_startPollingForInterval, _TokenBalancesController_setPollingTimer, _TokenBalancesController_onTokensChanged, _TokenBalancesController_onNetworkChanged, _TokenBalancesController_onAccountRemoved;
+var _TokenBalancesController_instances, _TokenBalancesController_platform, _TokenBalancesController_queryAllAccounts, _TokenBalancesController_accountsApiChainIds, _TokenBalancesController_balanceFetchers, _TokenBalancesController_allTokens, _TokenBalancesController_detectedTokens, _TokenBalancesController_defaultInterval, _TokenBalancesController_chainPollingConfig, _TokenBalancesController_intervalPollingTimers, _TokenBalancesController_isControllerPollingActive, _TokenBalancesController_requestedChainIds, _TokenBalancesController_chainIdsWithTokens, _TokenBalancesController_getProvider, _TokenBalancesController_getNetworkClient, _TokenBalancesController_createAccountsApiFetcher, _TokenBalancesController_startIntervalGroupPolling, _TokenBalancesController_startPollingForInterval, _TokenBalancesController_setPollingTimer, _TokenBalancesController_onTokensChanged, _TokenBalancesController_onNetworkChanged, _TokenBalancesController_onAccountRemoved;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TokenBalancesController = void 0;
 const providers_1 = require("@ethersproject/providers");
@@ -42,7 +42,7 @@ const checksum = (addr) => (0, controller_utils_1.toChecksumHexAddress)(addr);
 // ────────────────────────────────────────────────────────────────────────────
 // region: Main controller
 class TokenBalancesController extends (0, polling_controller_1.StaticIntervalPollingController)() {
-    constructor({ messenger, interval = DEFAULT_INTERVAL_MS, chainPollingIntervals = {}, state = {}, queryMultipleAccounts = true, accountsApiChainIds = [], allowExternalServices = () => true, }) {
+    constructor({ messenger, interval = DEFAULT_INTERVAL_MS, chainPollingIntervals = {}, state = {}, queryMultipleAccounts = true, accountsApiChainIds = () => [], allowExternalServices = () => true, platform, }) {
         super({
             name: CONTROLLER,
             messenger,
@@ -50,6 +50,7 @@ class TokenBalancesController extends (0, polling_controller_1.StaticIntervalPol
             state: { tokenBalances: {}, ...state },
         });
         _TokenBalancesController_instances.add(this);
+        _TokenBalancesController_platform.set(this, void 0);
         _TokenBalancesController_queryAllAccounts.set(this, void 0);
         _TokenBalancesController_accountsApiChainIds.set(this, void 0);
         _TokenBalancesController_balanceFetchers.set(this, void 0);
@@ -84,13 +85,13 @@ class TokenBalancesController extends (0, polling_controller_1.StaticIntervalPol
          * @returns A BalanceFetcher that wraps AccountsApiBalanceFetcher with chainId filtering
          */
         _TokenBalancesController_createAccountsApiFetcher.set(this, () => {
-            const originalFetcher = new api_balance_fetcher_1.AccountsApiBalanceFetcher('extension', __classPrivateFieldGet(this, _TokenBalancesController_getProvider, "f"));
+            const originalFetcher = new api_balance_fetcher_1.AccountsApiBalanceFetcher(__classPrivateFieldGet(this, _TokenBalancesController_platform, "f"), __classPrivateFieldGet(this, _TokenBalancesController_getProvider, "f"));
             return {
                 supports: (chainId) => {
                     // Only support chains that are both:
                     // 1. In our specified accountsApiChainIds array
                     // 2. Actually supported by the AccountsApi
-                    return (__classPrivateFieldGet(this, _TokenBalancesController_accountsApiChainIds, "f").includes(chainId) &&
+                    return (__classPrivateFieldGet(this, _TokenBalancesController_accountsApiChainIds, "f").call(this).includes(chainId) &&
                         originalFetcher.supports(chainId));
                 },
                 fetch: originalFetcher.fetch.bind(originalFetcher),
@@ -209,13 +210,14 @@ class TokenBalancesController extends (0, polling_controller_1.StaticIntervalPol
                 delete s.tokenBalances[addr];
             });
         });
+        __classPrivateFieldSet(this, _TokenBalancesController_platform, platform ?? 'extension', "f");
         __classPrivateFieldSet(this, _TokenBalancesController_queryAllAccounts, queryMultipleAccounts, "f");
-        __classPrivateFieldSet(this, _TokenBalancesController_accountsApiChainIds, [...accountsApiChainIds], "f");
+        __classPrivateFieldSet(this, _TokenBalancesController_accountsApiChainIds, accountsApiChainIds, "f");
         __classPrivateFieldSet(this, _TokenBalancesController_defaultInterval, interval, "f");
         __classPrivateFieldSet(this, _TokenBalancesController_chainPollingConfig, { ...chainPollingIntervals }, "f");
         // Strategy order: API first, then RPC fallback
         __classPrivateFieldSet(this, _TokenBalancesController_balanceFetchers, [
-            ...(accountsApiChainIds.length > 0 && allowExternalServices()
+            ...(accountsApiChainIds().length > 0 && allowExternalServices()
                 ? [__classPrivateFieldGet(this, _TokenBalancesController_createAccountsApiFetcher, "f").call(this)]
                 : []),
             new rpc_balance_fetcher_1.RpcBalanceFetcher(__classPrivateFieldGet(this, _TokenBalancesController_getProvider, "f"), __classPrivateFieldGet(this, _TokenBalancesController_getNetworkClient, "f"), () => ({
@@ -353,8 +355,8 @@ class TokenBalancesController extends (0, polling_controller_1.StaticIntervalPol
                 break;
             }
         }
-        // Determine which accounts to process
-        const accountsToProcess = __classPrivateFieldGet(this, _TokenBalancesController_queryAllAccounts, "f")
+        // Determine which accounts to process based on queryAllAccounts parameter
+        const accountsToProcess = (queryAllAccounts ?? __classPrivateFieldGet(this, _TokenBalancesController_queryAllAccounts, "f"))
             ? allAccounts.map((a) => a.address)
             : [selected];
         const prev = this.state;
@@ -427,13 +429,15 @@ class TokenBalancesController extends (0, polling_controller_1.StaticIntervalPol
                     this.messagingSystem.call('AccountTrackerController:updateNativeBalances', balanceUpdates);
                 }
             }
-            // Get staking contract addresses for filtering
-            const stakingContractAddresses = Object.values(AssetsContractController_1.STAKING_CONTRACT_ADDRESS_BY_CHAINID).map((addr) => addr.toLowerCase());
             // Filter and update staked balances in a single batch operation for better performance
             const stakedBalances = aggregated.filter((r) => {
-                return (r.success &&
-                    r.token !== ZERO_ADDRESS &&
-                    stakingContractAddresses.includes(r.token.toLowerCase()));
+                if (!r.success || r.token === ZERO_ADDRESS) {
+                    return false;
+                }
+                // Check if the chainId and token address match any staking contract
+                const stakingContractAddress = AssetsContractController_1.STAKING_CONTRACT_ADDRESS_BY_CHAINID[r.chainId];
+                return (stakingContractAddress &&
+                    stakingContractAddress.toLowerCase() === r.token.toLowerCase());
             });
             if (stakedBalances.length > 0) {
                 const stakedBalanceUpdates = stakedBalances
@@ -470,7 +474,7 @@ class TokenBalancesController extends (0, polling_controller_1.StaticIntervalPol
     }
 }
 exports.TokenBalancesController = TokenBalancesController;
-_TokenBalancesController_queryAllAccounts = new WeakMap(), _TokenBalancesController_accountsApiChainIds = new WeakMap(), _TokenBalancesController_balanceFetchers = new WeakMap(), _TokenBalancesController_allTokens = new WeakMap(), _TokenBalancesController_detectedTokens = new WeakMap(), _TokenBalancesController_defaultInterval = new WeakMap(), _TokenBalancesController_chainPollingConfig = new WeakMap(), _TokenBalancesController_intervalPollingTimers = new WeakMap(), _TokenBalancesController_isControllerPollingActive = new WeakMap(), _TokenBalancesController_requestedChainIds = new WeakMap(), _TokenBalancesController_getProvider = new WeakMap(), _TokenBalancesController_getNetworkClient = new WeakMap(), _TokenBalancesController_createAccountsApiFetcher = new WeakMap(), _TokenBalancesController_onTokensChanged = new WeakMap(), _TokenBalancesController_onNetworkChanged = new WeakMap(), _TokenBalancesController_onAccountRemoved = new WeakMap(), _TokenBalancesController_instances = new WeakSet(), _TokenBalancesController_chainIdsWithTokens = function _TokenBalancesController_chainIdsWithTokens() {
+_TokenBalancesController_platform = new WeakMap(), _TokenBalancesController_queryAllAccounts = new WeakMap(), _TokenBalancesController_accountsApiChainIds = new WeakMap(), _TokenBalancesController_balanceFetchers = new WeakMap(), _TokenBalancesController_allTokens = new WeakMap(), _TokenBalancesController_detectedTokens = new WeakMap(), _TokenBalancesController_defaultInterval = new WeakMap(), _TokenBalancesController_chainPollingConfig = new WeakMap(), _TokenBalancesController_intervalPollingTimers = new WeakMap(), _TokenBalancesController_isControllerPollingActive = new WeakMap(), _TokenBalancesController_requestedChainIds = new WeakMap(), _TokenBalancesController_getProvider = new WeakMap(), _TokenBalancesController_getNetworkClient = new WeakMap(), _TokenBalancesController_createAccountsApiFetcher = new WeakMap(), _TokenBalancesController_onTokensChanged = new WeakMap(), _TokenBalancesController_onNetworkChanged = new WeakMap(), _TokenBalancesController_onAccountRemoved = new WeakMap(), _TokenBalancesController_instances = new WeakSet(), _TokenBalancesController_chainIdsWithTokens = function _TokenBalancesController_chainIdsWithTokens() {
     return [
         ...new Set([
             ...Object.keys(__classPrivateFieldGet(this, _TokenBalancesController_allTokens, "f")),
diff --git a/dist/TokenBalancesController.d.cts b/dist/TokenBalancesController.d.cts
index c2b187eff4ff6471684af730e3cb9eab5ee2df21..7d41755d1e4dcd1a5d18874f2e8117a26e36138a 100644
--- a/dist/TokenBalancesController.d.cts
+++ b/dist/TokenBalancesController.d.cts
@@ -50,11 +50,12 @@ export type TokenBalancesControllerOptions = {
     /** When `true`, balances for *all* known accounts are queried. */
     queryMultipleAccounts?: boolean;
     /** Array of chainIds that should use Accounts-API strategy (if supported by API). */
-    accountsApiChainIds?: ChainIdHex[];
+    accountsApiChainIds?: () => ChainIdHex[];
     /** Disable external HTTP calls (privacy / offline mode). */
     allowExternalServices?: () => boolean;
     /** Custom logger. */
     log?: (...args: unknown[]) => void;
+    platform?: 'extension' | 'mobile';
 };
 declare const TokenBalancesController_base: (abstract new (...args: any[]) => {
     readonly "__#14@#intervalIds": Record<string, NodeJS.Timeout>;
@@ -85,7 +86,7 @@ declare const TokenBalancesController_base: (abstract new (...args: any[]) => {
 }) & typeof import("@metamask/base-controller").BaseController;
 export declare class TokenBalancesController extends TokenBalancesController_base<typeof CONTROLLER, TokenBalancesControllerState, TokenBalancesControllerMessenger> {
     #private;
-    constructor({ messenger, interval, chainPollingIntervals, state, queryMultipleAccounts, accountsApiChainIds, allowExternalServices, }: TokenBalancesControllerOptions);
+    constructor({ messenger, interval, chainPollingIntervals, state, queryMultipleAccounts, accountsApiChainIds, allowExternalServices, platform, }: TokenBalancesControllerOptions);
     /**
      * Override to support per-chain polling intervals by grouping chains by interval
      *
