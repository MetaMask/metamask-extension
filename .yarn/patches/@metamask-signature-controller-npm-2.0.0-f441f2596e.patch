diff --git a/dist/SignatureController.d.ts b/dist/SignatureController.d.ts
index b336d0d2149d492e0b1c8df08e1bfae3ab81ff79..9e10a1b9f580f4468f64652ea2818f51e9080b74 100644
--- a/dist/SignatureController.d.ts
+++ b/dist/SignatureController.d.ts
@@ -1,9 +1,10 @@
 /// <reference types="node" />
 import EventEmitter from 'events';
-import { MessageParams, MessageParamsMetamask, PersonalMessageParams, PersonalMessageParamsMetamask, TypedMessageParams, TypedMessageParamsMetamask, AbstractMessage, AbstractMessageParams, OriginalRequest } from '@metamask/message-manager';
+import type { Hex } from '@metamask/utils';
+import { MessageParams, PersonalMessageParams, TypedMessageParams, TypedMessageSigningOptions, AbstractMessage, AbstractMessageParams, OriginalRequest } from '@metamask/message-manager';
 import { BaseControllerV2, RestrictedControllerMessenger } from '@metamask/base-controller';
 import { Patch } from 'immer';
-import { AcceptRequest, AddApprovalRequest, RejectRequest } from '@metamask/approval-controller';
+import { AddApprovalRequest, RejectRequest } from '@metamask/approval-controller';
 declare const controllerName = "SignatureController";
 declare type StateMessage = Required<AbstractMessage> & {
     msgParams: Required<AbstractMessageParams>;
@@ -16,7 +17,7 @@ declare type SignatureControllerState = {
     unapprovedPersonalMsgCount: number;
     unapprovedTypedMessagesCount: number;
 };
-declare type AllowedActions = AddApprovalRequest | AcceptRequest | RejectRequest;
+declare type AllowedActions = AddApprovalRequest | RejectRequest;
 export declare type GetSignatureState = {
     type: `${typeof controllerName}:getState`;
     handler: () => SignatureControllerState;
@@ -41,7 +42,7 @@ export declare type SignatureControllerOptions = {
     isEthSignEnabled: () => boolean;
     getAllState: () => unknown;
     securityProviderRequest?: (requestData: any, methodName: string) => Promise<any>;
-    getCurrentChainId: () => string;
+    getCurrentChainId: () => Hex;
 };
 /**
  * Controller for creating signing requests requiring user approval.
@@ -83,17 +84,27 @@ export declare class SignatureController extends BaseControllerV2<typeof control
      * Reset the controller state to the initial state.
      */
     resetState(): void;
+    /**
+     * Reject all unapproved messages of any type.
+     *
+     * @param reason - A message to indicate why.
+     */
+    rejectUnapproved(reason?: string): void;
+    /**
+     * Clears all unapproved messages from memory.
+     */
+    clearUnapproved(): void;
     /**
      * Called when a Dapp uses the eth_sign method, to request user approval.
      * eth_sign is a pure signature of arbitrary data. It is on a deprecation
      * path, since this data can be a transaction, or can leak private key
      * information.
      *
-     * @param msgParams - The params passed to eth_sign.
+     * @param messageParams - The params passed to eth_sign.
      * @param [req] - The original request, containing the origin.
      * @returns Promise resolving to the raw data of the signature request.
      */
-    newUnsignedMessage(msgParams: MessageParams, req: OriginalRequest): Promise<string>;
+    newUnsignedMessage(messageParams: MessageParams, req: OriginalRequest): Promise<string>;
     /**
      * Called when a dapp uses the personal_sign method.
      * This is identical to the Geth eth_sign method, and may eventually replace
@@ -101,78 +112,24 @@ export declare class SignatureController extends BaseControllerV2<typeof control
      *
      * We currently define our eth_sign and personal_sign mostly for legacy Dapps.
      *
-     * @param msgParams - The params of the message to sign & return to the Dapp.
+     * @param messageParams - The params of the message to sign & return to the Dapp.
      * @param req - The original request, containing the origin.
      * @returns Promise resolving to the raw data of the signature request.
      */
-    newUnsignedPersonalMessage(msgParams: PersonalMessageParams, req: OriginalRequest): Promise<string>;
+    newUnsignedPersonalMessage(messageParams: PersonalMessageParams, req: OriginalRequest): Promise<string>;
     /**
      * Called when a dapp uses the eth_signTypedData method, per EIP 712.
      *
-     * @param msgParams - The params passed to eth_signTypedData.
+     * @param messageParams - The params passed to eth_signTypedData.
      * @param req - The original request, containing the origin.
      * @param version - The version indicating the format of the typed data.
+     * @param signingOpts - An options bag for signing.
+     * @param signingOpts.parseJsonData - Whether to parse the JSON before signing.
      * @returns Promise resolving to the raw data of the signature request.
      */
-    newUnsignedTypedMessage(msgParams: TypedMessageParams, req: OriginalRequest, version: string): Promise<string>;
-    /**
-     * Signifies user intent to complete an eth_sign method.
-     *
-     * @param msgParams - The params passed to eth_call.
-     * @returns Full state update.
-     */
-    signMessage(msgParams: MessageParamsMetamask): Promise<any>;
-    /**
-     * Signifies a user's approval to sign a personal_sign message in queue.
-     * Triggers signing, and the callback function from newUnsignedPersonalMessage.
-     *
-     * @param msgParams - The params of the message to sign & return to the Dapp.
-     * @returns A full state update.
-     */
-    signPersonalMessage(msgParams: PersonalMessageParamsMetamask): Promise<any>;
-    /**
-     * The method for a user approving a call to eth_signTypedData, per EIP 712.
-     * Triggers the callback in newUnsignedTypedMessage.
-     *
-     * @param msgParams - The params passed to eth_signTypedData.
-     * @param opts - Options bag.
-     * @param opts.parseJsonData - Whether to parse JSON data before calling the KeyringController.
-     * @returns Full state update.
-     */
-    signTypedMessage(msgParams: TypedMessageParamsMetamask, opts?: {
-        parseJsonData: boolean;
-    }): Promise<any>;
-    /**
-     * Used to cancel a message submitted via eth_sign.
-     *
-     * @param msgId - The id of the message to cancel.
-     * @returns A full state update.
-     */
-    cancelMessage(msgId: string): any;
-    /**
-     * Used to cancel a personal_sign type message.
-     *
-     * @param msgId - The ID of the message to cancel.
-     * @returns A full state update.
-     */
-    cancelPersonalMessage(msgId: string): any;
-    /**
-     * Used to cancel a eth_signTypedData type message.
-     *
-     * @param msgId - The ID of the message to cancel.
-     * @returns A full state update.
-     */
-    cancelTypedMessage(msgId: string): any;
-    /**
-     * Reject all unapproved messages of any type.
-     *
-     * @param reason - A message to indicate why.
-     */
-    rejectUnapproved(reason?: string): void;
-    /**
-     * Clears all unapproved messages from memory.
-     */
-    clearUnapproved(): void;
+    newUnsignedTypedMessage(messageParams: TypedMessageParams, req: OriginalRequest, version: string, signingOpts?: TypedMessageSigningOptions): Promise<string>;
+    setTypedMessageInProgress(messageId: string): void;
+    setPersonalMessageInProgress(messageId: string): void;
 }
 export {};
 //# sourceMappingURL=SignatureController.d.ts.map
\ No newline at end of file
diff --git a/dist/SignatureController.d.ts.map b/dist/SignatureController.d.ts.map
index 7ed723edb55934e3ff4975cd460bf3e830df405b..e61d436b983b0aaddbad85ab0de32fa1c97dcf98 100644
--- a/dist/SignatureController.d.ts.map
+++ b/dist/SignatureController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"SignatureController.d.ts","sourceRoot":"","sources":["../src/SignatureController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"SignatureController.d.ts","sourceRoot":"","sources":["../src/SignatureController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/SignatureController.js b/dist/SignatureController.js
index 59dc5974218e8d073b65969154f35ada3fd9e8ab..d9dc86d44ed6a0f364fc0971723423ff2acb6046 100644
--- a/dist/SignatureController.js
+++ b/dist/SignatureController.js
@@ -33,10 +33,11 @@ var __rest = (this && this.__rest) || function (s, e) {
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _SignatureController_instances, _SignatureController_keyringController, _SignatureController_isEthSignEnabled, _SignatureController_getAllState, _SignatureController_messageManager, _SignatureController_personalMessageManager, _SignatureController_typedMessageManager, _SignatureController_rejectUnapproved, _SignatureController_clearUnapproved, _SignatureController_signAbstractMessage, _SignatureController_errorMessage, _SignatureController_cancelAbstractMessage, _SignatureController_handleMessageManagerEvents, _SignatureController_subscribeToMessageState, _SignatureController_migrateMessages, _SignatureController_migrateMessage, _SignatureController_normalizeMsgData, _SignatureController_getMessage, _SignatureController_requestApproval, _SignatureController_acceptApproval, _SignatureController_rejectApproval, _SignatureController_removeJsonData;
+var _SignatureController_instances, _SignatureController_keyringController, _SignatureController_isEthSignEnabled, _SignatureController_getAllState, _SignatureController_messageManager, _SignatureController_personalMessageManager, _SignatureController_typedMessageManager, _SignatureController_newUnsignedAbstractMessage, _SignatureController_signMessage, _SignatureController_signPersonalMessage, _SignatureController_signTypedMessage, _SignatureController_rejectUnapproved, _SignatureController_clearUnapproved, _SignatureController_signAbstractMessage, _SignatureController_cancelAbstractMessage, _SignatureController_handleMessageManagerEvents, _SignatureController_subscribeToMessageState, _SignatureController_migrateMessages, _SignatureController_migrateMessage, _SignatureController_normalizeMsgData, _SignatureController_getMessage, _SignatureController_requestApproval, _SignatureController_removeJsonData;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.SignatureController = void 0;
 const events_1 = __importDefault(require("events"));
+const lodash_1 = require("lodash");
 const message_manager_1 = require("@metamask/message-manager");
 const eth_rpc_errors_1 = require("eth-rpc-errors");
 const ethereumjs_util_1 = require("ethereumjs-util");
@@ -95,9 +96,9 @@ class SignatureController extends base_controller_1.BaseControllerV2 {
         __classPrivateFieldSet(this, _SignatureController_messageManager, new message_manager_1.MessageManager(undefined, undefined, securityProviderRequest), "f");
         __classPrivateFieldSet(this, _SignatureController_personalMessageManager, new message_manager_1.PersonalMessageManager(undefined, undefined, securityProviderRequest), "f");
         __classPrivateFieldSet(this, _SignatureController_typedMessageManager, new message_manager_1.TypedMessageManager(undefined, undefined, securityProviderRequest, undefined, getCurrentChainId), "f");
-        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_handleMessageManagerEvents).call(this, __classPrivateFieldGet(this, _SignatureController_messageManager, "f"), controller_utils_1.ApprovalType.EthSign, 'unapprovedMessage');
-        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_handleMessageManagerEvents).call(this, __classPrivateFieldGet(this, _SignatureController_personalMessageManager, "f"), controller_utils_1.ApprovalType.PersonalSign, 'unapprovedPersonalMessage');
-        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_handleMessageManagerEvents).call(this, __classPrivateFieldGet(this, _SignatureController_typedMessageManager, "f"), controller_utils_1.ApprovalType.EthSignTypedData, 'unapprovedTypedMessage');
+        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_handleMessageManagerEvents).call(this, __classPrivateFieldGet(this, _SignatureController_messageManager, "f"), 'unapprovedMessage');
+        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_handleMessageManagerEvents).call(this, __classPrivateFieldGet(this, _SignatureController_personalMessageManager, "f"), 'unapprovedPersonalMessage');
+        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_handleMessageManagerEvents).call(this, __classPrivateFieldGet(this, _SignatureController_typedMessageManager, "f"), 'unapprovedTypedMessage');
         __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_subscribeToMessageState).call(this, __classPrivateFieldGet(this, _SignatureController_messageManager, "f"), (state, newMessages, messageCount) => {
             state.unapprovedMsgs = newMessages;
             state.unapprovedMsgCount = messageCount;
@@ -141,29 +142,48 @@ class SignatureController extends base_controller_1.BaseControllerV2 {
     resetState() {
         this.update(() => getDefaultState());
     }
+    /**
+     * Reject all unapproved messages of any type.
+     *
+     * @param reason - A message to indicate why.
+     */
+    rejectUnapproved(reason) {
+        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_rejectUnapproved).call(this, __classPrivateFieldGet(this, _SignatureController_messageManager, "f"), reason);
+        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_rejectUnapproved).call(this, __classPrivateFieldGet(this, _SignatureController_personalMessageManager, "f"), reason);
+        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_rejectUnapproved).call(this, __classPrivateFieldGet(this, _SignatureController_typedMessageManager, "f"), reason);
+    }
+    /**
+     * Clears all unapproved messages from memory.
+     */
+    clearUnapproved() {
+        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_clearUnapproved).call(this, __classPrivateFieldGet(this, _SignatureController_messageManager, "f"));
+        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_clearUnapproved).call(this, __classPrivateFieldGet(this, _SignatureController_personalMessageManager, "f"));
+        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_clearUnapproved).call(this, __classPrivateFieldGet(this, _SignatureController_typedMessageManager, "f"));
+    }
     /**
      * Called when a Dapp uses the eth_sign method, to request user approval.
      * eth_sign is a pure signature of arbitrary data. It is on a deprecation
      * path, since this data can be a transaction, or can leak private key
      * information.
      *
-     * @param msgParams - The params passed to eth_sign.
+     * @param messageParams - The params passed to eth_sign.
      * @param [req] - The original request, containing the origin.
      * @returns Promise resolving to the raw data of the signature request.
      */
-    newUnsignedMessage(msgParams, req) {
+    newUnsignedMessage(messageParams, req) {
         return __awaiter(this, void 0, void 0, function* () {
-            if (!__classPrivateFieldGet(this, _SignatureController_isEthSignEnabled, "f").call(this)) {
-                throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound('eth_sign has been disabled. You must enable it in the advanced settings');
-            }
-            const data = __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_normalizeMsgData).call(this, msgParams.data);
-            // 64 hex + "0x" at the beginning
-            // This is needed because Ethereum's EcSign works only on 32 byte numbers
-            // For 67 length see: https://github.com/MetaMask/metamask-extension/pull/12679/files#r749479607
-            if (data.length !== 66 && data.length !== 67) {
-                throw eth_rpc_errors_1.ethErrors.rpc.invalidParams('eth_sign requires 32 byte message hash');
-            }
-            return __classPrivateFieldGet(this, _SignatureController_messageManager, "f").addUnapprovedMessageAsync(msgParams, req);
+            return __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_newUnsignedAbstractMessage).call(this, __classPrivateFieldGet(this, _SignatureController_messageManager, "f"), controller_utils_1.ApprovalType.EthSign, 'Message', __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_signMessage).bind(this), messageParams, req, (params) => {
+                if (!__classPrivateFieldGet(this, _SignatureController_isEthSignEnabled, "f").call(this)) {
+                    throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound('eth_sign has been disabled. You must enable it in the advanced settings');
+                }
+                const data = __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_normalizeMsgData).call(this, params.data);
+                // 64 hex + "0x" at the beginning
+                // This is needed because Ethereum's EcSign works only on 32 byte numbers
+                // For 67 length see: https://github.com/MetaMask/metamask-extension/pull/12679/files#r749479607
+                if (data.length !== 66 && data.length !== 67) {
+                    throw eth_rpc_errors_1.ethErrors.rpc.invalidParams('eth_sign requires 32 byte message hash');
+                }
+            });
         });
     }
     /**
@@ -173,121 +193,76 @@ class SignatureController extends base_controller_1.BaseControllerV2 {
      *
      * We currently define our eth_sign and personal_sign mostly for legacy Dapps.
      *
-     * @param msgParams - The params of the message to sign & return to the Dapp.
+     * @param messageParams - The params of the message to sign & return to the Dapp.
      * @param req - The original request, containing the origin.
      * @returns Promise resolving to the raw data of the signature request.
      */
-    newUnsignedPersonalMessage(msgParams, req) {
+    newUnsignedPersonalMessage(messageParams, req) {
         return __awaiter(this, void 0, void 0, function* () {
-            return __classPrivateFieldGet(this, _SignatureController_personalMessageManager, "f").addUnapprovedMessageAsync(msgParams, req);
+            return __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_newUnsignedAbstractMessage).call(this, __classPrivateFieldGet(this, _SignatureController_personalMessageManager, "f"), controller_utils_1.ApprovalType.PersonalSign, 'Personal Message', __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_signPersonalMessage).bind(this), messageParams, req);
         });
     }
     /**
      * Called when a dapp uses the eth_signTypedData method, per EIP 712.
      *
-     * @param msgParams - The params passed to eth_signTypedData.
+     * @param messageParams - The params passed to eth_signTypedData.
      * @param req - The original request, containing the origin.
      * @param version - The version indicating the format of the typed data.
+     * @param signingOpts - An options bag for signing.
+     * @param signingOpts.parseJsonData - Whether to parse the JSON before signing.
      * @returns Promise resolving to the raw data of the signature request.
      */
-    newUnsignedTypedMessage(msgParams, req, version) {
-        return __awaiter(this, void 0, void 0, function* () {
-            return __classPrivateFieldGet(this, _SignatureController_typedMessageManager, "f").addUnapprovedMessageAsync(msgParams, version, req);
-        });
-    }
-    /**
-     * Signifies user intent to complete an eth_sign method.
-     *
-     * @param msgParams - The params passed to eth_call.
-     * @returns Full state update.
-     */
-    signMessage(msgParams) {
+    newUnsignedTypedMessage(messageParams, req, version, signingOpts = { parseJsonData: true }) {
         return __awaiter(this, void 0, void 0, function* () {
-            return yield __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_signAbstractMessage).call(this, __classPrivateFieldGet(this, _SignatureController_messageManager, "f"), controller_utils_1.ApprovalType.EthSign, msgParams, (cleanMsgParams) => __awaiter(this, void 0, void 0, function* () { return yield __classPrivateFieldGet(this, _SignatureController_keyringController, "f").signMessage(cleanMsgParams); }));
+            return __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_newUnsignedAbstractMessage).call(this, __classPrivateFieldGet(this, _SignatureController_typedMessageManager, "f"), controller_utils_1.ApprovalType.EthSignTypedData, 'Typed Message', __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_signTypedMessage).bind(this), messageParams, req, undefined, version, signingOpts);
         });
     }
-    /**
-     * Signifies a user's approval to sign a personal_sign message in queue.
-     * Triggers signing, and the callback function from newUnsignedPersonalMessage.
-     *
-     * @param msgParams - The params of the message to sign & return to the Dapp.
-     * @returns A full state update.
-     */
-    signPersonalMessage(msgParams) {
-        return __awaiter(this, void 0, void 0, function* () {
-            return yield __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_signAbstractMessage).call(this, __classPrivateFieldGet(this, _SignatureController_personalMessageManager, "f"), controller_utils_1.ApprovalType.PersonalSign, msgParams, (cleanMsgParams) => __awaiter(this, void 0, void 0, function* () { return yield __classPrivateFieldGet(this, _SignatureController_keyringController, "f").signPersonalMessage(cleanMsgParams); }));
-        });
+    setTypedMessageInProgress(messageId) {
+        __classPrivateFieldGet(this, _SignatureController_typedMessageManager, "f").setMessageStatusInProgress(messageId);
     }
-    /**
-     * The method for a user approving a call to eth_signTypedData, per EIP 712.
-     * Triggers the callback in newUnsignedTypedMessage.
-     *
-     * @param msgParams - The params passed to eth_signTypedData.
-     * @param opts - Options bag.
-     * @param opts.parseJsonData - Whether to parse JSON data before calling the KeyringController.
-     * @returns Full state update.
-     */
-    signTypedMessage(msgParams, opts = { parseJsonData: true }) {
-        return __awaiter(this, void 0, void 0, function* () {
-            const { version } = msgParams;
-            return yield __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_signAbstractMessage).call(this, __classPrivateFieldGet(this, _SignatureController_typedMessageManager, "f"), controller_utils_1.ApprovalType.EthSignTypedData, msgParams, (cleanMsgParams) => __awaiter(this, void 0, void 0, function* () {
-                const finalMessageParams = opts.parseJsonData
-                    ? __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_removeJsonData).call(this, cleanMsgParams, version)
-                    : cleanMsgParams;
-                return yield __classPrivateFieldGet(this, _SignatureController_keyringController, "f").signTypedMessage(finalMessageParams, {
-                    version,
-                });
-            }));
-        });
-    }
-    /**
-     * Used to cancel a message submitted via eth_sign.
-     *
-     * @param msgId - The id of the message to cancel.
-     * @returns A full state update.
-     */
-    cancelMessage(msgId) {
-        return __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_cancelAbstractMessage).call(this, __classPrivateFieldGet(this, _SignatureController_messageManager, "f"), msgId);
-    }
-    /**
-     * Used to cancel a personal_sign type message.
-     *
-     * @param msgId - The ID of the message to cancel.
-     * @returns A full state update.
-     */
-    cancelPersonalMessage(msgId) {
-        return __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_cancelAbstractMessage).call(this, __classPrivateFieldGet(this, _SignatureController_personalMessageManager, "f"), msgId);
-    }
-    /**
-     * Used to cancel a eth_signTypedData type message.
-     *
-     * @param msgId - The ID of the message to cancel.
-     * @returns A full state update.
-     */
-    cancelTypedMessage(msgId) {
-        return __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_cancelAbstractMessage).call(this, __classPrivateFieldGet(this, _SignatureController_typedMessageManager, "f"), msgId);
-    }
-    /**
-     * Reject all unapproved messages of any type.
-     *
-     * @param reason - A message to indicate why.
-     */
-    rejectUnapproved(reason) {
-        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_rejectUnapproved).call(this, __classPrivateFieldGet(this, _SignatureController_messageManager, "f"), reason);
-        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_rejectUnapproved).call(this, __classPrivateFieldGet(this, _SignatureController_personalMessageManager, "f"), reason);
-        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_rejectUnapproved).call(this, __classPrivateFieldGet(this, _SignatureController_typedMessageManager, "f"), reason);
-    }
-    /**
-     * Clears all unapproved messages from memory.
-     */
-    clearUnapproved() {
-        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_clearUnapproved).call(this, __classPrivateFieldGet(this, _SignatureController_messageManager, "f"));
-        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_clearUnapproved).call(this, __classPrivateFieldGet(this, _SignatureController_personalMessageManager, "f"));
-        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_clearUnapproved).call(this, __classPrivateFieldGet(this, _SignatureController_typedMessageManager, "f"));
+    setPersonalMessageInProgress(messageId) {
+        __classPrivateFieldGet(this, _SignatureController_personalMessageManager, "f").setMessageStatusInProgress(messageId);
     }
 }
 exports.SignatureController = SignatureController;
-_SignatureController_keyringController = new WeakMap(), _SignatureController_isEthSignEnabled = new WeakMap(), _SignatureController_getAllState = new WeakMap(), _SignatureController_messageManager = new WeakMap(), _SignatureController_personalMessageManager = new WeakMap(), _SignatureController_typedMessageManager = new WeakMap(), _SignatureController_instances = new WeakSet(), _SignatureController_rejectUnapproved = function _SignatureController_rejectUnapproved(messageManager, reason) {
+_SignatureController_keyringController = new WeakMap(), _SignatureController_isEthSignEnabled = new WeakMap(), _SignatureController_getAllState = new WeakMap(), _SignatureController_messageManager = new WeakMap(), _SignatureController_personalMessageManager = new WeakMap(), _SignatureController_typedMessageManager = new WeakMap(), _SignatureController_instances = new WeakSet(), _SignatureController_newUnsignedAbstractMessage = function _SignatureController_newUnsignedAbstractMessage(messageManager, approvalType, messageName, signMessage, messageParams, req, validateMessage, version, signingOpts) {
+    return __awaiter(this, void 0, void 0, function* () {
+        if (validateMessage) {
+            validateMessage(messageParams);
+        }
+        const messageId = yield messageManager.addUnapprovedMessage(messageParams, req, version);
+        const messageParamsWithId = Object.assign(Object.assign({}, messageParams), { metamaskId: messageId });
+        const signaturePromise = messageManager.waitForFinishStatus(messageParamsWithId, messageName, true);
+        try {
+            yield __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_requestApproval).call(this, messageParamsWithId, approvalType);
+        }
+        catch (error) {
+            __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_cancelAbstractMessage).call(this, messageManager, messageId);
+            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest('User rejected the request.');
+        }
+        yield signMessage(messageParamsWithId, version, signingOpts);
+        return signaturePromise;
+    });
+}, _SignatureController_signMessage = function _SignatureController_signMessage(msgParams) {
+    return __awaiter(this, void 0, void 0, function* () {
+        return yield __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_signAbstractMessage).call(this, __classPrivateFieldGet(this, _SignatureController_messageManager, "f"), controller_utils_1.ApprovalType.EthSign, msgParams, (cleanMsgParams) => __awaiter(this, void 0, void 0, function* () { return yield __classPrivateFieldGet(this, _SignatureController_keyringController, "f").signMessage(cleanMsgParams); }));
+    });
+}, _SignatureController_signPersonalMessage = function _SignatureController_signPersonalMessage(msgParams) {
+    return __awaiter(this, void 0, void 0, function* () {
+        return yield __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_signAbstractMessage).call(this, __classPrivateFieldGet(this, _SignatureController_personalMessageManager, "f"), controller_utils_1.ApprovalType.PersonalSign, msgParams, (cleanMsgParams) => __awaiter(this, void 0, void 0, function* () { return yield __classPrivateFieldGet(this, _SignatureController_keyringController, "f").signPersonalMessage(cleanMsgParams); }));
+    });
+}, _SignatureController_signTypedMessage = function _SignatureController_signTypedMessage(msgParams, version, opts) {
+    return __awaiter(this, void 0, void 0, function* () {
+        return yield __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_signAbstractMessage).call(this, __classPrivateFieldGet(this, _SignatureController_typedMessageManager, "f"), controller_utils_1.ApprovalType.EthSignTypedData, msgParams, (cleanMsgParams) => __awaiter(this, void 0, void 0, function* () {
+            const finalMessageParams = (opts === null || opts === void 0 ? void 0 : opts.parseJsonData)
+                ? __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_removeJsonData).call(this, cleanMsgParams, version)
+                : cleanMsgParams;
+            return yield __classPrivateFieldGet(this, _SignatureController_keyringController, "f").signTypedMessage(finalMessageParams, {
+                version,
+            });
+        }));
+    });
+}, _SignatureController_rejectUnapproved = function _SignatureController_rejectUnapproved(messageManager, reason) {
     Object.keys(messageManager.getUnapprovedMessages()).forEach((messageId) => {
         __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_cancelAbstractMessage).call(this, messageManager, messageId, reason);
     });
@@ -303,39 +278,29 @@ _SignatureController_keyringController = new WeakMap(), _SignatureController_isE
         try {
             const cleanMessageParams = yield messageManager.approveMessage(msgParams);
             const signature = yield getSignature(cleanMessageParams);
-            messageManager.setMessageStatusSigned(messageId, signature);
-            __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_acceptApproval).call(this, messageId);
-            return __classPrivateFieldGet(this, _SignatureController_getAllState, "f").call(this);
+            this.hub.emit(`${methodName}:signed`, { signature, messageId });
+            if (!cleanMessageParams.deferSetAsSigned) {
+                messageManager.setMessageStatusSigned(messageId, signature);
+            }
+            return signature;
         }
         catch (error) {
             console.info(`MetaMaskController - ${methodName} failed.`, error);
-            __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_errorMessage).call(this, messageManager, messageId, error.message);
             throw error;
         }
     });
-}, _SignatureController_errorMessage = function _SignatureController_errorMessage(messageManager, messageId, error) {
-    if (messageManager instanceof message_manager_1.TypedMessageManager) {
-        messageManager.setMessageStatusErrored(messageId, error);
-        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_rejectApproval).call(this, messageId);
-    }
-    else {
-        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_cancelAbstractMessage).call(this, messageManager, messageId);
-    }
 }, _SignatureController_cancelAbstractMessage = function _SignatureController_cancelAbstractMessage(messageManager, messageId, reason) {
     if (reason) {
         const message = __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_getMessage).call(this, messageId);
         this.hub.emit('cancelWithReason', { message, reason });
     }
     messageManager.rejectMessage(messageId);
-    __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_rejectApproval).call(this, messageId);
-    return __classPrivateFieldGet(this, _SignatureController_getAllState, "f").call(this);
-}, _SignatureController_handleMessageManagerEvents = function _SignatureController_handleMessageManagerEvents(messageManager, approvalType, eventName) {
+}, _SignatureController_handleMessageManagerEvents = function _SignatureController_handleMessageManagerEvents(messageManager, eventName) {
     messageManager.hub.on('updateBadge', () => {
         this.hub.emit('updateBadge');
     });
     messageManager.hub.on('unapprovedMessage', (msgParams) => {
         this.hub.emit(eventName, msgParams);
-        __classPrivateFieldGet(this, _SignatureController_instances, "m", _SignatureController_requestApproval).call(this, msgParams, approvalType);
     });
 }, _SignatureController_subscribeToMessageState = function _SignatureController_subscribeToMessageState(messageManager, updateState) {
     messageManager.subscribe((state) => {
@@ -369,22 +334,19 @@ _SignatureController_keyringController = new WeakMap(), _SignatureController_isE
 }, _SignatureController_getMessage = function _SignatureController_getMessage(messageId) {
     return Object.assign(Object.assign(Object.assign({}, this.state.unapprovedMsgs), this.state.unapprovedPersonalMsgs), this.state.unapprovedTypedMessages)[messageId];
 }, _SignatureController_requestApproval = function _SignatureController_requestApproval(msgParams, type) {
-    const id = msgParams.metamaskId;
-    const origin = msgParams.origin || controller_utils_1.ORIGIN_METAMASK;
-    this.messagingSystem
-        .call('ApprovalController:addRequest', {
-        id,
-        origin,
-        type,
-        requestData: msgParams,
-    }, true)
-        .catch(() => {
-        // Intentionally ignored as promise not currently used
+    return __awaiter(this, void 0, void 0, function* () {
+        const id = msgParams.metamaskId;
+        const origin = msgParams.origin || controller_utils_1.ORIGIN_METAMASK;
+        // We are explicitly cloning the message params here to prevent the mutation errors on development mode
+        // Because sending it through the messaging system will make the object read only
+        const clonedMsgParams = (0, lodash_1.cloneDeep)(msgParams);
+        return this.messagingSystem.call('ApprovalController:addRequest', {
+            id,
+            origin,
+            type,
+            requestData: clonedMsgParams,
+        }, true);
     });
-}, _SignatureController_acceptApproval = function _SignatureController_acceptApproval(messageId) {
-    this.messagingSystem.call('ApprovalController:acceptRequest', messageId);
-}, _SignatureController_rejectApproval = function _SignatureController_rejectApproval(messageId) {
-    this.messagingSystem.call('ApprovalController:rejectRequest', messageId, 'Cancel');
 }, _SignatureController_removeJsonData = function _SignatureController_removeJsonData(messageParams, version) {
     if (version === 'V1' || typeof messageParams.data !== 'string') {
         return messageParams;
diff --git a/dist/SignatureController.js.map b/dist/SignatureController.js.map
index 99f17a7580b4c85d4816406d9a483f088924d115..0303b097b5a9748c703d636c84ddd7aa52a4e188 100644
--- a/dist/SignatureController.js.map
+++ b/dist/SignatureController.js.map
@@ -1 +1 @@
-{"version":3,"file":"SignatureController.js","sourceRoot":"","sources":["../src/SignatureController.ts"],"names":[],"mappings":"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","sourcesContent":["import EventEmitter from 'events';\nimport {\n  MessageManager,\n  MessageParams,\n  MessageParamsMetamask,\n  PersonalMessageManager,\n  PersonalMessageParams,\n  PersonalMessageParamsMetamask,\n  TypedMessageManager,\n  TypedMessageParams,\n  TypedMessageParamsMetamask,\n  AbstractMessageManager,\n  AbstractMessage,\n  MessageManagerState,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from '@metamask/message-manager';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { bufferToHex } from 'ethereumjs-util';\n\nimport {\n  BaseControllerV2,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { Patch } from 'immer';\nimport {\n  AcceptRequest,\n  AddApprovalRequest,\n  RejectRequest,\n} from '@metamask/approval-controller';\nimport { ApprovalType, ORIGIN_METAMASK } from '@metamask/controller-utils';\n\nconst controllerName = 'SignatureController';\n\nconst stateMetadata = {\n  unapprovedMsgs: { persist: false, anonymous: false },\n  unapprovedPersonalMsgs: { persist: false, anonymous: false },\n  unapprovedTypedMessages: { persist: false, anonymous: false },\n  unapprovedMsgCount: { persist: false, anonymous: false },\n  unapprovedPersonalMsgCount: { persist: false, anonymous: false },\n  unapprovedTypedMessagesCount: { persist: false, anonymous: false },\n};\n\nconst getDefaultState = () => ({\n  unapprovedMsgs: {},\n  unapprovedPersonalMsgs: {},\n  unapprovedTypedMessages: {},\n  unapprovedMsgCount: 0,\n  unapprovedPersonalMsgCount: 0,\n  unapprovedTypedMessagesCount: 0,\n});\n\ntype CoreMessage = AbstractMessage & {\n  messageParams: AbstractMessageParams;\n};\n\ntype StateMessage = Required<AbstractMessage> & {\n  msgParams: Required<AbstractMessageParams>;\n};\n\ntype SignatureControllerState = {\n  unapprovedMsgs: Record<string, StateMessage>;\n  unapprovedPersonalMsgs: Record<string, StateMessage>;\n  unapprovedTypedMessages: Record<string, StateMessage>;\n  unapprovedMsgCount: number;\n  unapprovedPersonalMsgCount: number;\n  unapprovedTypedMessagesCount: number;\n};\n\ntype AllowedActions = AddApprovalRequest | AcceptRequest | RejectRequest;\n\nexport type GetSignatureState = {\n  type: `${typeof controllerName}:getState`;\n  handler: () => SignatureControllerState;\n};\n\nexport type SignatureStateChange = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [SignatureControllerState, Patch[]];\n};\n\nexport type SignatureControllerActions = GetSignatureState;\n\nexport type SignatureControllerEvents = SignatureStateChange;\n\nexport type SignatureControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  SignatureControllerActions | AllowedActions,\n  SignatureControllerEvents,\n  AllowedActions['type'],\n  never\n>;\n\nexport interface KeyringController {\n  signMessage: (messsageParams: MessageParams) => Promise<string>;\n  signPersonalMessage: (\n    messsageParams: PersonalMessageParams,\n  ) => Promise<string>;\n  signTypedMessage: (\n    messsageParams: TypedMessageParams,\n    options: { version: string | undefined },\n  ) => Promise<string>;\n}\n\nexport type SignatureControllerOptions = {\n  messenger: SignatureControllerMessenger;\n  keyringController: KeyringController;\n  isEthSignEnabled: () => boolean;\n  getAllState: () => unknown;\n  securityProviderRequest?: (\n    requestData: any,\n    methodName: string,\n  ) => Promise<any>;\n  getCurrentChainId: () => string;\n};\n\n/**\n * Controller for creating signing requests requiring user approval.\n */\nexport class SignatureController extends BaseControllerV2<\n  typeof controllerName,\n  SignatureControllerState,\n  SignatureControllerMessenger\n> {\n  hub: EventEmitter;\n\n  #keyringController: KeyringController;\n\n  #isEthSignEnabled: () => boolean;\n\n  #getAllState: () => any;\n\n  #messageManager: MessageManager;\n\n  #personalMessageManager: PersonalMessageManager;\n\n  #typedMessageManager: TypedMessageManager;\n\n  /**\n   * Construct a Sign controller.\n   *\n   * @param options - The controller options.\n   * @param options.messenger - The restricted controller messenger for the sign controller.\n   * @param options.keyringController - An instance of a keyring controller used to perform the signing operations.\n   * @param options.isEthSignEnabled - Callback to return true if eth_sign is enabled.\n   * @param options.getAllState - Callback to retrieve all user state.\n   * @param options.securityProviderRequest - A function for verifying a message, whether it is malicious or not.\n   * @param options.getCurrentChainId - A function for retrieving the current chainId.\n   */\n  constructor({\n    messenger,\n    keyringController,\n    isEthSignEnabled,\n    getAllState,\n    securityProviderRequest,\n    getCurrentChainId,\n  }: SignatureControllerOptions) {\n    super({\n      name: controllerName,\n      metadata: stateMetadata,\n      messenger,\n      state: getDefaultState(),\n    });\n\n    this.#keyringController = keyringController;\n    this.#isEthSignEnabled = isEthSignEnabled;\n    this.#getAllState = getAllState;\n\n    this.hub = new EventEmitter();\n    this.#messageManager = new MessageManager(\n      undefined,\n      undefined,\n      securityProviderRequest,\n    );\n    this.#personalMessageManager = new PersonalMessageManager(\n      undefined,\n      undefined,\n      securityProviderRequest,\n    );\n    this.#typedMessageManager = new TypedMessageManager(\n      undefined,\n      undefined,\n      securityProviderRequest,\n      undefined,\n      getCurrentChainId,\n    );\n\n    this.#handleMessageManagerEvents(\n      this.#messageManager,\n      ApprovalType.EthSign,\n      'unapprovedMessage',\n    );\n    this.#handleMessageManagerEvents(\n      this.#personalMessageManager,\n      ApprovalType.PersonalSign,\n      'unapprovedPersonalMessage',\n    );\n    this.#handleMessageManagerEvents(\n      this.#typedMessageManager,\n      ApprovalType.EthSignTypedData,\n      'unapprovedTypedMessage',\n    );\n\n    this.#subscribeToMessageState(\n      this.#messageManager,\n      (state, newMessages, messageCount) => {\n        state.unapprovedMsgs = newMessages;\n        state.unapprovedMsgCount = messageCount;\n      },\n    );\n\n    this.#subscribeToMessageState(\n      this.#personalMessageManager,\n      (state, newMessages, messageCount) => {\n        state.unapprovedPersonalMsgs = newMessages;\n        state.unapprovedPersonalMsgCount = messageCount;\n      },\n    );\n\n    this.#subscribeToMessageState(\n      this.#typedMessageManager,\n      (state, newMessages, messageCount) => {\n        state.unapprovedTypedMessages = newMessages;\n        state.unapprovedTypedMessagesCount = messageCount;\n      },\n    );\n  }\n\n  /**\n   * A getter for the number of 'unapproved' Messages in this.messages.\n   *\n   * @returns The number of 'unapproved' Messages in this.messages\n   */\n  get unapprovedMsgCount(): number {\n    return this.#messageManager.getUnapprovedMessagesCount();\n  }\n\n  /**\n   * A getter for the number of 'unapproved' PersonalMessages in this.messages.\n   *\n   * @returns The number of 'unapproved' PersonalMessages in this.messages\n   */\n  get unapprovedPersonalMessagesCount(): number {\n    return this.#personalMessageManager.getUnapprovedMessagesCount();\n  }\n\n  /**\n   * A getter for the number of 'unapproved' TypedMessages in this.messages.\n   *\n   * @returns The number of 'unapproved' TypedMessages in this.messages\n   */\n  get unapprovedTypedMessagesCount(): number {\n    return this.#typedMessageManager.getUnapprovedMessagesCount();\n  }\n\n  /**\n   * Reset the controller state to the initial state.\n   */\n  resetState() {\n    this.update(() => getDefaultState());\n  }\n\n  /**\n   * Called when a Dapp uses the eth_sign method, to request user approval.\n   * eth_sign is a pure signature of arbitrary data. It is on a deprecation\n   * path, since this data can be a transaction, or can leak private key\n   * information.\n   *\n   * @param msgParams - The params passed to eth_sign.\n   * @param [req] - The original request, containing the origin.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  async newUnsignedMessage(\n    msgParams: MessageParams,\n    req: OriginalRequest,\n  ): Promise<string> {\n    if (!this.#isEthSignEnabled()) {\n      throw ethErrors.rpc.methodNotFound(\n        'eth_sign has been disabled. You must enable it in the advanced settings',\n      );\n    }\n\n    const data = this.#normalizeMsgData(msgParams.data);\n\n    // 64 hex + \"0x\" at the beginning\n    // This is needed because Ethereum's EcSign works only on 32 byte numbers\n    // For 67 length see: https://github.com/MetaMask/metamask-extension/pull/12679/files#r749479607\n    if (data.length !== 66 && data.length !== 67) {\n      throw ethErrors.rpc.invalidParams(\n        'eth_sign requires 32 byte message hash',\n      );\n    }\n\n    return this.#messageManager.addUnapprovedMessageAsync(msgParams, req);\n  }\n\n  /**\n   * Called when a dapp uses the personal_sign method.\n   * This is identical to the Geth eth_sign method, and may eventually replace\n   * eth_sign.\n   *\n   * We currently define our eth_sign and personal_sign mostly for legacy Dapps.\n   *\n   * @param msgParams - The params of the message to sign & return to the Dapp.\n   * @param req - The original request, containing the origin.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  async newUnsignedPersonalMessage(\n    msgParams: PersonalMessageParams,\n    req: OriginalRequest,\n  ): Promise<string> {\n    return this.#personalMessageManager.addUnapprovedMessageAsync(\n      msgParams,\n      req,\n    );\n  }\n\n  /**\n   * Called when a dapp uses the eth_signTypedData method, per EIP 712.\n   *\n   * @param msgParams - The params passed to eth_signTypedData.\n   * @param req - The original request, containing the origin.\n   * @param version - The version indicating the format of the typed data.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  async newUnsignedTypedMessage(\n    msgParams: TypedMessageParams,\n    req: OriginalRequest,\n    version: string,\n  ): Promise<string> {\n    return this.#typedMessageManager.addUnapprovedMessageAsync(\n      msgParams,\n      version,\n      req,\n    );\n  }\n\n  /**\n   * Signifies user intent to complete an eth_sign method.\n   *\n   * @param msgParams - The params passed to eth_call.\n   * @returns Full state update.\n   */\n  async signMessage(msgParams: MessageParamsMetamask) {\n    return await this.#signAbstractMessage(\n      this.#messageManager,\n      ApprovalType.EthSign,\n      msgParams,\n      async (cleanMsgParams) =>\n        await this.#keyringController.signMessage(cleanMsgParams),\n    );\n  }\n\n  /**\n   * Signifies a user's approval to sign a personal_sign message in queue.\n   * Triggers signing, and the callback function from newUnsignedPersonalMessage.\n   *\n   * @param msgParams - The params of the message to sign & return to the Dapp.\n   * @returns A full state update.\n   */\n  async signPersonalMessage(msgParams: PersonalMessageParamsMetamask) {\n    return await this.#signAbstractMessage(\n      this.#personalMessageManager,\n      ApprovalType.PersonalSign,\n      msgParams,\n      async (cleanMsgParams) =>\n        await this.#keyringController.signPersonalMessage(cleanMsgParams),\n    );\n  }\n\n  /**\n   * The method for a user approving a call to eth_signTypedData, per EIP 712.\n   * Triggers the callback in newUnsignedTypedMessage.\n   *\n   * @param msgParams - The params passed to eth_signTypedData.\n   * @param opts - Options bag.\n   * @param opts.parseJsonData - Whether to parse JSON data before calling the KeyringController.\n   * @returns Full state update.\n   */\n  async signTypedMessage(\n    msgParams: TypedMessageParamsMetamask,\n    opts: { parseJsonData: boolean } = { parseJsonData: true },\n  ): Promise<any> {\n    const { version } = msgParams;\n\n    return await this.#signAbstractMessage(\n      this.#typedMessageManager,\n      ApprovalType.EthSignTypedData,\n      msgParams,\n      async (cleanMsgParams) => {\n        const finalMessageParams = opts.parseJsonData\n          ? this.#removeJsonData(cleanMsgParams, version as string)\n          : cleanMsgParams;\n\n        return await this.#keyringController.signTypedMessage(\n          finalMessageParams,\n          {\n            version,\n          },\n        );\n      },\n    );\n  }\n\n  /**\n   * Used to cancel a message submitted via eth_sign.\n   *\n   * @param msgId - The id of the message to cancel.\n   * @returns A full state update.\n   */\n  cancelMessage(msgId: string): any {\n    return this.#cancelAbstractMessage(this.#messageManager, msgId);\n  }\n\n  /**\n   * Used to cancel a personal_sign type message.\n   *\n   * @param msgId - The ID of the message to cancel.\n   * @returns A full state update.\n   */\n  cancelPersonalMessage(msgId: string): any {\n    return this.#cancelAbstractMessage(this.#personalMessageManager, msgId);\n  }\n\n  /**\n   * Used to cancel a eth_signTypedData type message.\n   *\n   * @param msgId - The ID of the message to cancel.\n   * @returns A full state update.\n   */\n  cancelTypedMessage(msgId: string): any {\n    return this.#cancelAbstractMessage(this.#typedMessageManager, msgId);\n  }\n\n  /**\n   * Reject all unapproved messages of any type.\n   *\n   * @param reason - A message to indicate why.\n   */\n  rejectUnapproved(reason?: string) {\n    this.#rejectUnapproved(this.#messageManager, reason);\n    this.#rejectUnapproved(this.#personalMessageManager, reason);\n    this.#rejectUnapproved(this.#typedMessageManager, reason);\n  }\n\n  /**\n   * Clears all unapproved messages from memory.\n   */\n  clearUnapproved() {\n    this.#clearUnapproved(this.#messageManager);\n    this.#clearUnapproved(this.#personalMessageManager);\n    this.#clearUnapproved(this.#typedMessageManager);\n  }\n\n  #rejectUnapproved<\n    M extends AbstractMessage,\n    P extends AbstractMessageParams,\n    PM extends AbstractMessageParamsMetamask,\n  >(messageManager: AbstractMessageManager<M, P, PM>, reason?: string) {\n    Object.keys(messageManager.getUnapprovedMessages()).forEach((messageId) => {\n      this.#cancelAbstractMessage(messageManager, messageId, reason);\n    });\n  }\n\n  #clearUnapproved<\n    M extends AbstractMessage,\n    P extends AbstractMessageParams,\n    PM extends AbstractMessageParamsMetamask,\n  >(messageManager: AbstractMessageManager<M, P, PM>) {\n    messageManager.update({\n      unapprovedMessages: {},\n      unapprovedMessagesCount: 0,\n    });\n  }\n\n  async #signAbstractMessage<\n    M extends AbstractMessage,\n    P extends AbstractMessageParams,\n    PM extends AbstractMessageParamsMetamask,\n  >(\n    messageManager: AbstractMessageManager<M, P, PM>,\n    methodName: string,\n    msgParams: PM,\n    getSignature: (cleanMessageParams: P) => Promise<any>,\n  ) {\n    console.info(`MetaMaskController - ${methodName}`);\n\n    const messageId = msgParams.metamaskId as string;\n\n    try {\n      const cleanMessageParams = await messageManager.approveMessage(msgParams);\n      const signature = await getSignature(cleanMessageParams);\n\n      messageManager.setMessageStatusSigned(messageId, signature);\n\n      this.#acceptApproval(messageId);\n\n      return this.#getAllState();\n    } catch (error: any) {\n      console.info(`MetaMaskController - ${methodName} failed.`, error);\n      this.#errorMessage(messageManager, messageId, error.message);\n      throw error;\n    }\n  }\n\n  #errorMessage<\n    M extends AbstractMessage,\n    P extends AbstractMessageParams,\n    PM extends AbstractMessageParamsMetamask,\n  >(\n    messageManager: AbstractMessageManager<M, P, PM>,\n    messageId: string,\n    error: string,\n  ) {\n    if (messageManager instanceof TypedMessageManager) {\n      messageManager.setMessageStatusErrored(messageId, error);\n      this.#rejectApproval(messageId);\n    } else {\n      this.#cancelAbstractMessage(messageManager, messageId);\n    }\n  }\n\n  #cancelAbstractMessage<\n    M extends AbstractMessage,\n    P extends AbstractMessageParams,\n    PM extends AbstractMessageParamsMetamask,\n  >(\n    messageManager: AbstractMessageManager<M, P, PM>,\n    messageId: string,\n    reason?: string,\n  ) {\n    if (reason) {\n      const message = this.#getMessage(messageId);\n      this.hub.emit('cancelWithReason', { message, reason });\n    }\n\n    messageManager.rejectMessage(messageId);\n    this.#rejectApproval(messageId);\n\n    return this.#getAllState();\n  }\n\n  #handleMessageManagerEvents<\n    M extends AbstractMessage,\n    P extends AbstractMessageParams,\n    PM extends AbstractMessageParamsMetamask,\n  >(\n    messageManager: AbstractMessageManager<M, P, PM>,\n    approvalType: ApprovalType,\n    eventName: string,\n  ) {\n    messageManager.hub.on('updateBadge', () => {\n      this.hub.emit('updateBadge');\n    });\n\n    messageManager.hub.on(\n      'unapprovedMessage',\n      (msgParams: AbstractMessageParamsMetamask) => {\n        this.hub.emit(eventName, msgParams);\n        this.#requestApproval(msgParams, approvalType);\n      },\n    );\n  }\n\n  #subscribeToMessageState<\n    M extends AbstractMessage,\n    P extends AbstractMessageParams,\n    PM extends AbstractMessageParamsMetamask,\n  >(\n    messageManager: AbstractMessageManager<M, P, PM>,\n    updateState: (\n      state: SignatureControllerState,\n      newMessages: Record<string, StateMessage>,\n      messageCount: number,\n    ) => void,\n  ) {\n    messageManager.subscribe((state: MessageManagerState<AbstractMessage>) => {\n      const newMessages = this.#migrateMessages(\n        state.unapprovedMessages as any,\n      );\n\n      this.update(() => {\n        const newState = { ...this.state };\n        updateState(newState, newMessages, state.unapprovedMessagesCount);\n        return newState;\n      });\n    });\n  }\n\n  #migrateMessages(\n    coreMessages: Record<string, CoreMessage>,\n  ): Record<string, StateMessage> {\n    const stateMessages: Record<string, StateMessage> = {};\n\n    for (const messageId of Object.keys(coreMessages)) {\n      const coreMessage = coreMessages[messageId];\n      const stateMessage = this.#migrateMessage(coreMessage);\n\n      stateMessages[messageId] = stateMessage;\n    }\n\n    return stateMessages;\n  }\n\n  #migrateMessage(coreMessage: CoreMessage): StateMessage {\n    const { messageParams, ...coreMessageData } = coreMessage;\n\n    // Core message managers use messageParams but frontend uses msgParams with lots of references\n    const stateMessage = {\n      ...coreMessageData,\n      msgParams: messageParams,\n    };\n\n    return stateMessage as StateMessage;\n  }\n\n  #normalizeMsgData(data: string) {\n    if (data.slice(0, 2) === '0x') {\n      // data is already hex\n      return data;\n    }\n    // data is unicode, convert to hex\n    return bufferToHex(Buffer.from(data, 'utf8'));\n  }\n\n  #getMessage(messageId: string): StateMessage {\n    return {\n      ...this.state.unapprovedMsgs,\n      ...this.state.unapprovedPersonalMsgs,\n      ...this.state.unapprovedTypedMessages,\n    }[messageId];\n  }\n\n  #requestApproval(\n    msgParams: AbstractMessageParamsMetamask,\n    type: ApprovalType,\n  ) {\n    const id = msgParams.metamaskId as string;\n    const origin = msgParams.origin || ORIGIN_METAMASK;\n\n    this.messagingSystem\n      .call(\n        'ApprovalController:addRequest',\n        {\n          id,\n          origin,\n          type,\n          requestData: msgParams as Required<AbstractMessageParamsMetamask>,\n        },\n        true,\n      )\n      .catch(() => {\n        // Intentionally ignored as promise not currently used\n      });\n  }\n\n  #acceptApproval(messageId: string) {\n    this.messagingSystem.call('ApprovalController:acceptRequest', messageId);\n  }\n\n  #rejectApproval(messageId: string) {\n    this.messagingSystem.call(\n      'ApprovalController:rejectRequest',\n      messageId,\n      'Cancel',\n    );\n  }\n\n  #removeJsonData(\n    messageParams: TypedMessageParams,\n    version: string,\n  ): TypedMessageParams {\n    if (version === 'V1' || typeof messageParams.data !== 'string') {\n      return messageParams;\n    }\n\n    return {\n      ...messageParams,\n      data: JSON.parse(messageParams.data),\n    };\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SignatureController.js","sourceRoot":"","sources":["../src/SignatureController.ts"],"names":[],"mappings":"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","sourcesContent":["import EventEmitter from 'events';\nimport type { Hex } from '@metamask/utils';\nimport { cloneDeep } from 'lodash';\nimport {\n  MessageManager,\n  MessageParams,\n  MessageParamsMetamask,\n  PersonalMessageManager,\n  PersonalMessageParams,\n  PersonalMessageParamsMetamask,\n  TypedMessageManager,\n  TypedMessageParams,\n  TypedMessageParamsMetamask,\n  TypedMessageSigningOptions,\n  AbstractMessageManager,\n  AbstractMessage,\n  MessageManagerState,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from '@metamask/message-manager';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { bufferToHex } from 'ethereumjs-util';\n\nimport {\n  BaseControllerV2,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { Patch } from 'immer';\nimport {\n  AddApprovalRequest,\n  RejectRequest,\n} from '@metamask/approval-controller';\nimport { ApprovalType, ORIGIN_METAMASK } from '@metamask/controller-utils';\n\nconst controllerName = 'SignatureController';\n\nconst stateMetadata = {\n  unapprovedMsgs: { persist: false, anonymous: false },\n  unapprovedPersonalMsgs: { persist: false, anonymous: false },\n  unapprovedTypedMessages: { persist: false, anonymous: false },\n  unapprovedMsgCount: { persist: false, anonymous: false },\n  unapprovedPersonalMsgCount: { persist: false, anonymous: false },\n  unapprovedTypedMessagesCount: { persist: false, anonymous: false },\n};\n\nconst getDefaultState = () => ({\n  unapprovedMsgs: {},\n  unapprovedPersonalMsgs: {},\n  unapprovedTypedMessages: {},\n  unapprovedMsgCount: 0,\n  unapprovedPersonalMsgCount: 0,\n  unapprovedTypedMessagesCount: 0,\n});\n\ntype CoreMessage = AbstractMessage & {\n  messageParams: AbstractMessageParams;\n};\n\ntype StateMessage = Required<AbstractMessage> & {\n  msgParams: Required<AbstractMessageParams>;\n};\n\ntype SignatureControllerState = {\n  unapprovedMsgs: Record<string, StateMessage>;\n  unapprovedPersonalMsgs: Record<string, StateMessage>;\n  unapprovedTypedMessages: Record<string, StateMessage>;\n  unapprovedMsgCount: number;\n  unapprovedPersonalMsgCount: number;\n  unapprovedTypedMessagesCount: number;\n};\n\ntype AllowedActions = AddApprovalRequest | RejectRequest;\n\nexport type GetSignatureState = {\n  type: `${typeof controllerName}:getState`;\n  handler: () => SignatureControllerState;\n};\n\nexport type SignatureStateChange = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [SignatureControllerState, Patch[]];\n};\n\nexport type SignatureControllerActions = GetSignatureState;\n\nexport type SignatureControllerEvents = SignatureStateChange;\n\nexport type SignatureControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  SignatureControllerActions | AllowedActions,\n  SignatureControllerEvents,\n  AllowedActions['type'],\n  never\n>;\n\nexport interface KeyringController {\n  signMessage: (messsageParams: MessageParams) => Promise<string>;\n  signPersonalMessage: (\n    messsageParams: PersonalMessageParams,\n  ) => Promise<string>;\n  signTypedMessage: (\n    messsageParams: TypedMessageParams,\n    options: { version: string | undefined },\n  ) => Promise<string>;\n}\n\nexport type SignatureControllerOptions = {\n  messenger: SignatureControllerMessenger;\n  keyringController: KeyringController;\n  isEthSignEnabled: () => boolean;\n  getAllState: () => unknown;\n  securityProviderRequest?: (\n    requestData: any,\n    methodName: string,\n  ) => Promise<any>;\n  getCurrentChainId: () => Hex;\n};\n\n/**\n * Controller for creating signing requests requiring user approval.\n */\nexport class SignatureController extends BaseControllerV2<\n  typeof controllerName,\n  SignatureControllerState,\n  SignatureControllerMessenger\n> {\n  hub: EventEmitter;\n\n  #keyringController: KeyringController;\n\n  #isEthSignEnabled: () => boolean;\n\n  #getAllState: () => any;\n\n  #messageManager: MessageManager;\n\n  #personalMessageManager: PersonalMessageManager;\n\n  #typedMessageManager: TypedMessageManager;\n\n  /**\n   * Construct a Sign controller.\n   *\n   * @param options - The controller options.\n   * @param options.messenger - The restricted controller messenger for the sign controller.\n   * @param options.keyringController - An instance of a keyring controller used to perform the signing operations.\n   * @param options.isEthSignEnabled - Callback to return true if eth_sign is enabled.\n   * @param options.getAllState - Callback to retrieve all user state.\n   * @param options.securityProviderRequest - A function for verifying a message, whether it is malicious or not.\n   * @param options.getCurrentChainId - A function for retrieving the current chainId.\n   */\n  constructor({\n    messenger,\n    keyringController,\n    isEthSignEnabled,\n    getAllState,\n    securityProviderRequest,\n    getCurrentChainId,\n  }: SignatureControllerOptions) {\n    super({\n      name: controllerName,\n      metadata: stateMetadata,\n      messenger,\n      state: getDefaultState(),\n    });\n\n    this.#keyringController = keyringController;\n    this.#isEthSignEnabled = isEthSignEnabled;\n    this.#getAllState = getAllState;\n\n    this.hub = new EventEmitter();\n    this.#messageManager = new MessageManager(\n      undefined,\n      undefined,\n      securityProviderRequest,\n    );\n    this.#personalMessageManager = new PersonalMessageManager(\n      undefined,\n      undefined,\n      securityProviderRequest,\n    );\n    this.#typedMessageManager = new TypedMessageManager(\n      undefined,\n      undefined,\n      securityProviderRequest,\n      undefined,\n      getCurrentChainId,\n    );\n\n    this.#handleMessageManagerEvents(this.#messageManager, 'unapprovedMessage');\n    this.#handleMessageManagerEvents(\n      this.#personalMessageManager,\n      'unapprovedPersonalMessage',\n    );\n    this.#handleMessageManagerEvents(\n      this.#typedMessageManager,\n      'unapprovedTypedMessage',\n    );\n\n    this.#subscribeToMessageState(\n      this.#messageManager,\n      (state, newMessages, messageCount) => {\n        state.unapprovedMsgs = newMessages;\n        state.unapprovedMsgCount = messageCount;\n      },\n    );\n\n    this.#subscribeToMessageState(\n      this.#personalMessageManager,\n      (state, newMessages, messageCount) => {\n        state.unapprovedPersonalMsgs = newMessages;\n        state.unapprovedPersonalMsgCount = messageCount;\n      },\n    );\n\n    this.#subscribeToMessageState(\n      this.#typedMessageManager,\n      (state, newMessages, messageCount) => {\n        state.unapprovedTypedMessages = newMessages;\n        state.unapprovedTypedMessagesCount = messageCount;\n      },\n    );\n  }\n\n  /**\n   * A getter for the number of 'unapproved' Messages in this.messages.\n   *\n   * @returns The number of 'unapproved' Messages in this.messages\n   */\n  get unapprovedMsgCount(): number {\n    return this.#messageManager.getUnapprovedMessagesCount();\n  }\n\n  /**\n   * A getter for the number of 'unapproved' PersonalMessages in this.messages.\n   *\n   * @returns The number of 'unapproved' PersonalMessages in this.messages\n   */\n  get unapprovedPersonalMessagesCount(): number {\n    return this.#personalMessageManager.getUnapprovedMessagesCount();\n  }\n\n  /**\n   * A getter for the number of 'unapproved' TypedMessages in this.messages.\n   *\n   * @returns The number of 'unapproved' TypedMessages in this.messages\n   */\n  get unapprovedTypedMessagesCount(): number {\n    return this.#typedMessageManager.getUnapprovedMessagesCount();\n  }\n\n  /**\n   * Reset the controller state to the initial state.\n   */\n  resetState() {\n    this.update(() => getDefaultState());\n  }\n\n  /**\n   * Reject all unapproved messages of any type.\n   *\n   * @param reason - A message to indicate why.\n   */\n  rejectUnapproved(reason?: string) {\n    this.#rejectUnapproved(this.#messageManager, reason);\n    this.#rejectUnapproved(this.#personalMessageManager, reason);\n    this.#rejectUnapproved(this.#typedMessageManager, reason);\n  }\n\n  /**\n   * Clears all unapproved messages from memory.\n   */\n  clearUnapproved() {\n    this.#clearUnapproved(this.#messageManager);\n    this.#clearUnapproved(this.#personalMessageManager);\n    this.#clearUnapproved(this.#typedMessageManager);\n  }\n\n  /**\n   * Called when a Dapp uses the eth_sign method, to request user approval.\n   * eth_sign is a pure signature of arbitrary data. It is on a deprecation\n   * path, since this data can be a transaction, or can leak private key\n   * information.\n   *\n   * @param messageParams - The params passed to eth_sign.\n   * @param [req] - The original request, containing the origin.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  async newUnsignedMessage(\n    messageParams: MessageParams,\n    req: OriginalRequest,\n  ): Promise<string> {\n    return this.#newUnsignedAbstractMessage(\n      this.#messageManager,\n      ApprovalType.EthSign,\n      'Message',\n      this.#signMessage.bind(this),\n      messageParams,\n      req,\n      (params) => {\n        if (!this.#isEthSignEnabled()) {\n          throw ethErrors.rpc.methodNotFound(\n            'eth_sign has been disabled. You must enable it in the advanced settings',\n          );\n        }\n        const data = this.#normalizeMsgData(params.data);\n        // 64 hex + \"0x\" at the beginning\n        // This is needed because Ethereum's EcSign works only on 32 byte numbers\n        // For 67 length see: https://github.com/MetaMask/metamask-extension/pull/12679/files#r749479607\n        if (data.length !== 66 && data.length !== 67) {\n          throw ethErrors.rpc.invalidParams(\n            'eth_sign requires 32 byte message hash',\n          );\n        }\n      },\n    );\n  }\n\n  /**\n   * Called when a dapp uses the personal_sign method.\n   * This is identical to the Geth eth_sign method, and may eventually replace\n   * eth_sign.\n   *\n   * We currently define our eth_sign and personal_sign mostly for legacy Dapps.\n   *\n   * @param messageParams - The params of the message to sign & return to the Dapp.\n   * @param req - The original request, containing the origin.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  async newUnsignedPersonalMessage(\n    messageParams: PersonalMessageParams,\n    req: OriginalRequest,\n  ): Promise<string> {\n    return this.#newUnsignedAbstractMessage(\n      this.#personalMessageManager,\n      ApprovalType.PersonalSign,\n      'Personal Message',\n      this.#signPersonalMessage.bind(this),\n      messageParams,\n      req,\n    );\n  }\n\n  /**\n   * Called when a dapp uses the eth_signTypedData method, per EIP 712.\n   *\n   * @param messageParams - The params passed to eth_signTypedData.\n   * @param req - The original request, containing the origin.\n   * @param version - The version indicating the format of the typed data.\n   * @param signingOpts - An options bag for signing.\n   * @param signingOpts.parseJsonData - Whether to parse the JSON before signing.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  async newUnsignedTypedMessage(\n    messageParams: TypedMessageParams,\n    req: OriginalRequest,\n    version: string,\n    signingOpts: TypedMessageSigningOptions = { parseJsonData: true },\n  ): Promise<string> {\n    return this.#newUnsignedAbstractMessage(\n      this.#typedMessageManager,\n      ApprovalType.EthSignTypedData,\n      'Typed Message',\n      this.#signTypedMessage.bind(this),\n      messageParams,\n      req,\n      undefined,\n      version,\n      signingOpts,\n    );\n  }\n\n  setTypedMessageInProgress(messageId: string) {\n    this.#typedMessageManager.setMessageStatusInProgress(messageId);\n  }\n\n  setPersonalMessageInProgress(messageId: string) {\n    this.#personalMessageManager.setMessageStatusInProgress(messageId);\n  }\n\n  async #newUnsignedAbstractMessage<\n    M extends AbstractMessage,\n    P extends AbstractMessageParams,\n    PM extends AbstractMessageParamsMetamask,\n  >(\n    messageManager: AbstractMessageManager<M, P, PM>,\n    approvalType: ApprovalType,\n    messageName: string,\n    signMessage: (\n      messageParams: PM,\n      version?: string,\n      signingOpts?: TypedMessageSigningOptions,\n    ) => void,\n    messageParams: PM,\n    req: OriginalRequest,\n    validateMessage?: (params: PM) => void,\n    version?: string,\n    signingOpts?: TypedMessageSigningOptions,\n  ) {\n    if (validateMessage) {\n      validateMessage(messageParams);\n    }\n\n    const messageId = await messageManager.addUnapprovedMessage(\n      messageParams,\n      req,\n      version,\n    );\n\n    const messageParamsWithId = {\n      ...messageParams,\n      metamaskId: messageId,\n    };\n\n    const signaturePromise = messageManager.waitForFinishStatus(\n      messageParamsWithId,\n      messageName,\n      true,\n    );\n\n    try {\n      await this.#requestApproval(messageParamsWithId, approvalType);\n    } catch (error) {\n      this.#cancelAbstractMessage(messageManager, messageId);\n      throw ethErrors.provider.userRejectedRequest(\n        'User rejected the request.',\n      );\n    }\n    await signMessage(messageParamsWithId, version, signingOpts);\n\n    return signaturePromise;\n  }\n\n  /**\n   * Signifies user intent to complete an eth_sign method.\n   *\n   * @param msgParams - The params passed to eth_call.\n   * @returns Signature result from signing.\n   */\n  async #signMessage(msgParams: MessageParamsMetamask) {\n    return await this.#signAbstractMessage(\n      this.#messageManager,\n      ApprovalType.EthSign,\n      msgParams,\n      async (cleanMsgParams) =>\n        await this.#keyringController.signMessage(cleanMsgParams),\n    );\n  }\n\n  /**\n   * Signifies a user's approval to sign a personal_sign message in queue.\n   * Triggers signing, and the callback function from newUnsignedPersonalMessage.\n   *\n   * @param msgParams - The params of the message to sign & return to the Dapp.\n   * @returns Signature result from signing.\n   */\n  async #signPersonalMessage(msgParams: PersonalMessageParamsMetamask) {\n    return await this.#signAbstractMessage(\n      this.#personalMessageManager,\n      ApprovalType.PersonalSign,\n      msgParams,\n      async (cleanMsgParams) =>\n        await this.#keyringController.signPersonalMessage(cleanMsgParams),\n    );\n  }\n\n  /**\n   * The method for a user approving a call to eth_signTypedData, per EIP 712.\n   * Triggers the callback in newUnsignedTypedMessage.\n   *\n   * @param msgParams - The params passed to eth_signTypedData.\n   * @param version - The version indicating the format of the typed data.\n   * @param opts - The options for the method.\n   * @param opts.parseJsonData - Whether to parse JSON data before calling the KeyringController.\n   * @returns Signature result from signing.\n   */\n  async #signTypedMessage(\n    msgParams: TypedMessageParamsMetamask,\n    version?: string,\n    opts?: TypedMessageSigningOptions,\n  ): Promise<any> {\n    return await this.#signAbstractMessage(\n      this.#typedMessageManager,\n      ApprovalType.EthSignTypedData,\n      msgParams,\n      async (cleanMsgParams) => {\n        const finalMessageParams = opts?.parseJsonData\n          ? this.#removeJsonData(cleanMsgParams, version as string)\n          : cleanMsgParams;\n\n        return await this.#keyringController.signTypedMessage(\n          finalMessageParams,\n          {\n            version,\n          },\n        );\n      },\n    );\n  }\n\n  #rejectUnapproved<\n    M extends AbstractMessage,\n    P extends AbstractMessageParams,\n    PM extends AbstractMessageParamsMetamask,\n  >(messageManager: AbstractMessageManager<M, P, PM>, reason?: string) {\n    Object.keys(messageManager.getUnapprovedMessages()).forEach((messageId) => {\n      this.#cancelAbstractMessage(messageManager, messageId, reason);\n    });\n  }\n\n  #clearUnapproved<\n    M extends AbstractMessage,\n    P extends AbstractMessageParams,\n    PM extends AbstractMessageParamsMetamask,\n  >(messageManager: AbstractMessageManager<M, P, PM>) {\n    messageManager.update({\n      unapprovedMessages: {},\n      unapprovedMessagesCount: 0,\n    });\n  }\n\n  async #signAbstractMessage<\n    M extends AbstractMessage,\n    P extends AbstractMessageParams,\n    PM extends AbstractMessageParamsMetamask,\n  >(\n    messageManager: AbstractMessageManager<M, P, PM>,\n    methodName: string,\n    msgParams: PM,\n    getSignature: (cleanMessageParams: P) => Promise<any>,\n  ) {\n    console.info(`MetaMaskController - ${methodName}`);\n\n    const messageId = msgParams.metamaskId as string;\n\n    try {\n      const cleanMessageParams = await messageManager.approveMessage(msgParams);\n      const signature = await getSignature(cleanMessageParams);\n\n      this.hub.emit(`${methodName}:signed`, { signature, messageId });\n\n      if (!cleanMessageParams.deferSetAsSigned) {\n        messageManager.setMessageStatusSigned(messageId, signature);\n      }\n\n      return signature;\n    } catch (error: any) {\n      console.info(`MetaMaskController - ${methodName} failed.`, error);\n      throw error;\n    }\n  }\n\n  #cancelAbstractMessage<\n    M extends AbstractMessage,\n    P extends AbstractMessageParams,\n    PM extends AbstractMessageParamsMetamask,\n  >(\n    messageManager: AbstractMessageManager<M, P, PM>,\n    messageId: string,\n    reason?: string,\n  ) {\n    if (reason) {\n      const message = this.#getMessage(messageId);\n      this.hub.emit('cancelWithReason', { message, reason });\n    }\n    messageManager.rejectMessage(messageId);\n  }\n\n  #handleMessageManagerEvents<\n    M extends AbstractMessage,\n    P extends AbstractMessageParams,\n    PM extends AbstractMessageParamsMetamask,\n  >(messageManager: AbstractMessageManager<M, P, PM>, eventName: string) {\n    messageManager.hub.on('updateBadge', () => {\n      this.hub.emit('updateBadge');\n    });\n\n    messageManager.hub.on(\n      'unapprovedMessage',\n      (msgParams: AbstractMessageParamsMetamask) => {\n        this.hub.emit(eventName, msgParams);\n      },\n    );\n  }\n\n  #subscribeToMessageState<\n    M extends AbstractMessage,\n    P extends AbstractMessageParams,\n    PM extends AbstractMessageParamsMetamask,\n  >(\n    messageManager: AbstractMessageManager<M, P, PM>,\n    updateState: (\n      state: SignatureControllerState,\n      newMessages: Record<string, StateMessage>,\n      messageCount: number,\n    ) => void,\n  ) {\n    messageManager.subscribe((state: MessageManagerState<AbstractMessage>) => {\n      const newMessages = this.#migrateMessages(\n        state.unapprovedMessages as any,\n      );\n\n      this.update(() => {\n        const newState = { ...this.state };\n        updateState(newState, newMessages, state.unapprovedMessagesCount);\n        return newState;\n      });\n    });\n  }\n\n  #migrateMessages(\n    coreMessages: Record<string, CoreMessage>,\n  ): Record<string, StateMessage> {\n    const stateMessages: Record<string, StateMessage> = {};\n\n    for (const messageId of Object.keys(coreMessages)) {\n      const coreMessage = coreMessages[messageId];\n      const stateMessage = this.#migrateMessage(coreMessage);\n\n      stateMessages[messageId] = stateMessage;\n    }\n\n    return stateMessages;\n  }\n\n  #migrateMessage(coreMessage: CoreMessage): StateMessage {\n    const { messageParams, ...coreMessageData } = coreMessage;\n\n    // Core message managers use messageParams but frontend uses msgParams with lots of references\n    const stateMessage = {\n      ...coreMessageData,\n      msgParams: messageParams,\n    };\n\n    return stateMessage as StateMessage;\n  }\n\n  #normalizeMsgData(data: string) {\n    if (data.slice(0, 2) === '0x') {\n      // data is already hex\n      return data;\n    }\n    // data is unicode, convert to hex\n    return bufferToHex(Buffer.from(data, 'utf8'));\n  }\n\n  #getMessage(messageId: string): StateMessage {\n    return {\n      ...this.state.unapprovedMsgs,\n      ...this.state.unapprovedPersonalMsgs,\n      ...this.state.unapprovedTypedMessages,\n    }[messageId];\n  }\n\n  async #requestApproval(\n    msgParams: AbstractMessageParamsMetamask,\n    type: ApprovalType,\n  ) {\n    const id = msgParams.metamaskId as string;\n    const origin = msgParams.origin || ORIGIN_METAMASK;\n\n    // We are explicitly cloning the message params here to prevent the mutation errors on development mode\n    // Because sending it through the messaging system will make the object read only\n    const clonedMsgParams = cloneDeep(msgParams);\n\n    return this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        id,\n        origin,\n        type,\n        requestData: clonedMsgParams as Required<AbstractMessageParamsMetamask>,\n      },\n      true,\n    );\n  }\n\n  #removeJsonData(\n    messageParams: TypedMessageParams,\n    version: string,\n  ): TypedMessageParams {\n    if (version === 'V1' || typeof messageParams.data !== 'string') {\n      return messageParams;\n    }\n\n    return {\n      ...messageParams,\n      data: JSON.parse(messageParams.data),\n    };\n  }\n}\n"]}
\ No newline at end of file
