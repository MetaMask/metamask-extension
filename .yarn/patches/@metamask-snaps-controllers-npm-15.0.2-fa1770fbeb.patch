diff --git a/dist/cronjob/CronjobController.cjs b/dist/cronjob/CronjobController.cjs
index 53650823260f5f288fb51ad9488822486182b80b..718bc63499a1f493d4c0660c8ad3b906dccfb4bb 100644
--- a/dist/cronjob/CronjobController.cjs
+++ b/dist/cronjob/CronjobController.cjs
@@ -1,7 +1,7 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.CronjobController = exports.DAILY_TIMEOUT = void 0;
-const base_controller_1 = require("@metamask/base-controller");
+const next_1 = require("@metamask/base-controller/next");
 const snaps_rpc_methods_1 = require("@metamask/snaps-rpc-methods");
 const snaps_utils_1 = require("@metamask/snaps-utils");
 const utils_1 = require("@metamask/utils");
@@ -18,7 +18,7 @@ const controllerName = 'CronjobController';
  * events for Snaps. It allows Snaps to schedule events that will be executed
  * at a later time.
  */
-class CronjobController extends base_controller_1.BaseController {
+class CronjobController extends next_1.BaseController {
     #timers;
     #stateManager;
     #dailyTimer = new Timer_1.Timer(exports.DAILY_TIMEOUT);
@@ -29,7 +29,7 @@ class CronjobController extends base_controller_1.BaseController {
                 events: {
                     includeInStateLogs: false,
                     persist: false,
-                    anonymous: false,
+                    includeInDebugSnapshot: false,
                     usedInUi: false,
                 },
             },
@@ -42,15 +42,15 @@ class CronjobController extends base_controller_1.BaseController {
         });
         this.#timers = new Map();
         this.#stateManager = stateManager;
-        this.messagingSystem.subscribe('SnapController:snapInstalled', this.#handleSnapInstalledEvent);
-        this.messagingSystem.subscribe('SnapController:snapUninstalled', this.#handleSnapUninstalledEvent);
-        this.messagingSystem.subscribe('SnapController:snapEnabled', this.#handleSnapEnabledEvent);
-        this.messagingSystem.subscribe('SnapController:snapDisabled', this.#handleSnapDisabledEvent);
-        this.messagingSystem.subscribe('SnapController:snapUpdated', this.#handleSnapUpdatedEvent);
-        this.messagingSystem.registerActionHandler(`${controllerName}:init`, (...args) => this.init(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:schedule`, (...args) => this.schedule(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:cancel`, (...args) => this.cancel(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:get`, (...args) => this.get(...args));
+        this.messenger.subscribe('SnapController:snapInstalled', this.#handleSnapInstalledEvent);
+        this.messenger.subscribe('SnapController:snapUninstalled', this.#handleSnapUninstalledEvent);
+        this.messenger.subscribe('SnapController:snapEnabled', this.#handleSnapEnabledEvent);
+        this.messenger.subscribe('SnapController:snapDisabled', this.#handleSnapDisabledEvent);
+        this.messenger.subscribe('SnapController:snapUpdated', this.#handleSnapUpdatedEvent);
+        this.messenger.registerActionHandler(`${controllerName}:init`, (...args) => this.init(...args));
+        this.messenger.registerActionHandler(`${controllerName}:schedule`, (...args) => this.schedule(...args));
+        this.messenger.registerActionHandler(`${controllerName}:cancel`, (...args) => this.cancel(...args));
+        this.messenger.registerActionHandler(`${controllerName}:get`, (...args) => this.get(...args));
     }
     /**
      * Initialize the CronjobController.
@@ -129,11 +129,11 @@ class CronjobController extends base_controller_1.BaseController {
      */
     destroy() {
         super.destroy();
-        this.messagingSystem.unsubscribe('SnapController:snapInstalled', this.#handleSnapInstalledEvent);
-        this.messagingSystem.unsubscribe('SnapController:snapUninstalled', this.#handleSnapUninstalledEvent);
-        this.messagingSystem.unsubscribe('SnapController:snapEnabled', this.#handleSnapEnabledEvent);
-        this.messagingSystem.unsubscribe('SnapController:snapDisabled', this.#handleSnapDisabledEvent);
-        this.messagingSystem.unsubscribe('SnapController:snapUpdated', this.#handleSnapUpdatedEvent);
+        this.messenger.unsubscribe('SnapController:snapInstalled', this.#handleSnapInstalledEvent);
+        this.messenger.unsubscribe('SnapController:snapUninstalled', this.#handleSnapUninstalledEvent);
+        this.messenger.unsubscribe('SnapController:snapEnabled', this.#handleSnapEnabledEvent);
+        this.messenger.unsubscribe('SnapController:snapDisabled', this.#handleSnapDisabledEvent);
+        this.messenger.unsubscribe('SnapController:snapUpdated', this.#handleSnapUpdatedEvent);
         // Cancel all timers and clear the map.
         this.#timers.forEach((timer) => timer.cancel());
         this.#timers.clear();
@@ -229,7 +229,7 @@ class CronjobController extends base_controller_1.BaseController {
      * @param event - The event to execute.
      */
     #execute(event) {
-        this.messagingSystem
+        this.messenger
             .call('SnapController:handleRequest', {
             snapId: event.snapId,
             origin: constants_1.METAMASK_ORIGIN,
@@ -273,7 +273,7 @@ class CronjobController extends base_controller_1.BaseController {
      * @returns Array of cronjob specifications.
      */
     #getSnapCronjobs(snapId) {
-        const permissions = this.messagingSystem.call('PermissionController:getPermissions', snapId);
+        const permissions = this.messenger.call('PermissionController:getPermissions', snapId);
         const permission = permissions?.[snaps_rpc_methods_1.SnapEndowments.Cronjob];
         const definitions = (0, snaps_rpc_methods_1.getCronjobCaveatJobs)(permission);
         if (!definitions) {
diff --git a/dist/cronjob/CronjobController.cjs.map b/dist/cronjob/CronjobController.cjs.map
index 2d12a74df2626bde77f7ca6fb97cc7acf35945c0..9c695e9dbc57a5238892749a6a55ad944c2a80b4 100644
--- a/dist/cronjob/CronjobController.cjs.map
+++ b/dist/cronjob/CronjobController.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"CronjobController.cjs","sourceRoot":"","sources":["../../src/cronjob/CronjobController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  RestrictedMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { GetPermissions } from '@metamask/permission-controller';\nimport {\n  getCronjobCaveatJobs,\n  SnapEndowments,\n} from '@metamask/snaps-rpc-methods';\nimport type { BackgroundEvent, SnapId } from '@metamask/snaps-sdk';\nimport type { TruncatedSnap } from '@metamask/snaps-utils';\nimport {\n  toCensoredISO8601String,\n  HandlerType,\n  logError,\n} from '@metamask/snaps-utils';\nimport { assert, Duration, inMilliseconds } from '@metamask/utils';\nimport { castDraft } from 'immer';\nimport { DateTime } from 'luxon';\nimport { nanoid } from 'nanoid';\n\nimport { getCronjobSpecificationSchedule, getExecutionDate } from './utils';\nimport type {\n  HandleSnapRequest,\n  SnapDisabled,\n  SnapEnabled,\n  SnapInstalled,\n  SnapUninstalled,\n  SnapUpdated,\n} from '..';\nimport { METAMASK_ORIGIN } from '../snaps/constants';\nimport { Timer } from '../snaps/Timer';\n\nexport type CronjobControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  CronjobControllerState\n>;\nexport type CronjobControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  CronjobControllerState\n>;\n\n/**\n * Initialise the CronjobController. This should be called after all controllers\n * are created.\n */\nexport type CronjobControllerInitAction = {\n  type: `${typeof controllerName}:init`;\n  handler: CronjobController['init'];\n};\n\nexport type Schedule = {\n  type: `${typeof controllerName}:schedule`;\n  handler: CronjobController['schedule'];\n};\n\nexport type Cancel = {\n  type: `${typeof controllerName}:cancel`;\n  handler: CronjobController['cancel'];\n};\n\nexport type Get = {\n  type: `${typeof controllerName}:get`;\n  handler: CronjobController['get'];\n};\n\nexport type CronjobControllerActions =\n  | CronjobControllerGetStateAction\n  | HandleSnapRequest\n  | GetPermissions\n  | Schedule\n  | Cancel\n  | Get\n  | CronjobControllerInitAction;\n\nexport type CronjobControllerEvents =\n  | CronjobControllerStateChangeEvent\n  | SnapInstalled\n  | SnapUninstalled\n  | SnapUpdated\n  | SnapEnabled\n  | SnapDisabled;\n\nexport type CronjobControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  CronjobControllerActions,\n  CronjobControllerEvents,\n  CronjobControllerActions['type'],\n  CronjobControllerEvents['type']\n>;\n\nexport const DAILY_TIMEOUT = inMilliseconds(24, Duration.Hour);\n\nexport type CronjobControllerStateManager = {\n  set(state: CronjobControllerState): void;\n  getInitialState(): CronjobControllerState | undefined;\n};\n\nexport type CronjobControllerArgs = {\n  messenger: CronjobControllerMessenger;\n\n  /**\n   * Persisted state that will be used for rehydration.\n   */\n  state?: CronjobControllerState;\n\n  /**\n   * State manager for the controller.\n   *\n   * This is a temporary workaround to allow the controller to update the state\n   * often without persisting all of the client state to disk.\n   */\n  stateManager: CronjobControllerStateManager;\n};\n\n/**\n * Represents a background event that is scheduled to be executed by the\n * cronjob controller.\n */\nexport type InternalBackgroundEvent = BackgroundEvent & {\n  /**\n   * Whether the event is recurring.\n   */\n  recurring: boolean;\n\n  /**\n   * The cron expression or ISO 8601 duration string that defines the event's\n   * schedule.\n   */\n  schedule: string;\n};\n\n/**\n * A schedulable background event, which is a subset of the\n * {@link InternalBackgroundEvent} type, containing only the fields required to\n * schedule an event. Other fields will be populated by the cronjob controller\n * automatically.\n */\nexport type SchedulableBackgroundEvent = Omit<\n  InternalBackgroundEvent,\n  'scheduledAt' | 'date' | 'id'\n> & {\n  /**\n   * The optional ID of the event. If not provided, a new ID will be\n   * generated.\n   */\n  id?: string;\n};\n\nexport type CronjobControllerState = {\n  /**\n   * Background events and cronjobs that are scheduled to be executed.\n   */\n  events: Record<string, InternalBackgroundEvent>;\n};\n\nconst controllerName = 'CronjobController';\n\n/**\n * The cronjob controller is responsible for managing cronjobs and background\n * events for Snaps. It allows Snaps to schedule events that will be executed\n * at a later time.\n */\nexport class CronjobController extends BaseController<\n  typeof controllerName,\n  CronjobControllerState,\n  CronjobControllerMessenger\n> {\n  readonly #timers: Map<string, Timer>;\n\n  readonly #stateManager: CronjobControllerStateManager;\n\n  #dailyTimer: Timer = new Timer(DAILY_TIMEOUT);\n\n  constructor({ messenger, state, stateManager }: CronjobControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        events: {\n          includeInStateLogs: false,\n          persist: false,\n          anonymous: false,\n          usedInUi: false,\n        },\n      },\n      name: controllerName,\n      state: {\n        events: {},\n        ...state,\n        ...stateManager.getInitialState(),\n      },\n    });\n\n    this.#timers = new Map();\n    this.#stateManager = stateManager;\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapInstalled',\n      this.#handleSnapInstalledEvent,\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapUninstalled',\n      this.#handleSnapUninstalledEvent,\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapEnabled',\n      this.#handleSnapEnabledEvent,\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapDisabled',\n      this.#handleSnapDisabledEvent,\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapUpdated',\n      this.#handleSnapUpdatedEvent,\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:init`,\n      (...args) => this.init(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:schedule`,\n      (...args) => this.schedule(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:cancel`,\n      (...args) => this.cancel(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:get`,\n      (...args) => this.get(...args),\n    );\n  }\n\n  /**\n   * Initialize the CronjobController.\n   *\n   * This starts the daily timer, clears out expired events\n   * and reschedules any remaining events.\n   */\n  init() {\n    this.#start();\n    this.#clear();\n    this.#reschedule();\n  }\n\n  /**\n   * Schedule a non-recurring background event.\n   *\n   * @param event - The event to schedule.\n   * @returns The ID of the scheduled event.\n   */\n  schedule(event: Omit<SchedulableBackgroundEvent, 'recurring'>) {\n    return this.#add({\n      ...event,\n      recurring: false,\n    });\n  }\n\n  /**\n   * Cancel an event.\n   *\n   * @param origin - The origin making the cancel call.\n   * @param id - The id of the event to cancel.\n   * @throws If the event does not exist.\n   */\n  cancel(origin: string, id: string) {\n    assert(\n      this.state.events[id],\n      `A background event with the id of \"${id}\" does not exist.`,\n    );\n\n    assert(\n      this.state.events[id].snapId === origin,\n      'Only the origin that scheduled this event can cancel it.',\n    );\n\n    this.#cancel(id);\n  }\n\n  /**\n   * Get a list of a Snap's background events.\n   *\n   * @param snapId - The id of the Snap to fetch background events for.\n   * @returns An array of background events.\n   */\n  get(snapId: SnapId): InternalBackgroundEvent[] {\n    return Object.values(this.state.events)\n      .filter(\n        (snapEvent) => snapEvent.snapId === snapId && !snapEvent.recurring,\n      )\n      .map((event) => ({\n        ...event,\n        date: toCensoredISO8601String(event.date),\n        scheduledAt: toCensoredISO8601String(event.scheduledAt),\n      }));\n  }\n\n  /**\n   * Register cronjobs for a given Snap by getting specification from the\n   * permission caveats. Once registered, each job will be scheduled.\n   *\n   * @param snapId - The snap ID to register jobs for.\n   */\n  register(snapId: SnapId) {\n    const jobs = this.#getSnapCronjobs(snapId);\n    jobs?.forEach((job) => this.#add(job));\n  }\n\n  /**\n   * Unregister all cronjobs and background events for a given Snap.\n   *\n   * @param snapId - ID of a snap.\n   */\n  unregister(snapId: SnapId) {\n    for (const [id, event] of Object.entries(this.state.events)) {\n      if (event.snapId === snapId) {\n        this.#cancel(id);\n      }\n    }\n  }\n\n  /**\n   * Run controller teardown process and unsubscribe from Snap events.\n   */\n  destroy() {\n    super.destroy();\n\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapInstalled',\n      this.#handleSnapInstalledEvent,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapUninstalled',\n      this.#handleSnapUninstalledEvent,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapEnabled',\n      this.#handleSnapEnabledEvent,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapDisabled',\n      this.#handleSnapDisabledEvent,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapUpdated',\n      this.#handleSnapUpdatedEvent,\n    );\n\n    // Cancel all timers and clear the map.\n    this.#timers.forEach((timer) => timer.cancel());\n    this.#timers.clear();\n\n    if (this.#dailyTimer.status === 'running') {\n      this.#dailyTimer.cancel();\n    }\n  }\n\n  /**\n   * Start the daily timer that will reschedule events every 24 hours.\n   */\n  #start() {\n    this.#dailyTimer = new Timer(DAILY_TIMEOUT);\n    this.#dailyTimer.start(() => {\n      this.#reschedule();\n      this.#start();\n    });\n  }\n\n  /**\n   * Add a cronjob or background event to the controller state and schedule it\n   * for execution.\n   *\n   * @param event - The event to schedule.\n   * @returns The ID of the scheduled event.\n   */\n  #add(event: SchedulableBackgroundEvent) {\n    const id = event.id ?? nanoid();\n    const internalEvent: InternalBackgroundEvent = {\n      ...event,\n      id,\n      date: getExecutionDate(event.schedule),\n      scheduledAt: new Date().toISOString(),\n    };\n\n    const { nextState } = this.update((state) => {\n      state.events[internalEvent.id] = castDraft(internalEvent);\n    });\n\n    this.#stateManager.set(nextState);\n\n    this.#schedule(internalEvent);\n    return id;\n  }\n\n  /**\n   * Get the next execution date for a given event and start a timer for it.\n   *\n   * @param event - The event to schedule.\n   * @param next - Whether to schedule to the next date, otherwise will\n   * schedule for existing date.\n   */\n  #schedule(event: InternalBackgroundEvent, next = true) {\n    if (!next) {\n      this.#startTimer(event);\n      return;\n    }\n\n    const date = getExecutionDate(event.schedule);\n    const { nextState } = this.update((state) => {\n      state.events[event.id].date = date;\n    });\n\n    this.#stateManager.set(nextState);\n\n    this.#startTimer({\n      ...event,\n      date,\n    });\n  }\n\n  /**\n   * Set up and start a timer for the given event.\n   *\n   * @param event - The event to schedule.\n   * @throws If the event is scheduled in the past.\n   */\n  #startTimer(event: InternalBackgroundEvent) {\n    const ms =\n      DateTime.fromISO(event.date, { setZone: true }).toMillis() - Date.now();\n\n    // We don't schedule this job yet as it is too far in the future.\n    if (ms > DAILY_TIMEOUT) {\n      return;\n    }\n\n    // When an event is supposed to be scheduled close to the current time\n    // we may end up needing to execute immediately instead.\n    if (ms <= 0) {\n      this.#execute(event);\n      return;\n    }\n\n    const timer = new Timer(ms);\n    timer.start(() => {\n      this.#execute(event);\n    });\n\n    this.#timers.set(event.id, timer);\n  }\n\n  /**\n   * Execute a background event. This method is called when the event's timer\n   * expires.\n   *\n   * If the event is not recurring, it will be removed from the state after\n   * execution. If it is recurring, it will be rescheduled.\n   *\n   * @param event - The event to execute.\n   */\n  #execute(event: InternalBackgroundEvent) {\n    this.messagingSystem\n      .call('SnapController:handleRequest', {\n        snapId: event.snapId,\n        origin: METAMASK_ORIGIN,\n        handler: HandlerType.OnCronjob,\n        request: event.request,\n      })\n      .catch((error) => {\n        logError(\n          `An error occurred while executing an event for Snap \"${event.snapId}\":`,\n          error,\n        );\n      });\n\n    this.#timers.delete(event.id);\n\n    // Non-recurring events are removed from the state after execution, and\n    // recurring events are rescheduled.\n    if (!event.recurring) {\n      const { nextState } = this.update((state) => {\n        delete state.events[event.id];\n      });\n\n      this.#stateManager.set(nextState);\n\n      return;\n    }\n\n    this.#schedule(event);\n  }\n\n  /**\n   * Cancel a background event by its ID. Unlike {@link cancel}, this method\n   * does not check the origin of the event, so it can be used internally.\n   *\n   * @param id - The ID of the background event to cancel.\n   */\n  #cancel(id: string) {\n    const timer = this.#timers.get(id);\n    timer?.cancel();\n    this.#timers.delete(id);\n\n    const { nextState } = this.update((state) => {\n      delete state.events[id];\n    });\n\n    this.#stateManager.set(nextState);\n  }\n\n  /**\n   * Retrieve all cronjob specifications for a Snap.\n   *\n   * @param snapId - ID of a Snap.\n   * @returns Array of cronjob specifications.\n   */\n  #getSnapCronjobs(snapId: SnapId): SchedulableBackgroundEvent[] {\n    const permissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n\n    const permission = permissions?.[SnapEndowments.Cronjob];\n    const definitions = getCronjobCaveatJobs(permission);\n\n    if (!definitions) {\n      return [];\n    }\n\n    return definitions.map((definition, idx) => {\n      return {\n        snapId,\n        id: `cronjob-${snapId}-${idx}`,\n        request: definition.request,\n        schedule: getCronjobSpecificationSchedule(definition),\n        recurring: true,\n      };\n    });\n  }\n\n  /**\n   * Handle events that should cause cron jobs to be registered.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapInstalledEvent = (snap: TruncatedSnap) => {\n    // In case of local Snaps, they may already have cronjobs that should be cleared.\n    this.unregister(snap.id);\n    this.register(snap.id);\n  };\n\n  /**\n   * Handle the Snap enabled event. This checks if the Snap has any cronjobs or\n   * background events that need to be rescheduled.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapEnabledEvent = (snap: TruncatedSnap) => {\n    const events = this.get(snap.id);\n    this.#reschedule(events);\n    this.register(snap.id);\n  };\n\n  /**\n   * Handle events that should cause cronjobs and background events to be\n   * unregistered.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapUninstalledEvent = (snap: TruncatedSnap) => {\n    this.unregister(snap.id);\n  };\n\n  /**\n   * Handle events that should cause cronjobs and background events to be\n   * unregistered.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapDisabledEvent = (snap: TruncatedSnap) => {\n    this.unregister(snap.id);\n  };\n\n  /**\n   * Handle cron jobs on 'snapUpdated' event.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapUpdatedEvent = (snap: TruncatedSnap) => {\n    this.unregister(snap.id);\n    this.register(snap.id);\n  };\n\n  /**\n   * Reschedule events that are yet to be executed. This should be called on\n   * controller initialization and once every 24 hours to ensure that\n   * background events are scheduled correctly.\n   *\n   * @param events - An array of events to reschedule. Defaults to all events in\n   * the controller state.\n   */\n  #reschedule(events = Object.values(this.state.events)) {\n    const now = Date.now();\n\n    for (const event of events) {\n      if (this.#timers.has(event.id)) {\n        // If the timer for this event already exists, we don't need to\n        // reschedule it.\n        continue;\n      }\n\n      const eventDate = DateTime.fromISO(event.date, {\n        setZone: true,\n      })\n        .toUTC()\n        .toMillis();\n\n      // If the event is recurring and the date is in the past, execute it\n      // immediately.\n      if (event.recurring && eventDate <= now) {\n        this.#execute(event);\n        continue;\n      }\n\n      this.#schedule(event, false);\n    }\n  }\n\n  /**\n   * Clear non-recurring events that are past their scheduled time.\n   */\n  #clear() {\n    const now = Date.now();\n\n    for (const event of Object.values(this.state.events)) {\n      const eventDate = DateTime.fromISO(event.date, {\n        setZone: true,\n      })\n        .toUTC()\n        .toMillis();\n\n      if (!event.recurring && eventDate < now) {\n        this.#cancel(event.id);\n      }\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"CronjobController.cjs","sourceRoot":"","sources":["../../src/cronjob/CronjobController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller/next';\nimport { BaseController } from '@metamask/base-controller/next';\nimport type { Messenger } from '@metamask/messenger';\nimport type { GetPermissions } from '@metamask/permission-controller';\nimport {\n  getCronjobCaveatJobs,\n  SnapEndowments,\n} from '@metamask/snaps-rpc-methods';\nimport type { BackgroundEvent, SnapId } from '@metamask/snaps-sdk';\nimport type { TruncatedSnap } from '@metamask/snaps-utils';\nimport {\n  toCensoredISO8601String,\n  HandlerType,\n  logError,\n} from '@metamask/snaps-utils';\nimport { assert, Duration, inMilliseconds } from '@metamask/utils';\nimport { castDraft } from 'immer';\nimport { DateTime } from 'luxon';\nimport { nanoid } from 'nanoid';\n\nimport { getCronjobSpecificationSchedule, getExecutionDate } from './utils';\nimport type {\n  HandleSnapRequest,\n  SnapDisabled,\n  SnapEnabled,\n  SnapInstalled,\n  SnapUninstalled,\n  SnapUpdated,\n} from '..';\nimport { METAMASK_ORIGIN } from '../snaps/constants';\nimport { Timer } from '../snaps/Timer';\n\nexport type CronjobControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  CronjobControllerState\n>;\nexport type CronjobControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  CronjobControllerState\n>;\n\n/**\n * Initialise the CronjobController. This should be called after all controllers\n * are created.\n */\nexport type CronjobControllerInitAction = {\n  type: `${typeof controllerName}:init`;\n  handler: CronjobController['init'];\n};\n\nexport type Schedule = {\n  type: `${typeof controllerName}:schedule`;\n  handler: CronjobController['schedule'];\n};\n\nexport type Cancel = {\n  type: `${typeof controllerName}:cancel`;\n  handler: CronjobController['cancel'];\n};\n\nexport type Get = {\n  type: `${typeof controllerName}:get`;\n  handler: CronjobController['get'];\n};\n\nexport type CronjobControllerActions =\n  | CronjobControllerGetStateAction\n  | HandleSnapRequest\n  | GetPermissions\n  | Schedule\n  | Cancel\n  | Get\n  | CronjobControllerInitAction;\n\nexport type CronjobControllerEvents =\n  | CronjobControllerStateChangeEvent\n  | SnapInstalled\n  | SnapUninstalled\n  | SnapUpdated\n  | SnapEnabled\n  | SnapDisabled;\n\nexport type CronjobControllerMessenger = Messenger<\n  typeof controllerName,\n  CronjobControllerActions,\n  CronjobControllerEvents\n>;\n\nexport const DAILY_TIMEOUT = inMilliseconds(24, Duration.Hour);\n\nexport type CronjobControllerStateManager = {\n  set(state: CronjobControllerState): void;\n  getInitialState(): CronjobControllerState | undefined;\n};\n\nexport type CronjobControllerArgs = {\n  messenger: CronjobControllerMessenger;\n\n  /**\n   * Persisted state that will be used for rehydration.\n   */\n  state?: CronjobControllerState;\n\n  /**\n   * State manager for the controller.\n   *\n   * This is a temporary workaround to allow the controller to update the state\n   * often without persisting all of the client state to disk.\n   */\n  stateManager: CronjobControllerStateManager;\n};\n\n/**\n * Represents a background event that is scheduled to be executed by the\n * cronjob controller.\n */\nexport type InternalBackgroundEvent = BackgroundEvent & {\n  /**\n   * Whether the event is recurring.\n   */\n  recurring: boolean;\n\n  /**\n   * The cron expression or ISO 8601 duration string that defines the event's\n   * schedule.\n   */\n  schedule: string;\n};\n\n/**\n * A schedulable background event, which is a subset of the\n * {@link InternalBackgroundEvent} type, containing only the fields required to\n * schedule an event. Other fields will be populated by the cronjob controller\n * automatically.\n */\nexport type SchedulableBackgroundEvent = Omit<\n  InternalBackgroundEvent,\n  'scheduledAt' | 'date' | 'id'\n> & {\n  /**\n   * The optional ID of the event. If not provided, a new ID will be\n   * generated.\n   */\n  id?: string;\n};\n\nexport type CronjobControllerState = {\n  /**\n   * Background events and cronjobs that are scheduled to be executed.\n   */\n  events: Record<string, InternalBackgroundEvent>;\n};\n\nconst controllerName = 'CronjobController';\n\n/**\n * The cronjob controller is responsible for managing cronjobs and background\n * events for Snaps. It allows Snaps to schedule events that will be executed\n * at a later time.\n */\nexport class CronjobController extends BaseController<\n  typeof controllerName,\n  CronjobControllerState,\n  CronjobControllerMessenger\n> {\n  readonly #timers: Map<string, Timer>;\n\n  readonly #stateManager: CronjobControllerStateManager;\n\n  #dailyTimer: Timer = new Timer(DAILY_TIMEOUT);\n\n  constructor({ messenger, state, stateManager }: CronjobControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        events: {\n          includeInStateLogs: false,\n          persist: false,\n          includeInDebugSnapshot: false,\n          usedInUi: false,\n        },\n      },\n      name: controllerName,\n      state: {\n        events: {},\n        ...state,\n        ...stateManager.getInitialState(),\n      },\n    });\n\n    this.#timers = new Map();\n    this.#stateManager = stateManager;\n\n    this.messenger.subscribe(\n      'SnapController:snapInstalled',\n      this.#handleSnapInstalledEvent,\n    );\n\n    this.messenger.subscribe(\n      'SnapController:snapUninstalled',\n      this.#handleSnapUninstalledEvent,\n    );\n\n    this.messenger.subscribe(\n      'SnapController:snapEnabled',\n      this.#handleSnapEnabledEvent,\n    );\n\n    this.messenger.subscribe(\n      'SnapController:snapDisabled',\n      this.#handleSnapDisabledEvent,\n    );\n\n    this.messenger.subscribe(\n      'SnapController:snapUpdated',\n      this.#handleSnapUpdatedEvent,\n    );\n\n    this.messenger.registerActionHandler(`${controllerName}:init`, (...args) =>\n      this.init(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:schedule`,\n      (...args) => this.schedule(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:cancel`,\n      (...args) => this.cancel(...args),\n    );\n\n    this.messenger.registerActionHandler(`${controllerName}:get`, (...args) =>\n      this.get(...args),\n    );\n  }\n\n  /**\n   * Initialize the CronjobController.\n   *\n   * This starts the daily timer, clears out expired events\n   * and reschedules any remaining events.\n   */\n  init() {\n    this.#start();\n    this.#clear();\n    this.#reschedule();\n  }\n\n  /**\n   * Schedule a non-recurring background event.\n   *\n   * @param event - The event to schedule.\n   * @returns The ID of the scheduled event.\n   */\n  schedule(event: Omit<SchedulableBackgroundEvent, 'recurring'>) {\n    return this.#add({\n      ...event,\n      recurring: false,\n    });\n  }\n\n  /**\n   * Cancel an event.\n   *\n   * @param origin - The origin making the cancel call.\n   * @param id - The id of the event to cancel.\n   * @throws If the event does not exist.\n   */\n  cancel(origin: string, id: string) {\n    assert(\n      this.state.events[id],\n      `A background event with the id of \"${id}\" does not exist.`,\n    );\n\n    assert(\n      this.state.events[id].snapId === origin,\n      'Only the origin that scheduled this event can cancel it.',\n    );\n\n    this.#cancel(id);\n  }\n\n  /**\n   * Get a list of a Snap's background events.\n   *\n   * @param snapId - The id of the Snap to fetch background events for.\n   * @returns An array of background events.\n   */\n  get(snapId: SnapId): InternalBackgroundEvent[] {\n    return Object.values(this.state.events)\n      .filter(\n        (snapEvent) => snapEvent.snapId === snapId && !snapEvent.recurring,\n      )\n      .map((event) => ({\n        ...event,\n        date: toCensoredISO8601String(event.date),\n        scheduledAt: toCensoredISO8601String(event.scheduledAt),\n      }));\n  }\n\n  /**\n   * Register cronjobs for a given Snap by getting specification from the\n   * permission caveats. Once registered, each job will be scheduled.\n   *\n   * @param snapId - The snap ID to register jobs for.\n   */\n  register(snapId: SnapId) {\n    const jobs = this.#getSnapCronjobs(snapId);\n    jobs?.forEach((job) => this.#add(job));\n  }\n\n  /**\n   * Unregister all cronjobs and background events for a given Snap.\n   *\n   * @param snapId - ID of a snap.\n   */\n  unregister(snapId: SnapId) {\n    for (const [id, event] of Object.entries(this.state.events)) {\n      if (event.snapId === snapId) {\n        this.#cancel(id);\n      }\n    }\n  }\n\n  /**\n   * Run controller teardown process and unsubscribe from Snap events.\n   */\n  destroy() {\n    super.destroy();\n\n    this.messenger.unsubscribe(\n      'SnapController:snapInstalled',\n      this.#handleSnapInstalledEvent,\n    );\n\n    this.messenger.unsubscribe(\n      'SnapController:snapUninstalled',\n      this.#handleSnapUninstalledEvent,\n    );\n\n    this.messenger.unsubscribe(\n      'SnapController:snapEnabled',\n      this.#handleSnapEnabledEvent,\n    );\n\n    this.messenger.unsubscribe(\n      'SnapController:snapDisabled',\n      this.#handleSnapDisabledEvent,\n    );\n\n    this.messenger.unsubscribe(\n      'SnapController:snapUpdated',\n      this.#handleSnapUpdatedEvent,\n    );\n\n    // Cancel all timers and clear the map.\n    this.#timers.forEach((timer) => timer.cancel());\n    this.#timers.clear();\n\n    if (this.#dailyTimer.status === 'running') {\n      this.#dailyTimer.cancel();\n    }\n  }\n\n  /**\n   * Start the daily timer that will reschedule events every 24 hours.\n   */\n  #start() {\n    this.#dailyTimer = new Timer(DAILY_TIMEOUT);\n    this.#dailyTimer.start(() => {\n      this.#reschedule();\n      this.#start();\n    });\n  }\n\n  /**\n   * Add a cronjob or background event to the controller state and schedule it\n   * for execution.\n   *\n   * @param event - The event to schedule.\n   * @returns The ID of the scheduled event.\n   */\n  #add(event: SchedulableBackgroundEvent) {\n    const id = event.id ?? nanoid();\n    const internalEvent: InternalBackgroundEvent = {\n      ...event,\n      id,\n      date: getExecutionDate(event.schedule),\n      scheduledAt: new Date().toISOString(),\n    };\n\n    const { nextState } = this.update((state) => {\n      state.events[internalEvent.id] = castDraft(internalEvent);\n    });\n\n    this.#stateManager.set(nextState);\n\n    this.#schedule(internalEvent);\n    return id;\n  }\n\n  /**\n   * Get the next execution date for a given event and start a timer for it.\n   *\n   * @param event - The event to schedule.\n   * @param next - Whether to schedule to the next date, otherwise will\n   * schedule for existing date.\n   */\n  #schedule(event: InternalBackgroundEvent, next = true) {\n    if (!next) {\n      this.#startTimer(event);\n      return;\n    }\n\n    const date = getExecutionDate(event.schedule);\n    const { nextState } = this.update((state) => {\n      state.events[event.id].date = date;\n    });\n\n    this.#stateManager.set(nextState);\n\n    this.#startTimer({\n      ...event,\n      date,\n    });\n  }\n\n  /**\n   * Set up and start a timer for the given event.\n   *\n   * @param event - The event to schedule.\n   * @throws If the event is scheduled in the past.\n   */\n  #startTimer(event: InternalBackgroundEvent) {\n    const ms =\n      DateTime.fromISO(event.date, { setZone: true }).toMillis() - Date.now();\n\n    // We don't schedule this job yet as it is too far in the future.\n    if (ms > DAILY_TIMEOUT) {\n      return;\n    }\n\n    // When an event is supposed to be scheduled close to the current time\n    // we may end up needing to execute immediately instead.\n    if (ms <= 0) {\n      this.#execute(event);\n      return;\n    }\n\n    const timer = new Timer(ms);\n    timer.start(() => {\n      this.#execute(event);\n    });\n\n    this.#timers.set(event.id, timer);\n  }\n\n  /**\n   * Execute a background event. This method is called when the event's timer\n   * expires.\n   *\n   * If the event is not recurring, it will be removed from the state after\n   * execution. If it is recurring, it will be rescheduled.\n   *\n   * @param event - The event to execute.\n   */\n  #execute(event: InternalBackgroundEvent) {\n    this.messenger\n      .call('SnapController:handleRequest', {\n        snapId: event.snapId,\n        origin: METAMASK_ORIGIN,\n        handler: HandlerType.OnCronjob,\n        request: event.request,\n      })\n      .catch((error) => {\n        logError(\n          `An error occurred while executing an event for Snap \"${event.snapId}\":`,\n          error,\n        );\n      });\n\n    this.#timers.delete(event.id);\n\n    // Non-recurring events are removed from the state after execution, and\n    // recurring events are rescheduled.\n    if (!event.recurring) {\n      const { nextState } = this.update((state) => {\n        delete state.events[event.id];\n      });\n\n      this.#stateManager.set(nextState);\n\n      return;\n    }\n\n    this.#schedule(event);\n  }\n\n  /**\n   * Cancel a background event by its ID. Unlike {@link cancel}, this method\n   * does not check the origin of the event, so it can be used internally.\n   *\n   * @param id - The ID of the background event to cancel.\n   */\n  #cancel(id: string) {\n    const timer = this.#timers.get(id);\n    timer?.cancel();\n    this.#timers.delete(id);\n\n    const { nextState } = this.update((state) => {\n      delete state.events[id];\n    });\n\n    this.#stateManager.set(nextState);\n  }\n\n  /**\n   * Retrieve all cronjob specifications for a Snap.\n   *\n   * @param snapId - ID of a Snap.\n   * @returns Array of cronjob specifications.\n   */\n  #getSnapCronjobs(snapId: SnapId): SchedulableBackgroundEvent[] {\n    const permissions = this.messenger.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n\n    const permission = permissions?.[SnapEndowments.Cronjob];\n    const definitions = getCronjobCaveatJobs(permission);\n\n    if (!definitions) {\n      return [];\n    }\n\n    return definitions.map((definition, idx) => {\n      return {\n        snapId,\n        id: `cronjob-${snapId}-${idx}`,\n        request: definition.request,\n        schedule: getCronjobSpecificationSchedule(definition),\n        recurring: true,\n      };\n    });\n  }\n\n  /**\n   * Handle events that should cause cron jobs to be registered.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapInstalledEvent = (snap: TruncatedSnap) => {\n    // In case of local Snaps, they may already have cronjobs that should be cleared.\n    this.unregister(snap.id);\n    this.register(snap.id);\n  };\n\n  /**\n   * Handle the Snap enabled event. This checks if the Snap has any cronjobs or\n   * background events that need to be rescheduled.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapEnabledEvent = (snap: TruncatedSnap) => {\n    const events = this.get(snap.id);\n    this.#reschedule(events);\n    this.register(snap.id);\n  };\n\n  /**\n   * Handle events that should cause cronjobs and background events to be\n   * unregistered.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapUninstalledEvent = (snap: TruncatedSnap) => {\n    this.unregister(snap.id);\n  };\n\n  /**\n   * Handle events that should cause cronjobs and background events to be\n   * unregistered.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapDisabledEvent = (snap: TruncatedSnap) => {\n    this.unregister(snap.id);\n  };\n\n  /**\n   * Handle cron jobs on 'snapUpdated' event.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapUpdatedEvent = (snap: TruncatedSnap) => {\n    this.unregister(snap.id);\n    this.register(snap.id);\n  };\n\n  /**\n   * Reschedule events that are yet to be executed. This should be called on\n   * controller initialization and once every 24 hours to ensure that\n   * background events are scheduled correctly.\n   *\n   * @param events - An array of events to reschedule. Defaults to all events in\n   * the controller state.\n   */\n  #reschedule(events = Object.values(this.state.events)) {\n    const now = Date.now();\n\n    for (const event of events) {\n      if (this.#timers.has(event.id)) {\n        // If the timer for this event already exists, we don't need to\n        // reschedule it.\n        continue;\n      }\n\n      const eventDate = DateTime.fromISO(event.date, {\n        setZone: true,\n      })\n        .toUTC()\n        .toMillis();\n\n      // If the event is recurring and the date is in the past, execute it\n      // immediately.\n      if (event.recurring && eventDate <= now) {\n        this.#execute(event);\n        continue;\n      }\n\n      this.#schedule(event, false);\n    }\n  }\n\n  /**\n   * Clear non-recurring events that are past their scheduled time.\n   */\n  #clear() {\n    const now = Date.now();\n\n    for (const event of Object.values(this.state.events)) {\n      const eventDate = DateTime.fromISO(event.date, {\n        setZone: true,\n      })\n        .toUTC()\n        .toMillis();\n\n      if (!event.recurring && eventDate < now) {\n        this.#cancel(event.id);\n      }\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/cronjob/CronjobController.d.cts b/dist/cronjob/CronjobController.d.cts
index 6bf50fb30a5c539b27445f3fa436a819123b98f4..d85a9e878ac44fa235dbfcc78a96e5173835e597 100644
--- a/dist/cronjob/CronjobController.d.cts
+++ b/dist/cronjob/CronjobController.d.cts
@@ -1,5 +1,6 @@
-import type { RestrictedMessenger, ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
-import { BaseController } from "@metamask/base-controller";
+import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller/next";
+import { BaseController } from "@metamask/base-controller/next";
+import type { Messenger } from "@metamask/messenger";
 import type { GetPermissions } from "@metamask/permission-controller";
 import type { BackgroundEvent, SnapId } from "@metamask/snaps-sdk";
 import type { HandleSnapRequest, SnapDisabled, SnapEnabled, SnapInstalled, SnapUninstalled, SnapUpdated } from "../index.cjs";
@@ -27,7 +28,7 @@ export type Get = {
 };
 export type CronjobControllerActions = CronjobControllerGetStateAction | HandleSnapRequest | GetPermissions | Schedule | Cancel | Get | CronjobControllerInitAction;
 export type CronjobControllerEvents = CronjobControllerStateChangeEvent | SnapInstalled | SnapUninstalled | SnapUpdated | SnapEnabled | SnapDisabled;
-export type CronjobControllerMessenger = RestrictedMessenger<typeof controllerName, CronjobControllerActions, CronjobControllerEvents, CronjobControllerActions['type'], CronjobControllerEvents['type']>;
+export type CronjobControllerMessenger = Messenger<typeof controllerName, CronjobControllerActions, CronjobControllerEvents>;
 export declare const DAILY_TIMEOUT: number;
 export type CronjobControllerStateManager = {
     set(state: CronjobControllerState): void;
diff --git a/dist/cronjob/CronjobController.d.cts.map b/dist/cronjob/CronjobController.d.cts.map
index acc7bd45882ecb54c9cd036f179bb2a7eac7d98e..83c68e570306bc0530f2fefae21f240577050cdf 100644
--- a/dist/cronjob/CronjobController.d.cts.map
+++ b/dist/cronjob/CronjobController.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"CronjobController.d.cts","sourceRoot":"","sources":["../../src/cronjob/CronjobController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"CronjobController.d.cts","sourceRoot":"","sources":["../../src/cronjob/CronjobController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/cronjob/CronjobController.d.mts b/dist/cronjob/CronjobController.d.mts
index 5640a145b7323c835f5021a89feef24a7bb8c717..665a0653babc92f89adf4e8dc1752153b597305f 100644
--- a/dist/cronjob/CronjobController.d.mts
+++ b/dist/cronjob/CronjobController.d.mts
@@ -1,5 +1,6 @@
-import type { RestrictedMessenger, ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
-import { BaseController } from "@metamask/base-controller";
+import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller/next";
+import { BaseController } from "@metamask/base-controller/next";
+import type { Messenger } from "@metamask/messenger";
 import type { GetPermissions } from "@metamask/permission-controller";
 import type { BackgroundEvent, SnapId } from "@metamask/snaps-sdk";
 import type { HandleSnapRequest, SnapDisabled, SnapEnabled, SnapInstalled, SnapUninstalled, SnapUpdated } from "../index.mjs";
@@ -27,7 +28,7 @@ export type Get = {
 };
 export type CronjobControllerActions = CronjobControllerGetStateAction | HandleSnapRequest | GetPermissions | Schedule | Cancel | Get | CronjobControllerInitAction;
 export type CronjobControllerEvents = CronjobControllerStateChangeEvent | SnapInstalled | SnapUninstalled | SnapUpdated | SnapEnabled | SnapDisabled;
-export type CronjobControllerMessenger = RestrictedMessenger<typeof controllerName, CronjobControllerActions, CronjobControllerEvents, CronjobControllerActions['type'], CronjobControllerEvents['type']>;
+export type CronjobControllerMessenger = Messenger<typeof controllerName, CronjobControllerActions, CronjobControllerEvents>;
 export declare const DAILY_TIMEOUT: number;
 export type CronjobControllerStateManager = {
     set(state: CronjobControllerState): void;
diff --git a/dist/cronjob/CronjobController.d.mts.map b/dist/cronjob/CronjobController.d.mts.map
index c069294dd7d3ddc70bfc718cfc1528a0b8e8dd90..c071ddb3e44d612324e623c20602f6d6c2e0342b 100644
--- a/dist/cronjob/CronjobController.d.mts.map
+++ b/dist/cronjob/CronjobController.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"CronjobController.d.mts","sourceRoot":"","sources":["../../src/cronjob/CronjobController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"CronjobController.d.mts","sourceRoot":"","sources":["../../src/cronjob/CronjobController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/cronjob/CronjobController.mjs b/dist/cronjob/CronjobController.mjs
index 8bb0abf973d3874369a049ab265234d0a2eff246..49daff01386bd76b0509a8255380e133feff86af 100644
--- a/dist/cronjob/CronjobController.mjs
+++ b/dist/cronjob/CronjobController.mjs
@@ -1,4 +1,4 @@
-import { BaseController } from "@metamask/base-controller";
+import { BaseController } from "@metamask/base-controller/next";
 import { getCronjobCaveatJobs, SnapEndowments } from "@metamask/snaps-rpc-methods";
 import { toCensoredISO8601String, HandlerType, logError } from "@metamask/snaps-utils";
 import { assert, Duration, inMilliseconds } from "@metamask/utils";
@@ -26,7 +26,7 @@ export class CronjobController extends BaseController {
                 events: {
                     includeInStateLogs: false,
                     persist: false,
-                    anonymous: false,
+                    includeInDebugSnapshot: false,
                     usedInUi: false,
                 },
             },
@@ -39,15 +39,15 @@ export class CronjobController extends BaseController {
         });
         this.#timers = new Map();
         this.#stateManager = stateManager;
-        this.messagingSystem.subscribe('SnapController:snapInstalled', this.#handleSnapInstalledEvent);
-        this.messagingSystem.subscribe('SnapController:snapUninstalled', this.#handleSnapUninstalledEvent);
-        this.messagingSystem.subscribe('SnapController:snapEnabled', this.#handleSnapEnabledEvent);
-        this.messagingSystem.subscribe('SnapController:snapDisabled', this.#handleSnapDisabledEvent);
-        this.messagingSystem.subscribe('SnapController:snapUpdated', this.#handleSnapUpdatedEvent);
-        this.messagingSystem.registerActionHandler(`${controllerName}:init`, (...args) => this.init(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:schedule`, (...args) => this.schedule(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:cancel`, (...args) => this.cancel(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:get`, (...args) => this.get(...args));
+        this.messenger.subscribe('SnapController:snapInstalled', this.#handleSnapInstalledEvent);
+        this.messenger.subscribe('SnapController:snapUninstalled', this.#handleSnapUninstalledEvent);
+        this.messenger.subscribe('SnapController:snapEnabled', this.#handleSnapEnabledEvent);
+        this.messenger.subscribe('SnapController:snapDisabled', this.#handleSnapDisabledEvent);
+        this.messenger.subscribe('SnapController:snapUpdated', this.#handleSnapUpdatedEvent);
+        this.messenger.registerActionHandler(`${controllerName}:init`, (...args) => this.init(...args));
+        this.messenger.registerActionHandler(`${controllerName}:schedule`, (...args) => this.schedule(...args));
+        this.messenger.registerActionHandler(`${controllerName}:cancel`, (...args) => this.cancel(...args));
+        this.messenger.registerActionHandler(`${controllerName}:get`, (...args) => this.get(...args));
     }
     /**
      * Initialize the CronjobController.
@@ -126,11 +126,11 @@ export class CronjobController extends BaseController {
      */
     destroy() {
         super.destroy();
-        this.messagingSystem.unsubscribe('SnapController:snapInstalled', this.#handleSnapInstalledEvent);
-        this.messagingSystem.unsubscribe('SnapController:snapUninstalled', this.#handleSnapUninstalledEvent);
-        this.messagingSystem.unsubscribe('SnapController:snapEnabled', this.#handleSnapEnabledEvent);
-        this.messagingSystem.unsubscribe('SnapController:snapDisabled', this.#handleSnapDisabledEvent);
-        this.messagingSystem.unsubscribe('SnapController:snapUpdated', this.#handleSnapUpdatedEvent);
+        this.messenger.unsubscribe('SnapController:snapInstalled', this.#handleSnapInstalledEvent);
+        this.messenger.unsubscribe('SnapController:snapUninstalled', this.#handleSnapUninstalledEvent);
+        this.messenger.unsubscribe('SnapController:snapEnabled', this.#handleSnapEnabledEvent);
+        this.messenger.unsubscribe('SnapController:snapDisabled', this.#handleSnapDisabledEvent);
+        this.messenger.unsubscribe('SnapController:snapUpdated', this.#handleSnapUpdatedEvent);
         // Cancel all timers and clear the map.
         this.#timers.forEach((timer) => timer.cancel());
         this.#timers.clear();
@@ -226,7 +226,7 @@ export class CronjobController extends BaseController {
      * @param event - The event to execute.
      */
     #execute(event) {
-        this.messagingSystem
+        this.messenger
             .call('SnapController:handleRequest', {
             snapId: event.snapId,
             origin: METAMASK_ORIGIN,
@@ -270,7 +270,7 @@ export class CronjobController extends BaseController {
      * @returns Array of cronjob specifications.
      */
     #getSnapCronjobs(snapId) {
-        const permissions = this.messagingSystem.call('PermissionController:getPermissions', snapId);
+        const permissions = this.messenger.call('PermissionController:getPermissions', snapId);
         const permission = permissions?.[SnapEndowments.Cronjob];
         const definitions = getCronjobCaveatJobs(permission);
         if (!definitions) {
diff --git a/dist/cronjob/CronjobController.mjs.map b/dist/cronjob/CronjobController.mjs.map
index fc2e007a8f3456c39a60ccc600958b99c46ef9fc..5ac4187c0c73c3f77dae89161ebb1ab486f4b3b4 100644
--- a/dist/cronjob/CronjobController.mjs.map
+++ b/dist/cronjob/CronjobController.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"CronjobController.mjs","sourceRoot":"","sources":["../../src/cronjob/CronjobController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  RestrictedMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { GetPermissions } from '@metamask/permission-controller';\nimport {\n  getCronjobCaveatJobs,\n  SnapEndowments,\n} from '@metamask/snaps-rpc-methods';\nimport type { BackgroundEvent, SnapId } from '@metamask/snaps-sdk';\nimport type { TruncatedSnap } from '@metamask/snaps-utils';\nimport {\n  toCensoredISO8601String,\n  HandlerType,\n  logError,\n} from '@metamask/snaps-utils';\nimport { assert, Duration, inMilliseconds } from '@metamask/utils';\nimport { castDraft } from 'immer';\nimport { DateTime } from 'luxon';\nimport { nanoid } from 'nanoid';\n\nimport { getCronjobSpecificationSchedule, getExecutionDate } from './utils';\nimport type {\n  HandleSnapRequest,\n  SnapDisabled,\n  SnapEnabled,\n  SnapInstalled,\n  SnapUninstalled,\n  SnapUpdated,\n} from '..';\nimport { METAMASK_ORIGIN } from '../snaps/constants';\nimport { Timer } from '../snaps/Timer';\n\nexport type CronjobControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  CronjobControllerState\n>;\nexport type CronjobControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  CronjobControllerState\n>;\n\n/**\n * Initialise the CronjobController. This should be called after all controllers\n * are created.\n */\nexport type CronjobControllerInitAction = {\n  type: `${typeof controllerName}:init`;\n  handler: CronjobController['init'];\n};\n\nexport type Schedule = {\n  type: `${typeof controllerName}:schedule`;\n  handler: CronjobController['schedule'];\n};\n\nexport type Cancel = {\n  type: `${typeof controllerName}:cancel`;\n  handler: CronjobController['cancel'];\n};\n\nexport type Get = {\n  type: `${typeof controllerName}:get`;\n  handler: CronjobController['get'];\n};\n\nexport type CronjobControllerActions =\n  | CronjobControllerGetStateAction\n  | HandleSnapRequest\n  | GetPermissions\n  | Schedule\n  | Cancel\n  | Get\n  | CronjobControllerInitAction;\n\nexport type CronjobControllerEvents =\n  | CronjobControllerStateChangeEvent\n  | SnapInstalled\n  | SnapUninstalled\n  | SnapUpdated\n  | SnapEnabled\n  | SnapDisabled;\n\nexport type CronjobControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  CronjobControllerActions,\n  CronjobControllerEvents,\n  CronjobControllerActions['type'],\n  CronjobControllerEvents['type']\n>;\n\nexport const DAILY_TIMEOUT = inMilliseconds(24, Duration.Hour);\n\nexport type CronjobControllerStateManager = {\n  set(state: CronjobControllerState): void;\n  getInitialState(): CronjobControllerState | undefined;\n};\n\nexport type CronjobControllerArgs = {\n  messenger: CronjobControllerMessenger;\n\n  /**\n   * Persisted state that will be used for rehydration.\n   */\n  state?: CronjobControllerState;\n\n  /**\n   * State manager for the controller.\n   *\n   * This is a temporary workaround to allow the controller to update the state\n   * often without persisting all of the client state to disk.\n   */\n  stateManager: CronjobControllerStateManager;\n};\n\n/**\n * Represents a background event that is scheduled to be executed by the\n * cronjob controller.\n */\nexport type InternalBackgroundEvent = BackgroundEvent & {\n  /**\n   * Whether the event is recurring.\n   */\n  recurring: boolean;\n\n  /**\n   * The cron expression or ISO 8601 duration string that defines the event's\n   * schedule.\n   */\n  schedule: string;\n};\n\n/**\n * A schedulable background event, which is a subset of the\n * {@link InternalBackgroundEvent} type, containing only the fields required to\n * schedule an event. Other fields will be populated by the cronjob controller\n * automatically.\n */\nexport type SchedulableBackgroundEvent = Omit<\n  InternalBackgroundEvent,\n  'scheduledAt' | 'date' | 'id'\n> & {\n  /**\n   * The optional ID of the event. If not provided, a new ID will be\n   * generated.\n   */\n  id?: string;\n};\n\nexport type CronjobControllerState = {\n  /**\n   * Background events and cronjobs that are scheduled to be executed.\n   */\n  events: Record<string, InternalBackgroundEvent>;\n};\n\nconst controllerName = 'CronjobController';\n\n/**\n * The cronjob controller is responsible for managing cronjobs and background\n * events for Snaps. It allows Snaps to schedule events that will be executed\n * at a later time.\n */\nexport class CronjobController extends BaseController<\n  typeof controllerName,\n  CronjobControllerState,\n  CronjobControllerMessenger\n> {\n  readonly #timers: Map<string, Timer>;\n\n  readonly #stateManager: CronjobControllerStateManager;\n\n  #dailyTimer: Timer = new Timer(DAILY_TIMEOUT);\n\n  constructor({ messenger, state, stateManager }: CronjobControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        events: {\n          includeInStateLogs: false,\n          persist: false,\n          anonymous: false,\n          usedInUi: false,\n        },\n      },\n      name: controllerName,\n      state: {\n        events: {},\n        ...state,\n        ...stateManager.getInitialState(),\n      },\n    });\n\n    this.#timers = new Map();\n    this.#stateManager = stateManager;\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapInstalled',\n      this.#handleSnapInstalledEvent,\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapUninstalled',\n      this.#handleSnapUninstalledEvent,\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapEnabled',\n      this.#handleSnapEnabledEvent,\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapDisabled',\n      this.#handleSnapDisabledEvent,\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapUpdated',\n      this.#handleSnapUpdatedEvent,\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:init`,\n      (...args) => this.init(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:schedule`,\n      (...args) => this.schedule(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:cancel`,\n      (...args) => this.cancel(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:get`,\n      (...args) => this.get(...args),\n    );\n  }\n\n  /**\n   * Initialize the CronjobController.\n   *\n   * This starts the daily timer, clears out expired events\n   * and reschedules any remaining events.\n   */\n  init() {\n    this.#start();\n    this.#clear();\n    this.#reschedule();\n  }\n\n  /**\n   * Schedule a non-recurring background event.\n   *\n   * @param event - The event to schedule.\n   * @returns The ID of the scheduled event.\n   */\n  schedule(event: Omit<SchedulableBackgroundEvent, 'recurring'>) {\n    return this.#add({\n      ...event,\n      recurring: false,\n    });\n  }\n\n  /**\n   * Cancel an event.\n   *\n   * @param origin - The origin making the cancel call.\n   * @param id - The id of the event to cancel.\n   * @throws If the event does not exist.\n   */\n  cancel(origin: string, id: string) {\n    assert(\n      this.state.events[id],\n      `A background event with the id of \"${id}\" does not exist.`,\n    );\n\n    assert(\n      this.state.events[id].snapId === origin,\n      'Only the origin that scheduled this event can cancel it.',\n    );\n\n    this.#cancel(id);\n  }\n\n  /**\n   * Get a list of a Snap's background events.\n   *\n   * @param snapId - The id of the Snap to fetch background events for.\n   * @returns An array of background events.\n   */\n  get(snapId: SnapId): InternalBackgroundEvent[] {\n    return Object.values(this.state.events)\n      .filter(\n        (snapEvent) => snapEvent.snapId === snapId && !snapEvent.recurring,\n      )\n      .map((event) => ({\n        ...event,\n        date: toCensoredISO8601String(event.date),\n        scheduledAt: toCensoredISO8601String(event.scheduledAt),\n      }));\n  }\n\n  /**\n   * Register cronjobs for a given Snap by getting specification from the\n   * permission caveats. Once registered, each job will be scheduled.\n   *\n   * @param snapId - The snap ID to register jobs for.\n   */\n  register(snapId: SnapId) {\n    const jobs = this.#getSnapCronjobs(snapId);\n    jobs?.forEach((job) => this.#add(job));\n  }\n\n  /**\n   * Unregister all cronjobs and background events for a given Snap.\n   *\n   * @param snapId - ID of a snap.\n   */\n  unregister(snapId: SnapId) {\n    for (const [id, event] of Object.entries(this.state.events)) {\n      if (event.snapId === snapId) {\n        this.#cancel(id);\n      }\n    }\n  }\n\n  /**\n   * Run controller teardown process and unsubscribe from Snap events.\n   */\n  destroy() {\n    super.destroy();\n\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapInstalled',\n      this.#handleSnapInstalledEvent,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapUninstalled',\n      this.#handleSnapUninstalledEvent,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapEnabled',\n      this.#handleSnapEnabledEvent,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapDisabled',\n      this.#handleSnapDisabledEvent,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'SnapController:snapUpdated',\n      this.#handleSnapUpdatedEvent,\n    );\n\n    // Cancel all timers and clear the map.\n    this.#timers.forEach((timer) => timer.cancel());\n    this.#timers.clear();\n\n    if (this.#dailyTimer.status === 'running') {\n      this.#dailyTimer.cancel();\n    }\n  }\n\n  /**\n   * Start the daily timer that will reschedule events every 24 hours.\n   */\n  #start() {\n    this.#dailyTimer = new Timer(DAILY_TIMEOUT);\n    this.#dailyTimer.start(() => {\n      this.#reschedule();\n      this.#start();\n    });\n  }\n\n  /**\n   * Add a cronjob or background event to the controller state and schedule it\n   * for execution.\n   *\n   * @param event - The event to schedule.\n   * @returns The ID of the scheduled event.\n   */\n  #add(event: SchedulableBackgroundEvent) {\n    const id = event.id ?? nanoid();\n    const internalEvent: InternalBackgroundEvent = {\n      ...event,\n      id,\n      date: getExecutionDate(event.schedule),\n      scheduledAt: new Date().toISOString(),\n    };\n\n    const { nextState } = this.update((state) => {\n      state.events[internalEvent.id] = castDraft(internalEvent);\n    });\n\n    this.#stateManager.set(nextState);\n\n    this.#schedule(internalEvent);\n    return id;\n  }\n\n  /**\n   * Get the next execution date for a given event and start a timer for it.\n   *\n   * @param event - The event to schedule.\n   * @param next - Whether to schedule to the next date, otherwise will\n   * schedule for existing date.\n   */\n  #schedule(event: InternalBackgroundEvent, next = true) {\n    if (!next) {\n      this.#startTimer(event);\n      return;\n    }\n\n    const date = getExecutionDate(event.schedule);\n    const { nextState } = this.update((state) => {\n      state.events[event.id].date = date;\n    });\n\n    this.#stateManager.set(nextState);\n\n    this.#startTimer({\n      ...event,\n      date,\n    });\n  }\n\n  /**\n   * Set up and start a timer for the given event.\n   *\n   * @param event - The event to schedule.\n   * @throws If the event is scheduled in the past.\n   */\n  #startTimer(event: InternalBackgroundEvent) {\n    const ms =\n      DateTime.fromISO(event.date, { setZone: true }).toMillis() - Date.now();\n\n    // We don't schedule this job yet as it is too far in the future.\n    if (ms > DAILY_TIMEOUT) {\n      return;\n    }\n\n    // When an event is supposed to be scheduled close to the current time\n    // we may end up needing to execute immediately instead.\n    if (ms <= 0) {\n      this.#execute(event);\n      return;\n    }\n\n    const timer = new Timer(ms);\n    timer.start(() => {\n      this.#execute(event);\n    });\n\n    this.#timers.set(event.id, timer);\n  }\n\n  /**\n   * Execute a background event. This method is called when the event's timer\n   * expires.\n   *\n   * If the event is not recurring, it will be removed from the state after\n   * execution. If it is recurring, it will be rescheduled.\n   *\n   * @param event - The event to execute.\n   */\n  #execute(event: InternalBackgroundEvent) {\n    this.messagingSystem\n      .call('SnapController:handleRequest', {\n        snapId: event.snapId,\n        origin: METAMASK_ORIGIN,\n        handler: HandlerType.OnCronjob,\n        request: event.request,\n      })\n      .catch((error) => {\n        logError(\n          `An error occurred while executing an event for Snap \"${event.snapId}\":`,\n          error,\n        );\n      });\n\n    this.#timers.delete(event.id);\n\n    // Non-recurring events are removed from the state after execution, and\n    // recurring events are rescheduled.\n    if (!event.recurring) {\n      const { nextState } = this.update((state) => {\n        delete state.events[event.id];\n      });\n\n      this.#stateManager.set(nextState);\n\n      return;\n    }\n\n    this.#schedule(event);\n  }\n\n  /**\n   * Cancel a background event by its ID. Unlike {@link cancel}, this method\n   * does not check the origin of the event, so it can be used internally.\n   *\n   * @param id - The ID of the background event to cancel.\n   */\n  #cancel(id: string) {\n    const timer = this.#timers.get(id);\n    timer?.cancel();\n    this.#timers.delete(id);\n\n    const { nextState } = this.update((state) => {\n      delete state.events[id];\n    });\n\n    this.#stateManager.set(nextState);\n  }\n\n  /**\n   * Retrieve all cronjob specifications for a Snap.\n   *\n   * @param snapId - ID of a Snap.\n   * @returns Array of cronjob specifications.\n   */\n  #getSnapCronjobs(snapId: SnapId): SchedulableBackgroundEvent[] {\n    const permissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n\n    const permission = permissions?.[SnapEndowments.Cronjob];\n    const definitions = getCronjobCaveatJobs(permission);\n\n    if (!definitions) {\n      return [];\n    }\n\n    return definitions.map((definition, idx) => {\n      return {\n        snapId,\n        id: `cronjob-${snapId}-${idx}`,\n        request: definition.request,\n        schedule: getCronjobSpecificationSchedule(definition),\n        recurring: true,\n      };\n    });\n  }\n\n  /**\n   * Handle events that should cause cron jobs to be registered.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapInstalledEvent = (snap: TruncatedSnap) => {\n    // In case of local Snaps, they may already have cronjobs that should be cleared.\n    this.unregister(snap.id);\n    this.register(snap.id);\n  };\n\n  /**\n   * Handle the Snap enabled event. This checks if the Snap has any cronjobs or\n   * background events that need to be rescheduled.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapEnabledEvent = (snap: TruncatedSnap) => {\n    const events = this.get(snap.id);\n    this.#reschedule(events);\n    this.register(snap.id);\n  };\n\n  /**\n   * Handle events that should cause cronjobs and background events to be\n   * unregistered.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapUninstalledEvent = (snap: TruncatedSnap) => {\n    this.unregister(snap.id);\n  };\n\n  /**\n   * Handle events that should cause cronjobs and background events to be\n   * unregistered.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapDisabledEvent = (snap: TruncatedSnap) => {\n    this.unregister(snap.id);\n  };\n\n  /**\n   * Handle cron jobs on 'snapUpdated' event.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapUpdatedEvent = (snap: TruncatedSnap) => {\n    this.unregister(snap.id);\n    this.register(snap.id);\n  };\n\n  /**\n   * Reschedule events that are yet to be executed. This should be called on\n   * controller initialization and once every 24 hours to ensure that\n   * background events are scheduled correctly.\n   *\n   * @param events - An array of events to reschedule. Defaults to all events in\n   * the controller state.\n   */\n  #reschedule(events = Object.values(this.state.events)) {\n    const now = Date.now();\n\n    for (const event of events) {\n      if (this.#timers.has(event.id)) {\n        // If the timer for this event already exists, we don't need to\n        // reschedule it.\n        continue;\n      }\n\n      const eventDate = DateTime.fromISO(event.date, {\n        setZone: true,\n      })\n        .toUTC()\n        .toMillis();\n\n      // If the event is recurring and the date is in the past, execute it\n      // immediately.\n      if (event.recurring && eventDate <= now) {\n        this.#execute(event);\n        continue;\n      }\n\n      this.#schedule(event, false);\n    }\n  }\n\n  /**\n   * Clear non-recurring events that are past their scheduled time.\n   */\n  #clear() {\n    const now = Date.now();\n\n    for (const event of Object.values(this.state.events)) {\n      const eventDate = DateTime.fromISO(event.date, {\n        setZone: true,\n      })\n        .toUTC()\n        .toMillis();\n\n      if (!event.recurring && eventDate < now) {\n        this.#cancel(event.id);\n      }\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"CronjobController.mjs","sourceRoot":"","sources":["../../src/cronjob/CronjobController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller/next';\nimport { BaseController } from '@metamask/base-controller/next';\nimport type { Messenger } from '@metamask/messenger';\nimport type { GetPermissions } from '@metamask/permission-controller';\nimport {\n  getCronjobCaveatJobs,\n  SnapEndowments,\n} from '@metamask/snaps-rpc-methods';\nimport type { BackgroundEvent, SnapId } from '@metamask/snaps-sdk';\nimport type { TruncatedSnap } from '@metamask/snaps-utils';\nimport {\n  toCensoredISO8601String,\n  HandlerType,\n  logError,\n} from '@metamask/snaps-utils';\nimport { assert, Duration, inMilliseconds } from '@metamask/utils';\nimport { castDraft } from 'immer';\nimport { DateTime } from 'luxon';\nimport { nanoid } from 'nanoid';\n\nimport { getCronjobSpecificationSchedule, getExecutionDate } from './utils';\nimport type {\n  HandleSnapRequest,\n  SnapDisabled,\n  SnapEnabled,\n  SnapInstalled,\n  SnapUninstalled,\n  SnapUpdated,\n} from '..';\nimport { METAMASK_ORIGIN } from '../snaps/constants';\nimport { Timer } from '../snaps/Timer';\n\nexport type CronjobControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  CronjobControllerState\n>;\nexport type CronjobControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  CronjobControllerState\n>;\n\n/**\n * Initialise the CronjobController. This should be called after all controllers\n * are created.\n */\nexport type CronjobControllerInitAction = {\n  type: `${typeof controllerName}:init`;\n  handler: CronjobController['init'];\n};\n\nexport type Schedule = {\n  type: `${typeof controllerName}:schedule`;\n  handler: CronjobController['schedule'];\n};\n\nexport type Cancel = {\n  type: `${typeof controllerName}:cancel`;\n  handler: CronjobController['cancel'];\n};\n\nexport type Get = {\n  type: `${typeof controllerName}:get`;\n  handler: CronjobController['get'];\n};\n\nexport type CronjobControllerActions =\n  | CronjobControllerGetStateAction\n  | HandleSnapRequest\n  | GetPermissions\n  | Schedule\n  | Cancel\n  | Get\n  | CronjobControllerInitAction;\n\nexport type CronjobControllerEvents =\n  | CronjobControllerStateChangeEvent\n  | SnapInstalled\n  | SnapUninstalled\n  | SnapUpdated\n  | SnapEnabled\n  | SnapDisabled;\n\nexport type CronjobControllerMessenger = Messenger<\n  typeof controllerName,\n  CronjobControllerActions,\n  CronjobControllerEvents\n>;\n\nexport const DAILY_TIMEOUT = inMilliseconds(24, Duration.Hour);\n\nexport type CronjobControllerStateManager = {\n  set(state: CronjobControllerState): void;\n  getInitialState(): CronjobControllerState | undefined;\n};\n\nexport type CronjobControllerArgs = {\n  messenger: CronjobControllerMessenger;\n\n  /**\n   * Persisted state that will be used for rehydration.\n   */\n  state?: CronjobControllerState;\n\n  /**\n   * State manager for the controller.\n   *\n   * This is a temporary workaround to allow the controller to update the state\n   * often without persisting all of the client state to disk.\n   */\n  stateManager: CronjobControllerStateManager;\n};\n\n/**\n * Represents a background event that is scheduled to be executed by the\n * cronjob controller.\n */\nexport type InternalBackgroundEvent = BackgroundEvent & {\n  /**\n   * Whether the event is recurring.\n   */\n  recurring: boolean;\n\n  /**\n   * The cron expression or ISO 8601 duration string that defines the event's\n   * schedule.\n   */\n  schedule: string;\n};\n\n/**\n * A schedulable background event, which is a subset of the\n * {@link InternalBackgroundEvent} type, containing only the fields required to\n * schedule an event. Other fields will be populated by the cronjob controller\n * automatically.\n */\nexport type SchedulableBackgroundEvent = Omit<\n  InternalBackgroundEvent,\n  'scheduledAt' | 'date' | 'id'\n> & {\n  /**\n   * The optional ID of the event. If not provided, a new ID will be\n   * generated.\n   */\n  id?: string;\n};\n\nexport type CronjobControllerState = {\n  /**\n   * Background events and cronjobs that are scheduled to be executed.\n   */\n  events: Record<string, InternalBackgroundEvent>;\n};\n\nconst controllerName = 'CronjobController';\n\n/**\n * The cronjob controller is responsible for managing cronjobs and background\n * events for Snaps. It allows Snaps to schedule events that will be executed\n * at a later time.\n */\nexport class CronjobController extends BaseController<\n  typeof controllerName,\n  CronjobControllerState,\n  CronjobControllerMessenger\n> {\n  readonly #timers: Map<string, Timer>;\n\n  readonly #stateManager: CronjobControllerStateManager;\n\n  #dailyTimer: Timer = new Timer(DAILY_TIMEOUT);\n\n  constructor({ messenger, state, stateManager }: CronjobControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        events: {\n          includeInStateLogs: false,\n          persist: false,\n          includeInDebugSnapshot: false,\n          usedInUi: false,\n        },\n      },\n      name: controllerName,\n      state: {\n        events: {},\n        ...state,\n        ...stateManager.getInitialState(),\n      },\n    });\n\n    this.#timers = new Map();\n    this.#stateManager = stateManager;\n\n    this.messenger.subscribe(\n      'SnapController:snapInstalled',\n      this.#handleSnapInstalledEvent,\n    );\n\n    this.messenger.subscribe(\n      'SnapController:snapUninstalled',\n      this.#handleSnapUninstalledEvent,\n    );\n\n    this.messenger.subscribe(\n      'SnapController:snapEnabled',\n      this.#handleSnapEnabledEvent,\n    );\n\n    this.messenger.subscribe(\n      'SnapController:snapDisabled',\n      this.#handleSnapDisabledEvent,\n    );\n\n    this.messenger.subscribe(\n      'SnapController:snapUpdated',\n      this.#handleSnapUpdatedEvent,\n    );\n\n    this.messenger.registerActionHandler(`${controllerName}:init`, (...args) =>\n      this.init(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:schedule`,\n      (...args) => this.schedule(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:cancel`,\n      (...args) => this.cancel(...args),\n    );\n\n    this.messenger.registerActionHandler(`${controllerName}:get`, (...args) =>\n      this.get(...args),\n    );\n  }\n\n  /**\n   * Initialize the CronjobController.\n   *\n   * This starts the daily timer, clears out expired events\n   * and reschedules any remaining events.\n   */\n  init() {\n    this.#start();\n    this.#clear();\n    this.#reschedule();\n  }\n\n  /**\n   * Schedule a non-recurring background event.\n   *\n   * @param event - The event to schedule.\n   * @returns The ID of the scheduled event.\n   */\n  schedule(event: Omit<SchedulableBackgroundEvent, 'recurring'>) {\n    return this.#add({\n      ...event,\n      recurring: false,\n    });\n  }\n\n  /**\n   * Cancel an event.\n   *\n   * @param origin - The origin making the cancel call.\n   * @param id - The id of the event to cancel.\n   * @throws If the event does not exist.\n   */\n  cancel(origin: string, id: string) {\n    assert(\n      this.state.events[id],\n      `A background event with the id of \"${id}\" does not exist.`,\n    );\n\n    assert(\n      this.state.events[id].snapId === origin,\n      'Only the origin that scheduled this event can cancel it.',\n    );\n\n    this.#cancel(id);\n  }\n\n  /**\n   * Get a list of a Snap's background events.\n   *\n   * @param snapId - The id of the Snap to fetch background events for.\n   * @returns An array of background events.\n   */\n  get(snapId: SnapId): InternalBackgroundEvent[] {\n    return Object.values(this.state.events)\n      .filter(\n        (snapEvent) => snapEvent.snapId === snapId && !snapEvent.recurring,\n      )\n      .map((event) => ({\n        ...event,\n        date: toCensoredISO8601String(event.date),\n        scheduledAt: toCensoredISO8601String(event.scheduledAt),\n      }));\n  }\n\n  /**\n   * Register cronjobs for a given Snap by getting specification from the\n   * permission caveats. Once registered, each job will be scheduled.\n   *\n   * @param snapId - The snap ID to register jobs for.\n   */\n  register(snapId: SnapId) {\n    const jobs = this.#getSnapCronjobs(snapId);\n    jobs?.forEach((job) => this.#add(job));\n  }\n\n  /**\n   * Unregister all cronjobs and background events for a given Snap.\n   *\n   * @param snapId - ID of a snap.\n   */\n  unregister(snapId: SnapId) {\n    for (const [id, event] of Object.entries(this.state.events)) {\n      if (event.snapId === snapId) {\n        this.#cancel(id);\n      }\n    }\n  }\n\n  /**\n   * Run controller teardown process and unsubscribe from Snap events.\n   */\n  destroy() {\n    super.destroy();\n\n    this.messenger.unsubscribe(\n      'SnapController:snapInstalled',\n      this.#handleSnapInstalledEvent,\n    );\n\n    this.messenger.unsubscribe(\n      'SnapController:snapUninstalled',\n      this.#handleSnapUninstalledEvent,\n    );\n\n    this.messenger.unsubscribe(\n      'SnapController:snapEnabled',\n      this.#handleSnapEnabledEvent,\n    );\n\n    this.messenger.unsubscribe(\n      'SnapController:snapDisabled',\n      this.#handleSnapDisabledEvent,\n    );\n\n    this.messenger.unsubscribe(\n      'SnapController:snapUpdated',\n      this.#handleSnapUpdatedEvent,\n    );\n\n    // Cancel all timers and clear the map.\n    this.#timers.forEach((timer) => timer.cancel());\n    this.#timers.clear();\n\n    if (this.#dailyTimer.status === 'running') {\n      this.#dailyTimer.cancel();\n    }\n  }\n\n  /**\n   * Start the daily timer that will reschedule events every 24 hours.\n   */\n  #start() {\n    this.#dailyTimer = new Timer(DAILY_TIMEOUT);\n    this.#dailyTimer.start(() => {\n      this.#reschedule();\n      this.#start();\n    });\n  }\n\n  /**\n   * Add a cronjob or background event to the controller state and schedule it\n   * for execution.\n   *\n   * @param event - The event to schedule.\n   * @returns The ID of the scheduled event.\n   */\n  #add(event: SchedulableBackgroundEvent) {\n    const id = event.id ?? nanoid();\n    const internalEvent: InternalBackgroundEvent = {\n      ...event,\n      id,\n      date: getExecutionDate(event.schedule),\n      scheduledAt: new Date().toISOString(),\n    };\n\n    const { nextState } = this.update((state) => {\n      state.events[internalEvent.id] = castDraft(internalEvent);\n    });\n\n    this.#stateManager.set(nextState);\n\n    this.#schedule(internalEvent);\n    return id;\n  }\n\n  /**\n   * Get the next execution date for a given event and start a timer for it.\n   *\n   * @param event - The event to schedule.\n   * @param next - Whether to schedule to the next date, otherwise will\n   * schedule for existing date.\n   */\n  #schedule(event: InternalBackgroundEvent, next = true) {\n    if (!next) {\n      this.#startTimer(event);\n      return;\n    }\n\n    const date = getExecutionDate(event.schedule);\n    const { nextState } = this.update((state) => {\n      state.events[event.id].date = date;\n    });\n\n    this.#stateManager.set(nextState);\n\n    this.#startTimer({\n      ...event,\n      date,\n    });\n  }\n\n  /**\n   * Set up and start a timer for the given event.\n   *\n   * @param event - The event to schedule.\n   * @throws If the event is scheduled in the past.\n   */\n  #startTimer(event: InternalBackgroundEvent) {\n    const ms =\n      DateTime.fromISO(event.date, { setZone: true }).toMillis() - Date.now();\n\n    // We don't schedule this job yet as it is too far in the future.\n    if (ms > DAILY_TIMEOUT) {\n      return;\n    }\n\n    // When an event is supposed to be scheduled close to the current time\n    // we may end up needing to execute immediately instead.\n    if (ms <= 0) {\n      this.#execute(event);\n      return;\n    }\n\n    const timer = new Timer(ms);\n    timer.start(() => {\n      this.#execute(event);\n    });\n\n    this.#timers.set(event.id, timer);\n  }\n\n  /**\n   * Execute a background event. This method is called when the event's timer\n   * expires.\n   *\n   * If the event is not recurring, it will be removed from the state after\n   * execution. If it is recurring, it will be rescheduled.\n   *\n   * @param event - The event to execute.\n   */\n  #execute(event: InternalBackgroundEvent) {\n    this.messenger\n      .call('SnapController:handleRequest', {\n        snapId: event.snapId,\n        origin: METAMASK_ORIGIN,\n        handler: HandlerType.OnCronjob,\n        request: event.request,\n      })\n      .catch((error) => {\n        logError(\n          `An error occurred while executing an event for Snap \"${event.snapId}\":`,\n          error,\n        );\n      });\n\n    this.#timers.delete(event.id);\n\n    // Non-recurring events are removed from the state after execution, and\n    // recurring events are rescheduled.\n    if (!event.recurring) {\n      const { nextState } = this.update((state) => {\n        delete state.events[event.id];\n      });\n\n      this.#stateManager.set(nextState);\n\n      return;\n    }\n\n    this.#schedule(event);\n  }\n\n  /**\n   * Cancel a background event by its ID. Unlike {@link cancel}, this method\n   * does not check the origin of the event, so it can be used internally.\n   *\n   * @param id - The ID of the background event to cancel.\n   */\n  #cancel(id: string) {\n    const timer = this.#timers.get(id);\n    timer?.cancel();\n    this.#timers.delete(id);\n\n    const { nextState } = this.update((state) => {\n      delete state.events[id];\n    });\n\n    this.#stateManager.set(nextState);\n  }\n\n  /**\n   * Retrieve all cronjob specifications for a Snap.\n   *\n   * @param snapId - ID of a Snap.\n   * @returns Array of cronjob specifications.\n   */\n  #getSnapCronjobs(snapId: SnapId): SchedulableBackgroundEvent[] {\n    const permissions = this.messenger.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n\n    const permission = permissions?.[SnapEndowments.Cronjob];\n    const definitions = getCronjobCaveatJobs(permission);\n\n    if (!definitions) {\n      return [];\n    }\n\n    return definitions.map((definition, idx) => {\n      return {\n        snapId,\n        id: `cronjob-${snapId}-${idx}`,\n        request: definition.request,\n        schedule: getCronjobSpecificationSchedule(definition),\n        recurring: true,\n      };\n    });\n  }\n\n  /**\n   * Handle events that should cause cron jobs to be registered.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapInstalledEvent = (snap: TruncatedSnap) => {\n    // In case of local Snaps, they may already have cronjobs that should be cleared.\n    this.unregister(snap.id);\n    this.register(snap.id);\n  };\n\n  /**\n   * Handle the Snap enabled event. This checks if the Snap has any cronjobs or\n   * background events that need to be rescheduled.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapEnabledEvent = (snap: TruncatedSnap) => {\n    const events = this.get(snap.id);\n    this.#reschedule(events);\n    this.register(snap.id);\n  };\n\n  /**\n   * Handle events that should cause cronjobs and background events to be\n   * unregistered.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapUninstalledEvent = (snap: TruncatedSnap) => {\n    this.unregister(snap.id);\n  };\n\n  /**\n   * Handle events that should cause cronjobs and background events to be\n   * unregistered.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapDisabledEvent = (snap: TruncatedSnap) => {\n    this.unregister(snap.id);\n  };\n\n  /**\n   * Handle cron jobs on 'snapUpdated' event.\n   *\n   * @param snap - Basic Snap information.\n   */\n  readonly #handleSnapUpdatedEvent = (snap: TruncatedSnap) => {\n    this.unregister(snap.id);\n    this.register(snap.id);\n  };\n\n  /**\n   * Reschedule events that are yet to be executed. This should be called on\n   * controller initialization and once every 24 hours to ensure that\n   * background events are scheduled correctly.\n   *\n   * @param events - An array of events to reschedule. Defaults to all events in\n   * the controller state.\n   */\n  #reschedule(events = Object.values(this.state.events)) {\n    const now = Date.now();\n\n    for (const event of events) {\n      if (this.#timers.has(event.id)) {\n        // If the timer for this event already exists, we don't need to\n        // reschedule it.\n        continue;\n      }\n\n      const eventDate = DateTime.fromISO(event.date, {\n        setZone: true,\n      })\n        .toUTC()\n        .toMillis();\n\n      // If the event is recurring and the date is in the past, execute it\n      // immediately.\n      if (event.recurring && eventDate <= now) {\n        this.#execute(event);\n        continue;\n      }\n\n      this.#schedule(event, false);\n    }\n  }\n\n  /**\n   * Clear non-recurring events that are past their scheduled time.\n   */\n  #clear() {\n    const now = Date.now();\n\n    for (const event of Object.values(this.state.events)) {\n      const eventDate = DateTime.fromISO(event.date, {\n        setZone: true,\n      })\n        .toUTC()\n        .toMillis();\n\n      if (!event.recurring && eventDate < now) {\n        this.#cancel(event.id);\n      }\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/insights/SnapInsightsController.cjs b/dist/insights/SnapInsightsController.cjs
index 5bad2b03d9f297e09be8c9d7756e9db4f5fefa33..6cd532b48fc3e96efd314914054083ed61a6f304 100644
--- a/dist/insights/SnapInsightsController.cjs
+++ b/dist/insights/SnapInsightsController.cjs
@@ -1,7 +1,7 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.SnapInsightsController = void 0;
-const base_controller_1 = require("@metamask/base-controller");
+const next_1 = require("@metamask/base-controller/next");
 const snaps_rpc_methods_1 = require("@metamask/snaps-rpc-methods");
 const snaps_utils_1 = require("@metamask/snaps-utils");
 const utils_1 = require("@metamask/utils");
@@ -10,7 +10,7 @@ const controllerName = 'SnapInsightsController';
 /**
  * Controller for monitoring for new transactions and signatures to provide insight for.
  */
-class SnapInsightsController extends base_controller_1.BaseController {
+class SnapInsightsController extends next_1.BaseController {
     constructor({ messenger, state }) {
         super({
             messenger,
@@ -18,16 +18,16 @@ class SnapInsightsController extends base_controller_1.BaseController {
                 insights: {
                     includeInStateLogs: true,
                     persist: false,
-                    anonymous: false,
+                    includeInDebugSnapshot: false,
                     usedInUi: true,
                 },
             },
             name: controllerName,
             state: { insights: {}, ...state },
         });
-        this.messagingSystem.subscribe('TransactionController:unapprovedTransactionAdded', this.#handleTransaction.bind(this));
-        this.messagingSystem.subscribe('TransactionController:transactionStatusUpdated', this.#handleTransactionStatusUpdate.bind(this));
-        this.messagingSystem.subscribe('SignatureController:stateChange', this.#handleSignatureStateChange.bind(this));
+        this.messenger.subscribe('TransactionController:unapprovedTransactionAdded', this.#handleTransaction.bind(this));
+        this.messenger.subscribe('TransactionController:transactionStatusUpdated', this.#handleTransactionStatusUpdate.bind(this));
+        this.messenger.subscribe('SignatureController:stateChange', this.#handleSignatureStateChange.bind(this));
     }
     /**
      * Check if an insight already exists for a given ID.
@@ -46,10 +46,10 @@ class SnapInsightsController extends base_controller_1.BaseController {
      * @returns A list of objects containing Snap IDs and the permission object.
      */
     #getSnapsWithPermission(permissionName) {
-        const allSnaps = this.messagingSystem.call('SnapController:getAll');
+        const allSnaps = this.messenger.call('SnapController:getAll');
         const filteredSnaps = (0, snaps_1.getRunnableSnaps)(allSnaps);
         return filteredSnaps.reduce((accumulator, snap) => {
-            const permissions = this.messagingSystem.call('PermissionController:getPermissions', snap.id);
+            const permissions = this.messenger.call('PermissionController:getPermissions', snap.id);
             if (permissions && (0, utils_1.hasProperty)(permissions, permissionName)) {
                 accumulator.push({
                     snapId: snap.id,
@@ -189,7 +189,7 @@ class SnapInsightsController extends base_controller_1.BaseController {
         Object.values(this.state.insights[id])
             .filter((insight) => insight.interfaceId)
             .forEach((insight) => {
-            this.messagingSystem.call('SnapInterfaceController:deleteInterface', insight.interfaceId);
+            this.messenger.call('SnapInterfaceController:deleteInterface', insight.interfaceId);
         });
         this.update((state) => {
             delete state.insights[id];
@@ -205,7 +205,7 @@ class SnapInsightsController extends base_controller_1.BaseController {
      * @returns The response from the Snap.
      */
     async #handleSnapRequest({ snapId, handler, params, }) {
-        return this.messagingSystem.call('SnapController:handleRequest', {
+        return this.messenger.call('SnapController:handleRequest', {
             snapId,
             origin: 'metamask',
             handler,
diff --git a/dist/insights/SnapInsightsController.cjs.map b/dist/insights/SnapInsightsController.cjs.map
index c06edf55a60d79064de899160f3e7d9eec94e0f8..7120aab497835db76adf0141c7c613c2013cb912 100644
--- a/dist/insights/SnapInsightsController.cjs.map
+++ b/dist/insights/SnapInsightsController.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"SnapInsightsController.cjs","sourceRoot":"","sources":["../../src/insights/SnapInsightsController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  RestrictedMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type {\n  Caveat,\n  GetPermissions,\n  ValidPermission,\n} from '@metamask/permission-controller';\nimport {\n  getSignatureOriginCaveat,\n  getTransactionOriginCaveat,\n  SnapEndowments,\n} from '@metamask/snaps-rpc-methods';\nimport type { Json, SnapId } from '@metamask/snaps-sdk';\nimport { HandlerType } from '@metamask/snaps-utils';\nimport { hasProperty, hexToBigInt } from '@metamask/utils';\n\nimport type { DeleteInterface } from '../interface';\nimport type { GetAllSnaps, HandleSnapRequest } from '../snaps';\nimport { getRunnableSnaps } from '../snaps';\nimport type {\n  TransactionControllerUnapprovedTransactionAddedEvent,\n  TransactionMeta,\n  SignatureStateChange,\n  SignatureControllerState,\n  StateSignature,\n  TransactionControllerTransactionStatusUpdatedEvent,\n} from '../types';\n\nconst controllerName = 'SnapInsightsController';\n\nexport type SnapInsightsControllerAllowedActions =\n  | HandleSnapRequest\n  | GetAllSnaps\n  | GetPermissions\n  | DeleteInterface;\n\nexport type SnapInsightsControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapInsightsControllerState\n>;\n\nexport type SnapInsightsControllerActions =\n  SnapInsightsControllerGetStateAction;\n\nexport type SnapInsightControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  SnapInsightsControllerState\n>;\n\nexport type SnapInsightControllerEvents = SnapInsightControllerStateChangeEvent;\n\nexport type SnapInsightsControllerAllowedEvents =\n  | TransactionControllerUnapprovedTransactionAddedEvent\n  | TransactionControllerTransactionStatusUpdatedEvent\n  | SignatureStateChange;\n\nexport type SnapInsightsControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  SnapInsightsControllerActions | SnapInsightsControllerAllowedActions,\n  SnapInsightControllerEvents | SnapInsightsControllerAllowedEvents,\n  SnapInsightsControllerAllowedActions['type'],\n  SnapInsightsControllerAllowedEvents['type']\n>;\n\nexport type SnapInsight = {\n  snapId: SnapId;\n  interfaceId?: string | null;\n  error?: string;\n  loading: boolean;\n  severity?: string;\n};\n\nexport type SnapInsightsControllerState = {\n  insights: Record<string, Record<SnapId, SnapInsight>>;\n};\n\nexport type SnapInsightsControllerArgs = {\n  messenger: SnapInsightsControllerMessenger;\n  state?: SnapInsightsControllerState;\n};\n\ntype SnapWithPermission = {\n  snapId: SnapId;\n  permission: ValidPermission<string, Caveat<string, Json>>;\n};\n\n/**\n * Controller for monitoring for new transactions and signatures to provide insight for.\n */\nexport class SnapInsightsController extends BaseController<\n  typeof controllerName,\n  SnapInsightsControllerState,\n  SnapInsightsControllerMessenger\n> {\n  constructor({ messenger, state }: SnapInsightsControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        insights: {\n          includeInStateLogs: true,\n          persist: false,\n          anonymous: false,\n          usedInUi: true,\n        },\n      },\n      name: controllerName,\n      state: { insights: {}, ...state },\n    });\n\n    this.messagingSystem.subscribe(\n      'TransactionController:unapprovedTransactionAdded',\n      this.#handleTransaction.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'TransactionController:transactionStatusUpdated',\n      this.#handleTransactionStatusUpdate.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'SignatureController:stateChange',\n      this.#handleSignatureStateChange.bind(this),\n    );\n  }\n\n  /**\n   * Check if an insight already exists for a given ID.\n   *\n   * @param id - The ID.\n   * @returns True if the insight already exists, otherwise false.\n   */\n  #hasInsight(id: string) {\n    return hasProperty(this.state.insights, id);\n  }\n\n  /**\n   * Get a list of runnable Snaps that have a given permission.\n   * Also includes the permission object itself.\n   *\n   * @param permissionName - The permission name.\n   * @returns A list of objects containing Snap IDs and the permission object.\n   */\n  #getSnapsWithPermission(permissionName: string) {\n    const allSnaps = this.messagingSystem.call('SnapController:getAll');\n    const filteredSnaps = getRunnableSnaps(allSnaps);\n\n    return filteredSnaps.reduce<SnapWithPermission[]>((accumulator, snap) => {\n      const permissions = this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        snap.id,\n      );\n      if (permissions && hasProperty(permissions, permissionName)) {\n        accumulator.push({\n          snapId: snap.id,\n          permission: permissions[permissionName],\n        });\n      }\n\n      return accumulator;\n    }, []);\n  }\n\n  /**\n   * Handle a newly added unapproved transaction.\n   * This function fetches insights from all available Snaps\n   * and populates the insights state blob with the responses.\n   *\n   * @param transaction - The transaction object.\n   */\n  #handleTransaction(transaction: TransactionMeta) {\n    const { id, txParams, chainId, origin } = transaction;\n\n    // This assumes that the transactions are EVM-compatible for now.\n    const caipChainId = `eip155:${hexToBigInt(chainId).toString(10)}`;\n\n    const snaps = this.#getSnapsWithPermission(\n      SnapEndowments.TransactionInsight,\n    );\n\n    snaps.forEach(({ snapId, permission }) => {\n      const hasTransactionOriginCaveat = getTransactionOriginCaveat(permission);\n      const transactionOrigin =\n        hasTransactionOriginCaveat && origin ? origin : null;\n\n      this.update((state) => {\n        state.insights[id] ??= {};\n        state.insights[id][snapId] = { snapId, loading: true };\n      });\n\n      this.#handleSnapRequest({\n        snapId,\n        handler: HandlerType.OnTransaction,\n        params: {\n          transaction: txParams,\n          chainId: caipChainId,\n          transactionOrigin,\n        },\n      })\n        .then((response) =>\n          this.#handleSnapResponse({\n            id,\n            snapId,\n            response: response as Record<string, Json>,\n          }),\n        )\n        .catch((error) => this.#handleSnapResponse({ id, snapId, error }));\n    });\n  }\n\n  /**\n   * Handle the stateChange event emitted by the SignatureController.\n   * This function will remove existing insights from the state when applicable, as well as\n   * trigger insight fetching for newly added signatures.\n   *\n   * @param state - The SignatureController state blob.\n   */\n  #handleSignatureStateChange(state: SignatureControllerState) {\n    // If any IDs have disappeared since the last state update, the insight may be cleaned up.\n    for (const id of Object.keys(this.state.insights)) {\n      if (\n        !hasProperty(state.unapprovedTypedMessages, id) &&\n        !hasProperty(state.unapprovedPersonalMsgs, id)\n      ) {\n        this.#handleInsightCleanup(id);\n      }\n    }\n\n    if (\n      state.unapprovedPersonalMsgCount > 0 ||\n      state.unapprovedTypedMessagesCount > 0\n    ) {\n      const snaps = this.#getSnapsWithPermission(\n        SnapEndowments.SignatureInsight,\n      );\n\n      // This isn't very efficient, but SignatureController doesn't expose a better event for us to use yet.\n      for (const personalSignature of Object.values(\n        state.unapprovedPersonalMsgs,\n      )) {\n        this.#handleSignature(snaps, personalSignature);\n      }\n\n      for (const typedMessage of Object.values(state.unapprovedTypedMessages)) {\n        this.#handleSignature(snaps, typedMessage);\n      }\n    }\n  }\n\n  /**\n   * Handle a newly added unapproved signature.\n   * This function fetches insights from all available Snaps\n   * and populates the insights state blob with the responses.\n   *\n   * @param snaps - A list of Snaps to invoke.\n   * @param signature - The signature object.\n   */\n  #handleSignature(snaps: SnapWithPermission[], signature: StateSignature) {\n    const { id, msgParams } = signature;\n\n    if (this.#hasInsight(id)) {\n      return;\n    }\n\n    const { from, data, signatureMethod, origin } = msgParams;\n\n    /**\n     * Both eth_signTypedData_v3 and eth_signTypedData_v4 methods\n     * need to be parsed because their data is stringified. All other\n     * signature methods do not, so they are ignored.\n     */\n    const shouldParse =\n      signatureMethod === 'eth_signTypedData_v3' ||\n      signatureMethod === 'eth_signTypedData_v4';\n\n    const payload = {\n      from,\n      data: shouldParse ? JSON.parse(data as string) : data,\n      signatureMethod,\n    };\n\n    snaps.forEach(({ snapId, permission }) => {\n      const hasSignatureOriginCaveat = getSignatureOriginCaveat(permission);\n      const signatureOrigin =\n        origin && hasSignatureOriginCaveat ? origin : null;\n\n      this.update((state) => {\n        state.insights[id] ??= {};\n        state.insights[id][snapId] = { snapId, loading: true };\n      });\n\n      this.#handleSnapRequest({\n        snapId,\n        handler: HandlerType.OnSignature,\n        params: { signature: payload, signatureOrigin },\n      })\n        .then((response) =>\n          this.#handleSnapResponse({\n            id,\n            snapId,\n            response: response as Record<string, Json>,\n          }),\n        )\n        .catch((error) => this.#handleSnapResponse({ id, snapId, error }));\n    });\n  }\n\n  /**\n   * Handle the transactionStatusUpdated event emitted by the TransactionController.\n   * This function will remove insights for the transaction in question\n   * once the transaction status has changed from unapproved.\n   *\n   * @param args - An options bag.\n   * @param args.transactionMeta - The transaction.\n   */\n  #handleTransactionStatusUpdate({\n    transactionMeta,\n  }: {\n    transactionMeta: TransactionMeta;\n  }) {\n    if (transactionMeta.status !== 'unapproved') {\n      this.#handleInsightCleanup(transactionMeta.id);\n    }\n  }\n\n  #handleInsightCleanup(id: string) {\n    if (!this.#hasInsight(id)) {\n      return;\n    }\n\n    // Delete interfaces from interface controller.\n    Object.values(this.state.insights[id])\n      .filter((insight) => insight.interfaceId)\n      .forEach((insight) => {\n        this.messagingSystem.call(\n          'SnapInterfaceController:deleteInterface',\n          insight.interfaceId as string,\n        );\n      });\n\n    this.update((state) => {\n      delete state.insights[id];\n    });\n  }\n\n  /**\n   * Handle sending a request to a given Snap with a given payload.\n   *\n   * @param args - An options bag.\n   * @param args.snapId - The Snap ID.\n   * @param args.handler - The handler to invoke.\n   * @param args.params - The JSON-RPC params to send.\n   * @returns The response from the Snap.\n   */\n  async #handleSnapRequest({\n    snapId,\n    handler,\n    params,\n  }: {\n    snapId: SnapId;\n    handler: HandlerType.OnTransaction | HandlerType.OnSignature;\n    params: Record<string, Json>;\n  }) {\n    return this.messagingSystem.call('SnapController:handleRequest', {\n      snapId,\n      origin: 'metamask',\n      handler,\n      request: {\n        method: '',\n        params,\n      },\n    });\n  }\n\n  /**\n   * Handle response from a given Snap by persisting the response or error in state.\n   *\n   * @param args - An options bag.\n   * @param args.id - The transaction or signature ID.\n   * @param args.snapId - The Snap ID.\n   * @param args.response - An optional response object returned by the Snap.\n   * @param args.error - An optional error returned by the Snap.\n   */\n  #handleSnapResponse({\n    id,\n    snapId,\n    response,\n    error,\n  }: {\n    id: string;\n    snapId: SnapId;\n    response?: Record<string, Json>;\n    error?: Error;\n  }) {\n    // If the insight has been cleaned up already, we can skip setting the state.\n    // This may happen if a user accepts/rejects a transaction/signature faster than the Snap responds.\n    if (!this.#hasInsight(id)) {\n      return;\n    }\n\n    this.update((state) => {\n      state.insights[id][snapId].loading = false;\n      state.insights[id][snapId].interfaceId = response?.id as string;\n      state.insights[id][snapId].severity = response?.severity as string;\n      state.insights[id][snapId].error = error?.message;\n    });\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SnapInsightsController.cjs","sourceRoot":"","sources":["../../src/insights/SnapInsightsController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller/next';\nimport { BaseController } from '@metamask/base-controller/next';\nimport type { Messenger } from '@metamask/messenger';\nimport type {\n  Caveat,\n  GetPermissions,\n  ValidPermission,\n} from '@metamask/permission-controller';\nimport {\n  getSignatureOriginCaveat,\n  getTransactionOriginCaveat,\n  SnapEndowments,\n} from '@metamask/snaps-rpc-methods';\nimport type { Json, SnapId } from '@metamask/snaps-sdk';\nimport { HandlerType } from '@metamask/snaps-utils';\nimport { hasProperty, hexToBigInt } from '@metamask/utils';\n\nimport type { DeleteInterface } from '../interface';\nimport type { GetAllSnaps, HandleSnapRequest } from '../snaps';\nimport { getRunnableSnaps } from '../snaps';\nimport type {\n  TransactionControllerUnapprovedTransactionAddedEvent,\n  TransactionMeta,\n  SignatureStateChange,\n  SignatureControllerState,\n  StateSignature,\n  TransactionControllerTransactionStatusUpdatedEvent,\n} from '../types';\n\nconst controllerName = 'SnapInsightsController';\n\nexport type SnapInsightsControllerAllowedActions =\n  | HandleSnapRequest\n  | GetAllSnaps\n  | GetPermissions\n  | DeleteInterface;\n\nexport type SnapInsightsControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapInsightsControllerState\n>;\n\nexport type SnapInsightsControllerActions =\n  SnapInsightsControllerGetStateAction;\n\nexport type SnapInsightControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  SnapInsightsControllerState\n>;\n\nexport type SnapInsightControllerEvents = SnapInsightControllerStateChangeEvent;\n\nexport type SnapInsightsControllerAllowedEvents =\n  | TransactionControllerUnapprovedTransactionAddedEvent\n  | TransactionControllerTransactionStatusUpdatedEvent\n  | SignatureStateChange;\n\nexport type SnapInsightsControllerMessenger = Messenger<\n  typeof controllerName,\n  SnapInsightsControllerActions | SnapInsightsControllerAllowedActions,\n  SnapInsightControllerEvents | SnapInsightsControllerAllowedEvents\n>;\n\nexport type SnapInsight = {\n  snapId: SnapId;\n  interfaceId?: string | null;\n  error?: string;\n  loading: boolean;\n  severity?: string;\n};\n\nexport type SnapInsightsControllerState = {\n  insights: Record<string, Record<SnapId, SnapInsight>>;\n};\n\nexport type SnapInsightsControllerArgs = {\n  messenger: SnapInsightsControllerMessenger;\n  state?: SnapInsightsControllerState;\n};\n\ntype SnapWithPermission = {\n  snapId: SnapId;\n  permission: ValidPermission<string, Caveat<string, Json>>;\n};\n\n/**\n * Controller for monitoring for new transactions and signatures to provide insight for.\n */\nexport class SnapInsightsController extends BaseController<\n  typeof controllerName,\n  SnapInsightsControllerState,\n  SnapInsightsControllerMessenger\n> {\n  constructor({ messenger, state }: SnapInsightsControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        insights: {\n          includeInStateLogs: true,\n          persist: false,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n      },\n      name: controllerName,\n      state: { insights: {}, ...state },\n    });\n\n    this.messenger.subscribe(\n      'TransactionController:unapprovedTransactionAdded',\n      this.#handleTransaction.bind(this),\n    );\n\n    this.messenger.subscribe(\n      'TransactionController:transactionStatusUpdated',\n      this.#handleTransactionStatusUpdate.bind(this),\n    );\n\n    this.messenger.subscribe(\n      'SignatureController:stateChange',\n      this.#handleSignatureStateChange.bind(this),\n    );\n  }\n\n  /**\n   * Check if an insight already exists for a given ID.\n   *\n   * @param id - The ID.\n   * @returns True if the insight already exists, otherwise false.\n   */\n  #hasInsight(id: string) {\n    return hasProperty(this.state.insights, id);\n  }\n\n  /**\n   * Get a list of runnable Snaps that have a given permission.\n   * Also includes the permission object itself.\n   *\n   * @param permissionName - The permission name.\n   * @returns A list of objects containing Snap IDs and the permission object.\n   */\n  #getSnapsWithPermission(permissionName: string) {\n    const allSnaps = this.messenger.call('SnapController:getAll');\n    const filteredSnaps = getRunnableSnaps(allSnaps);\n\n    return filteredSnaps.reduce<SnapWithPermission[]>((accumulator, snap) => {\n      const permissions = this.messenger.call(\n        'PermissionController:getPermissions',\n        snap.id,\n      );\n      if (permissions && hasProperty(permissions, permissionName)) {\n        accumulator.push({\n          snapId: snap.id,\n          permission: permissions[permissionName],\n        });\n      }\n\n      return accumulator;\n    }, []);\n  }\n\n  /**\n   * Handle a newly added unapproved transaction.\n   * This function fetches insights from all available Snaps\n   * and populates the insights state blob with the responses.\n   *\n   * @param transaction - The transaction object.\n   */\n  #handleTransaction(transaction: TransactionMeta) {\n    const { id, txParams, chainId, origin } = transaction;\n\n    // This assumes that the transactions are EVM-compatible for now.\n    const caipChainId = `eip155:${hexToBigInt(chainId).toString(10)}`;\n\n    const snaps = this.#getSnapsWithPermission(\n      SnapEndowments.TransactionInsight,\n    );\n\n    snaps.forEach(({ snapId, permission }) => {\n      const hasTransactionOriginCaveat = getTransactionOriginCaveat(permission);\n      const transactionOrigin =\n        hasTransactionOriginCaveat && origin ? origin : null;\n\n      this.update((state) => {\n        state.insights[id] ??= {};\n        state.insights[id][snapId] = { snapId, loading: true };\n      });\n\n      this.#handleSnapRequest({\n        snapId,\n        handler: HandlerType.OnTransaction,\n        params: {\n          transaction: txParams,\n          chainId: caipChainId,\n          transactionOrigin,\n        },\n      })\n        .then((response) =>\n          this.#handleSnapResponse({\n            id,\n            snapId,\n            response: response as Record<string, Json>,\n          }),\n        )\n        .catch((error) => this.#handleSnapResponse({ id, snapId, error }));\n    });\n  }\n\n  /**\n   * Handle the stateChange event emitted by the SignatureController.\n   * This function will remove existing insights from the state when applicable, as well as\n   * trigger insight fetching for newly added signatures.\n   *\n   * @param state - The SignatureController state blob.\n   */\n  #handleSignatureStateChange(state: SignatureControllerState) {\n    // If any IDs have disappeared since the last state update, the insight may be cleaned up.\n    for (const id of Object.keys(this.state.insights)) {\n      if (\n        !hasProperty(state.unapprovedTypedMessages, id) &&\n        !hasProperty(state.unapprovedPersonalMsgs, id)\n      ) {\n        this.#handleInsightCleanup(id);\n      }\n    }\n\n    if (\n      state.unapprovedPersonalMsgCount > 0 ||\n      state.unapprovedTypedMessagesCount > 0\n    ) {\n      const snaps = this.#getSnapsWithPermission(\n        SnapEndowments.SignatureInsight,\n      );\n\n      // This isn't very efficient, but SignatureController doesn't expose a better event for us to use yet.\n      for (const personalSignature of Object.values(\n        state.unapprovedPersonalMsgs,\n      )) {\n        this.#handleSignature(snaps, personalSignature);\n      }\n\n      for (const typedMessage of Object.values(state.unapprovedTypedMessages)) {\n        this.#handleSignature(snaps, typedMessage);\n      }\n    }\n  }\n\n  /**\n   * Handle a newly added unapproved signature.\n   * This function fetches insights from all available Snaps\n   * and populates the insights state blob with the responses.\n   *\n   * @param snaps - A list of Snaps to invoke.\n   * @param signature - The signature object.\n   */\n  #handleSignature(snaps: SnapWithPermission[], signature: StateSignature) {\n    const { id, msgParams } = signature;\n\n    if (this.#hasInsight(id)) {\n      return;\n    }\n\n    const { from, data, signatureMethod, origin } = msgParams;\n\n    /**\n     * Both eth_signTypedData_v3 and eth_signTypedData_v4 methods\n     * need to be parsed because their data is stringified. All other\n     * signature methods do not, so they are ignored.\n     */\n    const shouldParse =\n      signatureMethod === 'eth_signTypedData_v3' ||\n      signatureMethod === 'eth_signTypedData_v4';\n\n    const payload = {\n      from,\n      data: shouldParse ? JSON.parse(data as string) : data,\n      signatureMethod,\n    };\n\n    snaps.forEach(({ snapId, permission }) => {\n      const hasSignatureOriginCaveat = getSignatureOriginCaveat(permission);\n      const signatureOrigin =\n        origin && hasSignatureOriginCaveat ? origin : null;\n\n      this.update((state) => {\n        state.insights[id] ??= {};\n        state.insights[id][snapId] = { snapId, loading: true };\n      });\n\n      this.#handleSnapRequest({\n        snapId,\n        handler: HandlerType.OnSignature,\n        params: { signature: payload, signatureOrigin },\n      })\n        .then((response) =>\n          this.#handleSnapResponse({\n            id,\n            snapId,\n            response: response as Record<string, Json>,\n          }),\n        )\n        .catch((error) => this.#handleSnapResponse({ id, snapId, error }));\n    });\n  }\n\n  /**\n   * Handle the transactionStatusUpdated event emitted by the TransactionController.\n   * This function will remove insights for the transaction in question\n   * once the transaction status has changed from unapproved.\n   *\n   * @param args - An options bag.\n   * @param args.transactionMeta - The transaction.\n   */\n  #handleTransactionStatusUpdate({\n    transactionMeta,\n  }: {\n    transactionMeta: TransactionMeta;\n  }) {\n    if (transactionMeta.status !== 'unapproved') {\n      this.#handleInsightCleanup(transactionMeta.id);\n    }\n  }\n\n  #handleInsightCleanup(id: string) {\n    if (!this.#hasInsight(id)) {\n      return;\n    }\n\n    // Delete interfaces from interface controller.\n    Object.values(this.state.insights[id])\n      .filter((insight) => insight.interfaceId)\n      .forEach((insight) => {\n        this.messenger.call(\n          'SnapInterfaceController:deleteInterface',\n          insight.interfaceId as string,\n        );\n      });\n\n    this.update((state) => {\n      delete state.insights[id];\n    });\n  }\n\n  /**\n   * Handle sending a request to a given Snap with a given payload.\n   *\n   * @param args - An options bag.\n   * @param args.snapId - The Snap ID.\n   * @param args.handler - The handler to invoke.\n   * @param args.params - The JSON-RPC params to send.\n   * @returns The response from the Snap.\n   */\n  async #handleSnapRequest({\n    snapId,\n    handler,\n    params,\n  }: {\n    snapId: SnapId;\n    handler: HandlerType.OnTransaction | HandlerType.OnSignature;\n    params: Record<string, Json>;\n  }) {\n    return this.messenger.call('SnapController:handleRequest', {\n      snapId,\n      origin: 'metamask',\n      handler,\n      request: {\n        method: '',\n        params,\n      },\n    });\n  }\n\n  /**\n   * Handle response from a given Snap by persisting the response or error in state.\n   *\n   * @param args - An options bag.\n   * @param args.id - The transaction or signature ID.\n   * @param args.snapId - The Snap ID.\n   * @param args.response - An optional response object returned by the Snap.\n   * @param args.error - An optional error returned by the Snap.\n   */\n  #handleSnapResponse({\n    id,\n    snapId,\n    response,\n    error,\n  }: {\n    id: string;\n    snapId: SnapId;\n    response?: Record<string, Json>;\n    error?: Error;\n  }) {\n    // If the insight has been cleaned up already, we can skip setting the state.\n    // This may happen if a user accepts/rejects a transaction/signature faster than the Snap responds.\n    if (!this.#hasInsight(id)) {\n      return;\n    }\n\n    this.update((state) => {\n      state.insights[id][snapId].loading = false;\n      state.insights[id][snapId].interfaceId = response?.id as string;\n      state.insights[id][snapId].severity = response?.severity as string;\n      state.insights[id][snapId].error = error?.message;\n    });\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/insights/SnapInsightsController.d.cts b/dist/insights/SnapInsightsController.d.cts
index bafe35e169c5e8dbb5da730e379bb84be8dbce2a..5e5f57c4294ce4fefaf294318958838be5acced9 100644
--- a/dist/insights/SnapInsightsController.d.cts
+++ b/dist/insights/SnapInsightsController.d.cts
@@ -1,5 +1,6 @@
-import type { RestrictedMessenger, ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
-import { BaseController } from "@metamask/base-controller";
+import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller/next";
+import { BaseController } from "@metamask/base-controller/next";
+import type { Messenger } from "@metamask/messenger";
 import type { GetPermissions } from "@metamask/permission-controller";
 import type { SnapId } from "@metamask/snaps-sdk";
 import type { DeleteInterface } from "../interface/index.cjs";
@@ -12,7 +13,7 @@ export type SnapInsightsControllerActions = SnapInsightsControllerGetStateAction
 export type SnapInsightControllerStateChangeEvent = ControllerStateChangeEvent<typeof controllerName, SnapInsightsControllerState>;
 export type SnapInsightControllerEvents = SnapInsightControllerStateChangeEvent;
 export type SnapInsightsControllerAllowedEvents = TransactionControllerUnapprovedTransactionAddedEvent | TransactionControllerTransactionStatusUpdatedEvent | SignatureStateChange;
-export type SnapInsightsControllerMessenger = RestrictedMessenger<typeof controllerName, SnapInsightsControllerActions | SnapInsightsControllerAllowedActions, SnapInsightControllerEvents | SnapInsightsControllerAllowedEvents, SnapInsightsControllerAllowedActions['type'], SnapInsightsControllerAllowedEvents['type']>;
+export type SnapInsightsControllerMessenger = Messenger<typeof controllerName, SnapInsightsControllerActions | SnapInsightsControllerAllowedActions, SnapInsightControllerEvents | SnapInsightsControllerAllowedEvents>;
 export type SnapInsight = {
     snapId: SnapId;
     interfaceId?: string | null;
diff --git a/dist/insights/SnapInsightsController.d.cts.map b/dist/insights/SnapInsightsController.d.cts.map
index b11077e678fdcd75f285438b7e01e0d605c56c21..0e97efdb22d867b2a8477563d0fe28332d1b30ae 100644
--- a/dist/insights/SnapInsightsController.d.cts.map
+++ b/dist/insights/SnapInsightsController.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"SnapInsightsController.d.cts","sourceRoot":"","sources":["../../src/insights/SnapInsightsController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,mBAAmB,EACnB,wBAAwB,EACxB,0BAA0B,EAC3B,kCAAkC;AACnC,OAAO,EAAE,cAAc,EAAE,kCAAkC;AAC3D,OAAO,KAAK,EAEV,cAAc,EAEf,wCAAwC;AAMzC,OAAO,KAAK,EAAQ,MAAM,EAAE,4BAA4B;AAIxD,OAAO,KAAK,EAAE,eAAe,EAAE,+BAAqB;AACpD,OAAO,KAAK,EAAE,WAAW,EAAE,iBAAiB,EAAE,2BAAiB;AAE/D,OAAO,KAAK,EACV,oDAAoD,EAEpD,oBAAoB,EAGpB,kDAAkD,EACnD,2BAAiB;AAElB,QAAA,MAAM,cAAc,2BAA2B,CAAC;AAEhD,MAAM,MAAM,oCAAoC,GAC5C,iBAAiB,GACjB,WAAW,GACX,cAAc,GACd,eAAe,CAAC;AAEpB,MAAM,MAAM,oCAAoC,GAAG,wBAAwB,CACzE,OAAO,cAAc,EACrB,2BAA2B,CAC5B,CAAC;AAEF,MAAM,MAAM,6BAA6B,GACvC,oCAAoC,CAAC;AAEvC,MAAM,MAAM,qCAAqC,GAAG,0BAA0B,CAC5E,OAAO,cAAc,EACrB,2BAA2B,CAC5B,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG,qCAAqC,CAAC;AAEhF,MAAM,MAAM,mCAAmC,GAC3C,oDAAoD,GACpD,kDAAkD,GAClD,oBAAoB,CAAC;AAEzB,MAAM,MAAM,+BAA+B,GAAG,mBAAmB,CAC/D,OAAO,cAAc,EACrB,6BAA6B,GAAG,oCAAoC,EACpE,2BAA2B,GAAG,mCAAmC,EACjE,oCAAoC,CAAC,MAAM,CAAC,EAC5C,mCAAmC,CAAC,MAAM,CAAC,CAC5C,CAAC;AAEF,MAAM,MAAM,WAAW,GAAG;IACxB,MAAM,EAAE,MAAM,CAAC;IACf,WAAW,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IAC5B,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,OAAO,EAAE,OAAO,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG;IACxC,QAAQ,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC,CAAC;CACvD,CAAC;AAEF,MAAM,MAAM,0BAA0B,GAAG;IACvC,SAAS,EAAE,+BAA+B,CAAC;IAC3C,KAAK,CAAC,EAAE,2BAA2B,CAAC;CACrC,CAAC;AAOF;;GAEG;AACH,qBAAa,sBAAuB,SAAQ,cAAc,CACxD,OAAO,cAAc,EACrB,2BAA2B,EAC3B,+BAA+B,CAChC;;gBACa,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,0BAA0B;CAwT7D"}
\ No newline at end of file
+{"version":3,"file":"SnapInsightsController.d.cts","sourceRoot":"","sources":["../../src/insights/SnapInsightsController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAC3B,uCAAuC;AACxC,OAAO,EAAE,cAAc,EAAE,uCAAuC;AAChE,OAAO,KAAK,EAAE,SAAS,EAAE,4BAA4B;AACrD,OAAO,KAAK,EAEV,cAAc,EAEf,wCAAwC;AAMzC,OAAO,KAAK,EAAQ,MAAM,EAAE,4BAA4B;AAIxD,OAAO,KAAK,EAAE,eAAe,EAAE,+BAAqB;AACpD,OAAO,KAAK,EAAE,WAAW,EAAE,iBAAiB,EAAE,2BAAiB;AAE/D,OAAO,KAAK,EACV,oDAAoD,EAEpD,oBAAoB,EAGpB,kDAAkD,EACnD,2BAAiB;AAElB,QAAA,MAAM,cAAc,2BAA2B,CAAC;AAEhD,MAAM,MAAM,oCAAoC,GAC5C,iBAAiB,GACjB,WAAW,GACX,cAAc,GACd,eAAe,CAAC;AAEpB,MAAM,MAAM,oCAAoC,GAAG,wBAAwB,CACzE,OAAO,cAAc,EACrB,2BAA2B,CAC5B,CAAC;AAEF,MAAM,MAAM,6BAA6B,GACvC,oCAAoC,CAAC;AAEvC,MAAM,MAAM,qCAAqC,GAAG,0BAA0B,CAC5E,OAAO,cAAc,EACrB,2BAA2B,CAC5B,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG,qCAAqC,CAAC;AAEhF,MAAM,MAAM,mCAAmC,GAC3C,oDAAoD,GACpD,kDAAkD,GAClD,oBAAoB,CAAC;AAEzB,MAAM,MAAM,+BAA+B,GAAG,SAAS,CACrD,OAAO,cAAc,EACrB,6BAA6B,GAAG,oCAAoC,EACpE,2BAA2B,GAAG,mCAAmC,CAClE,CAAC;AAEF,MAAM,MAAM,WAAW,GAAG;IACxB,MAAM,EAAE,MAAM,CAAC;IACf,WAAW,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IAC5B,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,OAAO,EAAE,OAAO,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG;IACxC,QAAQ,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC,CAAC;CACvD,CAAC;AAEF,MAAM,MAAM,0BAA0B,GAAG;IACvC,SAAS,EAAE,+BAA+B,CAAC;IAC3C,KAAK,CAAC,EAAE,2BAA2B,CAAC;CACrC,CAAC;AAOF;;GAEG;AACH,qBAAa,sBAAuB,SAAQ,cAAc,CACxD,OAAO,cAAc,EACrB,2BAA2B,EAC3B,+BAA+B,CAChC;;gBACa,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,0BAA0B;CAwT7D"}
\ No newline at end of file
diff --git a/dist/insights/SnapInsightsController.d.mts b/dist/insights/SnapInsightsController.d.mts
index 9d39488fd1917372bc6e940402d5cf5c11c68126..9102c4859d0960791e60262bbe6ed81a8d0887c0 100644
--- a/dist/insights/SnapInsightsController.d.mts
+++ b/dist/insights/SnapInsightsController.d.mts
@@ -1,5 +1,6 @@
-import type { RestrictedMessenger, ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
-import { BaseController } from "@metamask/base-controller";
+import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller/next";
+import { BaseController } from "@metamask/base-controller/next";
+import type { Messenger } from "@metamask/messenger";
 import type { GetPermissions } from "@metamask/permission-controller";
 import type { SnapId } from "@metamask/snaps-sdk";
 import type { DeleteInterface } from "../interface/index.mjs";
@@ -12,7 +13,7 @@ export type SnapInsightsControllerActions = SnapInsightsControllerGetStateAction
 export type SnapInsightControllerStateChangeEvent = ControllerStateChangeEvent<typeof controllerName, SnapInsightsControllerState>;
 export type SnapInsightControllerEvents = SnapInsightControllerStateChangeEvent;
 export type SnapInsightsControllerAllowedEvents = TransactionControllerUnapprovedTransactionAddedEvent | TransactionControllerTransactionStatusUpdatedEvent | SignatureStateChange;
-export type SnapInsightsControllerMessenger = RestrictedMessenger<typeof controllerName, SnapInsightsControllerActions | SnapInsightsControllerAllowedActions, SnapInsightControllerEvents | SnapInsightsControllerAllowedEvents, SnapInsightsControllerAllowedActions['type'], SnapInsightsControllerAllowedEvents['type']>;
+export type SnapInsightsControllerMessenger = Messenger<typeof controllerName, SnapInsightsControllerActions | SnapInsightsControllerAllowedActions, SnapInsightControllerEvents | SnapInsightsControllerAllowedEvents>;
 export type SnapInsight = {
     snapId: SnapId;
     interfaceId?: string | null;
diff --git a/dist/insights/SnapInsightsController.d.mts.map b/dist/insights/SnapInsightsController.d.mts.map
index 9d535c987ad07eaaa1d7eb4ae7643cb5ad2ccea2..02bdfb3de07643f1891f47a1666eb2cfdcca8969 100644
--- a/dist/insights/SnapInsightsController.d.mts.map
+++ b/dist/insights/SnapInsightsController.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"SnapInsightsController.d.mts","sourceRoot":"","sources":["../../src/insights/SnapInsightsController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,mBAAmB,EACnB,wBAAwB,EACxB,0BAA0B,EAC3B,kCAAkC;AACnC,OAAO,EAAE,cAAc,EAAE,kCAAkC;AAC3D,OAAO,KAAK,EAEV,cAAc,EAEf,wCAAwC;AAMzC,OAAO,KAAK,EAAQ,MAAM,EAAE,4BAA4B;AAIxD,OAAO,KAAK,EAAE,eAAe,EAAE,+BAAqB;AACpD,OAAO,KAAK,EAAE,WAAW,EAAE,iBAAiB,EAAE,2BAAiB;AAE/D,OAAO,KAAK,EACV,oDAAoD,EAEpD,oBAAoB,EAGpB,kDAAkD,EACnD,2BAAiB;AAElB,QAAA,MAAM,cAAc,2BAA2B,CAAC;AAEhD,MAAM,MAAM,oCAAoC,GAC5C,iBAAiB,GACjB,WAAW,GACX,cAAc,GACd,eAAe,CAAC;AAEpB,MAAM,MAAM,oCAAoC,GAAG,wBAAwB,CACzE,OAAO,cAAc,EACrB,2BAA2B,CAC5B,CAAC;AAEF,MAAM,MAAM,6BAA6B,GACvC,oCAAoC,CAAC;AAEvC,MAAM,MAAM,qCAAqC,GAAG,0BAA0B,CAC5E,OAAO,cAAc,EACrB,2BAA2B,CAC5B,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG,qCAAqC,CAAC;AAEhF,MAAM,MAAM,mCAAmC,GAC3C,oDAAoD,GACpD,kDAAkD,GAClD,oBAAoB,CAAC;AAEzB,MAAM,MAAM,+BAA+B,GAAG,mBAAmB,CAC/D,OAAO,cAAc,EACrB,6BAA6B,GAAG,oCAAoC,EACpE,2BAA2B,GAAG,mCAAmC,EACjE,oCAAoC,CAAC,MAAM,CAAC,EAC5C,mCAAmC,CAAC,MAAM,CAAC,CAC5C,CAAC;AAEF,MAAM,MAAM,WAAW,GAAG;IACxB,MAAM,EAAE,MAAM,CAAC;IACf,WAAW,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IAC5B,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,OAAO,EAAE,OAAO,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG;IACxC,QAAQ,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC,CAAC;CACvD,CAAC;AAEF,MAAM,MAAM,0BAA0B,GAAG;IACvC,SAAS,EAAE,+BAA+B,CAAC;IAC3C,KAAK,CAAC,EAAE,2BAA2B,CAAC;CACrC,CAAC;AAOF;;GAEG;AACH,qBAAa,sBAAuB,SAAQ,cAAc,CACxD,OAAO,cAAc,EACrB,2BAA2B,EAC3B,+BAA+B,CAChC;;gBACa,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,0BAA0B;CAwT7D"}
\ No newline at end of file
+{"version":3,"file":"SnapInsightsController.d.mts","sourceRoot":"","sources":["../../src/insights/SnapInsightsController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAC3B,uCAAuC;AACxC,OAAO,EAAE,cAAc,EAAE,uCAAuC;AAChE,OAAO,KAAK,EAAE,SAAS,EAAE,4BAA4B;AACrD,OAAO,KAAK,EAEV,cAAc,EAEf,wCAAwC;AAMzC,OAAO,KAAK,EAAQ,MAAM,EAAE,4BAA4B;AAIxD,OAAO,KAAK,EAAE,eAAe,EAAE,+BAAqB;AACpD,OAAO,KAAK,EAAE,WAAW,EAAE,iBAAiB,EAAE,2BAAiB;AAE/D,OAAO,KAAK,EACV,oDAAoD,EAEpD,oBAAoB,EAGpB,kDAAkD,EACnD,2BAAiB;AAElB,QAAA,MAAM,cAAc,2BAA2B,CAAC;AAEhD,MAAM,MAAM,oCAAoC,GAC5C,iBAAiB,GACjB,WAAW,GACX,cAAc,GACd,eAAe,CAAC;AAEpB,MAAM,MAAM,oCAAoC,GAAG,wBAAwB,CACzE,OAAO,cAAc,EACrB,2BAA2B,CAC5B,CAAC;AAEF,MAAM,MAAM,6BAA6B,GACvC,oCAAoC,CAAC;AAEvC,MAAM,MAAM,qCAAqC,GAAG,0BAA0B,CAC5E,OAAO,cAAc,EACrB,2BAA2B,CAC5B,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG,qCAAqC,CAAC;AAEhF,MAAM,MAAM,mCAAmC,GAC3C,oDAAoD,GACpD,kDAAkD,GAClD,oBAAoB,CAAC;AAEzB,MAAM,MAAM,+BAA+B,GAAG,SAAS,CACrD,OAAO,cAAc,EACrB,6BAA6B,GAAG,oCAAoC,EACpE,2BAA2B,GAAG,mCAAmC,CAClE,CAAC;AAEF,MAAM,MAAM,WAAW,GAAG;IACxB,MAAM,EAAE,MAAM,CAAC;IACf,WAAW,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IAC5B,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,OAAO,EAAE,OAAO,CAAC;IACjB,QAAQ,CAAC,EAAE,MAAM,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG;IACxC,QAAQ,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC,CAAC;CACvD,CAAC;AAEF,MAAM,MAAM,0BAA0B,GAAG;IACvC,SAAS,EAAE,+BAA+B,CAAC;IAC3C,KAAK,CAAC,EAAE,2BAA2B,CAAC;CACrC,CAAC;AAOF;;GAEG;AACH,qBAAa,sBAAuB,SAAQ,cAAc,CACxD,OAAO,cAAc,EACrB,2BAA2B,EAC3B,+BAA+B,CAChC;;gBACa,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,0BAA0B;CAwT7D"}
\ No newline at end of file
diff --git a/dist/insights/SnapInsightsController.mjs b/dist/insights/SnapInsightsController.mjs
index dbd531aa550ea9540eabddbc8b97dbdf4667a40e..2c97e8810ca91978c652e6d1fc7b6ea6a9a12466 100644
--- a/dist/insights/SnapInsightsController.mjs
+++ b/dist/insights/SnapInsightsController.mjs
@@ -1,4 +1,4 @@
-import { BaseController } from "@metamask/base-controller";
+import { BaseController } from "@metamask/base-controller/next";
 import { getSignatureOriginCaveat, getTransactionOriginCaveat, SnapEndowments } from "@metamask/snaps-rpc-methods";
 import { HandlerType } from "@metamask/snaps-utils";
 import { hasProperty, hexToBigInt } from "@metamask/utils";
@@ -15,16 +15,16 @@ export class SnapInsightsController extends BaseController {
                 insights: {
                     includeInStateLogs: true,
                     persist: false,
-                    anonymous: false,
+                    includeInDebugSnapshot: false,
                     usedInUi: true,
                 },
             },
             name: controllerName,
             state: { insights: {}, ...state },
         });
-        this.messagingSystem.subscribe('TransactionController:unapprovedTransactionAdded', this.#handleTransaction.bind(this));
-        this.messagingSystem.subscribe('TransactionController:transactionStatusUpdated', this.#handleTransactionStatusUpdate.bind(this));
-        this.messagingSystem.subscribe('SignatureController:stateChange', this.#handleSignatureStateChange.bind(this));
+        this.messenger.subscribe('TransactionController:unapprovedTransactionAdded', this.#handleTransaction.bind(this));
+        this.messenger.subscribe('TransactionController:transactionStatusUpdated', this.#handleTransactionStatusUpdate.bind(this));
+        this.messenger.subscribe('SignatureController:stateChange', this.#handleSignatureStateChange.bind(this));
     }
     /**
      * Check if an insight already exists for a given ID.
@@ -43,10 +43,10 @@ export class SnapInsightsController extends BaseController {
      * @returns A list of objects containing Snap IDs and the permission object.
      */
     #getSnapsWithPermission(permissionName) {
-        const allSnaps = this.messagingSystem.call('SnapController:getAll');
+        const allSnaps = this.messenger.call('SnapController:getAll');
         const filteredSnaps = getRunnableSnaps(allSnaps);
         return filteredSnaps.reduce((accumulator, snap) => {
-            const permissions = this.messagingSystem.call('PermissionController:getPermissions', snap.id);
+            const permissions = this.messenger.call('PermissionController:getPermissions', snap.id);
             if (permissions && hasProperty(permissions, permissionName)) {
                 accumulator.push({
                     snapId: snap.id,
@@ -186,7 +186,7 @@ export class SnapInsightsController extends BaseController {
         Object.values(this.state.insights[id])
             .filter((insight) => insight.interfaceId)
             .forEach((insight) => {
-            this.messagingSystem.call('SnapInterfaceController:deleteInterface', insight.interfaceId);
+            this.messenger.call('SnapInterfaceController:deleteInterface', insight.interfaceId);
         });
         this.update((state) => {
             delete state.insights[id];
@@ -202,7 +202,7 @@ export class SnapInsightsController extends BaseController {
      * @returns The response from the Snap.
      */
     async #handleSnapRequest({ snapId, handler, params, }) {
-        return this.messagingSystem.call('SnapController:handleRequest', {
+        return this.messenger.call('SnapController:handleRequest', {
             snapId,
             origin: 'metamask',
             handler,
diff --git a/dist/insights/SnapInsightsController.mjs.map b/dist/insights/SnapInsightsController.mjs.map
index 34391c918f5126191cf3e15dbe3a856ba2ea660a..15aa479b441fe917f396daac735da8a038e16f6a 100644
--- a/dist/insights/SnapInsightsController.mjs.map
+++ b/dist/insights/SnapInsightsController.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"SnapInsightsController.mjs","sourceRoot":"","sources":["../../src/insights/SnapInsightsController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  RestrictedMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type {\n  Caveat,\n  GetPermissions,\n  ValidPermission,\n} from '@metamask/permission-controller';\nimport {\n  getSignatureOriginCaveat,\n  getTransactionOriginCaveat,\n  SnapEndowments,\n} from '@metamask/snaps-rpc-methods';\nimport type { Json, SnapId } from '@metamask/snaps-sdk';\nimport { HandlerType } from '@metamask/snaps-utils';\nimport { hasProperty, hexToBigInt } from '@metamask/utils';\n\nimport type { DeleteInterface } from '../interface';\nimport type { GetAllSnaps, HandleSnapRequest } from '../snaps';\nimport { getRunnableSnaps } from '../snaps';\nimport type {\n  TransactionControllerUnapprovedTransactionAddedEvent,\n  TransactionMeta,\n  SignatureStateChange,\n  SignatureControllerState,\n  StateSignature,\n  TransactionControllerTransactionStatusUpdatedEvent,\n} from '../types';\n\nconst controllerName = 'SnapInsightsController';\n\nexport type SnapInsightsControllerAllowedActions =\n  | HandleSnapRequest\n  | GetAllSnaps\n  | GetPermissions\n  | DeleteInterface;\n\nexport type SnapInsightsControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapInsightsControllerState\n>;\n\nexport type SnapInsightsControllerActions =\n  SnapInsightsControllerGetStateAction;\n\nexport type SnapInsightControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  SnapInsightsControllerState\n>;\n\nexport type SnapInsightControllerEvents = SnapInsightControllerStateChangeEvent;\n\nexport type SnapInsightsControllerAllowedEvents =\n  | TransactionControllerUnapprovedTransactionAddedEvent\n  | TransactionControllerTransactionStatusUpdatedEvent\n  | SignatureStateChange;\n\nexport type SnapInsightsControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  SnapInsightsControllerActions | SnapInsightsControllerAllowedActions,\n  SnapInsightControllerEvents | SnapInsightsControllerAllowedEvents,\n  SnapInsightsControllerAllowedActions['type'],\n  SnapInsightsControllerAllowedEvents['type']\n>;\n\nexport type SnapInsight = {\n  snapId: SnapId;\n  interfaceId?: string | null;\n  error?: string;\n  loading: boolean;\n  severity?: string;\n};\n\nexport type SnapInsightsControllerState = {\n  insights: Record<string, Record<SnapId, SnapInsight>>;\n};\n\nexport type SnapInsightsControllerArgs = {\n  messenger: SnapInsightsControllerMessenger;\n  state?: SnapInsightsControllerState;\n};\n\ntype SnapWithPermission = {\n  snapId: SnapId;\n  permission: ValidPermission<string, Caveat<string, Json>>;\n};\n\n/**\n * Controller for monitoring for new transactions and signatures to provide insight for.\n */\nexport class SnapInsightsController extends BaseController<\n  typeof controllerName,\n  SnapInsightsControllerState,\n  SnapInsightsControllerMessenger\n> {\n  constructor({ messenger, state }: SnapInsightsControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        insights: {\n          includeInStateLogs: true,\n          persist: false,\n          anonymous: false,\n          usedInUi: true,\n        },\n      },\n      name: controllerName,\n      state: { insights: {}, ...state },\n    });\n\n    this.messagingSystem.subscribe(\n      'TransactionController:unapprovedTransactionAdded',\n      this.#handleTransaction.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'TransactionController:transactionStatusUpdated',\n      this.#handleTransactionStatusUpdate.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'SignatureController:stateChange',\n      this.#handleSignatureStateChange.bind(this),\n    );\n  }\n\n  /**\n   * Check if an insight already exists for a given ID.\n   *\n   * @param id - The ID.\n   * @returns True if the insight already exists, otherwise false.\n   */\n  #hasInsight(id: string) {\n    return hasProperty(this.state.insights, id);\n  }\n\n  /**\n   * Get a list of runnable Snaps that have a given permission.\n   * Also includes the permission object itself.\n   *\n   * @param permissionName - The permission name.\n   * @returns A list of objects containing Snap IDs and the permission object.\n   */\n  #getSnapsWithPermission(permissionName: string) {\n    const allSnaps = this.messagingSystem.call('SnapController:getAll');\n    const filteredSnaps = getRunnableSnaps(allSnaps);\n\n    return filteredSnaps.reduce<SnapWithPermission[]>((accumulator, snap) => {\n      const permissions = this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        snap.id,\n      );\n      if (permissions && hasProperty(permissions, permissionName)) {\n        accumulator.push({\n          snapId: snap.id,\n          permission: permissions[permissionName],\n        });\n      }\n\n      return accumulator;\n    }, []);\n  }\n\n  /**\n   * Handle a newly added unapproved transaction.\n   * This function fetches insights from all available Snaps\n   * and populates the insights state blob with the responses.\n   *\n   * @param transaction - The transaction object.\n   */\n  #handleTransaction(transaction: TransactionMeta) {\n    const { id, txParams, chainId, origin } = transaction;\n\n    // This assumes that the transactions are EVM-compatible for now.\n    const caipChainId = `eip155:${hexToBigInt(chainId).toString(10)}`;\n\n    const snaps = this.#getSnapsWithPermission(\n      SnapEndowments.TransactionInsight,\n    );\n\n    snaps.forEach(({ snapId, permission }) => {\n      const hasTransactionOriginCaveat = getTransactionOriginCaveat(permission);\n      const transactionOrigin =\n        hasTransactionOriginCaveat && origin ? origin : null;\n\n      this.update((state) => {\n        state.insights[id] ??= {};\n        state.insights[id][snapId] = { snapId, loading: true };\n      });\n\n      this.#handleSnapRequest({\n        snapId,\n        handler: HandlerType.OnTransaction,\n        params: {\n          transaction: txParams,\n          chainId: caipChainId,\n          transactionOrigin,\n        },\n      })\n        .then((response) =>\n          this.#handleSnapResponse({\n            id,\n            snapId,\n            response: response as Record<string, Json>,\n          }),\n        )\n        .catch((error) => this.#handleSnapResponse({ id, snapId, error }));\n    });\n  }\n\n  /**\n   * Handle the stateChange event emitted by the SignatureController.\n   * This function will remove existing insights from the state when applicable, as well as\n   * trigger insight fetching for newly added signatures.\n   *\n   * @param state - The SignatureController state blob.\n   */\n  #handleSignatureStateChange(state: SignatureControllerState) {\n    // If any IDs have disappeared since the last state update, the insight may be cleaned up.\n    for (const id of Object.keys(this.state.insights)) {\n      if (\n        !hasProperty(state.unapprovedTypedMessages, id) &&\n        !hasProperty(state.unapprovedPersonalMsgs, id)\n      ) {\n        this.#handleInsightCleanup(id);\n      }\n    }\n\n    if (\n      state.unapprovedPersonalMsgCount > 0 ||\n      state.unapprovedTypedMessagesCount > 0\n    ) {\n      const snaps = this.#getSnapsWithPermission(\n        SnapEndowments.SignatureInsight,\n      );\n\n      // This isn't very efficient, but SignatureController doesn't expose a better event for us to use yet.\n      for (const personalSignature of Object.values(\n        state.unapprovedPersonalMsgs,\n      )) {\n        this.#handleSignature(snaps, personalSignature);\n      }\n\n      for (const typedMessage of Object.values(state.unapprovedTypedMessages)) {\n        this.#handleSignature(snaps, typedMessage);\n      }\n    }\n  }\n\n  /**\n   * Handle a newly added unapproved signature.\n   * This function fetches insights from all available Snaps\n   * and populates the insights state blob with the responses.\n   *\n   * @param snaps - A list of Snaps to invoke.\n   * @param signature - The signature object.\n   */\n  #handleSignature(snaps: SnapWithPermission[], signature: StateSignature) {\n    const { id, msgParams } = signature;\n\n    if (this.#hasInsight(id)) {\n      return;\n    }\n\n    const { from, data, signatureMethod, origin } = msgParams;\n\n    /**\n     * Both eth_signTypedData_v3 and eth_signTypedData_v4 methods\n     * need to be parsed because their data is stringified. All other\n     * signature methods do not, so they are ignored.\n     */\n    const shouldParse =\n      signatureMethod === 'eth_signTypedData_v3' ||\n      signatureMethod === 'eth_signTypedData_v4';\n\n    const payload = {\n      from,\n      data: shouldParse ? JSON.parse(data as string) : data,\n      signatureMethod,\n    };\n\n    snaps.forEach(({ snapId, permission }) => {\n      const hasSignatureOriginCaveat = getSignatureOriginCaveat(permission);\n      const signatureOrigin =\n        origin && hasSignatureOriginCaveat ? origin : null;\n\n      this.update((state) => {\n        state.insights[id] ??= {};\n        state.insights[id][snapId] = { snapId, loading: true };\n      });\n\n      this.#handleSnapRequest({\n        snapId,\n        handler: HandlerType.OnSignature,\n        params: { signature: payload, signatureOrigin },\n      })\n        .then((response) =>\n          this.#handleSnapResponse({\n            id,\n            snapId,\n            response: response as Record<string, Json>,\n          }),\n        )\n        .catch((error) => this.#handleSnapResponse({ id, snapId, error }));\n    });\n  }\n\n  /**\n   * Handle the transactionStatusUpdated event emitted by the TransactionController.\n   * This function will remove insights for the transaction in question\n   * once the transaction status has changed from unapproved.\n   *\n   * @param args - An options bag.\n   * @param args.transactionMeta - The transaction.\n   */\n  #handleTransactionStatusUpdate({\n    transactionMeta,\n  }: {\n    transactionMeta: TransactionMeta;\n  }) {\n    if (transactionMeta.status !== 'unapproved') {\n      this.#handleInsightCleanup(transactionMeta.id);\n    }\n  }\n\n  #handleInsightCleanup(id: string) {\n    if (!this.#hasInsight(id)) {\n      return;\n    }\n\n    // Delete interfaces from interface controller.\n    Object.values(this.state.insights[id])\n      .filter((insight) => insight.interfaceId)\n      .forEach((insight) => {\n        this.messagingSystem.call(\n          'SnapInterfaceController:deleteInterface',\n          insight.interfaceId as string,\n        );\n      });\n\n    this.update((state) => {\n      delete state.insights[id];\n    });\n  }\n\n  /**\n   * Handle sending a request to a given Snap with a given payload.\n   *\n   * @param args - An options bag.\n   * @param args.snapId - The Snap ID.\n   * @param args.handler - The handler to invoke.\n   * @param args.params - The JSON-RPC params to send.\n   * @returns The response from the Snap.\n   */\n  async #handleSnapRequest({\n    snapId,\n    handler,\n    params,\n  }: {\n    snapId: SnapId;\n    handler: HandlerType.OnTransaction | HandlerType.OnSignature;\n    params: Record<string, Json>;\n  }) {\n    return this.messagingSystem.call('SnapController:handleRequest', {\n      snapId,\n      origin: 'metamask',\n      handler,\n      request: {\n        method: '',\n        params,\n      },\n    });\n  }\n\n  /**\n   * Handle response from a given Snap by persisting the response or error in state.\n   *\n   * @param args - An options bag.\n   * @param args.id - The transaction or signature ID.\n   * @param args.snapId - The Snap ID.\n   * @param args.response - An optional response object returned by the Snap.\n   * @param args.error - An optional error returned by the Snap.\n   */\n  #handleSnapResponse({\n    id,\n    snapId,\n    response,\n    error,\n  }: {\n    id: string;\n    snapId: SnapId;\n    response?: Record<string, Json>;\n    error?: Error;\n  }) {\n    // If the insight has been cleaned up already, we can skip setting the state.\n    // This may happen if a user accepts/rejects a transaction/signature faster than the Snap responds.\n    if (!this.#hasInsight(id)) {\n      return;\n    }\n\n    this.update((state) => {\n      state.insights[id][snapId].loading = false;\n      state.insights[id][snapId].interfaceId = response?.id as string;\n      state.insights[id][snapId].severity = response?.severity as string;\n      state.insights[id][snapId].error = error?.message;\n    });\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SnapInsightsController.mjs","sourceRoot":"","sources":["../../src/insights/SnapInsightsController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller/next';\nimport { BaseController } from '@metamask/base-controller/next';\nimport type { Messenger } from '@metamask/messenger';\nimport type {\n  Caveat,\n  GetPermissions,\n  ValidPermission,\n} from '@metamask/permission-controller';\nimport {\n  getSignatureOriginCaveat,\n  getTransactionOriginCaveat,\n  SnapEndowments,\n} from '@metamask/snaps-rpc-methods';\nimport type { Json, SnapId } from '@metamask/snaps-sdk';\nimport { HandlerType } from '@metamask/snaps-utils';\nimport { hasProperty, hexToBigInt } from '@metamask/utils';\n\nimport type { DeleteInterface } from '../interface';\nimport type { GetAllSnaps, HandleSnapRequest } from '../snaps';\nimport { getRunnableSnaps } from '../snaps';\nimport type {\n  TransactionControllerUnapprovedTransactionAddedEvent,\n  TransactionMeta,\n  SignatureStateChange,\n  SignatureControllerState,\n  StateSignature,\n  TransactionControllerTransactionStatusUpdatedEvent,\n} from '../types';\n\nconst controllerName = 'SnapInsightsController';\n\nexport type SnapInsightsControllerAllowedActions =\n  | HandleSnapRequest\n  | GetAllSnaps\n  | GetPermissions\n  | DeleteInterface;\n\nexport type SnapInsightsControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapInsightsControllerState\n>;\n\nexport type SnapInsightsControllerActions =\n  SnapInsightsControllerGetStateAction;\n\nexport type SnapInsightControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  SnapInsightsControllerState\n>;\n\nexport type SnapInsightControllerEvents = SnapInsightControllerStateChangeEvent;\n\nexport type SnapInsightsControllerAllowedEvents =\n  | TransactionControllerUnapprovedTransactionAddedEvent\n  | TransactionControllerTransactionStatusUpdatedEvent\n  | SignatureStateChange;\n\nexport type SnapInsightsControllerMessenger = Messenger<\n  typeof controllerName,\n  SnapInsightsControllerActions | SnapInsightsControllerAllowedActions,\n  SnapInsightControllerEvents | SnapInsightsControllerAllowedEvents\n>;\n\nexport type SnapInsight = {\n  snapId: SnapId;\n  interfaceId?: string | null;\n  error?: string;\n  loading: boolean;\n  severity?: string;\n};\n\nexport type SnapInsightsControllerState = {\n  insights: Record<string, Record<SnapId, SnapInsight>>;\n};\n\nexport type SnapInsightsControllerArgs = {\n  messenger: SnapInsightsControllerMessenger;\n  state?: SnapInsightsControllerState;\n};\n\ntype SnapWithPermission = {\n  snapId: SnapId;\n  permission: ValidPermission<string, Caveat<string, Json>>;\n};\n\n/**\n * Controller for monitoring for new transactions and signatures to provide insight for.\n */\nexport class SnapInsightsController extends BaseController<\n  typeof controllerName,\n  SnapInsightsControllerState,\n  SnapInsightsControllerMessenger\n> {\n  constructor({ messenger, state }: SnapInsightsControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        insights: {\n          includeInStateLogs: true,\n          persist: false,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n      },\n      name: controllerName,\n      state: { insights: {}, ...state },\n    });\n\n    this.messenger.subscribe(\n      'TransactionController:unapprovedTransactionAdded',\n      this.#handleTransaction.bind(this),\n    );\n\n    this.messenger.subscribe(\n      'TransactionController:transactionStatusUpdated',\n      this.#handleTransactionStatusUpdate.bind(this),\n    );\n\n    this.messenger.subscribe(\n      'SignatureController:stateChange',\n      this.#handleSignatureStateChange.bind(this),\n    );\n  }\n\n  /**\n   * Check if an insight already exists for a given ID.\n   *\n   * @param id - The ID.\n   * @returns True if the insight already exists, otherwise false.\n   */\n  #hasInsight(id: string) {\n    return hasProperty(this.state.insights, id);\n  }\n\n  /**\n   * Get a list of runnable Snaps that have a given permission.\n   * Also includes the permission object itself.\n   *\n   * @param permissionName - The permission name.\n   * @returns A list of objects containing Snap IDs and the permission object.\n   */\n  #getSnapsWithPermission(permissionName: string) {\n    const allSnaps = this.messenger.call('SnapController:getAll');\n    const filteredSnaps = getRunnableSnaps(allSnaps);\n\n    return filteredSnaps.reduce<SnapWithPermission[]>((accumulator, snap) => {\n      const permissions = this.messenger.call(\n        'PermissionController:getPermissions',\n        snap.id,\n      );\n      if (permissions && hasProperty(permissions, permissionName)) {\n        accumulator.push({\n          snapId: snap.id,\n          permission: permissions[permissionName],\n        });\n      }\n\n      return accumulator;\n    }, []);\n  }\n\n  /**\n   * Handle a newly added unapproved transaction.\n   * This function fetches insights from all available Snaps\n   * and populates the insights state blob with the responses.\n   *\n   * @param transaction - The transaction object.\n   */\n  #handleTransaction(transaction: TransactionMeta) {\n    const { id, txParams, chainId, origin } = transaction;\n\n    // This assumes that the transactions are EVM-compatible for now.\n    const caipChainId = `eip155:${hexToBigInt(chainId).toString(10)}`;\n\n    const snaps = this.#getSnapsWithPermission(\n      SnapEndowments.TransactionInsight,\n    );\n\n    snaps.forEach(({ snapId, permission }) => {\n      const hasTransactionOriginCaveat = getTransactionOriginCaveat(permission);\n      const transactionOrigin =\n        hasTransactionOriginCaveat && origin ? origin : null;\n\n      this.update((state) => {\n        state.insights[id] ??= {};\n        state.insights[id][snapId] = { snapId, loading: true };\n      });\n\n      this.#handleSnapRequest({\n        snapId,\n        handler: HandlerType.OnTransaction,\n        params: {\n          transaction: txParams,\n          chainId: caipChainId,\n          transactionOrigin,\n        },\n      })\n        .then((response) =>\n          this.#handleSnapResponse({\n            id,\n            snapId,\n            response: response as Record<string, Json>,\n          }),\n        )\n        .catch((error) => this.#handleSnapResponse({ id, snapId, error }));\n    });\n  }\n\n  /**\n   * Handle the stateChange event emitted by the SignatureController.\n   * This function will remove existing insights from the state when applicable, as well as\n   * trigger insight fetching for newly added signatures.\n   *\n   * @param state - The SignatureController state blob.\n   */\n  #handleSignatureStateChange(state: SignatureControllerState) {\n    // If any IDs have disappeared since the last state update, the insight may be cleaned up.\n    for (const id of Object.keys(this.state.insights)) {\n      if (\n        !hasProperty(state.unapprovedTypedMessages, id) &&\n        !hasProperty(state.unapprovedPersonalMsgs, id)\n      ) {\n        this.#handleInsightCleanup(id);\n      }\n    }\n\n    if (\n      state.unapprovedPersonalMsgCount > 0 ||\n      state.unapprovedTypedMessagesCount > 0\n    ) {\n      const snaps = this.#getSnapsWithPermission(\n        SnapEndowments.SignatureInsight,\n      );\n\n      // This isn't very efficient, but SignatureController doesn't expose a better event for us to use yet.\n      for (const personalSignature of Object.values(\n        state.unapprovedPersonalMsgs,\n      )) {\n        this.#handleSignature(snaps, personalSignature);\n      }\n\n      for (const typedMessage of Object.values(state.unapprovedTypedMessages)) {\n        this.#handleSignature(snaps, typedMessage);\n      }\n    }\n  }\n\n  /**\n   * Handle a newly added unapproved signature.\n   * This function fetches insights from all available Snaps\n   * and populates the insights state blob with the responses.\n   *\n   * @param snaps - A list of Snaps to invoke.\n   * @param signature - The signature object.\n   */\n  #handleSignature(snaps: SnapWithPermission[], signature: StateSignature) {\n    const { id, msgParams } = signature;\n\n    if (this.#hasInsight(id)) {\n      return;\n    }\n\n    const { from, data, signatureMethod, origin } = msgParams;\n\n    /**\n     * Both eth_signTypedData_v3 and eth_signTypedData_v4 methods\n     * need to be parsed because their data is stringified. All other\n     * signature methods do not, so they are ignored.\n     */\n    const shouldParse =\n      signatureMethod === 'eth_signTypedData_v3' ||\n      signatureMethod === 'eth_signTypedData_v4';\n\n    const payload = {\n      from,\n      data: shouldParse ? JSON.parse(data as string) : data,\n      signatureMethod,\n    };\n\n    snaps.forEach(({ snapId, permission }) => {\n      const hasSignatureOriginCaveat = getSignatureOriginCaveat(permission);\n      const signatureOrigin =\n        origin && hasSignatureOriginCaveat ? origin : null;\n\n      this.update((state) => {\n        state.insights[id] ??= {};\n        state.insights[id][snapId] = { snapId, loading: true };\n      });\n\n      this.#handleSnapRequest({\n        snapId,\n        handler: HandlerType.OnSignature,\n        params: { signature: payload, signatureOrigin },\n      })\n        .then((response) =>\n          this.#handleSnapResponse({\n            id,\n            snapId,\n            response: response as Record<string, Json>,\n          }),\n        )\n        .catch((error) => this.#handleSnapResponse({ id, snapId, error }));\n    });\n  }\n\n  /**\n   * Handle the transactionStatusUpdated event emitted by the TransactionController.\n   * This function will remove insights for the transaction in question\n   * once the transaction status has changed from unapproved.\n   *\n   * @param args - An options bag.\n   * @param args.transactionMeta - The transaction.\n   */\n  #handleTransactionStatusUpdate({\n    transactionMeta,\n  }: {\n    transactionMeta: TransactionMeta;\n  }) {\n    if (transactionMeta.status !== 'unapproved') {\n      this.#handleInsightCleanup(transactionMeta.id);\n    }\n  }\n\n  #handleInsightCleanup(id: string) {\n    if (!this.#hasInsight(id)) {\n      return;\n    }\n\n    // Delete interfaces from interface controller.\n    Object.values(this.state.insights[id])\n      .filter((insight) => insight.interfaceId)\n      .forEach((insight) => {\n        this.messenger.call(\n          'SnapInterfaceController:deleteInterface',\n          insight.interfaceId as string,\n        );\n      });\n\n    this.update((state) => {\n      delete state.insights[id];\n    });\n  }\n\n  /**\n   * Handle sending a request to a given Snap with a given payload.\n   *\n   * @param args - An options bag.\n   * @param args.snapId - The Snap ID.\n   * @param args.handler - The handler to invoke.\n   * @param args.params - The JSON-RPC params to send.\n   * @returns The response from the Snap.\n   */\n  async #handleSnapRequest({\n    snapId,\n    handler,\n    params,\n  }: {\n    snapId: SnapId;\n    handler: HandlerType.OnTransaction | HandlerType.OnSignature;\n    params: Record<string, Json>;\n  }) {\n    return this.messenger.call('SnapController:handleRequest', {\n      snapId,\n      origin: 'metamask',\n      handler,\n      request: {\n        method: '',\n        params,\n      },\n    });\n  }\n\n  /**\n   * Handle response from a given Snap by persisting the response or error in state.\n   *\n   * @param args - An options bag.\n   * @param args.id - The transaction or signature ID.\n   * @param args.snapId - The Snap ID.\n   * @param args.response - An optional response object returned by the Snap.\n   * @param args.error - An optional error returned by the Snap.\n   */\n  #handleSnapResponse({\n    id,\n    snapId,\n    response,\n    error,\n  }: {\n    id: string;\n    snapId: SnapId;\n    response?: Record<string, Json>;\n    error?: Error;\n  }) {\n    // If the insight has been cleaned up already, we can skip setting the state.\n    // This may happen if a user accepts/rejects a transaction/signature faster than the Snap responds.\n    if (!this.#hasInsight(id)) {\n      return;\n    }\n\n    this.update((state) => {\n      state.insights[id][snapId].loading = false;\n      state.insights[id][snapId].interfaceId = response?.id as string;\n      state.insights[id][snapId].severity = response?.severity as string;\n      state.insights[id][snapId].error = error?.message;\n    });\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/interface/SnapInterfaceController.cjs b/dist/interface/SnapInterfaceController.cjs
index 396892eb079f67754c2a34e5e98e8064f70ad065..00d6da36e2f82eb12d1497197533af1355062bca 100644
--- a/dist/interface/SnapInterfaceController.cjs
+++ b/dist/interface/SnapInterfaceController.cjs
@@ -1,7 +1,7 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.SnapInterfaceController = void 0;
-const base_controller_1 = require("@metamask/base-controller");
+const next_1 = require("@metamask/base-controller/next");
 const snaps_sdk_1 = require("@metamask/snaps-sdk");
 const snaps_utils_1 = require("@metamask/snaps-utils");
 const utils_1 = require("@metamask/utils");
@@ -13,7 +13,7 @@ const controllerName = 'SnapInterfaceController';
 /**
  * Use this controller to manage snaps UI interfaces using RPC method hooks.
  */
-class SnapInterfaceController extends base_controller_1.BaseController {
+class SnapInterfaceController extends next_1.BaseController {
     constructor({ messenger, state }) {
         super({
             messenger,
@@ -31,14 +31,14 @@ class SnapInterfaceController extends base_controller_1.BaseController {
                             }
                         }, {});
                     },
-                    anonymous: false,
+                    includeInDebugSnapshot: false,
                     usedInUi: true,
                 },
             },
             name: controllerName,
             state: { interfaces: {}, ...state },
         });
-        this.messagingSystem.subscribe('NotificationServicesController:notificationsListUpdated', this.#onNotificationsListUpdated.bind(this));
+        this.messenger.subscribe('NotificationServicesController:notificationsListUpdated', this.#onNotificationsListUpdated.bind(this));
         this.#registerMessageHandlers();
     }
     /**
@@ -46,12 +46,12 @@ class SnapInterfaceController extends base_controller_1.BaseController {
      * actions.
      */
     #registerMessageHandlers() {
-        this.messagingSystem.registerActionHandler(`${controllerName}:createInterface`, this.createInterface.bind(this));
-        this.messagingSystem.registerActionHandler(`${controllerName}:getInterface`, this.getInterface.bind(this));
-        this.messagingSystem.registerActionHandler(`${controllerName}:updateInterface`, this.updateInterface.bind(this));
-        this.messagingSystem.registerActionHandler(`${controllerName}:deleteInterface`, this.deleteInterface.bind(this));
-        this.messagingSystem.registerActionHandler(`${controllerName}:updateInterfaceState`, this.updateInterfaceState.bind(this));
-        this.messagingSystem.registerActionHandler(`${controllerName}:resolveInterface`, this.resolveInterface.bind(this));
+        this.messenger.registerActionHandler(`${controllerName}:createInterface`, this.createInterface.bind(this));
+        this.messenger.registerActionHandler(`${controllerName}:getInterface`, this.getInterface.bind(this));
+        this.messenger.registerActionHandler(`${controllerName}:updateInterface`, this.updateInterface.bind(this));
+        this.messenger.registerActionHandler(`${controllerName}:deleteInterface`, this.deleteInterface.bind(this));
+        this.messenger.registerActionHandler(`${controllerName}:updateInterfaceState`, this.updateInterfaceState.bind(this));
+        this.messenger.registerActionHandler(`${controllerName}:resolveInterface`, this.resolveInterface.bind(this));
     }
     /**
      * Create an interface in the controller state with the associated data.
@@ -188,8 +188,7 @@ class SnapInterfaceController extends base_controller_1.BaseController {
      * @returns True if the origin is on the phishing list, otherwise false.
      */
     #checkPhishingList(origin) {
-        return this.messagingSystem.call('PhishingController:testOrigin', origin)
-            .result;
+        return this.messenger.call('PhishingController:testOrigin', origin).result;
     }
     /**
      * Check if an approval request exists for a given interface by looking up
@@ -199,7 +198,7 @@ class SnapInterfaceController extends base_controller_1.BaseController {
      * @returns True if an approval request exists, otherwise false.
      */
     #hasApprovalRequest(id) {
-        return this.messagingSystem.call('ApprovalController:hasRequest', {
+        return this.messenger.call('ApprovalController:hasRequest', {
             id,
         });
     }
@@ -210,7 +209,7 @@ class SnapInterfaceController extends base_controller_1.BaseController {
      * @param value - The value to resolve the promise with.
      */
     async #acceptApprovalRequest(id, value) {
-        await this.messagingSystem.call('ApprovalController:acceptRequest', id, value);
+        await this.messenger.call('ApprovalController:acceptRequest', id, value);
     }
     /**
      * Get the selected account in the client.
@@ -218,7 +217,7 @@ class SnapInterfaceController extends base_controller_1.BaseController {
      * @returns The selected account.
      */
     #getSelectedAccount() {
-        return this.messagingSystem.call('AccountsController:getSelectedMultichainAccount');
+        return this.messenger.call('AccountsController:getSelectedMultichainAccount');
     }
     /**
      * Get a list of accounts for the given chain IDs.
@@ -227,7 +226,7 @@ class SnapInterfaceController extends base_controller_1.BaseController {
      * @returns The list of accounts.
      */
     #listAccounts(chainIds) {
-        const accounts = this.messagingSystem.call('AccountsController:listMultichainAccounts');
+        const accounts = this.messenger.call('AccountsController:listMultichainAccounts');
         if (!chainIds || chainIds.length === 0) {
             return accounts;
         }
@@ -241,7 +240,7 @@ class SnapInterfaceController extends base_controller_1.BaseController {
      */
     #getAccountByAddress(address) {
         const { address: parsedAddress } = (0, utils_1.parseCaipAccountId)(address);
-        return this.messagingSystem.call('AccountsController:getAccountByAddress', parsedAddress);
+        return this.messenger.call('AccountsController:getAccountByAddress', parsedAddress);
     }
     /**
      * Get the MultichainAssetsController state.
@@ -249,7 +248,7 @@ class SnapInterfaceController extends base_controller_1.BaseController {
      * @returns The MultichainAssetsController state.
      */
     #getAssetsState() {
-        return this.messagingSystem.call('MultichainAssetsController:getState');
+        return this.messenger.call('MultichainAssetsController:getState');
     }
     /**
      * Get a snap by its id.
@@ -258,7 +257,7 @@ class SnapInterfaceController extends base_controller_1.BaseController {
      * @returns The snap.
      */
     #getSnap(id) {
-        return this.messagingSystem.call('SnapController:get', id);
+        return this.messenger.call('SnapController:get', id);
     }
     /**
      * Utility function to validate the components of an interface.
diff --git a/dist/interface/SnapInterfaceController.cjs.map b/dist/interface/SnapInterfaceController.cjs.map
index 92862fdfc66a26ddca10be229c37a0df6d9c8300..64a2209113773c9c4d9148491d0eb8311f2d1d1c 100644
--- a/dist/interface/SnapInterfaceController.cjs.map
+++ b/dist/interface/SnapInterfaceController.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"SnapInterfaceController.cjs","sourceRoot":"","sources":["../../src/interface/SnapInterfaceController.ts"],"names":[],"mappings":";;;AASA,+DAA2D;AAS3D,mDAAkD;AAGlD,uDAI+B;AAO/B,2CAA0E;AAC1E,iCAAkC;AAClC,mCAAgC;AAEhC,uCAKiB;AAGjB,MAAM,mBAAmB,GAAG,QAAU,CAAC,CAAC,QAAQ;AAEhD,MAAM,cAAc,GAAG,yBAAyB,CAAC;AAiJjD;;GAEG;AACH,MAAa,uBAAwB,SAAQ,gCAI5C;IACC,YAAY,EAAE,SAAS,EAAE,KAAK,EAA+B;QAC3D,KAAK,CAAC;YACJ,SAAS;YACT,QAAQ,EAAE;gBACR,UAAU,EAAE;oBACV,kBAAkB,EAAE,IAAI;oBACxB,OAAO,EAAE,CAAC,UAA2C,EAAE,EAAE;wBACvD,OAAO,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,MAAM,CAEtC,CAAC,mBAAmB,EAAE,CAAC,EAAE,EAAE,aAAa,CAAC,EAAE,EAAE;4BAC7C,QAAQ,aAAa,CAAC,WAAW,EAAE,CAAC;gCAClC,KAAK,uBAAW,CAAC,YAAY;oCAC3B,mBAAmB,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC;oCACxC,OAAO,mBAAmB,CAAC;gCAC7B;oCACE,OAAO,mBAAmB,CAAC;4BAC/B,CAAC;wBACH,CAAC,EAAE,EAAE,CAAC,CAAC;oBACT,CAAC;oBACD,SAAS,EAAE,KAAK;oBAChB,QAAQ,EAAE,IAAI;iBACf;aACF;YACD,IAAI,EAAE,cAAc;YACpB,KAAK,EAAE,EAAE,UAAU,EAAE,EAAE,EAAE,GAAG,KAAK,EAAE;SACpC,CAAC,CAAC;QAEH,IAAI,CAAC,eAAe,CAAC,SAAS,CAC5B,yDAAyD,EACzD,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,IAAI,CAAC,CAC5C,CAAC;QAEF,IAAI,CAAC,wBAAwB,EAAE,CAAC;IAClC,CAAC;IAED;;;OAGG;IACH,wBAAwB;QACtB,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,cAAc,kBAAkB,EACnC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAChC,CAAC;QAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,cAAc,eAAe,EAChC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAC7B,CAAC;QAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,cAAc,kBAAkB,EACnC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAChC,CAAC;QAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,cAAc,kBAAkB,EACnC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAChC,CAAC;QAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,cAAc,uBAAuB,EACxC,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,CACrC,CAAC;QAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,cAAc,mBAAmB,EACpC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CACjC,CAAC;IACJ,CAAC;IAED;;;;;;;;OAQG;IACH,eAAe,CACb,MAAc,EACd,OAA2B,EAC3B,OAA0B,EAC1B,WAAyB;QAEzB,MAAM,OAAO,GAAG,IAAA,uBAAe,EAAC,OAAO,CAAC,CAAC;QACzC,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;QAC/B,IAAA,gCAAwB,EAAC,OAAO,CAAC,CAAC;QAElC,MAAM,EAAE,GAAG,IAAA,eAAM,GAAE,CAAC;QACpB,MAAM,cAAc,GAAG,IAAA,sBAAc,EAAC,EAAE,EAAE,OAAO,EAAE;YACjD,cAAc,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC;YAC/C,mBAAmB,EAAE,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC;YACzD,kBAAkB,EAAE,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC;YACvD,YAAY,EAAE,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC;YAC3C,eAAe,EAAE,CAAC,OAAwB,EAAE,EAAE,CAC5C,IAAA,6BAAe,EAAC,MAAM,EAAE,OAAO,CAAC;SACnC,CAAC,CAAC;QAEH,IAAI,CAAC,MAAM,CAAC,CAAC,UAAU,EAAE,EAAE;YACzB,wEAAwE;YACxE,qBAAqB;YACrB,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC,GAAG;gBAC1B,MAAM;gBACN,OAAO,EAAE,IAAA,iBAAS,EAAC,OAAO,CAAC;gBAC3B,KAAK,EAAE,cAAc;gBACrB,OAAO,EAAE,OAAO,IAAI,IAAI;gBACxB,WAAW,EAAE,WAAW,IAAI,IAAI;aACjC,CAAC;QACJ,CAAC,CAAC,CAAC;QAEH,OAAO,EAAE,CAAC;IACZ,CAAC;IAED;;;;;;OAMG;IACH,YAAY,CAAC,MAAc,EAAE,EAAU;QACrC,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAE/B,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IACnC,CAAC;IAED;;;;;;;OAOG;IACH,eAAe,CACb,MAAc,EACd,EAAU,EACV,OAA2B,EAC3B,OAA0B;QAE1B,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAC/B,MAAM,OAAO,GAAG,IAAA,uBAAe,EAAC,OAAO,CAAC,CAAC;QACzC,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;QAC/B,IAAA,gCAAwB,EAAC,OAAO,CAAC,CAAC;QAElC,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC;QACjD,MAAM,QAAQ,GAAG,IAAA,sBAAc,EAAC,QAAQ,EAAE,OAAO,EAAE;YACjD,cAAc,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC;YAC/C,mBAAmB,EAAE,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC;YACzD,kBAAkB,EAAE,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC;YACvD,YAAY,EAAE,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC;YAC3C,eAAe,EAAE,CAAC,OAAwB,EAAE,EAAE,CAC5C,IAAA,6BAAe,EAAC,MAAM,EAAE,OAAO,CAAC;SACnC,CAAC,CAAC;QAEH,IAAI,CAAC,MAAM,CAAC,CAAC,UAAU,EAAE,EAAE;YACzB,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,QAAQ,CAAC;YAC3C,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,OAAO,GAAG,IAAA,iBAAS,EAAC,OAAO,CAAC,CAAC;YACvD,IAAI,OAAO,EAAE,CAAC;gBACZ,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,OAAO,GAAG,OAAO,CAAC;YAC9C,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;OAIG;IACH,eAAe,CAAC,EAAU;QACxB,IAAI,CAAC,MAAM,CAAC,CAAC,UAAU,EAAE,EAAE;YACzB,OAAO,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;QACnC,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACH,oBAAoB,CAAC,EAAU,EAAE,KAAqB;QACpD,IAAI,CAAC,MAAM,CAAC,CAAC,UAAU,EAAE,EAAE;YACzB,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,KAAK,CAAC;QAC1C,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,gBAAgB,CAAC,MAAc,EAAE,EAAU,EAAE,KAAW;QAC5D,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAC/B,IAAI,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC;QAE3B,MAAM,IAAI,CAAC,sBAAsB,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;QAE7C,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC;IAC3B,CAAC;IAED;;;;;OAKG;IACH,aAAa,CAAC,MAAc,EAAE,EAAU;QACtC,MAAM,iBAAiB,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;QAEpD,IAAA,cAAM,EACJ,iBAAiB,KAAK,SAAS,EAC/B,sBAAsB,EAAE,cAAc,CACvC,CAAC;QACF,IAAA,cAAM,EACJ,iBAAiB,CAAC,MAAM,KAAK,MAAM,EACnC,4BAA4B,MAAM,GAAG,CACtC,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACH,iBAAiB,CAAC,EAAU;QAC1B,IAAA,cAAM,EACJ,IAAI,CAAC,mBAAmB,CAAC,EAAE,CAAC,EAC5B,6BAA6B,EAAE,cAAc,CAC9C,CAAC;IACJ,CAAC;IAED;;;;;OAKG;IACH,kBAAkB,CAAC,MAAc;QAC/B,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,+BAA+B,EAAE,MAAM,CAAC;aACtE,MAAM,CAAC;IACZ,CAAC;IAED;;;;;;OAMG;IACH,mBAAmB,CAAC,EAAU;QAC5B,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,+BAA+B,EAAE;YAChE,EAAE;SACH,CAAC,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,sBAAsB,CAAC,EAAU,EAAE,KAAW;QAClD,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAC7B,kCAAkC,EAClC,EAAE,EACF,KAAK,CACN,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACH,mBAAmB;QACjB,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAC9B,iDAAiD,CAClD,CAAC;IACJ,CAAC;IAED;;;;;OAKG;IACH,aAAa,CAAC,QAAwB;QACpC,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CACxC,2CAA2C,CAC5C,CAAC;QAEF,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACvC,OAAO,QAAQ,CAAC;QAClB,CAAC;QAED,OAAO,QAAQ,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,EAAE,CACjC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,IAAA,yBAAiB,EAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,CACnE,CAAC;IACJ,CAAC;IAED;;;;;OAKG;IACH,oBAAoB,CAAC,OAAsB;QACzC,MAAM,EAAE,OAAO,EAAE,aAAa,EAAE,GAAG,IAAA,0BAAkB,EAAC,OAAO,CAAC,CAAC;QAE/D,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAC9B,wCAAwC,EACxC,aAAa,CACd,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACH,eAAe;QACb,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,qCAAqC,CAAC,CAAC;IAC1E,CAAC;IAED;;;;;OAKG;IACH,QAAQ,CAAC,EAAU;QACjB,OAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,oBAAoB,EAAE,EAAE,CAAC,CAAC;IAC7D,CAAC;IAED;;;;;OAKG;IACH,gBAAgB,CAAC,OAAmB;QAClC,qEAAqE;QACrE,0CAA0C;QAC1C,MAAM,IAAI,GAAG,IAAA,+BAAiB,EAAC,OAAO,CAAC,CAAC;QACxC,IAAA,cAAM,EACJ,IAAI,IAAI,mBAAmB,EAC3B,oCAAoC,mBAAmB,GAAG,OAAO,MAAM,CACxE,CAAC;QAEF,IAAA,iCAAmB,EAAC,OAAO,EAAE;YAC3B,gBAAgB,EAAE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC;YACpD,OAAO,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;YACjC,mBAAmB,EAAE,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC;SAC1D,CAAC,CAAC;IACL,CAAC;IAED,2BAA2B,CAAC,iBAAiC;QAC3D,MAAM,8BAA8B,GAAG,iBAAiB,CAAC,MAAM,CAC7D,CAAC,YAAY,EAAE,EAAE;YACf,OAAO,CACL,YAAY,CAAC,IAAI,KAAK,MAAM;gBAC5B,IAAA,mBAAW,EAAE,YAAiC,CAAC,IAAI,EAAE,cAAc,CAAC,CACrE,CAAC;QACJ,CAAC,CACF,CAAC;QAEF,MAAM,cAAc,GAAG,IAAI,GAAG,CAC5B,8BAA8B,CAAC,GAAG,CAChC,CAAC,YAAY,EAAE,EAAE,CAEZ,YAAiC;aAC/B,IACJ,CAAC,YAAY,CAAC,WAAW,CAC7B,CACF,CAAC;QAEF,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;YACpB,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,aAAa,CAAC,EAAE,EAAE;gBAC/D,IACE,aAAa,CAAC,WAAW,KAAK,uBAAW,CAAC,YAAY;oBACtD,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE,CAAC,EACvB,CAAC;oBACD,OAAO,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;gBAC9B,CAAC;YACH,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AA9YD,0DA8YC","sourcesContent":["import type {\n  AcceptRequest,\n  HasApprovalRequest,\n} from '@metamask/approval-controller';\nimport type {\n  RestrictedMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { TestOrigin } from '@metamask/phishing-controller';\nimport type {\n  InterfaceState,\n  SnapId,\n  ComponentOrElement,\n  InterfaceContext,\n  FungibleAssetMetadata,\n} from '@metamask/snaps-sdk';\nimport { ContentType } from '@metamask/snaps-sdk';\nimport type { JSXElement } from '@metamask/snaps-sdk/jsx';\nimport type { InternalAccount } from '@metamask/snaps-utils';\nimport {\n  getJsonSizeUnsafe,\n  snapOwnsAccount,\n  validateJsxElements,\n} from '@metamask/snaps-utils';\nimport type {\n  CaipAccountId,\n  CaipAssetType,\n  CaipChainId,\n  Json,\n} from '@metamask/utils';\nimport { assert, hasProperty, parseCaipAccountId } from '@metamask/utils';\nimport { castDraft } from 'immer';\nimport { nanoid } from 'nanoid';\n\nimport {\n  constructState,\n  getJsxInterface,\n  isMatchingChainId,\n  validateInterfaceContext,\n} from './utils';\nimport type { GetSnap } from '../snaps';\n\nconst MAX_UI_CONTENT_SIZE = 10_000_000; // 10 mb\n\nconst controllerName = 'SnapInterfaceController';\n\nexport type CreateInterface = {\n  type: `${typeof controllerName}:createInterface`;\n  handler: SnapInterfaceController['createInterface'];\n};\n\nexport type GetInterface = {\n  type: `${typeof controllerName}:getInterface`;\n  handler: SnapInterfaceController['getInterface'];\n};\n\nexport type UpdateInterface = {\n  type: `${typeof controllerName}:updateInterface`;\n  handler: SnapInterfaceController['updateInterface'];\n};\n\nexport type DeleteInterface = {\n  type: `${typeof controllerName}:deleteInterface`;\n  handler: SnapInterfaceController['deleteInterface'];\n};\n\nexport type UpdateInterfaceState = {\n  type: `${typeof controllerName}:updateInterfaceState`;\n  handler: SnapInterfaceController['updateInterfaceState'];\n};\n\nexport type ResolveInterface = {\n  type: `${typeof controllerName}:resolveInterface`;\n  handler: SnapInterfaceController['resolveInterface'];\n};\n\ntype AccountsControllerGetAccountByAddressAction = {\n  type: `AccountsController:getAccountByAddress`;\n  handler: (address: string) => InternalAccount | undefined;\n};\n\ntype AccountsControllerGetSelectedMultichainAccountAction = {\n  type: `AccountsController:getSelectedMultichainAccount`;\n  handler: () => InternalAccount;\n};\n\ntype AccountsControllerListMultichainAccountsAction = {\n  type: `AccountsController:listMultichainAccounts`;\n  handler: (chainId?: CaipChainId) => InternalAccount[];\n};\n\nexport type SnapInterfaceControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapInterfaceControllerState\n>;\n\ntype MultichainAssetsControllerGetStateAction = ControllerGetStateAction<\n  'MultichainAssetsController',\n  {\n    assetsMetadata: {\n      [asset: CaipAssetType]: FungibleAssetMetadata;\n    };\n    accountsAssets: { [account: string]: CaipAssetType[] };\n  }\n>;\n\nexport type SnapInterfaceControllerAllowedActions =\n  | TestOrigin\n  | HasApprovalRequest\n  | AcceptRequest\n  | GetSnap\n  | MultichainAssetsControllerGetStateAction\n  | AccountsControllerGetSelectedMultichainAccountAction\n  | AccountsControllerGetAccountByAddressAction\n  | AccountsControllerListMultichainAccountsAction;\n\nexport type SnapInterfaceControllerActions =\n  | CreateInterface\n  | GetInterface\n  | UpdateInterface\n  | DeleteInterface\n  | UpdateInterfaceState\n  | ResolveInterface\n  | SnapInterfaceControllerGetStateAction;\n\nexport type SnapInterfaceControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    SnapInterfaceControllerState\n  >;\n\ntype OtherNotification = { type: string; [key: string]: unknown };\n\nexport type ExpandedView = {\n  title: string;\n  interfaceId: string;\n  footerLink?: { href: string; text: string };\n};\n\ntype NormalSnapNotificationData = { message: string; origin: string };\n\ntype ExpandedSnapNotificationData = {\n  message: string;\n  origin: string;\n  detailedView: ExpandedView;\n};\n\ntype SnapNotification = {\n  type: 'snap';\n  data: NormalSnapNotificationData | ExpandedSnapNotificationData;\n  readDate: string | null;\n};\n\ntype Notification = OtherNotification | SnapNotification;\n\ntype NotificationListUpdatedEvent = {\n  type: 'NotificationServicesController:notificationsListUpdated';\n  payload: [Notification[]];\n};\n\nexport type SnapInterfaceControllerEvents =\n  | SnapInterfaceControllerStateChangeEvent\n  | NotificationListUpdatedEvent;\n\nexport type SnapInterfaceControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  SnapInterfaceControllerActions | SnapInterfaceControllerAllowedActions,\n  SnapInterfaceControllerEvents,\n  SnapInterfaceControllerAllowedActions['type'],\n  SnapInterfaceControllerEvents['type']\n>;\n\nexport type StoredInterface = {\n  snapId: SnapId;\n  content: JSXElement;\n  state: InterfaceState;\n  context: InterfaceContext | null;\n  contentType: ContentType | null;\n};\n\nexport type SnapInterfaceControllerState = {\n  interfaces: Record<string, StoredInterface>;\n};\n\nexport type SnapInterfaceControllerArgs = {\n  messenger: SnapInterfaceControllerMessenger;\n  state?: SnapInterfaceControllerState;\n};\n\n/**\n * Use this controller to manage snaps UI interfaces using RPC method hooks.\n */\nexport class SnapInterfaceController extends BaseController<\n  typeof controllerName,\n  SnapInterfaceControllerState,\n  SnapInterfaceControllerMessenger\n> {\n  constructor({ messenger, state }: SnapInterfaceControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        interfaces: {\n          includeInStateLogs: true,\n          persist: (interfaces: Record<string, StoredInterface>) => {\n            return Object.entries(interfaces).reduce<\n              Record<string, StoredInterface>\n            >((persistedInterfaces, [id, snapInterface]) => {\n              switch (snapInterface.contentType) {\n                case ContentType.Notification:\n                  persistedInterfaces[id] = snapInterface;\n                  return persistedInterfaces;\n                default:\n                  return persistedInterfaces;\n              }\n            }, {});\n          },\n          anonymous: false,\n          usedInUi: true,\n        },\n      },\n      name: controllerName,\n      state: { interfaces: {}, ...state },\n    });\n\n    this.messagingSystem.subscribe(\n      'NotificationServicesController:notificationsListUpdated',\n      this.#onNotificationsListUpdated.bind(this),\n    );\n\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers() {\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:createInterface`,\n      this.createInterface.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getInterface`,\n      this.getInterface.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateInterface`,\n      this.updateInterface.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:deleteInterface`,\n      this.deleteInterface.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateInterfaceState`,\n      this.updateInterfaceState.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:resolveInterface`,\n      this.resolveInterface.bind(this),\n    );\n  }\n\n  /**\n   * Create an interface in the controller state with the associated data.\n   *\n   * @param snapId - The snap id that created the interface.\n   * @param content - The interface content.\n   * @param context - An optional interface context object.\n   * @param contentType - The type of content.\n   * @returns The newly interface id.\n   */\n  createInterface(\n    snapId: SnapId,\n    content: ComponentOrElement,\n    context?: InterfaceContext,\n    contentType?: ContentType,\n  ) {\n    const element = getJsxInterface(content);\n    this.#validateContent(element);\n    validateInterfaceContext(context);\n\n    const id = nanoid();\n    const componentState = constructState({}, element, {\n      getAssetsState: this.#getAssetsState.bind(this),\n      getAccountByAddress: this.#getAccountByAddress.bind(this),\n      getSelectedAccount: this.#getSelectedAccount.bind(this),\n      listAccounts: this.#listAccounts.bind(this),\n      snapOwnsAccount: (account: InternalAccount) =>\n        snapOwnsAccount(snapId, account),\n    });\n\n    this.update((draftState) => {\n      // @ts-expect-error - TS2589: Type instantiation is excessively deep and\n      // possibly infinite.\n      draftState.interfaces[id] = {\n        snapId,\n        content: castDraft(element),\n        state: componentState,\n        context: context ?? null,\n        contentType: contentType ?? null,\n      };\n    });\n\n    return id;\n  }\n\n  /**\n   * Get the data of a given interface id.\n   *\n   * @param snapId - The snap id requesting the interface data.\n   * @param id - The interface id.\n   * @returns The interface state.\n   */\n  getInterface(snapId: SnapId, id: string) {\n    this.#validateArgs(snapId, id);\n\n    return this.state.interfaces[id];\n  }\n\n  /**\n   * Update the interface with the given content.\n   *\n   * @param snapId - The snap id requesting the update.\n   * @param id - The interface id.\n   * @param content - The new content.\n   * @param context - An optional interface context object.\n   */\n  updateInterface(\n    snapId: SnapId,\n    id: string,\n    content: ComponentOrElement,\n    context?: InterfaceContext,\n  ) {\n    this.#validateArgs(snapId, id);\n    const element = getJsxInterface(content);\n    this.#validateContent(element);\n    validateInterfaceContext(context);\n\n    const oldState = this.state.interfaces[id].state;\n    const newState = constructState(oldState, element, {\n      getAssetsState: this.#getAssetsState.bind(this),\n      getAccountByAddress: this.#getAccountByAddress.bind(this),\n      getSelectedAccount: this.#getSelectedAccount.bind(this),\n      listAccounts: this.#listAccounts.bind(this),\n      snapOwnsAccount: (account: InternalAccount) =>\n        snapOwnsAccount(snapId, account),\n    });\n\n    this.update((draftState) => {\n      draftState.interfaces[id].state = newState;\n      draftState.interfaces[id].content = castDraft(element);\n      if (context) {\n        draftState.interfaces[id].context = context;\n      }\n    });\n  }\n\n  /**\n   * Delete an interface from state.\n   *\n   * @param id - The interface id.\n   */\n  deleteInterface(id: string) {\n    this.update((draftState) => {\n      delete draftState.interfaces[id];\n    });\n  }\n\n  /**\n   * Update the interface state.\n   *\n   * @param id - The interface id.\n   * @param state - The new state.\n   */\n  updateInterfaceState(id: string, state: InterfaceState) {\n    this.update((draftState) => {\n      draftState.interfaces[id].state = state;\n    });\n  }\n\n  /**\n   * Resolve the promise of a given interface approval request.\n   * The approval needs to have the same ID as the interface.\n   *\n   * @param snapId - The snap id.\n   * @param id - The interface id.\n   * @param value - The value to resolve the promise with.\n   */\n  async resolveInterface(snapId: SnapId, id: string, value: Json) {\n    this.#validateArgs(snapId, id);\n    this.#validateApproval(id);\n\n    await this.#acceptApprovalRequest(id, value);\n\n    this.deleteInterface(id);\n  }\n\n  /**\n   * Utility function to validate the args passed to the other methods.\n   *\n   * @param snapId - The snap id.\n   * @param id - The interface id.\n   */\n  #validateArgs(snapId: SnapId, id: string) {\n    const existingInterface = this.state.interfaces[id];\n\n    assert(\n      existingInterface !== undefined,\n      `Interface with id '${id}' not found.`,\n    );\n    assert(\n      existingInterface.snapId === snapId,\n      `Interface not created by ${snapId}.`,\n    );\n  }\n\n  /**\n   * Utility function to validate that the approval request exists.\n   *\n   * @param id - The interface id.\n   */\n  #validateApproval(id: string) {\n    assert(\n      this.#hasApprovalRequest(id),\n      `Approval request with id '${id}' not found.`,\n    );\n  }\n\n  /**\n   * Check an origin against the phishing list.\n   *\n   * @param origin - The origin to check.\n   * @returns True if the origin is on the phishing list, otherwise false.\n   */\n  #checkPhishingList(origin: string) {\n    return this.messagingSystem.call('PhishingController:testOrigin', origin)\n      .result;\n  }\n\n  /**\n   * Check if an approval request exists for a given interface by looking up\n   * if the ApprovalController has a request with the given interface ID.\n   *\n   * @param id - The interface id.\n   * @returns True if an approval request exists, otherwise false.\n   */\n  #hasApprovalRequest(id: string) {\n    return this.messagingSystem.call('ApprovalController:hasRequest', {\n      id,\n    });\n  }\n\n  /**\n   * Accept an approval request for a given interface.\n   *\n   * @param id - The interface id.\n   * @param value - The value to resolve the promise with.\n   */\n  async #acceptApprovalRequest(id: string, value: Json) {\n    await this.messagingSystem.call(\n      'ApprovalController:acceptRequest',\n      id,\n      value,\n    );\n  }\n\n  /**\n   * Get the selected account in the client.\n   *\n   * @returns The selected account.\n   */\n  #getSelectedAccount() {\n    return this.messagingSystem.call(\n      'AccountsController:getSelectedMultichainAccount',\n    );\n  }\n\n  /**\n   * Get a list of accounts for the given chain IDs.\n   *\n   * @param chainIds - The chain IDs to get the accounts for.\n   * @returns The list of accounts.\n   */\n  #listAccounts(chainIds?: CaipChainId[]) {\n    const accounts = this.messagingSystem.call(\n      'AccountsController:listMultichainAccounts',\n    );\n\n    if (!chainIds || chainIds.length === 0) {\n      return accounts;\n    }\n\n    return accounts.filter((account) =>\n      account.scopes.some((scope) => isMatchingChainId(scope, chainIds)),\n    );\n  }\n\n  /**\n   * Get an account by its address.\n   *\n   * @param address - The account address.\n   * @returns The account or undefined if not found.\n   */\n  #getAccountByAddress(address: CaipAccountId) {\n    const { address: parsedAddress } = parseCaipAccountId(address);\n\n    return this.messagingSystem.call(\n      'AccountsController:getAccountByAddress',\n      parsedAddress,\n    );\n  }\n\n  /**\n   * Get the MultichainAssetsController state.\n   *\n   * @returns The MultichainAssetsController state.\n   */\n  #getAssetsState() {\n    return this.messagingSystem.call('MultichainAssetsController:getState');\n  }\n\n  /**\n   * Get a snap by its id.\n   *\n   * @param id - The snap id.\n   * @returns The snap.\n   */\n  #getSnap(id: string) {\n    return this.messagingSystem.call('SnapController:get', id);\n  }\n\n  /**\n   * Utility function to validate the components of an interface.\n   * Throws if something is invalid.\n   *\n   * @param element - The JSX element to verify.\n   */\n  #validateContent(element: JSXElement) {\n    // We assume the validity of this JSON to be validated by the caller.\n    // E.g., in the RPC method implementation.\n    const size = getJsonSizeUnsafe(element);\n    assert(\n      size <= MAX_UI_CONTENT_SIZE,\n      `A Snap UI may not be larger than ${MAX_UI_CONTENT_SIZE / 1000000} MB.`,\n    );\n\n    validateJsxElements(element, {\n      isOnPhishingList: this.#checkPhishingList.bind(this),\n      getSnap: this.#getSnap.bind(this),\n      getAccountByAddress: this.#getAccountByAddress.bind(this),\n    });\n  }\n\n  #onNotificationsListUpdated(notificationsList: Notification[]) {\n    const snapNotificationsWithInterface = notificationsList.filter(\n      (notification) => {\n        return (\n          notification.type === 'snap' &&\n          hasProperty((notification as SnapNotification).data, 'detailedView')\n        );\n      },\n    );\n\n    const interfaceIdSet = new Set(\n      snapNotificationsWithInterface.map(\n        (notification) =>\n          (\n            (notification as SnapNotification)\n              .data as ExpandedSnapNotificationData\n          ).detailedView.interfaceId,\n      ),\n    );\n\n    this.update((state) => {\n      Object.entries(state.interfaces).forEach(([id, snapInterface]) => {\n        if (\n          snapInterface.contentType === ContentType.Notification &&\n          !interfaceIdSet.has(id)\n        ) {\n          delete state.interfaces[id];\n        }\n      });\n    });\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SnapInterfaceController.cjs","sourceRoot":"","sources":["../../src/interface/SnapInterfaceController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  AcceptRequest,\n  HasApprovalRequest,\n} from '@metamask/approval-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller/next';\nimport { BaseController } from '@metamask/base-controller/next';\nimport type { Messenger } from '@metamask/messenger';\nimport type { TestOrigin } from '@metamask/phishing-controller';\nimport type {\n  InterfaceState,\n  SnapId,\n  ComponentOrElement,\n  InterfaceContext,\n  FungibleAssetMetadata,\n} from '@metamask/snaps-sdk';\nimport { ContentType } from '@metamask/snaps-sdk';\nimport type { JSXElement } from '@metamask/snaps-sdk/jsx';\nimport type { InternalAccount } from '@metamask/snaps-utils';\nimport {\n  getJsonSizeUnsafe,\n  snapOwnsAccount,\n  validateJsxElements,\n} from '@metamask/snaps-utils';\nimport type {\n  CaipAccountId,\n  CaipAssetType,\n  CaipChainId,\n  Json,\n} from '@metamask/utils';\nimport { assert, hasProperty, parseCaipAccountId } from '@metamask/utils';\nimport { castDraft } from 'immer';\nimport { nanoid } from 'nanoid';\n\nimport {\n  constructState,\n  getJsxInterface,\n  isMatchingChainId,\n  validateInterfaceContext,\n} from './utils';\nimport type { GetSnap } from '../snaps';\n\nconst MAX_UI_CONTENT_SIZE = 10_000_000; // 10 mb\n\nconst controllerName = 'SnapInterfaceController';\n\nexport type CreateInterface = {\n  type: `${typeof controllerName}:createInterface`;\n  handler: SnapInterfaceController['createInterface'];\n};\n\nexport type GetInterface = {\n  type: `${typeof controllerName}:getInterface`;\n  handler: SnapInterfaceController['getInterface'];\n};\n\nexport type UpdateInterface = {\n  type: `${typeof controllerName}:updateInterface`;\n  handler: SnapInterfaceController['updateInterface'];\n};\n\nexport type DeleteInterface = {\n  type: `${typeof controllerName}:deleteInterface`;\n  handler: SnapInterfaceController['deleteInterface'];\n};\n\nexport type UpdateInterfaceState = {\n  type: `${typeof controllerName}:updateInterfaceState`;\n  handler: SnapInterfaceController['updateInterfaceState'];\n};\n\nexport type ResolveInterface = {\n  type: `${typeof controllerName}:resolveInterface`;\n  handler: SnapInterfaceController['resolveInterface'];\n};\n\ntype AccountsControllerGetAccountByAddressAction = {\n  type: `AccountsController:getAccountByAddress`;\n  handler: (address: string) => InternalAccount | undefined;\n};\n\ntype AccountsControllerGetSelectedMultichainAccountAction = {\n  type: `AccountsController:getSelectedMultichainAccount`;\n  handler: () => InternalAccount;\n};\n\ntype AccountsControllerListMultichainAccountsAction = {\n  type: `AccountsController:listMultichainAccounts`;\n  handler: (chainId?: CaipChainId) => InternalAccount[];\n};\n\nexport type SnapInterfaceControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapInterfaceControllerState\n>;\n\ntype MultichainAssetsControllerGetStateAction = ControllerGetStateAction<\n  'MultichainAssetsController',\n  {\n    assetsMetadata: {\n      [asset: CaipAssetType]: FungibleAssetMetadata;\n    };\n    accountsAssets: { [account: string]: CaipAssetType[] };\n  }\n>;\n\nexport type SnapInterfaceControllerAllowedActions =\n  | TestOrigin\n  | HasApprovalRequest\n  | AcceptRequest\n  | GetSnap\n  | MultichainAssetsControllerGetStateAction\n  | AccountsControllerGetSelectedMultichainAccountAction\n  | AccountsControllerGetAccountByAddressAction\n  | AccountsControllerListMultichainAccountsAction;\n\nexport type SnapInterfaceControllerActions =\n  | CreateInterface\n  | GetInterface\n  | UpdateInterface\n  | DeleteInterface\n  | UpdateInterfaceState\n  | ResolveInterface\n  | SnapInterfaceControllerGetStateAction;\n\nexport type SnapInterfaceControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    SnapInterfaceControllerState\n  >;\n\ntype OtherNotification = { type: string; [key: string]: unknown };\n\nexport type ExpandedView = {\n  title: string;\n  interfaceId: string;\n  footerLink?: { href: string; text: string };\n};\n\ntype NormalSnapNotificationData = { message: string; origin: string };\n\ntype ExpandedSnapNotificationData = {\n  message: string;\n  origin: string;\n  detailedView: ExpandedView;\n};\n\ntype SnapNotification = {\n  type: 'snap';\n  data: NormalSnapNotificationData | ExpandedSnapNotificationData;\n  readDate: string | null;\n};\n\ntype Notification = OtherNotification | SnapNotification;\n\ntype NotificationListUpdatedEvent = {\n  type: 'NotificationServicesController:notificationsListUpdated';\n  payload: [Notification[]];\n};\n\nexport type SnapInterfaceControllerEvents =\n  | SnapInterfaceControllerStateChangeEvent\n  | NotificationListUpdatedEvent;\n\nexport type SnapInterfaceControllerMessenger = Messenger<\n  typeof controllerName,\n  SnapInterfaceControllerActions | SnapInterfaceControllerAllowedActions,\n  SnapInterfaceControllerEvents\n>;\n\nexport type StoredInterface = {\n  snapId: SnapId;\n  content: JSXElement;\n  state: InterfaceState;\n  context: InterfaceContext | null;\n  contentType: ContentType | null;\n};\n\nexport type SnapInterfaceControllerState = {\n  interfaces: Record<string, StoredInterface>;\n};\n\nexport type SnapInterfaceControllerArgs = {\n  messenger: SnapInterfaceControllerMessenger;\n  state?: SnapInterfaceControllerState;\n};\n\n/**\n * Use this controller to manage snaps UI interfaces using RPC method hooks.\n */\nexport class SnapInterfaceController extends BaseController<\n  typeof controllerName,\n  SnapInterfaceControllerState,\n  SnapInterfaceControllerMessenger\n> {\n  constructor({ messenger, state }: SnapInterfaceControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        interfaces: {\n          includeInStateLogs: true,\n          persist: (interfaces: Record<string, StoredInterface>) => {\n            return Object.entries(interfaces).reduce<\n              Record<string, StoredInterface>\n            >((persistedInterfaces, [id, snapInterface]) => {\n              switch (snapInterface.contentType) {\n                case ContentType.Notification:\n                  persistedInterfaces[id] = snapInterface;\n                  return persistedInterfaces;\n                default:\n                  return persistedInterfaces;\n              }\n            }, {});\n          },\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n      },\n      name: controllerName,\n      state: { interfaces: {}, ...state },\n    });\n\n    this.messenger.subscribe(\n      'NotificationServicesController:notificationsListUpdated',\n      this.#onNotificationsListUpdated.bind(this),\n    );\n\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers() {\n    this.messenger.registerActionHandler(\n      `${controllerName}:createInterface`,\n      this.createInterface.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:getInterface`,\n      this.getInterface.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:updateInterface`,\n      this.updateInterface.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:deleteInterface`,\n      this.deleteInterface.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:updateInterfaceState`,\n      this.updateInterfaceState.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:resolveInterface`,\n      this.resolveInterface.bind(this),\n    );\n  }\n\n  /**\n   * Create an interface in the controller state with the associated data.\n   *\n   * @param snapId - The snap id that created the interface.\n   * @param content - The interface content.\n   * @param context - An optional interface context object.\n   * @param contentType - The type of content.\n   * @returns The newly interface id.\n   */\n  createInterface(\n    snapId: SnapId,\n    content: ComponentOrElement,\n    context?: InterfaceContext,\n    contentType?: ContentType,\n  ) {\n    const element = getJsxInterface(content);\n    this.#validateContent(element);\n    validateInterfaceContext(context);\n\n    const id = nanoid();\n    const componentState = constructState({}, element, {\n      getAssetsState: this.#getAssetsState.bind(this),\n      getAccountByAddress: this.#getAccountByAddress.bind(this),\n      getSelectedAccount: this.#getSelectedAccount.bind(this),\n      listAccounts: this.#listAccounts.bind(this),\n      snapOwnsAccount: (account: InternalAccount) =>\n        snapOwnsAccount(snapId, account),\n    });\n\n    this.update((draftState) => {\n      // @ts-expect-error - TS2589: Type instantiation is excessively deep and\n      // possibly infinite.\n      draftState.interfaces[id] = {\n        snapId,\n        content: castDraft(element),\n        state: componentState,\n        context: context ?? null,\n        contentType: contentType ?? null,\n      };\n    });\n\n    return id;\n  }\n\n  /**\n   * Get the data of a given interface id.\n   *\n   * @param snapId - The snap id requesting the interface data.\n   * @param id - The interface id.\n   * @returns The interface state.\n   */\n  getInterface(snapId: SnapId, id: string) {\n    this.#validateArgs(snapId, id);\n\n    return this.state.interfaces[id];\n  }\n\n  /**\n   * Update the interface with the given content.\n   *\n   * @param snapId - The snap id requesting the update.\n   * @param id - The interface id.\n   * @param content - The new content.\n   * @param context - An optional interface context object.\n   */\n  updateInterface(\n    snapId: SnapId,\n    id: string,\n    content: ComponentOrElement,\n    context?: InterfaceContext,\n  ) {\n    this.#validateArgs(snapId, id);\n    const element = getJsxInterface(content);\n    this.#validateContent(element);\n    validateInterfaceContext(context);\n\n    const oldState = this.state.interfaces[id].state;\n    const newState = constructState(oldState, element, {\n      getAssetsState: this.#getAssetsState.bind(this),\n      getAccountByAddress: this.#getAccountByAddress.bind(this),\n      getSelectedAccount: this.#getSelectedAccount.bind(this),\n      listAccounts: this.#listAccounts.bind(this),\n      snapOwnsAccount: (account: InternalAccount) =>\n        snapOwnsAccount(snapId, account),\n    });\n\n    this.update((draftState) => {\n      draftState.interfaces[id].state = newState;\n      draftState.interfaces[id].content = castDraft(element);\n      if (context) {\n        draftState.interfaces[id].context = context;\n      }\n    });\n  }\n\n  /**\n   * Delete an interface from state.\n   *\n   * @param id - The interface id.\n   */\n  deleteInterface(id: string) {\n    this.update((draftState) => {\n      delete draftState.interfaces[id];\n    });\n  }\n\n  /**\n   * Update the interface state.\n   *\n   * @param id - The interface id.\n   * @param state - The new state.\n   */\n  updateInterfaceState(id: string, state: InterfaceState) {\n    this.update((draftState) => {\n      draftState.interfaces[id].state = state;\n    });\n  }\n\n  /**\n   * Resolve the promise of a given interface approval request.\n   * The approval needs to have the same ID as the interface.\n   *\n   * @param snapId - The snap id.\n   * @param id - The interface id.\n   * @param value - The value to resolve the promise with.\n   */\n  async resolveInterface(snapId: SnapId, id: string, value: Json) {\n    this.#validateArgs(snapId, id);\n    this.#validateApproval(id);\n\n    await this.#acceptApprovalRequest(id, value);\n\n    this.deleteInterface(id);\n  }\n\n  /**\n   * Utility function to validate the args passed to the other methods.\n   *\n   * @param snapId - The snap id.\n   * @param id - The interface id.\n   */\n  #validateArgs(snapId: SnapId, id: string) {\n    const existingInterface = this.state.interfaces[id];\n\n    assert(\n      existingInterface !== undefined,\n      `Interface with id '${id}' not found.`,\n    );\n    assert(\n      existingInterface.snapId === snapId,\n      `Interface not created by ${snapId}.`,\n    );\n  }\n\n  /**\n   * Utility function to validate that the approval request exists.\n   *\n   * @param id - The interface id.\n   */\n  #validateApproval(id: string) {\n    assert(\n      this.#hasApprovalRequest(id),\n      `Approval request with id '${id}' not found.`,\n    );\n  }\n\n  /**\n   * Check an origin against the phishing list.\n   *\n   * @param origin - The origin to check.\n   * @returns True if the origin is on the phishing list, otherwise false.\n   */\n  #checkPhishingList(origin: string) {\n    return this.messenger.call('PhishingController:testOrigin', origin).result;\n  }\n\n  /**\n   * Check if an approval request exists for a given interface by looking up\n   * if the ApprovalController has a request with the given interface ID.\n   *\n   * @param id - The interface id.\n   * @returns True if an approval request exists, otherwise false.\n   */\n  #hasApprovalRequest(id: string) {\n    return this.messenger.call('ApprovalController:hasRequest', {\n      id,\n    });\n  }\n\n  /**\n   * Accept an approval request for a given interface.\n   *\n   * @param id - The interface id.\n   * @param value - The value to resolve the promise with.\n   */\n  async #acceptApprovalRequest(id: string, value: Json) {\n    await this.messenger.call('ApprovalController:acceptRequest', id, value);\n  }\n\n  /**\n   * Get the selected account in the client.\n   *\n   * @returns The selected account.\n   */\n  #getSelectedAccount() {\n    return this.messenger.call(\n      'AccountsController:getSelectedMultichainAccount',\n    );\n  }\n\n  /**\n   * Get a list of accounts for the given chain IDs.\n   *\n   * @param chainIds - The chain IDs to get the accounts for.\n   * @returns The list of accounts.\n   */\n  #listAccounts(chainIds?: CaipChainId[]) {\n    const accounts = this.messenger.call(\n      'AccountsController:listMultichainAccounts',\n    );\n\n    if (!chainIds || chainIds.length === 0) {\n      return accounts;\n    }\n\n    return accounts.filter((account) =>\n      account.scopes.some((scope) => isMatchingChainId(scope, chainIds)),\n    );\n  }\n\n  /**\n   * Get an account by its address.\n   *\n   * @param address - The account address.\n   * @returns The account or undefined if not found.\n   */\n  #getAccountByAddress(address: CaipAccountId) {\n    const { address: parsedAddress } = parseCaipAccountId(address);\n\n    return this.messenger.call(\n      'AccountsController:getAccountByAddress',\n      parsedAddress,\n    );\n  }\n\n  /**\n   * Get the MultichainAssetsController state.\n   *\n   * @returns The MultichainAssetsController state.\n   */\n  #getAssetsState() {\n    return this.messenger.call('MultichainAssetsController:getState');\n  }\n\n  /**\n   * Get a snap by its id.\n   *\n   * @param id - The snap id.\n   * @returns The snap.\n   */\n  #getSnap(id: string) {\n    return this.messenger.call('SnapController:get', id);\n  }\n\n  /**\n   * Utility function to validate the components of an interface.\n   * Throws if something is invalid.\n   *\n   * @param element - The JSX element to verify.\n   */\n  #validateContent(element: JSXElement) {\n    // We assume the validity of this JSON to be validated by the caller.\n    // E.g., in the RPC method implementation.\n    const size = getJsonSizeUnsafe(element);\n    assert(\n      size <= MAX_UI_CONTENT_SIZE,\n      `A Snap UI may not be larger than ${MAX_UI_CONTENT_SIZE / 1000000} MB.`,\n    );\n\n    validateJsxElements(element, {\n      isOnPhishingList: this.#checkPhishingList.bind(this),\n      getSnap: this.#getSnap.bind(this),\n      getAccountByAddress: this.#getAccountByAddress.bind(this),\n    });\n  }\n\n  #onNotificationsListUpdated(notificationsList: Notification[]) {\n    const snapNotificationsWithInterface = notificationsList.filter(\n      (notification) => {\n        return (\n          notification.type === 'snap' &&\n          hasProperty((notification as SnapNotification).data, 'detailedView')\n        );\n      },\n    );\n\n    const interfaceIdSet = new Set(\n      snapNotificationsWithInterface.map(\n        (notification) =>\n          (\n            (notification as SnapNotification)\n              .data as ExpandedSnapNotificationData\n          ).detailedView.interfaceId,\n      ),\n    );\n\n    this.update((state) => {\n      Object.entries(state.interfaces).forEach(([id, snapInterface]) => {\n        if (\n          snapInterface.contentType === ContentType.Notification &&\n          !interfaceIdSet.has(id)\n        ) {\n          delete state.interfaces[id];\n        }\n      });\n    });\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/interface/SnapInterfaceController.d.cts b/dist/interface/SnapInterfaceController.d.cts
index 7ea097e7e5d914a0bf3b7e1b78c22b2be070d2aa..407393b20cd88a3bfe7a13bac501bd8a5ad68b91 100644
--- a/dist/interface/SnapInterfaceController.d.cts
+++ b/dist/interface/SnapInterfaceController.d.cts
@@ -1,6 +1,7 @@
 import type { AcceptRequest, HasApprovalRequest } from "@metamask/approval-controller";
-import type { RestrictedMessenger, ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
-import { BaseController } from "@metamask/base-controller";
+import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller/next";
+import { BaseController } from "@metamask/base-controller/next";
+import type { Messenger } from "@metamask/messenger";
 import type { TestOrigin } from "@metamask/phishing-controller";
 import type { InterfaceState, SnapId, ComponentOrElement, InterfaceContext, FungibleAssetMetadata } from "@metamask/snaps-sdk";
 import { ContentType } from "@metamask/snaps-sdk";
@@ -89,7 +90,7 @@ type NotificationListUpdatedEvent = {
     payload: [Notification[]];
 };
 export type SnapInterfaceControllerEvents = SnapInterfaceControllerStateChangeEvent | NotificationListUpdatedEvent;
-export type SnapInterfaceControllerMessenger = RestrictedMessenger<typeof controllerName, SnapInterfaceControllerActions | SnapInterfaceControllerAllowedActions, SnapInterfaceControllerEvents, SnapInterfaceControllerAllowedActions['type'], SnapInterfaceControllerEvents['type']>;
+export type SnapInterfaceControllerMessenger = Messenger<typeof controllerName, SnapInterfaceControllerActions | SnapInterfaceControllerAllowedActions, SnapInterfaceControllerEvents>;
 export type StoredInterface = {
     snapId: SnapId;
     content: JSXElement;
diff --git a/dist/interface/SnapInterfaceController.d.cts.map b/dist/interface/SnapInterfaceController.d.cts.map
index c5e38ae0bc48124c76e5f30c0a968126c46ea85c..e386fb2bfa27f8d84c410412c92f0c30e3df1453 100644
--- a/dist/interface/SnapInterfaceController.d.cts.map
+++ b/dist/interface/SnapInterfaceController.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"SnapInterfaceController.d.cts","sourceRoot":"","sources":["../../src/interface/SnapInterfaceController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"SnapInterfaceController.d.cts","sourceRoot":"","sources":["../../src/interface/SnapInterfaceController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/interface/SnapInterfaceController.d.mts b/dist/interface/SnapInterfaceController.d.mts
index 249937e6bf0f01308a72d4072fc9ac45853e2b3e..751d69e04373fd1eeed2f5a046b434174b7a3754 100644
--- a/dist/interface/SnapInterfaceController.d.mts
+++ b/dist/interface/SnapInterfaceController.d.mts
@@ -1,6 +1,7 @@
 import type { AcceptRequest, HasApprovalRequest } from "@metamask/approval-controller";
-import type { RestrictedMessenger, ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
-import { BaseController } from "@metamask/base-controller";
+import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller/next";
+import { BaseController } from "@metamask/base-controller/next";
+import type { Messenger } from "@metamask/messenger";
 import type { TestOrigin } from "@metamask/phishing-controller";
 import type { InterfaceState, SnapId, ComponentOrElement, InterfaceContext, FungibleAssetMetadata } from "@metamask/snaps-sdk";
 import { ContentType } from "@metamask/snaps-sdk";
@@ -89,7 +90,7 @@ type NotificationListUpdatedEvent = {
     payload: [Notification[]];
 };
 export type SnapInterfaceControllerEvents = SnapInterfaceControllerStateChangeEvent | NotificationListUpdatedEvent;
-export type SnapInterfaceControllerMessenger = RestrictedMessenger<typeof controllerName, SnapInterfaceControllerActions | SnapInterfaceControllerAllowedActions, SnapInterfaceControllerEvents, SnapInterfaceControllerAllowedActions['type'], SnapInterfaceControllerEvents['type']>;
+export type SnapInterfaceControllerMessenger = Messenger<typeof controllerName, SnapInterfaceControllerActions | SnapInterfaceControllerAllowedActions, SnapInterfaceControllerEvents>;
 export type StoredInterface = {
     snapId: SnapId;
     content: JSXElement;
diff --git a/dist/interface/SnapInterfaceController.d.mts.map b/dist/interface/SnapInterfaceController.d.mts.map
index c8ff63c41bcc9e3e43d4ccba92bfedca704c8f2e..45e31770f4be684770ea4ee3efc3b0c9ef4b84bb 100644
--- a/dist/interface/SnapInterfaceController.d.mts.map
+++ b/dist/interface/SnapInterfaceController.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"SnapInterfaceController.d.mts","sourceRoot":"","sources":["../../src/interface/SnapInterfaceController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,aAAa,EACb,kBAAkB,EACnB,sCAAsC;AACvC,OAAO,KAAK,EACV,mBAAmB,EACnB,wBAAwB,EACxB,0BAA0B,EAC3B,kCAAkC;AACnC,OAAO,EAAE,cAAc,EAAE,kCAAkC;AAC3D,OAAO,KAAK,EAAE,UAAU,EAAE,sCAAsC;AAChE,OAAO,KAAK,EACV,cAAc,EACd,MAAM,EACN,kBAAkB,EAClB,gBAAgB,EAChB,qBAAqB,EACtB,4BAA4B;AAC7B,OAAO,EAAE,WAAW,EAAE,4BAA4B;AAClD,OAAO,KAAK,EAAE,UAAU,EAAE,gCAAgC;AAC1D,OAAO,KAAK,EAAE,eAAe,EAAE,8BAA8B;AAM7D,OAAO,KAAK,EAEV,aAAa,EACb,WAAW,EACX,IAAI,EACL,wBAAwB;AAWzB,OAAO,KAAK,EAAE,OAAO,EAAE,2BAAiB;AAIxC,QAAA,MAAM,cAAc,4BAA4B,CAAC;AAEjD,MAAM,MAAM,eAAe,GAAG;IAC5B,IAAI,EAAE,GAAG,OAAO,cAAc,kBAAkB,CAAC;IACjD,OAAO,EAAE,uBAAuB,CAAC,iBAAiB,CAAC,CAAC;CACrD,CAAC;AAEF,MAAM,MAAM,YAAY,GAAG;IACzB,IAAI,EAAE,GAAG,OAAO,cAAc,eAAe,CAAC;IAC9C,OAAO,EAAE,uBAAuB,CAAC,cAAc,CAAC,CAAC;CAClD,CAAC;AAEF,MAAM,MAAM,eAAe,GAAG;IAC5B,IAAI,EAAE,GAAG,OAAO,cAAc,kBAAkB,CAAC;IACjD,OAAO,EAAE,uBAAuB,CAAC,iBAAiB,CAAC,CAAC;CACrD,CAAC;AAEF,MAAM,MAAM,eAAe,GAAG;IAC5B,IAAI,EAAE,GAAG,OAAO,cAAc,kBAAkB,CAAC;IACjD,OAAO,EAAE,uBAAuB,CAAC,iBAAiB,CAAC,CAAC;CACrD,CAAC;AAEF,MAAM,MAAM,oBAAoB,GAAG;IACjC,IAAI,EAAE,GAAG,OAAO,cAAc,uBAAuB,CAAC;IACtD,OAAO,EAAE,uBAAuB,CAAC,sBAAsB,CAAC,CAAC;CAC1D,CAAC;AAEF,MAAM,MAAM,gBAAgB,GAAG;IAC7B,IAAI,EAAE,GAAG,OAAO,cAAc,mBAAmB,CAAC;IAClD,OAAO,EAAE,uBAAuB,CAAC,kBAAkB,CAAC,CAAC;CACtD,CAAC;AAEF,KAAK,2CAA2C,GAAG;IACjD,IAAI,EAAE,wCAAwC,CAAC;IAC/C,OAAO,EAAE,CAAC,OAAO,EAAE,MAAM,KAAK,eAAe,GAAG,SAAS,CAAC;CAC3D,CAAC;AAEF,KAAK,oDAAoD,GAAG;IAC1D,IAAI,EAAE,iDAAiD,CAAC;IACxD,OAAO,EAAE,MAAM,eAAe,CAAC;CAChC,CAAC;AAEF,KAAK,8CAA8C,GAAG;IACpD,IAAI,EAAE,2CAA2C,CAAC;IAClD,OAAO,EAAE,CAAC,OAAO,CAAC,EAAE,WAAW,KAAK,eAAe,EAAE,CAAC;CACvD,CAAC;AAEF,MAAM,MAAM,qCAAqC,GAAG,wBAAwB,CAC1E,OAAO,cAAc,EACrB,4BAA4B,CAC7B,CAAC;AAEF,KAAK,wCAAwC,GAAG,wBAAwB,CACtE,4BAA4B,EAC5B;IACE,cAAc,EAAE;QACd,CAAC,KAAK,EAAE,aAAa,GAAG,qBAAqB,CAAC;KAC/C,CAAC;IACF,cAAc,EAAE;QAAE,CAAC,OAAO,EAAE,MAAM,GAAG,aAAa,EAAE,CAAA;KAAE,CAAC;CACxD,CACF,CAAC;AAEF,MAAM,MAAM,qCAAqC,GAC7C,UAAU,GACV,kBAAkB,GAClB,aAAa,GACb,OAAO,GACP,wCAAwC,GACxC,oDAAoD,GACpD,2CAA2C,GAC3C,8CAA8C,CAAC;AAEnD,MAAM,MAAM,8BAA8B,GACtC,eAAe,GACf,YAAY,GACZ,eAAe,GACf,eAAe,GACf,oBAAoB,GACpB,gBAAgB,GAChB,qCAAqC,CAAC;AAE1C,MAAM,MAAM,uCAAuC,GACjD,0BAA0B,CACxB,OAAO,cAAc,EACrB,4BAA4B,CAC7B,CAAC;AAEJ,KAAK,iBAAiB,GAAG;IAAE,IAAI,EAAE,MAAM,CAAC;IAAC,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAA;CAAE,CAAC;AAElE,MAAM,MAAM,YAAY,GAAG;IACzB,KAAK,EAAE,MAAM,CAAC;IACd,WAAW,EAAE,MAAM,CAAC;IACpB,UAAU,CAAC,EAAE;QAAE,IAAI,EAAE,MAAM,CAAC;QAAC,IAAI,EAAE,MAAM,CAAA;KAAE,CAAC;CAC7C,CAAC;AAEF,KAAK,0BAA0B,GAAG;IAAE,OAAO,EAAE,MAAM,CAAC;IAAC,MAAM,EAAE,MAAM,CAAA;CAAE,CAAC;AAEtE,KAAK,4BAA4B,GAAG;IAClC,OAAO,EAAE,MAAM,CAAC;IAChB,MAAM,EAAE,MAAM,CAAC;IACf,YAAY,EAAE,YAAY,CAAC;CAC5B,CAAC;AAEF,KAAK,gBAAgB,GAAG;IACtB,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,EAAE,0BAA0B,GAAG,4BAA4B,CAAC;IAChE,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC;CACzB,CAAC;AAEF,KAAK,YAAY,GAAG,iBAAiB,GAAG,gBAAgB,CAAC;AAEzD,KAAK,4BAA4B,GAAG;IAClC,IAAI,EAAE,yDAAyD,CAAC;IAChE,OAAO,EAAE,CAAC,YAAY,EAAE,CAAC,CAAC;CAC3B,CAAC;AAEF,MAAM,MAAM,6BAA6B,GACrC,uCAAuC,GACvC,4BAA4B,CAAC;AAEjC,MAAM,MAAM,gCAAgC,GAAG,mBAAmB,CAChE,OAAO,cAAc,EACrB,8BAA8B,GAAG,qCAAqC,EACtE,6BAA6B,EAC7B,qCAAqC,CAAC,MAAM,CAAC,EAC7C,6BAA6B,CAAC,MAAM,CAAC,CACtC,CAAC;AAEF,MAAM,MAAM,eAAe,GAAG;IAC5B,MAAM,EAAE,MAAM,CAAC;IACf,OAAO,EAAE,UAAU,CAAC;IACpB,KAAK,EAAE,cAAc,CAAC;IACtB,OAAO,EAAE,gBAAgB,GAAG,IAAI,CAAC;IACjC,WAAW,EAAE,WAAW,GAAG,IAAI,CAAC;CACjC,CAAC;AAEF,MAAM,MAAM,4BAA4B,GAAG;IACzC,UAAU,EAAE,MAAM,CAAC,MAAM,EAAE,eAAe,CAAC,CAAC;CAC7C,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG;IACxC,SAAS,EAAE,gCAAgC,CAAC;IAC5C,KAAK,CAAC,EAAE,4BAA4B,CAAC;CACtC,CAAC;AAEF;;GAEG;AACH,qBAAa,uBAAwB,SAAQ,cAAc,CACzD,OAAO,cAAc,EACrB,4BAA4B,EAC5B,gCAAgC,CACjC;;gBACa,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,2BAA2B;IAuE7D;;;;;;;;OAQG;IACH,eAAe,CACb,MAAM,EAAE,MAAM,EACd,OAAO,EAAE,kBAAkB,EAC3B,OAAO,CAAC,EAAE,gBAAgB,EAC1B,WAAW,CAAC,EAAE,WAAW;IA+B3B;;;;;;OAMG;IACH,YAAY,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM;IAMvC;;;;;;;OAOG;IACH,eAAe,CACb,MAAM,EAAE,MAAM,EACd,EAAE,EAAE,MAAM,EACV,OAAO,EAAE,kBAAkB,EAC3B,OAAO,CAAC,EAAE,gBAAgB;IA0B5B;;;;OAIG;IACH,eAAe,CAAC,EAAE,EAAE,MAAM;IAM1B;;;;;OAKG;IACH,oBAAoB,CAAC,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,cAAc;IAMtD;;;;;;;OAOG;IACG,gBAAgB,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,IAAI;CAoM/D"}
\ No newline at end of file
+{"version":3,"file":"SnapInterfaceController.d.mts","sourceRoot":"","sources":["../../src/interface/SnapInterfaceController.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,aAAa,EACb,kBAAkB,EACnB,sCAAsC;AACvC,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAC3B,uCAAuC;AACxC,OAAO,EAAE,cAAc,EAAE,uCAAuC;AAChE,OAAO,KAAK,EAAE,SAAS,EAAE,4BAA4B;AACrD,OAAO,KAAK,EAAE,UAAU,EAAE,sCAAsC;AAChE,OAAO,KAAK,EACV,cAAc,EACd,MAAM,EACN,kBAAkB,EAClB,gBAAgB,EAChB,qBAAqB,EACtB,4BAA4B;AAC7B,OAAO,EAAE,WAAW,EAAE,4BAA4B;AAClD,OAAO,KAAK,EAAE,UAAU,EAAE,gCAAgC;AAC1D,OAAO,KAAK,EAAE,eAAe,EAAE,8BAA8B;AAM7D,OAAO,KAAK,EAEV,aAAa,EACb,WAAW,EACX,IAAI,EACL,wBAAwB;AAWzB,OAAO,KAAK,EAAE,OAAO,EAAE,2BAAiB;AAIxC,QAAA,MAAM,cAAc,4BAA4B,CAAC;AAEjD,MAAM,MAAM,eAAe,GAAG;IAC5B,IAAI,EAAE,GAAG,OAAO,cAAc,kBAAkB,CAAC;IACjD,OAAO,EAAE,uBAAuB,CAAC,iBAAiB,CAAC,CAAC;CACrD,CAAC;AAEF,MAAM,MAAM,YAAY,GAAG;IACzB,IAAI,EAAE,GAAG,OAAO,cAAc,eAAe,CAAC;IAC9C,OAAO,EAAE,uBAAuB,CAAC,cAAc,CAAC,CAAC;CAClD,CAAC;AAEF,MAAM,MAAM,eAAe,GAAG;IAC5B,IAAI,EAAE,GAAG,OAAO,cAAc,kBAAkB,CAAC;IACjD,OAAO,EAAE,uBAAuB,CAAC,iBAAiB,CAAC,CAAC;CACrD,CAAC;AAEF,MAAM,MAAM,eAAe,GAAG;IAC5B,IAAI,EAAE,GAAG,OAAO,cAAc,kBAAkB,CAAC;IACjD,OAAO,EAAE,uBAAuB,CAAC,iBAAiB,CAAC,CAAC;CACrD,CAAC;AAEF,MAAM,MAAM,oBAAoB,GAAG;IACjC,IAAI,EAAE,GAAG,OAAO,cAAc,uBAAuB,CAAC;IACtD,OAAO,EAAE,uBAAuB,CAAC,sBAAsB,CAAC,CAAC;CAC1D,CAAC;AAEF,MAAM,MAAM,gBAAgB,GAAG;IAC7B,IAAI,EAAE,GAAG,OAAO,cAAc,mBAAmB,CAAC;IAClD,OAAO,EAAE,uBAAuB,CAAC,kBAAkB,CAAC,CAAC;CACtD,CAAC;AAEF,KAAK,2CAA2C,GAAG;IACjD,IAAI,EAAE,wCAAwC,CAAC;IAC/C,OAAO,EAAE,CAAC,OAAO,EAAE,MAAM,KAAK,eAAe,GAAG,SAAS,CAAC;CAC3D,CAAC;AAEF,KAAK,oDAAoD,GAAG;IAC1D,IAAI,EAAE,iDAAiD,CAAC;IACxD,OAAO,EAAE,MAAM,eAAe,CAAC;CAChC,CAAC;AAEF,KAAK,8CAA8C,GAAG;IACpD,IAAI,EAAE,2CAA2C,CAAC;IAClD,OAAO,EAAE,CAAC,OAAO,CAAC,EAAE,WAAW,KAAK,eAAe,EAAE,CAAC;CACvD,CAAC;AAEF,MAAM,MAAM,qCAAqC,GAAG,wBAAwB,CAC1E,OAAO,cAAc,EACrB,4BAA4B,CAC7B,CAAC;AAEF,KAAK,wCAAwC,GAAG,wBAAwB,CACtE,4BAA4B,EAC5B;IACE,cAAc,EAAE;QACd,CAAC,KAAK,EAAE,aAAa,GAAG,qBAAqB,CAAC;KAC/C,CAAC;IACF,cAAc,EAAE;QAAE,CAAC,OAAO,EAAE,MAAM,GAAG,aAAa,EAAE,CAAA;KAAE,CAAC;CACxD,CACF,CAAC;AAEF,MAAM,MAAM,qCAAqC,GAC7C,UAAU,GACV,kBAAkB,GAClB,aAAa,GACb,OAAO,GACP,wCAAwC,GACxC,oDAAoD,GACpD,2CAA2C,GAC3C,8CAA8C,CAAC;AAEnD,MAAM,MAAM,8BAA8B,GACtC,eAAe,GACf,YAAY,GACZ,eAAe,GACf,eAAe,GACf,oBAAoB,GACpB,gBAAgB,GAChB,qCAAqC,CAAC;AAE1C,MAAM,MAAM,uCAAuC,GACjD,0BAA0B,CACxB,OAAO,cAAc,EACrB,4BAA4B,CAC7B,CAAC;AAEJ,KAAK,iBAAiB,GAAG;IAAE,IAAI,EAAE,MAAM,CAAC;IAAC,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAA;CAAE,CAAC;AAElE,MAAM,MAAM,YAAY,GAAG;IACzB,KAAK,EAAE,MAAM,CAAC;IACd,WAAW,EAAE,MAAM,CAAC;IACpB,UAAU,CAAC,EAAE;QAAE,IAAI,EAAE,MAAM,CAAC;QAAC,IAAI,EAAE,MAAM,CAAA;KAAE,CAAC;CAC7C,CAAC;AAEF,KAAK,0BAA0B,GAAG;IAAE,OAAO,EAAE,MAAM,CAAC;IAAC,MAAM,EAAE,MAAM,CAAA;CAAE,CAAC;AAEtE,KAAK,4BAA4B,GAAG;IAClC,OAAO,EAAE,MAAM,CAAC;IAChB,MAAM,EAAE,MAAM,CAAC;IACf,YAAY,EAAE,YAAY,CAAC;CAC5B,CAAC;AAEF,KAAK,gBAAgB,GAAG;IACtB,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,EAAE,0BAA0B,GAAG,4BAA4B,CAAC;IAChE,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC;CACzB,CAAC;AAEF,KAAK,YAAY,GAAG,iBAAiB,GAAG,gBAAgB,CAAC;AAEzD,KAAK,4BAA4B,GAAG;IAClC,IAAI,EAAE,yDAAyD,CAAC;IAChE,OAAO,EAAE,CAAC,YAAY,EAAE,CAAC,CAAC;CAC3B,CAAC;AAEF,MAAM,MAAM,6BAA6B,GACrC,uCAAuC,GACvC,4BAA4B,CAAC;AAEjC,MAAM,MAAM,gCAAgC,GAAG,SAAS,CACtD,OAAO,cAAc,EACrB,8BAA8B,GAAG,qCAAqC,EACtE,6BAA6B,CAC9B,CAAC;AAEF,MAAM,MAAM,eAAe,GAAG;IAC5B,MAAM,EAAE,MAAM,CAAC;IACf,OAAO,EAAE,UAAU,CAAC;IACpB,KAAK,EAAE,cAAc,CAAC;IACtB,OAAO,EAAE,gBAAgB,GAAG,IAAI,CAAC;IACjC,WAAW,EAAE,WAAW,GAAG,IAAI,CAAC;CACjC,CAAC;AAEF,MAAM,MAAM,4BAA4B,GAAG;IACzC,UAAU,EAAE,MAAM,CAAC,MAAM,EAAE,eAAe,CAAC,CAAC;CAC7C,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG;IACxC,SAAS,EAAE,gCAAgC,CAAC;IAC5C,KAAK,CAAC,EAAE,4BAA4B,CAAC;CACtC,CAAC;AAEF;;GAEG;AACH,qBAAa,uBAAwB,SAAQ,cAAc,CACzD,OAAO,cAAc,EACrB,4BAA4B,EAC5B,gCAAgC,CACjC;;gBACa,EAAE,SAAS,EAAE,KAAK,EAAE,EAAE,2BAA2B;IAuE7D;;;;;;;;OAQG;IACH,eAAe,CACb,MAAM,EAAE,MAAM,EACd,OAAO,EAAE,kBAAkB,EAC3B,OAAO,CAAC,EAAE,gBAAgB,EAC1B,WAAW,CAAC,EAAE,WAAW;IA+B3B;;;;;;OAMG;IACH,YAAY,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM;IAMvC;;;;;;;OAOG;IACH,eAAe,CACb,MAAM,EAAE,MAAM,EACd,EAAE,EAAE,MAAM,EACV,OAAO,EAAE,kBAAkB,EAC3B,OAAO,CAAC,EAAE,gBAAgB;IA0B5B;;;;OAIG;IACH,eAAe,CAAC,EAAE,EAAE,MAAM;IAM1B;;;;;OAKG;IACH,oBAAoB,CAAC,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,cAAc;IAMtD;;;;;;;OAOG;IACG,gBAAgB,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,IAAI;CA+L/D"}
\ No newline at end of file
diff --git a/dist/interface/SnapInterfaceController.mjs b/dist/interface/SnapInterfaceController.mjs
index b6f0bb60c4a802e1dc3005e3abacbbfe1013770c..b74ef9921cdaf67dd9146d9453bc3f0b70af72d8 100644
--- a/dist/interface/SnapInterfaceController.mjs
+++ b/dist/interface/SnapInterfaceController.mjs
@@ -1,4 +1,4 @@
-import { BaseController } from "@metamask/base-controller";
+import { BaseController } from "@metamask/base-controller/next";
 import { ContentType } from "@metamask/snaps-sdk";
 import { getJsonSizeUnsafe, snapOwnsAccount, validateJsxElements } from "@metamask/snaps-utils";
 import { assert, hasProperty, parseCaipAccountId } from "@metamask/utils";
@@ -28,14 +28,14 @@ export class SnapInterfaceController extends BaseController {
                             }
                         }, {});
                     },
-                    anonymous: false,
+                    includeInDebugSnapshot: false,
                     usedInUi: true,
                 },
             },
             name: controllerName,
             state: { interfaces: {}, ...state },
         });
-        this.messagingSystem.subscribe('NotificationServicesController:notificationsListUpdated', this.#onNotificationsListUpdated.bind(this));
+        this.messenger.subscribe('NotificationServicesController:notificationsListUpdated', this.#onNotificationsListUpdated.bind(this));
         this.#registerMessageHandlers();
     }
     /**
@@ -43,12 +43,12 @@ export class SnapInterfaceController extends BaseController {
      * actions.
      */
     #registerMessageHandlers() {
-        this.messagingSystem.registerActionHandler(`${controllerName}:createInterface`, this.createInterface.bind(this));
-        this.messagingSystem.registerActionHandler(`${controllerName}:getInterface`, this.getInterface.bind(this));
-        this.messagingSystem.registerActionHandler(`${controllerName}:updateInterface`, this.updateInterface.bind(this));
-        this.messagingSystem.registerActionHandler(`${controllerName}:deleteInterface`, this.deleteInterface.bind(this));
-        this.messagingSystem.registerActionHandler(`${controllerName}:updateInterfaceState`, this.updateInterfaceState.bind(this));
-        this.messagingSystem.registerActionHandler(`${controllerName}:resolveInterface`, this.resolveInterface.bind(this));
+        this.messenger.registerActionHandler(`${controllerName}:createInterface`, this.createInterface.bind(this));
+        this.messenger.registerActionHandler(`${controllerName}:getInterface`, this.getInterface.bind(this));
+        this.messenger.registerActionHandler(`${controllerName}:updateInterface`, this.updateInterface.bind(this));
+        this.messenger.registerActionHandler(`${controllerName}:deleteInterface`, this.deleteInterface.bind(this));
+        this.messenger.registerActionHandler(`${controllerName}:updateInterfaceState`, this.updateInterfaceState.bind(this));
+        this.messenger.registerActionHandler(`${controllerName}:resolveInterface`, this.resolveInterface.bind(this));
     }
     /**
      * Create an interface in the controller state with the associated data.
@@ -185,8 +185,7 @@ export class SnapInterfaceController extends BaseController {
      * @returns True if the origin is on the phishing list, otherwise false.
      */
     #checkPhishingList(origin) {
-        return this.messagingSystem.call('PhishingController:testOrigin', origin)
-            .result;
+        return this.messenger.call('PhishingController:testOrigin', origin).result;
     }
     /**
      * Check if an approval request exists for a given interface by looking up
@@ -196,7 +195,7 @@ export class SnapInterfaceController extends BaseController {
      * @returns True if an approval request exists, otherwise false.
      */
     #hasApprovalRequest(id) {
-        return this.messagingSystem.call('ApprovalController:hasRequest', {
+        return this.messenger.call('ApprovalController:hasRequest', {
             id,
         });
     }
@@ -207,7 +206,7 @@ export class SnapInterfaceController extends BaseController {
      * @param value - The value to resolve the promise with.
      */
     async #acceptApprovalRequest(id, value) {
-        await this.messagingSystem.call('ApprovalController:acceptRequest', id, value);
+        await this.messenger.call('ApprovalController:acceptRequest', id, value);
     }
     /**
      * Get the selected account in the client.
@@ -215,7 +214,7 @@ export class SnapInterfaceController extends BaseController {
      * @returns The selected account.
      */
     #getSelectedAccount() {
-        return this.messagingSystem.call('AccountsController:getSelectedMultichainAccount');
+        return this.messenger.call('AccountsController:getSelectedMultichainAccount');
     }
     /**
      * Get a list of accounts for the given chain IDs.
@@ -224,7 +223,7 @@ export class SnapInterfaceController extends BaseController {
      * @returns The list of accounts.
      */
     #listAccounts(chainIds) {
-        const accounts = this.messagingSystem.call('AccountsController:listMultichainAccounts');
+        const accounts = this.messenger.call('AccountsController:listMultichainAccounts');
         if (!chainIds || chainIds.length === 0) {
             return accounts;
         }
@@ -238,7 +237,7 @@ export class SnapInterfaceController extends BaseController {
      */
     #getAccountByAddress(address) {
         const { address: parsedAddress } = parseCaipAccountId(address);
-        return this.messagingSystem.call('AccountsController:getAccountByAddress', parsedAddress);
+        return this.messenger.call('AccountsController:getAccountByAddress', parsedAddress);
     }
     /**
      * Get the MultichainAssetsController state.
@@ -246,7 +245,7 @@ export class SnapInterfaceController extends BaseController {
      * @returns The MultichainAssetsController state.
      */
     #getAssetsState() {
-        return this.messagingSystem.call('MultichainAssetsController:getState');
+        return this.messenger.call('MultichainAssetsController:getState');
     }
     /**
      * Get a snap by its id.
@@ -255,7 +254,7 @@ export class SnapInterfaceController extends BaseController {
      * @returns The snap.
      */
     #getSnap(id) {
-        return this.messagingSystem.call('SnapController:get', id);
+        return this.messenger.call('SnapController:get', id);
     }
     /**
      * Utility function to validate the components of an interface.
diff --git a/dist/interface/SnapInterfaceController.mjs.map b/dist/interface/SnapInterfaceController.mjs.map
index 4856abc338841455b2c9f905351752af14f583cd..076793dacbd5cdef2a5d659e9c769f580f1080e6 100644
--- a/dist/interface/SnapInterfaceController.mjs.map
+++ b/dist/interface/SnapInterfaceController.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"SnapInterfaceController.mjs","sourceRoot":"","sources":["../../src/interface/SnapInterfaceController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  AcceptRequest,\n  HasApprovalRequest,\n} from '@metamask/approval-controller';\nimport type {\n  RestrictedMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { TestOrigin } from '@metamask/phishing-controller';\nimport type {\n  InterfaceState,\n  SnapId,\n  ComponentOrElement,\n  InterfaceContext,\n  FungibleAssetMetadata,\n} from '@metamask/snaps-sdk';\nimport { ContentType } from '@metamask/snaps-sdk';\nimport type { JSXElement } from '@metamask/snaps-sdk/jsx';\nimport type { InternalAccount } from '@metamask/snaps-utils';\nimport {\n  getJsonSizeUnsafe,\n  snapOwnsAccount,\n  validateJsxElements,\n} from '@metamask/snaps-utils';\nimport type {\n  CaipAccountId,\n  CaipAssetType,\n  CaipChainId,\n  Json,\n} from '@metamask/utils';\nimport { assert, hasProperty, parseCaipAccountId } from '@metamask/utils';\nimport { castDraft } from 'immer';\nimport { nanoid } from 'nanoid';\n\nimport {\n  constructState,\n  getJsxInterface,\n  isMatchingChainId,\n  validateInterfaceContext,\n} from './utils';\nimport type { GetSnap } from '../snaps';\n\nconst MAX_UI_CONTENT_SIZE = 10_000_000; // 10 mb\n\nconst controllerName = 'SnapInterfaceController';\n\nexport type CreateInterface = {\n  type: `${typeof controllerName}:createInterface`;\n  handler: SnapInterfaceController['createInterface'];\n};\n\nexport type GetInterface = {\n  type: `${typeof controllerName}:getInterface`;\n  handler: SnapInterfaceController['getInterface'];\n};\n\nexport type UpdateInterface = {\n  type: `${typeof controllerName}:updateInterface`;\n  handler: SnapInterfaceController['updateInterface'];\n};\n\nexport type DeleteInterface = {\n  type: `${typeof controllerName}:deleteInterface`;\n  handler: SnapInterfaceController['deleteInterface'];\n};\n\nexport type UpdateInterfaceState = {\n  type: `${typeof controllerName}:updateInterfaceState`;\n  handler: SnapInterfaceController['updateInterfaceState'];\n};\n\nexport type ResolveInterface = {\n  type: `${typeof controllerName}:resolveInterface`;\n  handler: SnapInterfaceController['resolveInterface'];\n};\n\ntype AccountsControllerGetAccountByAddressAction = {\n  type: `AccountsController:getAccountByAddress`;\n  handler: (address: string) => InternalAccount | undefined;\n};\n\ntype AccountsControllerGetSelectedMultichainAccountAction = {\n  type: `AccountsController:getSelectedMultichainAccount`;\n  handler: () => InternalAccount;\n};\n\ntype AccountsControllerListMultichainAccountsAction = {\n  type: `AccountsController:listMultichainAccounts`;\n  handler: (chainId?: CaipChainId) => InternalAccount[];\n};\n\nexport type SnapInterfaceControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapInterfaceControllerState\n>;\n\ntype MultichainAssetsControllerGetStateAction = ControllerGetStateAction<\n  'MultichainAssetsController',\n  {\n    assetsMetadata: {\n      [asset: CaipAssetType]: FungibleAssetMetadata;\n    };\n    accountsAssets: { [account: string]: CaipAssetType[] };\n  }\n>;\n\nexport type SnapInterfaceControllerAllowedActions =\n  | TestOrigin\n  | HasApprovalRequest\n  | AcceptRequest\n  | GetSnap\n  | MultichainAssetsControllerGetStateAction\n  | AccountsControllerGetSelectedMultichainAccountAction\n  | AccountsControllerGetAccountByAddressAction\n  | AccountsControllerListMultichainAccountsAction;\n\nexport type SnapInterfaceControllerActions =\n  | CreateInterface\n  | GetInterface\n  | UpdateInterface\n  | DeleteInterface\n  | UpdateInterfaceState\n  | ResolveInterface\n  | SnapInterfaceControllerGetStateAction;\n\nexport type SnapInterfaceControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    SnapInterfaceControllerState\n  >;\n\ntype OtherNotification = { type: string; [key: string]: unknown };\n\nexport type ExpandedView = {\n  title: string;\n  interfaceId: string;\n  footerLink?: { href: string; text: string };\n};\n\ntype NormalSnapNotificationData = { message: string; origin: string };\n\ntype ExpandedSnapNotificationData = {\n  message: string;\n  origin: string;\n  detailedView: ExpandedView;\n};\n\ntype SnapNotification = {\n  type: 'snap';\n  data: NormalSnapNotificationData | ExpandedSnapNotificationData;\n  readDate: string | null;\n};\n\ntype Notification = OtherNotification | SnapNotification;\n\ntype NotificationListUpdatedEvent = {\n  type: 'NotificationServicesController:notificationsListUpdated';\n  payload: [Notification[]];\n};\n\nexport type SnapInterfaceControllerEvents =\n  | SnapInterfaceControllerStateChangeEvent\n  | NotificationListUpdatedEvent;\n\nexport type SnapInterfaceControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  SnapInterfaceControllerActions | SnapInterfaceControllerAllowedActions,\n  SnapInterfaceControllerEvents,\n  SnapInterfaceControllerAllowedActions['type'],\n  SnapInterfaceControllerEvents['type']\n>;\n\nexport type StoredInterface = {\n  snapId: SnapId;\n  content: JSXElement;\n  state: InterfaceState;\n  context: InterfaceContext | null;\n  contentType: ContentType | null;\n};\n\nexport type SnapInterfaceControllerState = {\n  interfaces: Record<string, StoredInterface>;\n};\n\nexport type SnapInterfaceControllerArgs = {\n  messenger: SnapInterfaceControllerMessenger;\n  state?: SnapInterfaceControllerState;\n};\n\n/**\n * Use this controller to manage snaps UI interfaces using RPC method hooks.\n */\nexport class SnapInterfaceController extends BaseController<\n  typeof controllerName,\n  SnapInterfaceControllerState,\n  SnapInterfaceControllerMessenger\n> {\n  constructor({ messenger, state }: SnapInterfaceControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        interfaces: {\n          includeInStateLogs: true,\n          persist: (interfaces: Record<string, StoredInterface>) => {\n            return Object.entries(interfaces).reduce<\n              Record<string, StoredInterface>\n            >((persistedInterfaces, [id, snapInterface]) => {\n              switch (snapInterface.contentType) {\n                case ContentType.Notification:\n                  persistedInterfaces[id] = snapInterface;\n                  return persistedInterfaces;\n                default:\n                  return persistedInterfaces;\n              }\n            }, {});\n          },\n          anonymous: false,\n          usedInUi: true,\n        },\n      },\n      name: controllerName,\n      state: { interfaces: {}, ...state },\n    });\n\n    this.messagingSystem.subscribe(\n      'NotificationServicesController:notificationsListUpdated',\n      this.#onNotificationsListUpdated.bind(this),\n    );\n\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers() {\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:createInterface`,\n      this.createInterface.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getInterface`,\n      this.getInterface.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateInterface`,\n      this.updateInterface.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:deleteInterface`,\n      this.deleteInterface.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateInterfaceState`,\n      this.updateInterfaceState.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:resolveInterface`,\n      this.resolveInterface.bind(this),\n    );\n  }\n\n  /**\n   * Create an interface in the controller state with the associated data.\n   *\n   * @param snapId - The snap id that created the interface.\n   * @param content - The interface content.\n   * @param context - An optional interface context object.\n   * @param contentType - The type of content.\n   * @returns The newly interface id.\n   */\n  createInterface(\n    snapId: SnapId,\n    content: ComponentOrElement,\n    context?: InterfaceContext,\n    contentType?: ContentType,\n  ) {\n    const element = getJsxInterface(content);\n    this.#validateContent(element);\n    validateInterfaceContext(context);\n\n    const id = nanoid();\n    const componentState = constructState({}, element, {\n      getAssetsState: this.#getAssetsState.bind(this),\n      getAccountByAddress: this.#getAccountByAddress.bind(this),\n      getSelectedAccount: this.#getSelectedAccount.bind(this),\n      listAccounts: this.#listAccounts.bind(this),\n      snapOwnsAccount: (account: InternalAccount) =>\n        snapOwnsAccount(snapId, account),\n    });\n\n    this.update((draftState) => {\n      // @ts-expect-error - TS2589: Type instantiation is excessively deep and\n      // possibly infinite.\n      draftState.interfaces[id] = {\n        snapId,\n        content: castDraft(element),\n        state: componentState,\n        context: context ?? null,\n        contentType: contentType ?? null,\n      };\n    });\n\n    return id;\n  }\n\n  /**\n   * Get the data of a given interface id.\n   *\n   * @param snapId - The snap id requesting the interface data.\n   * @param id - The interface id.\n   * @returns The interface state.\n   */\n  getInterface(snapId: SnapId, id: string) {\n    this.#validateArgs(snapId, id);\n\n    return this.state.interfaces[id];\n  }\n\n  /**\n   * Update the interface with the given content.\n   *\n   * @param snapId - The snap id requesting the update.\n   * @param id - The interface id.\n   * @param content - The new content.\n   * @param context - An optional interface context object.\n   */\n  updateInterface(\n    snapId: SnapId,\n    id: string,\n    content: ComponentOrElement,\n    context?: InterfaceContext,\n  ) {\n    this.#validateArgs(snapId, id);\n    const element = getJsxInterface(content);\n    this.#validateContent(element);\n    validateInterfaceContext(context);\n\n    const oldState = this.state.interfaces[id].state;\n    const newState = constructState(oldState, element, {\n      getAssetsState: this.#getAssetsState.bind(this),\n      getAccountByAddress: this.#getAccountByAddress.bind(this),\n      getSelectedAccount: this.#getSelectedAccount.bind(this),\n      listAccounts: this.#listAccounts.bind(this),\n      snapOwnsAccount: (account: InternalAccount) =>\n        snapOwnsAccount(snapId, account),\n    });\n\n    this.update((draftState) => {\n      draftState.interfaces[id].state = newState;\n      draftState.interfaces[id].content = castDraft(element);\n      if (context) {\n        draftState.interfaces[id].context = context;\n      }\n    });\n  }\n\n  /**\n   * Delete an interface from state.\n   *\n   * @param id - The interface id.\n   */\n  deleteInterface(id: string) {\n    this.update((draftState) => {\n      delete draftState.interfaces[id];\n    });\n  }\n\n  /**\n   * Update the interface state.\n   *\n   * @param id - The interface id.\n   * @param state - The new state.\n   */\n  updateInterfaceState(id: string, state: InterfaceState) {\n    this.update((draftState) => {\n      draftState.interfaces[id].state = state;\n    });\n  }\n\n  /**\n   * Resolve the promise of a given interface approval request.\n   * The approval needs to have the same ID as the interface.\n   *\n   * @param snapId - The snap id.\n   * @param id - The interface id.\n   * @param value - The value to resolve the promise with.\n   */\n  async resolveInterface(snapId: SnapId, id: string, value: Json) {\n    this.#validateArgs(snapId, id);\n    this.#validateApproval(id);\n\n    await this.#acceptApprovalRequest(id, value);\n\n    this.deleteInterface(id);\n  }\n\n  /**\n   * Utility function to validate the args passed to the other methods.\n   *\n   * @param snapId - The snap id.\n   * @param id - The interface id.\n   */\n  #validateArgs(snapId: SnapId, id: string) {\n    const existingInterface = this.state.interfaces[id];\n\n    assert(\n      existingInterface !== undefined,\n      `Interface with id '${id}' not found.`,\n    );\n    assert(\n      existingInterface.snapId === snapId,\n      `Interface not created by ${snapId}.`,\n    );\n  }\n\n  /**\n   * Utility function to validate that the approval request exists.\n   *\n   * @param id - The interface id.\n   */\n  #validateApproval(id: string) {\n    assert(\n      this.#hasApprovalRequest(id),\n      `Approval request with id '${id}' not found.`,\n    );\n  }\n\n  /**\n   * Check an origin against the phishing list.\n   *\n   * @param origin - The origin to check.\n   * @returns True if the origin is on the phishing list, otherwise false.\n   */\n  #checkPhishingList(origin: string) {\n    return this.messagingSystem.call('PhishingController:testOrigin', origin)\n      .result;\n  }\n\n  /**\n   * Check if an approval request exists for a given interface by looking up\n   * if the ApprovalController has a request with the given interface ID.\n   *\n   * @param id - The interface id.\n   * @returns True if an approval request exists, otherwise false.\n   */\n  #hasApprovalRequest(id: string) {\n    return this.messagingSystem.call('ApprovalController:hasRequest', {\n      id,\n    });\n  }\n\n  /**\n   * Accept an approval request for a given interface.\n   *\n   * @param id - The interface id.\n   * @param value - The value to resolve the promise with.\n   */\n  async #acceptApprovalRequest(id: string, value: Json) {\n    await this.messagingSystem.call(\n      'ApprovalController:acceptRequest',\n      id,\n      value,\n    );\n  }\n\n  /**\n   * Get the selected account in the client.\n   *\n   * @returns The selected account.\n   */\n  #getSelectedAccount() {\n    return this.messagingSystem.call(\n      'AccountsController:getSelectedMultichainAccount',\n    );\n  }\n\n  /**\n   * Get a list of accounts for the given chain IDs.\n   *\n   * @param chainIds - The chain IDs to get the accounts for.\n   * @returns The list of accounts.\n   */\n  #listAccounts(chainIds?: CaipChainId[]) {\n    const accounts = this.messagingSystem.call(\n      'AccountsController:listMultichainAccounts',\n    );\n\n    if (!chainIds || chainIds.length === 0) {\n      return accounts;\n    }\n\n    return accounts.filter((account) =>\n      account.scopes.some((scope) => isMatchingChainId(scope, chainIds)),\n    );\n  }\n\n  /**\n   * Get an account by its address.\n   *\n   * @param address - The account address.\n   * @returns The account or undefined if not found.\n   */\n  #getAccountByAddress(address: CaipAccountId) {\n    const { address: parsedAddress } = parseCaipAccountId(address);\n\n    return this.messagingSystem.call(\n      'AccountsController:getAccountByAddress',\n      parsedAddress,\n    );\n  }\n\n  /**\n   * Get the MultichainAssetsController state.\n   *\n   * @returns The MultichainAssetsController state.\n   */\n  #getAssetsState() {\n    return this.messagingSystem.call('MultichainAssetsController:getState');\n  }\n\n  /**\n   * Get a snap by its id.\n   *\n   * @param id - The snap id.\n   * @returns The snap.\n   */\n  #getSnap(id: string) {\n    return this.messagingSystem.call('SnapController:get', id);\n  }\n\n  /**\n   * Utility function to validate the components of an interface.\n   * Throws if something is invalid.\n   *\n   * @param element - The JSX element to verify.\n   */\n  #validateContent(element: JSXElement) {\n    // We assume the validity of this JSON to be validated by the caller.\n    // E.g., in the RPC method implementation.\n    const size = getJsonSizeUnsafe(element);\n    assert(\n      size <= MAX_UI_CONTENT_SIZE,\n      `A Snap UI may not be larger than ${MAX_UI_CONTENT_SIZE / 1000000} MB.`,\n    );\n\n    validateJsxElements(element, {\n      isOnPhishingList: this.#checkPhishingList.bind(this),\n      getSnap: this.#getSnap.bind(this),\n      getAccountByAddress: this.#getAccountByAddress.bind(this),\n    });\n  }\n\n  #onNotificationsListUpdated(notificationsList: Notification[]) {\n    const snapNotificationsWithInterface = notificationsList.filter(\n      (notification) => {\n        return (\n          notification.type === 'snap' &&\n          hasProperty((notification as SnapNotification).data, 'detailedView')\n        );\n      },\n    );\n\n    const interfaceIdSet = new Set(\n      snapNotificationsWithInterface.map(\n        (notification) =>\n          (\n            (notification as SnapNotification)\n              .data as ExpandedSnapNotificationData\n          ).detailedView.interfaceId,\n      ),\n    );\n\n    this.update((state) => {\n      Object.entries(state.interfaces).forEach(([id, snapInterface]) => {\n        if (\n          snapInterface.contentType === ContentType.Notification &&\n          !interfaceIdSet.has(id)\n        ) {\n          delete state.interfaces[id];\n        }\n      });\n    });\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SnapInterfaceController.mjs","sourceRoot":"","sources":["../../src/interface/SnapInterfaceController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  AcceptRequest,\n  HasApprovalRequest,\n} from '@metamask/approval-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller/next';\nimport { BaseController } from '@metamask/base-controller/next';\nimport type { Messenger } from '@metamask/messenger';\nimport type { TestOrigin } from '@metamask/phishing-controller';\nimport type {\n  InterfaceState,\n  SnapId,\n  ComponentOrElement,\n  InterfaceContext,\n  FungibleAssetMetadata,\n} from '@metamask/snaps-sdk';\nimport { ContentType } from '@metamask/snaps-sdk';\nimport type { JSXElement } from '@metamask/snaps-sdk/jsx';\nimport type { InternalAccount } from '@metamask/snaps-utils';\nimport {\n  getJsonSizeUnsafe,\n  snapOwnsAccount,\n  validateJsxElements,\n} from '@metamask/snaps-utils';\nimport type {\n  CaipAccountId,\n  CaipAssetType,\n  CaipChainId,\n  Json,\n} from '@metamask/utils';\nimport { assert, hasProperty, parseCaipAccountId } from '@metamask/utils';\nimport { castDraft } from 'immer';\nimport { nanoid } from 'nanoid';\n\nimport {\n  constructState,\n  getJsxInterface,\n  isMatchingChainId,\n  validateInterfaceContext,\n} from './utils';\nimport type { GetSnap } from '../snaps';\n\nconst MAX_UI_CONTENT_SIZE = 10_000_000; // 10 mb\n\nconst controllerName = 'SnapInterfaceController';\n\nexport type CreateInterface = {\n  type: `${typeof controllerName}:createInterface`;\n  handler: SnapInterfaceController['createInterface'];\n};\n\nexport type GetInterface = {\n  type: `${typeof controllerName}:getInterface`;\n  handler: SnapInterfaceController['getInterface'];\n};\n\nexport type UpdateInterface = {\n  type: `${typeof controllerName}:updateInterface`;\n  handler: SnapInterfaceController['updateInterface'];\n};\n\nexport type DeleteInterface = {\n  type: `${typeof controllerName}:deleteInterface`;\n  handler: SnapInterfaceController['deleteInterface'];\n};\n\nexport type UpdateInterfaceState = {\n  type: `${typeof controllerName}:updateInterfaceState`;\n  handler: SnapInterfaceController['updateInterfaceState'];\n};\n\nexport type ResolveInterface = {\n  type: `${typeof controllerName}:resolveInterface`;\n  handler: SnapInterfaceController['resolveInterface'];\n};\n\ntype AccountsControllerGetAccountByAddressAction = {\n  type: `AccountsController:getAccountByAddress`;\n  handler: (address: string) => InternalAccount | undefined;\n};\n\ntype AccountsControllerGetSelectedMultichainAccountAction = {\n  type: `AccountsController:getSelectedMultichainAccount`;\n  handler: () => InternalAccount;\n};\n\ntype AccountsControllerListMultichainAccountsAction = {\n  type: `AccountsController:listMultichainAccounts`;\n  handler: (chainId?: CaipChainId) => InternalAccount[];\n};\n\nexport type SnapInterfaceControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapInterfaceControllerState\n>;\n\ntype MultichainAssetsControllerGetStateAction = ControllerGetStateAction<\n  'MultichainAssetsController',\n  {\n    assetsMetadata: {\n      [asset: CaipAssetType]: FungibleAssetMetadata;\n    };\n    accountsAssets: { [account: string]: CaipAssetType[] };\n  }\n>;\n\nexport type SnapInterfaceControllerAllowedActions =\n  | TestOrigin\n  | HasApprovalRequest\n  | AcceptRequest\n  | GetSnap\n  | MultichainAssetsControllerGetStateAction\n  | AccountsControllerGetSelectedMultichainAccountAction\n  | AccountsControllerGetAccountByAddressAction\n  | AccountsControllerListMultichainAccountsAction;\n\nexport type SnapInterfaceControllerActions =\n  | CreateInterface\n  | GetInterface\n  | UpdateInterface\n  | DeleteInterface\n  | UpdateInterfaceState\n  | ResolveInterface\n  | SnapInterfaceControllerGetStateAction;\n\nexport type SnapInterfaceControllerStateChangeEvent =\n  ControllerStateChangeEvent<\n    typeof controllerName,\n    SnapInterfaceControllerState\n  >;\n\ntype OtherNotification = { type: string; [key: string]: unknown };\n\nexport type ExpandedView = {\n  title: string;\n  interfaceId: string;\n  footerLink?: { href: string; text: string };\n};\n\ntype NormalSnapNotificationData = { message: string; origin: string };\n\ntype ExpandedSnapNotificationData = {\n  message: string;\n  origin: string;\n  detailedView: ExpandedView;\n};\n\ntype SnapNotification = {\n  type: 'snap';\n  data: NormalSnapNotificationData | ExpandedSnapNotificationData;\n  readDate: string | null;\n};\n\ntype Notification = OtherNotification | SnapNotification;\n\ntype NotificationListUpdatedEvent = {\n  type: 'NotificationServicesController:notificationsListUpdated';\n  payload: [Notification[]];\n};\n\nexport type SnapInterfaceControllerEvents =\n  | SnapInterfaceControllerStateChangeEvent\n  | NotificationListUpdatedEvent;\n\nexport type SnapInterfaceControllerMessenger = Messenger<\n  typeof controllerName,\n  SnapInterfaceControllerActions | SnapInterfaceControllerAllowedActions,\n  SnapInterfaceControllerEvents\n>;\n\nexport type StoredInterface = {\n  snapId: SnapId;\n  content: JSXElement;\n  state: InterfaceState;\n  context: InterfaceContext | null;\n  contentType: ContentType | null;\n};\n\nexport type SnapInterfaceControllerState = {\n  interfaces: Record<string, StoredInterface>;\n};\n\nexport type SnapInterfaceControllerArgs = {\n  messenger: SnapInterfaceControllerMessenger;\n  state?: SnapInterfaceControllerState;\n};\n\n/**\n * Use this controller to manage snaps UI interfaces using RPC method hooks.\n */\nexport class SnapInterfaceController extends BaseController<\n  typeof controllerName,\n  SnapInterfaceControllerState,\n  SnapInterfaceControllerMessenger\n> {\n  constructor({ messenger, state }: SnapInterfaceControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        interfaces: {\n          includeInStateLogs: true,\n          persist: (interfaces: Record<string, StoredInterface>) => {\n            return Object.entries(interfaces).reduce<\n              Record<string, StoredInterface>\n            >((persistedInterfaces, [id, snapInterface]) => {\n              switch (snapInterface.contentType) {\n                case ContentType.Notification:\n                  persistedInterfaces[id] = snapInterface;\n                  return persistedInterfaces;\n                default:\n                  return persistedInterfaces;\n              }\n            }, {});\n          },\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n      },\n      name: controllerName,\n      state: { interfaces: {}, ...state },\n    });\n\n    this.messenger.subscribe(\n      'NotificationServicesController:notificationsListUpdated',\n      this.#onNotificationsListUpdated.bind(this),\n    );\n\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers() {\n    this.messenger.registerActionHandler(\n      `${controllerName}:createInterface`,\n      this.createInterface.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:getInterface`,\n      this.getInterface.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:updateInterface`,\n      this.updateInterface.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:deleteInterface`,\n      this.deleteInterface.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:updateInterfaceState`,\n      this.updateInterfaceState.bind(this),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:resolveInterface`,\n      this.resolveInterface.bind(this),\n    );\n  }\n\n  /**\n   * Create an interface in the controller state with the associated data.\n   *\n   * @param snapId - The snap id that created the interface.\n   * @param content - The interface content.\n   * @param context - An optional interface context object.\n   * @param contentType - The type of content.\n   * @returns The newly interface id.\n   */\n  createInterface(\n    snapId: SnapId,\n    content: ComponentOrElement,\n    context?: InterfaceContext,\n    contentType?: ContentType,\n  ) {\n    const element = getJsxInterface(content);\n    this.#validateContent(element);\n    validateInterfaceContext(context);\n\n    const id = nanoid();\n    const componentState = constructState({}, element, {\n      getAssetsState: this.#getAssetsState.bind(this),\n      getAccountByAddress: this.#getAccountByAddress.bind(this),\n      getSelectedAccount: this.#getSelectedAccount.bind(this),\n      listAccounts: this.#listAccounts.bind(this),\n      snapOwnsAccount: (account: InternalAccount) =>\n        snapOwnsAccount(snapId, account),\n    });\n\n    this.update((draftState) => {\n      // @ts-expect-error - TS2589: Type instantiation is excessively deep and\n      // possibly infinite.\n      draftState.interfaces[id] = {\n        snapId,\n        content: castDraft(element),\n        state: componentState,\n        context: context ?? null,\n        contentType: contentType ?? null,\n      };\n    });\n\n    return id;\n  }\n\n  /**\n   * Get the data of a given interface id.\n   *\n   * @param snapId - The snap id requesting the interface data.\n   * @param id - The interface id.\n   * @returns The interface state.\n   */\n  getInterface(snapId: SnapId, id: string) {\n    this.#validateArgs(snapId, id);\n\n    return this.state.interfaces[id];\n  }\n\n  /**\n   * Update the interface with the given content.\n   *\n   * @param snapId - The snap id requesting the update.\n   * @param id - The interface id.\n   * @param content - The new content.\n   * @param context - An optional interface context object.\n   */\n  updateInterface(\n    snapId: SnapId,\n    id: string,\n    content: ComponentOrElement,\n    context?: InterfaceContext,\n  ) {\n    this.#validateArgs(snapId, id);\n    const element = getJsxInterface(content);\n    this.#validateContent(element);\n    validateInterfaceContext(context);\n\n    const oldState = this.state.interfaces[id].state;\n    const newState = constructState(oldState, element, {\n      getAssetsState: this.#getAssetsState.bind(this),\n      getAccountByAddress: this.#getAccountByAddress.bind(this),\n      getSelectedAccount: this.#getSelectedAccount.bind(this),\n      listAccounts: this.#listAccounts.bind(this),\n      snapOwnsAccount: (account: InternalAccount) =>\n        snapOwnsAccount(snapId, account),\n    });\n\n    this.update((draftState) => {\n      draftState.interfaces[id].state = newState;\n      draftState.interfaces[id].content = castDraft(element);\n      if (context) {\n        draftState.interfaces[id].context = context;\n      }\n    });\n  }\n\n  /**\n   * Delete an interface from state.\n   *\n   * @param id - The interface id.\n   */\n  deleteInterface(id: string) {\n    this.update((draftState) => {\n      delete draftState.interfaces[id];\n    });\n  }\n\n  /**\n   * Update the interface state.\n   *\n   * @param id - The interface id.\n   * @param state - The new state.\n   */\n  updateInterfaceState(id: string, state: InterfaceState) {\n    this.update((draftState) => {\n      draftState.interfaces[id].state = state;\n    });\n  }\n\n  /**\n   * Resolve the promise of a given interface approval request.\n   * The approval needs to have the same ID as the interface.\n   *\n   * @param snapId - The snap id.\n   * @param id - The interface id.\n   * @param value - The value to resolve the promise with.\n   */\n  async resolveInterface(snapId: SnapId, id: string, value: Json) {\n    this.#validateArgs(snapId, id);\n    this.#validateApproval(id);\n\n    await this.#acceptApprovalRequest(id, value);\n\n    this.deleteInterface(id);\n  }\n\n  /**\n   * Utility function to validate the args passed to the other methods.\n   *\n   * @param snapId - The snap id.\n   * @param id - The interface id.\n   */\n  #validateArgs(snapId: SnapId, id: string) {\n    const existingInterface = this.state.interfaces[id];\n\n    assert(\n      existingInterface !== undefined,\n      `Interface with id '${id}' not found.`,\n    );\n    assert(\n      existingInterface.snapId === snapId,\n      `Interface not created by ${snapId}.`,\n    );\n  }\n\n  /**\n   * Utility function to validate that the approval request exists.\n   *\n   * @param id - The interface id.\n   */\n  #validateApproval(id: string) {\n    assert(\n      this.#hasApprovalRequest(id),\n      `Approval request with id '${id}' not found.`,\n    );\n  }\n\n  /**\n   * Check an origin against the phishing list.\n   *\n   * @param origin - The origin to check.\n   * @returns True if the origin is on the phishing list, otherwise false.\n   */\n  #checkPhishingList(origin: string) {\n    return this.messenger.call('PhishingController:testOrigin', origin).result;\n  }\n\n  /**\n   * Check if an approval request exists for a given interface by looking up\n   * if the ApprovalController has a request with the given interface ID.\n   *\n   * @param id - The interface id.\n   * @returns True if an approval request exists, otherwise false.\n   */\n  #hasApprovalRequest(id: string) {\n    return this.messenger.call('ApprovalController:hasRequest', {\n      id,\n    });\n  }\n\n  /**\n   * Accept an approval request for a given interface.\n   *\n   * @param id - The interface id.\n   * @param value - The value to resolve the promise with.\n   */\n  async #acceptApprovalRequest(id: string, value: Json) {\n    await this.messenger.call('ApprovalController:acceptRequest', id, value);\n  }\n\n  /**\n   * Get the selected account in the client.\n   *\n   * @returns The selected account.\n   */\n  #getSelectedAccount() {\n    return this.messenger.call(\n      'AccountsController:getSelectedMultichainAccount',\n    );\n  }\n\n  /**\n   * Get a list of accounts for the given chain IDs.\n   *\n   * @param chainIds - The chain IDs to get the accounts for.\n   * @returns The list of accounts.\n   */\n  #listAccounts(chainIds?: CaipChainId[]) {\n    const accounts = this.messenger.call(\n      'AccountsController:listMultichainAccounts',\n    );\n\n    if (!chainIds || chainIds.length === 0) {\n      return accounts;\n    }\n\n    return accounts.filter((account) =>\n      account.scopes.some((scope) => isMatchingChainId(scope, chainIds)),\n    );\n  }\n\n  /**\n   * Get an account by its address.\n   *\n   * @param address - The account address.\n   * @returns The account or undefined if not found.\n   */\n  #getAccountByAddress(address: CaipAccountId) {\n    const { address: parsedAddress } = parseCaipAccountId(address);\n\n    return this.messenger.call(\n      'AccountsController:getAccountByAddress',\n      parsedAddress,\n    );\n  }\n\n  /**\n   * Get the MultichainAssetsController state.\n   *\n   * @returns The MultichainAssetsController state.\n   */\n  #getAssetsState() {\n    return this.messenger.call('MultichainAssetsController:getState');\n  }\n\n  /**\n   * Get a snap by its id.\n   *\n   * @param id - The snap id.\n   * @returns The snap.\n   */\n  #getSnap(id: string) {\n    return this.messenger.call('SnapController:get', id);\n  }\n\n  /**\n   * Utility function to validate the components of an interface.\n   * Throws if something is invalid.\n   *\n   * @param element - The JSX element to verify.\n   */\n  #validateContent(element: JSXElement) {\n    // We assume the validity of this JSON to be validated by the caller.\n    // E.g., in the RPC method implementation.\n    const size = getJsonSizeUnsafe(element);\n    assert(\n      size <= MAX_UI_CONTENT_SIZE,\n      `A Snap UI may not be larger than ${MAX_UI_CONTENT_SIZE / 1000000} MB.`,\n    );\n\n    validateJsxElements(element, {\n      isOnPhishingList: this.#checkPhishingList.bind(this),\n      getSnap: this.#getSnap.bind(this),\n      getAccountByAddress: this.#getAccountByAddress.bind(this),\n    });\n  }\n\n  #onNotificationsListUpdated(notificationsList: Notification[]) {\n    const snapNotificationsWithInterface = notificationsList.filter(\n      (notification) => {\n        return (\n          notification.type === 'snap' &&\n          hasProperty((notification as SnapNotification).data, 'detailedView')\n        );\n      },\n    );\n\n    const interfaceIdSet = new Set(\n      snapNotificationsWithInterface.map(\n        (notification) =>\n          (\n            (notification as SnapNotification)\n              .data as ExpandedSnapNotificationData\n          ).detailedView.interfaceId,\n      ),\n    );\n\n    this.update((state) => {\n      Object.entries(state.interfaces).forEach(([id, snapInterface]) => {\n        if (\n          snapInterface.contentType === ContentType.Notification &&\n          !interfaceIdSet.has(id)\n        ) {\n          delete state.interfaces[id];\n        }\n      });\n    });\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/multichain/MultichainRouter.cjs.map b/dist/multichain/MultichainRouter.cjs.map
index 252a350f3aa80d29bdd56afe7b21b40f925d9ea3..0317bb374f5882666df4e7bec2d205f7fd5a5be5 100644
--- a/dist/multichain/MultichainRouter.cjs.map
+++ b/dist/multichain/MultichainRouter.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"MultichainRouter.cjs","sourceRoot":"","sources":["../../src/multichain/MultichainRouter.ts"],"names":[],"mappings":"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","sourcesContent":["import type { RestrictedMessenger } from '@metamask/base-controller';\nimport type { GetPermissions } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport {\n  getProtocolCaveatScopes,\n  SnapEndowments,\n} from '@metamask/snaps-rpc-methods';\nimport type { Json, JsonRpcRequest, SnapId } from '@metamask/snaps-sdk';\nimport type { InternalAccount } from '@metamask/snaps-utils';\nimport { HandlerType } from '@metamask/snaps-utils';\nimport type {\n  CaipAccountId,\n  CaipChainId,\n  JsonRpcParams,\n} from '@metamask/utils';\nimport {\n  assert,\n  hasProperty,\n  KnownCaipNamespace,\n  parseCaipAccountId,\n} from '@metamask/utils';\nimport { nanoid } from 'nanoid';\n\nimport { getRunnableSnaps } from '../snaps';\nimport type { GetAllSnaps, HandleSnapRequest } from '../snaps';\n\nexport type MultichainRouterHandleRequestAction = {\n  type: `${typeof name}:handleRequest`;\n  handler: MultichainRouter['handleRequest'];\n};\n\nexport type MultichainRouterGetSupportedMethodsAction = {\n  type: `${typeof name}:getSupportedMethods`;\n  handler: MultichainRouter['getSupportedMethods'];\n};\n\nexport type MultichainRouterGetSupportedAccountsAction = {\n  type: `${typeof name}:getSupportedAccounts`;\n  handler: MultichainRouter['getSupportedAccounts'];\n};\n\nexport type MultichainRouterIsSupportedScopeAction = {\n  type: `${typeof name}:isSupportedScope`;\n  handler: MultichainRouter['isSupportedScope'];\n};\n\ntype SnapKeyring = {\n  submitRequest: (request: {\n    origin: string;\n    account: string;\n    method: string;\n    params?: Json[] | Record<string, Json>;\n    scope: CaipChainId;\n  }) => Promise<Json>;\n  resolveAccountAddress: (\n    snapId: SnapId,\n    scope: CaipChainId,\n    request: Json,\n  ) => Promise<{ address: CaipAccountId } | null>;\n};\n\n// Expecting a bound function that calls KeyringController.withKeyring selecting the Snap keyring\ntype WithSnapKeyringFunction = <ReturnType>(\n  operation: ({ keyring }: { keyring: SnapKeyring }) => Promise<ReturnType>,\n) => Promise<ReturnType>;\n\nexport type AccountsControllerListMultichainAccountsAction = {\n  type: `AccountsController:listMultichainAccounts`;\n  handler: (chainId?: CaipChainId) => InternalAccount[];\n};\n\nexport type MultichainRouterActions =\n  | MultichainRouterHandleRequestAction\n  | MultichainRouterGetSupportedMethodsAction\n  | MultichainRouterGetSupportedAccountsAction\n  | MultichainRouterIsSupportedScopeAction;\n\nexport type MultichainRouterAllowedActions =\n  | GetAllSnaps\n  | HandleSnapRequest\n  | GetPermissions\n  | AccountsControllerListMultichainAccountsAction;\n\nexport type MultichainRouterEvents = never;\n\nexport type MultichainRouterMessenger = RestrictedMessenger<\n  typeof name,\n  MultichainRouterActions | MultichainRouterAllowedActions,\n  never,\n  MultichainRouterAllowedActions['type'],\n  MultichainRouterEvents['type']\n>;\n\nexport type MultichainRouterArgs = {\n  messenger: MultichainRouterMessenger;\n  withSnapKeyring: WithSnapKeyringFunction;\n};\n\ntype ProtocolSnap = {\n  snapId: SnapId;\n  methods: string[];\n};\n\nconst name = 'MultichainRouter';\n\nexport class MultichainRouter {\n  name: typeof name = name;\n\n  state = null;\n\n  readonly #messenger: MultichainRouterMessenger;\n\n  readonly #withSnapKeyring: WithSnapKeyringFunction;\n\n  constructor({ messenger, withSnapKeyring }: MultichainRouterArgs) {\n    this.#messenger = messenger;\n    this.#withSnapKeyring = withSnapKeyring;\n\n    this.#messenger.registerActionHandler(\n      `${name}:handleRequest`,\n      async (...args) => this.handleRequest(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${name}:getSupportedMethods`,\n      (...args) => this.getSupportedMethods(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${name}:getSupportedAccounts`,\n      (...args) => this.getSupportedAccounts(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${name}:isSupportedScope`,\n      (...args) => this.isSupportedScope(...args),\n    );\n  }\n\n  /**\n   * Attempts to resolve the account address to use for a given request by inspecting the request itself.\n   *\n   * The request is sent to to an account Snap via the SnapKeyring that will attempt this resolution.\n   *\n   * @param snapId - The ID of the Snap to send the request to.\n   * @param scope - The CAIP-2 scope for the request.\n   * @param request - The JSON-RPC request.\n   * @returns The resolved address if found, otherwise null.\n   * @throws If the invocation of the SnapKeyring fails.\n   */\n  async #resolveRequestAddress(\n    snapId: SnapId,\n    scope: CaipChainId,\n    request: JsonRpcRequest,\n  ) {\n    try {\n      const result = await this.#withSnapKeyring(async ({ keyring }) =>\n        keyring.resolveAccountAddress(snapId, scope, request),\n      );\n      const address = result?.address;\n      return address ? parseCaipAccountId(address).address : null;\n    } catch {\n      throw rpcErrors.internal();\n    }\n  }\n\n  /**\n   * Get the account ID of the account that should service the RPC request via an account Snap.\n   *\n   * This function checks whether any accounts exist that can service a given request by\n   * using a combination of the resolveAccountAddress functionality and the connected accounts.\n   *\n   * If an account is expected to service this request but none is found, the function will throw.\n   *\n   * @param connectedAddresses - The CAIP-10 addresses connected to the requesting origin.\n   * @param scope - The CAIP-2 scope for the request.\n   * @param request - The JSON-RPC request.\n   * @returns An account ID if found, otherwise null.\n   * @throws If no account is found, but the accounts exist that could service the request.\n   */\n  async #getSnapAccountId(\n    connectedAddresses: CaipAccountId[],\n    scope: CaipChainId,\n    request: JsonRpcRequest,\n  ) {\n    const accounts = this.#messenger\n      .call('AccountsController:listMultichainAccounts', scope)\n      .filter(\n        (\n          account: InternalAccount,\n        ): account is InternalAccount & {\n          metadata: Required<InternalAccount['metadata']>;\n        } =>\n          Boolean(account.metadata.snap?.enabled) &&\n          account.methods.includes(request.method),\n      );\n\n    // If no accounts can service the request, return null.\n    if (accounts.length === 0) {\n      return null;\n    }\n\n    const resolutionSnapId = accounts[0].metadata.snap.id;\n\n    // Attempt to resolve the address that should be used for signing.\n    const address = await this.#resolveRequestAddress(\n      resolutionSnapId,\n      scope,\n      request,\n    );\n\n    const parsedConnectedAddresses = connectedAddresses.map(\n      (connectedAddress) => parseCaipAccountId(connectedAddress).address,\n    );\n\n    // If we have a resolved address, try to find the selected account based on that\n    // otherwise, default to one of the connected accounts.\n    // TODO: Eventually let the user choose if we have more than one option for the account.\n    const selectedAccount = accounts.find(\n      (account) =>\n        parsedConnectedAddresses.includes(account.address) &&\n        (!address || account.address === address),\n    );\n\n    if (!selectedAccount) {\n      throw rpcErrors.invalidParams({\n        message: 'No available account found for request.',\n      });\n    }\n\n    return selectedAccount.id;\n  }\n\n  /**\n   * Get all protocol Snaps that can service a given CAIP-2 scope.\n   *\n   * Protocol Snaps are deemed fit to service a scope if they are runnable\n   * and have the proper permissions set for the scope.\n   *\n   * @param scope - A CAIP-2 scope.\n   * @returns A list of all the protocol Snaps available and their RPC methods.\n   */\n  #getProtocolSnaps(scope: CaipChainId) {\n    const allSnaps = this.#messenger.call('SnapController:getAll');\n    const filteredSnaps = getRunnableSnaps(allSnaps);\n\n    return filteredSnaps.reduce<ProtocolSnap[]>((accumulator, snap) => {\n      const permissions = this.#messenger.call(\n        'PermissionController:getPermissions',\n        snap.id,\n      );\n\n      if (permissions && hasProperty(permissions, SnapEndowments.Protocol)) {\n        const permission = permissions[SnapEndowments.Protocol];\n        const scopes = getProtocolCaveatScopes(permission);\n        if (scopes && hasProperty(scopes, scope)) {\n          accumulator.push({\n            snapId: snap.id,\n            methods: scopes[scope].methods,\n          });\n        }\n      }\n\n      return accumulator;\n    }, []);\n  }\n\n  /**\n   * Handle an incoming JSON-RPC request tied to a specific scope by routing\n   * to either a protocol Snap or an account Snap.\n   *\n   * Note: Addresses are considered case sensitive by the MultichainRouter as\n   * not all non-EVM chains are case insensitive.\n   *\n   * @param options - An options bag.\n   * @param options.connectedAddresses - Addresses currently connected to the origin.\n   * @param options.origin - The origin of the RPC request.\n   * @param options.request - The JSON-RPC request.\n   * @param options.scope - The CAIP-2 scope for the request.\n   * @returns The response from the chosen Snap.\n   * @throws If no handler was found.\n   */\n  async handleRequest({\n    connectedAddresses,\n    origin,\n    scope,\n    request: rawRequest,\n  }: {\n    connectedAddresses: CaipAccountId[];\n    origin: string;\n    scope: CaipChainId;\n    request: JsonRpcRequest;\n  }): Promise<Json> {\n    // Explicitly block EVM scopes, just in case.\n    assert(\n      !scope.startsWith(KnownCaipNamespace.Eip155) &&\n        !scope.startsWith('wallet:eip155'),\n    );\n\n    // Re-create the request to simplify and remove additional properties that may be present in MM middleware.\n    const request = {\n      jsonrpc: '2.0' as const,\n      id: rawRequest.id ?? nanoid(),\n      method: rawRequest.method,\n      ...(rawRequest.params ? { params: rawRequest.params } : {}),\n    };\n\n    const { method, params } = request;\n\n    // If the RPC request can be serviced by an account Snap, route it there.\n    const accountId = await this.#getSnapAccountId(\n      connectedAddresses,\n      scope,\n      request,\n    );\n\n    if (accountId) {\n      return this.#withSnapKeyring(async ({ keyring }) =>\n        keyring.submitRequest({\n          origin,\n          account: accountId,\n          scope,\n          method,\n          params: params as JsonRpcParams,\n        }),\n      );\n    }\n\n    // If the RPC request cannot be serviced by an account Snap,\n    // but has a protocol Snap available, route it there.\n    const protocolSnaps = this.#getProtocolSnaps(scope);\n    const protocolSnap = protocolSnaps.find((snap) =>\n      snap.methods.includes(method),\n    );\n\n    if (protocolSnap) {\n      return this.#messenger.call('SnapController:handleRequest', {\n        snapId: protocolSnap.snapId,\n        origin,\n        request: {\n          method: '',\n          params: {\n            request,\n            scope,\n          },\n        },\n        handler: HandlerType.OnProtocolRequest,\n      }) as Promise<Json>;\n    }\n\n    // If no compatible account or protocol Snaps were found, throw.\n    throw rpcErrors.methodNotFound();\n  }\n\n  /**\n   * Get a list of metadata for supported accounts for a given scope from the client.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns A list of metadata for the supported accounts.\n   */\n  #getSupportedAccountsMetadata(scope: CaipChainId): InternalAccount[] {\n    return this.#messenger\n      .call('AccountsController:listMultichainAccounts', scope)\n      .filter((account: InternalAccount) => account.metadata.snap?.enabled);\n  }\n\n  /**\n   * Get a list of supported methods for a given scope.\n   * This combines both protocol and account Snaps supported methods.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns A list of supported methods.\n   */\n  getSupportedMethods(scope: CaipChainId): string[] {\n    const accountMethods = this.#getSupportedAccountsMetadata(scope).flatMap(\n      (account) => account.methods,\n    );\n\n    const protocolMethods = this.#getProtocolSnaps(scope).flatMap(\n      (snap) => snap.methods,\n    );\n\n    return Array.from(new Set([...accountMethods, ...protocolMethods]));\n  }\n\n  /**\n   * Get a list of supported accounts for a given scope.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns A list of CAIP-10 addresses.\n   */\n  getSupportedAccounts(scope: CaipChainId): string[] {\n    return this.#getSupportedAccountsMetadata(scope).map(\n      (account) => `${scope}:${account.address}`,\n    );\n  }\n\n  /**\n   * Determine whether a given CAIP-2 scope is supported by the router.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns True if the router can service the scope, otherwise false.\n   */\n  isSupportedScope(scope: CaipChainId): boolean {\n    const hasAccountSnap = this.#messenger\n      .call('AccountsController:listMultichainAccounts', scope)\n      .some((account: InternalAccount) => account.metadata.snap?.enabled);\n    // We currently assume here that if one Snap exists that service the scope, we can service the scope generally.\n    return hasAccountSnap || this.#getProtocolSnaps(scope).length > 0;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"MultichainRouter.cjs","sourceRoot":"","sources":["../../src/multichain/MultichainRouter.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Messenger } from '@metamask/messenger';\nimport type { GetPermissions } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport {\n  getProtocolCaveatScopes,\n  SnapEndowments,\n} from '@metamask/snaps-rpc-methods';\nimport type { Json, JsonRpcRequest, SnapId } from '@metamask/snaps-sdk';\nimport type { InternalAccount } from '@metamask/snaps-utils';\nimport { HandlerType } from '@metamask/snaps-utils';\nimport type {\n  CaipAccountId,\n  CaipChainId,\n  JsonRpcParams,\n} from '@metamask/utils';\nimport {\n  assert,\n  hasProperty,\n  KnownCaipNamespace,\n  parseCaipAccountId,\n} from '@metamask/utils';\nimport { nanoid } from 'nanoid';\n\nimport { getRunnableSnaps } from '../snaps';\nimport type { GetAllSnaps, HandleSnapRequest } from '../snaps';\n\nexport type MultichainRouterHandleRequestAction = {\n  type: `${typeof name}:handleRequest`;\n  handler: MultichainRouter['handleRequest'];\n};\n\nexport type MultichainRouterGetSupportedMethodsAction = {\n  type: `${typeof name}:getSupportedMethods`;\n  handler: MultichainRouter['getSupportedMethods'];\n};\n\nexport type MultichainRouterGetSupportedAccountsAction = {\n  type: `${typeof name}:getSupportedAccounts`;\n  handler: MultichainRouter['getSupportedAccounts'];\n};\n\nexport type MultichainRouterIsSupportedScopeAction = {\n  type: `${typeof name}:isSupportedScope`;\n  handler: MultichainRouter['isSupportedScope'];\n};\n\ntype SnapKeyring = {\n  submitRequest: (request: {\n    origin: string;\n    account: string;\n    method: string;\n    params?: Json[] | Record<string, Json>;\n    scope: CaipChainId;\n  }) => Promise<Json>;\n  resolveAccountAddress: (\n    snapId: SnapId,\n    scope: CaipChainId,\n    request: Json,\n  ) => Promise<{ address: CaipAccountId } | null>;\n};\n\n// Expecting a bound function that calls KeyringController.withKeyring selecting the Snap keyring\nexport type WithSnapKeyringFunction = <ReturnType>(\n  operation: ({ keyring }: { keyring: SnapKeyring }) => Promise<ReturnType>,\n) => Promise<ReturnType>;\n\nexport type AccountsControllerListMultichainAccountsAction = {\n  type: `AccountsController:listMultichainAccounts`;\n  handler: (chainId?: CaipChainId) => InternalAccount[];\n};\n\nexport type MultichainRouterActions =\n  | MultichainRouterHandleRequestAction\n  | MultichainRouterGetSupportedMethodsAction\n  | MultichainRouterGetSupportedAccountsAction\n  | MultichainRouterIsSupportedScopeAction;\n\nexport type MultichainRouterAllowedActions =\n  | GetAllSnaps\n  | HandleSnapRequest\n  | GetPermissions\n  | AccountsControllerListMultichainAccountsAction;\n\nexport type MultichainRouterEvents = never;\n\nexport type MultichainRouterMessenger = Messenger<\n  typeof name,\n  MultichainRouterActions | MultichainRouterAllowedActions\n>;\n\nexport type MultichainRouterArgs = {\n  messenger: MultichainRouterMessenger;\n  withSnapKeyring: WithSnapKeyringFunction;\n};\n\ntype ProtocolSnap = {\n  snapId: SnapId;\n  methods: string[];\n};\n\nconst name = 'MultichainRouter';\n\nexport class MultichainRouter {\n  name: typeof name = name;\n\n  state = null;\n\n  readonly #messenger: MultichainRouterMessenger;\n\n  readonly #withSnapKeyring: WithSnapKeyringFunction;\n\n  constructor({ messenger, withSnapKeyring }: MultichainRouterArgs) {\n    this.#messenger = messenger;\n    this.#withSnapKeyring = withSnapKeyring;\n\n    this.#messenger.registerActionHandler(\n      `${name}:handleRequest`,\n      async (...args) => this.handleRequest(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${name}:getSupportedMethods`,\n      (...args) => this.getSupportedMethods(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${name}:getSupportedAccounts`,\n      (...args) => this.getSupportedAccounts(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${name}:isSupportedScope`,\n      (...args) => this.isSupportedScope(...args),\n    );\n  }\n\n  /**\n   * Attempts to resolve the account address to use for a given request by inspecting the request itself.\n   *\n   * The request is sent to to an account Snap via the SnapKeyring that will attempt this resolution.\n   *\n   * @param snapId - The ID of the Snap to send the request to.\n   * @param scope - The CAIP-2 scope for the request.\n   * @param request - The JSON-RPC request.\n   * @returns The resolved address if found, otherwise null.\n   * @throws If the invocation of the SnapKeyring fails.\n   */\n  async #resolveRequestAddress(\n    snapId: SnapId,\n    scope: CaipChainId,\n    request: JsonRpcRequest,\n  ) {\n    try {\n      const result = await this.#withSnapKeyring(async ({ keyring }) =>\n        keyring.resolveAccountAddress(snapId, scope, request),\n      );\n      const address = result?.address;\n      return address ? parseCaipAccountId(address).address : null;\n    } catch {\n      throw rpcErrors.internal();\n    }\n  }\n\n  /**\n   * Get the account ID of the account that should service the RPC request via an account Snap.\n   *\n   * This function checks whether any accounts exist that can service a given request by\n   * using a combination of the resolveAccountAddress functionality and the connected accounts.\n   *\n   * If an account is expected to service this request but none is found, the function will throw.\n   *\n   * @param connectedAddresses - The CAIP-10 addresses connected to the requesting origin.\n   * @param scope - The CAIP-2 scope for the request.\n   * @param request - The JSON-RPC request.\n   * @returns An account ID if found, otherwise null.\n   * @throws If no account is found, but the accounts exist that could service the request.\n   */\n  async #getSnapAccountId(\n    connectedAddresses: CaipAccountId[],\n    scope: CaipChainId,\n    request: JsonRpcRequest,\n  ) {\n    const accounts = this.#messenger\n      .call('AccountsController:listMultichainAccounts', scope)\n      .filter(\n        (\n          account: InternalAccount,\n        ): account is InternalAccount & {\n          metadata: Required<InternalAccount['metadata']>;\n        } =>\n          Boolean(account.metadata.snap?.enabled) &&\n          account.methods.includes(request.method),\n      );\n\n    // If no accounts can service the request, return null.\n    if (accounts.length === 0) {\n      return null;\n    }\n\n    const resolutionSnapId = accounts[0].metadata.snap.id;\n\n    // Attempt to resolve the address that should be used for signing.\n    const address = await this.#resolveRequestAddress(\n      resolutionSnapId,\n      scope,\n      request,\n    );\n\n    const parsedConnectedAddresses = connectedAddresses.map(\n      (connectedAddress) => parseCaipAccountId(connectedAddress).address,\n    );\n\n    // If we have a resolved address, try to find the selected account based on that\n    // otherwise, default to one of the connected accounts.\n    // TODO: Eventually let the user choose if we have more than one option for the account.\n    const selectedAccount = accounts.find(\n      (account) =>\n        parsedConnectedAddresses.includes(account.address) &&\n        (!address || account.address === address),\n    );\n\n    if (!selectedAccount) {\n      throw rpcErrors.invalidParams({\n        message: 'No available account found for request.',\n      });\n    }\n\n    return selectedAccount.id;\n  }\n\n  /**\n   * Get all protocol Snaps that can service a given CAIP-2 scope.\n   *\n   * Protocol Snaps are deemed fit to service a scope if they are runnable\n   * and have the proper permissions set for the scope.\n   *\n   * @param scope - A CAIP-2 scope.\n   * @returns A list of all the protocol Snaps available and their RPC methods.\n   */\n  #getProtocolSnaps(scope: CaipChainId) {\n    const allSnaps = this.#messenger.call('SnapController:getAll');\n    const filteredSnaps = getRunnableSnaps(allSnaps);\n\n    return filteredSnaps.reduce<ProtocolSnap[]>((accumulator, snap) => {\n      const permissions = this.#messenger.call(\n        'PermissionController:getPermissions',\n        snap.id,\n      );\n\n      if (permissions && hasProperty(permissions, SnapEndowments.Protocol)) {\n        const permission = permissions[SnapEndowments.Protocol];\n        const scopes = getProtocolCaveatScopes(permission);\n        if (scopes && hasProperty(scopes, scope)) {\n          accumulator.push({\n            snapId: snap.id,\n            methods: scopes[scope].methods,\n          });\n        }\n      }\n\n      return accumulator;\n    }, []);\n  }\n\n  /**\n   * Handle an incoming JSON-RPC request tied to a specific scope by routing\n   * to either a protocol Snap or an account Snap.\n   *\n   * Note: Addresses are considered case sensitive by the MultichainRouter as\n   * not all non-EVM chains are case insensitive.\n   *\n   * @param options - An options bag.\n   * @param options.connectedAddresses - Addresses currently connected to the origin.\n   * @param options.origin - The origin of the RPC request.\n   * @param options.request - The JSON-RPC request.\n   * @param options.scope - The CAIP-2 scope for the request.\n   * @returns The response from the chosen Snap.\n   * @throws If no handler was found.\n   */\n  async handleRequest({\n    connectedAddresses,\n    origin,\n    scope,\n    request: rawRequest,\n  }: {\n    connectedAddresses: CaipAccountId[];\n    origin: string;\n    scope: CaipChainId;\n    request: JsonRpcRequest;\n  }): Promise<Json> {\n    // Explicitly block EVM scopes, just in case.\n    assert(\n      !scope.startsWith(KnownCaipNamespace.Eip155) &&\n        !scope.startsWith('wallet:eip155'),\n    );\n\n    // Re-create the request to simplify and remove additional properties that may be present in MM middleware.\n    const request = {\n      jsonrpc: '2.0' as const,\n      id: rawRequest.id ?? nanoid(),\n      method: rawRequest.method,\n      ...(rawRequest.params ? { params: rawRequest.params } : {}),\n    };\n\n    const { method, params } = request;\n\n    // If the RPC request can be serviced by an account Snap, route it there.\n    const accountId = await this.#getSnapAccountId(\n      connectedAddresses,\n      scope,\n      request,\n    );\n\n    if (accountId) {\n      return this.#withSnapKeyring(async ({ keyring }) =>\n        keyring.submitRequest({\n          origin,\n          account: accountId,\n          scope,\n          method,\n          params: params as JsonRpcParams,\n        }),\n      );\n    }\n\n    // If the RPC request cannot be serviced by an account Snap,\n    // but has a protocol Snap available, route it there.\n    const protocolSnaps = this.#getProtocolSnaps(scope);\n    const protocolSnap = protocolSnaps.find((snap) =>\n      snap.methods.includes(method),\n    );\n\n    if (protocolSnap) {\n      return this.#messenger.call('SnapController:handleRequest', {\n        snapId: protocolSnap.snapId,\n        origin,\n        request: {\n          method: '',\n          params: {\n            request,\n            scope,\n          },\n        },\n        handler: HandlerType.OnProtocolRequest,\n      }) as Promise<Json>;\n    }\n\n    // If no compatible account or protocol Snaps were found, throw.\n    throw rpcErrors.methodNotFound();\n  }\n\n  /**\n   * Get a list of metadata for supported accounts for a given scope from the client.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns A list of metadata for the supported accounts.\n   */\n  #getSupportedAccountsMetadata(scope: CaipChainId): InternalAccount[] {\n    return this.#messenger\n      .call('AccountsController:listMultichainAccounts', scope)\n      .filter((account: InternalAccount) => account.metadata.snap?.enabled);\n  }\n\n  /**\n   * Get a list of supported methods for a given scope.\n   * This combines both protocol and account Snaps supported methods.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns A list of supported methods.\n   */\n  getSupportedMethods(scope: CaipChainId): string[] {\n    const accountMethods = this.#getSupportedAccountsMetadata(scope).flatMap(\n      (account) => account.methods,\n    );\n\n    const protocolMethods = this.#getProtocolSnaps(scope).flatMap(\n      (snap) => snap.methods,\n    );\n\n    return Array.from(new Set([...accountMethods, ...protocolMethods]));\n  }\n\n  /**\n   * Get a list of supported accounts for a given scope.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns A list of CAIP-10 addresses.\n   */\n  getSupportedAccounts(scope: CaipChainId): string[] {\n    return this.#getSupportedAccountsMetadata(scope).map(\n      (account) => `${scope}:${account.address}`,\n    );\n  }\n\n  /**\n   * Determine whether a given CAIP-2 scope is supported by the router.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns True if the router can service the scope, otherwise false.\n   */\n  isSupportedScope(scope: CaipChainId): boolean {\n    const hasAccountSnap = this.#messenger\n      .call('AccountsController:listMultichainAccounts', scope)\n      .some((account: InternalAccount) => account.metadata.snap?.enabled);\n    // We currently assume here that if one Snap exists that service the scope, we can service the scope generally.\n    return hasAccountSnap || this.#getProtocolSnaps(scope).length > 0;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/multichain/MultichainRouter.d.cts b/dist/multichain/MultichainRouter.d.cts
index bd5daa4deb2a04af3ffb21821799ba3aad7435db..3861e24a182cd7222959bcdec037fe4a5762e23f 100644
--- a/dist/multichain/MultichainRouter.d.cts
+++ b/dist/multichain/MultichainRouter.d.cts
@@ -1,4 +1,4 @@
-import type { RestrictedMessenger } from "@metamask/base-controller";
+import type { Messenger } from "@metamask/messenger";
 import type { GetPermissions } from "@metamask/permission-controller";
 import type { Json, JsonRpcRequest, SnapId } from "@metamask/snaps-sdk";
 import type { InternalAccount } from "@metamask/snaps-utils";
@@ -32,7 +32,7 @@ type SnapKeyring = {
         address: CaipAccountId;
     } | null>;
 };
-type WithSnapKeyringFunction = <ReturnType>(operation: ({ keyring }: {
+export type WithSnapKeyringFunction = <ReturnType>(operation: ({ keyring }: {
     keyring: SnapKeyring;
 }) => Promise<ReturnType>) => Promise<ReturnType>;
 export type AccountsControllerListMultichainAccountsAction = {
@@ -42,7 +42,7 @@ export type AccountsControllerListMultichainAccountsAction = {
 export type MultichainRouterActions = MultichainRouterHandleRequestAction | MultichainRouterGetSupportedMethodsAction | MultichainRouterGetSupportedAccountsAction | MultichainRouterIsSupportedScopeAction;
 export type MultichainRouterAllowedActions = GetAllSnaps | HandleSnapRequest | GetPermissions | AccountsControllerListMultichainAccountsAction;
 export type MultichainRouterEvents = never;
-export type MultichainRouterMessenger = RestrictedMessenger<typeof name, MultichainRouterActions | MultichainRouterAllowedActions, never, MultichainRouterAllowedActions['type'], MultichainRouterEvents['type']>;
+export type MultichainRouterMessenger = Messenger<typeof name, MultichainRouterActions | MultichainRouterAllowedActions>;
 export type MultichainRouterArgs = {
     messenger: MultichainRouterMessenger;
     withSnapKeyring: WithSnapKeyringFunction;
diff --git a/dist/multichain/MultichainRouter.d.cts.map b/dist/multichain/MultichainRouter.d.cts.map
index b84c91dc71d85b21a665885e33e17959c6ce3ccf..fa11f728f4bd12cc5877e54384b43cba8c7836da 100644
--- a/dist/multichain/MultichainRouter.d.cts.map
+++ b/dist/multichain/MultichainRouter.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"MultichainRouter.d.cts","sourceRoot":"","sources":["../../src/multichain/MultichainRouter.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"MultichainRouter.d.cts","sourceRoot":"","sources":["../../src/multichain/MultichainRouter.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/multichain/MultichainRouter.d.mts b/dist/multichain/MultichainRouter.d.mts
index 19fbe55be1d645be2646d0823af0ed7b035b83c4..943a1c7d3f49da5d501c47404b4b2dd7847af71d 100644
--- a/dist/multichain/MultichainRouter.d.mts
+++ b/dist/multichain/MultichainRouter.d.mts
@@ -1,4 +1,4 @@
-import type { RestrictedMessenger } from "@metamask/base-controller";
+import type { Messenger } from "@metamask/messenger";
 import type { GetPermissions } from "@metamask/permission-controller";
 import type { Json, JsonRpcRequest, SnapId } from "@metamask/snaps-sdk";
 import type { InternalAccount } from "@metamask/snaps-utils";
@@ -32,7 +32,7 @@ type SnapKeyring = {
         address: CaipAccountId;
     } | null>;
 };
-type WithSnapKeyringFunction = <ReturnType>(operation: ({ keyring }: {
+export type WithSnapKeyringFunction = <ReturnType>(operation: ({ keyring }: {
     keyring: SnapKeyring;
 }) => Promise<ReturnType>) => Promise<ReturnType>;
 export type AccountsControllerListMultichainAccountsAction = {
@@ -42,7 +42,7 @@ export type AccountsControllerListMultichainAccountsAction = {
 export type MultichainRouterActions = MultichainRouterHandleRequestAction | MultichainRouterGetSupportedMethodsAction | MultichainRouterGetSupportedAccountsAction | MultichainRouterIsSupportedScopeAction;
 export type MultichainRouterAllowedActions = GetAllSnaps | HandleSnapRequest | GetPermissions | AccountsControllerListMultichainAccountsAction;
 export type MultichainRouterEvents = never;
-export type MultichainRouterMessenger = RestrictedMessenger<typeof name, MultichainRouterActions | MultichainRouterAllowedActions, never, MultichainRouterAllowedActions['type'], MultichainRouterEvents['type']>;
+export type MultichainRouterMessenger = Messenger<typeof name, MultichainRouterActions | MultichainRouterAllowedActions>;
 export type MultichainRouterArgs = {
     messenger: MultichainRouterMessenger;
     withSnapKeyring: WithSnapKeyringFunction;
diff --git a/dist/multichain/MultichainRouter.d.mts.map b/dist/multichain/MultichainRouter.d.mts.map
index 34a177f343059ce745bb3fedb62c9eec6dadf4d2..02e1d1cbd29a2b04091d902cf6214002ff83a183 100644
--- a/dist/multichain/MultichainRouter.d.mts.map
+++ b/dist/multichain/MultichainRouter.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"MultichainRouter.d.mts","sourceRoot":"","sources":["../../src/multichain/MultichainRouter.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"MultichainRouter.d.mts","sourceRoot":"","sources":["../../src/multichain/MultichainRouter.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/multichain/MultichainRouter.mjs.map b/dist/multichain/MultichainRouter.mjs.map
index 3ada8acb0d611d0e66ccaf1c5f1fa7c920699737..71c997635d49d10ed386634b3ef1a2e641b6baaf 100644
--- a/dist/multichain/MultichainRouter.mjs.map
+++ b/dist/multichain/MultichainRouter.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"MultichainRouter.mjs","sourceRoot":"","sources":["../../src/multichain/MultichainRouter.ts"],"names":[],"mappings":"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","sourcesContent":["import type { RestrictedMessenger } from '@metamask/base-controller';\nimport type { GetPermissions } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport {\n  getProtocolCaveatScopes,\n  SnapEndowments,\n} from '@metamask/snaps-rpc-methods';\nimport type { Json, JsonRpcRequest, SnapId } from '@metamask/snaps-sdk';\nimport type { InternalAccount } from '@metamask/snaps-utils';\nimport { HandlerType } from '@metamask/snaps-utils';\nimport type {\n  CaipAccountId,\n  CaipChainId,\n  JsonRpcParams,\n} from '@metamask/utils';\nimport {\n  assert,\n  hasProperty,\n  KnownCaipNamespace,\n  parseCaipAccountId,\n} from '@metamask/utils';\nimport { nanoid } from 'nanoid';\n\nimport { getRunnableSnaps } from '../snaps';\nimport type { GetAllSnaps, HandleSnapRequest } from '../snaps';\n\nexport type MultichainRouterHandleRequestAction = {\n  type: `${typeof name}:handleRequest`;\n  handler: MultichainRouter['handleRequest'];\n};\n\nexport type MultichainRouterGetSupportedMethodsAction = {\n  type: `${typeof name}:getSupportedMethods`;\n  handler: MultichainRouter['getSupportedMethods'];\n};\n\nexport type MultichainRouterGetSupportedAccountsAction = {\n  type: `${typeof name}:getSupportedAccounts`;\n  handler: MultichainRouter['getSupportedAccounts'];\n};\n\nexport type MultichainRouterIsSupportedScopeAction = {\n  type: `${typeof name}:isSupportedScope`;\n  handler: MultichainRouter['isSupportedScope'];\n};\n\ntype SnapKeyring = {\n  submitRequest: (request: {\n    origin: string;\n    account: string;\n    method: string;\n    params?: Json[] | Record<string, Json>;\n    scope: CaipChainId;\n  }) => Promise<Json>;\n  resolveAccountAddress: (\n    snapId: SnapId,\n    scope: CaipChainId,\n    request: Json,\n  ) => Promise<{ address: CaipAccountId } | null>;\n};\n\n// Expecting a bound function that calls KeyringController.withKeyring selecting the Snap keyring\ntype WithSnapKeyringFunction = <ReturnType>(\n  operation: ({ keyring }: { keyring: SnapKeyring }) => Promise<ReturnType>,\n) => Promise<ReturnType>;\n\nexport type AccountsControllerListMultichainAccountsAction = {\n  type: `AccountsController:listMultichainAccounts`;\n  handler: (chainId?: CaipChainId) => InternalAccount[];\n};\n\nexport type MultichainRouterActions =\n  | MultichainRouterHandleRequestAction\n  | MultichainRouterGetSupportedMethodsAction\n  | MultichainRouterGetSupportedAccountsAction\n  | MultichainRouterIsSupportedScopeAction;\n\nexport type MultichainRouterAllowedActions =\n  | GetAllSnaps\n  | HandleSnapRequest\n  | GetPermissions\n  | AccountsControllerListMultichainAccountsAction;\n\nexport type MultichainRouterEvents = never;\n\nexport type MultichainRouterMessenger = RestrictedMessenger<\n  typeof name,\n  MultichainRouterActions | MultichainRouterAllowedActions,\n  never,\n  MultichainRouterAllowedActions['type'],\n  MultichainRouterEvents['type']\n>;\n\nexport type MultichainRouterArgs = {\n  messenger: MultichainRouterMessenger;\n  withSnapKeyring: WithSnapKeyringFunction;\n};\n\ntype ProtocolSnap = {\n  snapId: SnapId;\n  methods: string[];\n};\n\nconst name = 'MultichainRouter';\n\nexport class MultichainRouter {\n  name: typeof name = name;\n\n  state = null;\n\n  readonly #messenger: MultichainRouterMessenger;\n\n  readonly #withSnapKeyring: WithSnapKeyringFunction;\n\n  constructor({ messenger, withSnapKeyring }: MultichainRouterArgs) {\n    this.#messenger = messenger;\n    this.#withSnapKeyring = withSnapKeyring;\n\n    this.#messenger.registerActionHandler(\n      `${name}:handleRequest`,\n      async (...args) => this.handleRequest(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${name}:getSupportedMethods`,\n      (...args) => this.getSupportedMethods(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${name}:getSupportedAccounts`,\n      (...args) => this.getSupportedAccounts(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${name}:isSupportedScope`,\n      (...args) => this.isSupportedScope(...args),\n    );\n  }\n\n  /**\n   * Attempts to resolve the account address to use for a given request by inspecting the request itself.\n   *\n   * The request is sent to to an account Snap via the SnapKeyring that will attempt this resolution.\n   *\n   * @param snapId - The ID of the Snap to send the request to.\n   * @param scope - The CAIP-2 scope for the request.\n   * @param request - The JSON-RPC request.\n   * @returns The resolved address if found, otherwise null.\n   * @throws If the invocation of the SnapKeyring fails.\n   */\n  async #resolveRequestAddress(\n    snapId: SnapId,\n    scope: CaipChainId,\n    request: JsonRpcRequest,\n  ) {\n    try {\n      const result = await this.#withSnapKeyring(async ({ keyring }) =>\n        keyring.resolveAccountAddress(snapId, scope, request),\n      );\n      const address = result?.address;\n      return address ? parseCaipAccountId(address).address : null;\n    } catch {\n      throw rpcErrors.internal();\n    }\n  }\n\n  /**\n   * Get the account ID of the account that should service the RPC request via an account Snap.\n   *\n   * This function checks whether any accounts exist that can service a given request by\n   * using a combination of the resolveAccountAddress functionality and the connected accounts.\n   *\n   * If an account is expected to service this request but none is found, the function will throw.\n   *\n   * @param connectedAddresses - The CAIP-10 addresses connected to the requesting origin.\n   * @param scope - The CAIP-2 scope for the request.\n   * @param request - The JSON-RPC request.\n   * @returns An account ID if found, otherwise null.\n   * @throws If no account is found, but the accounts exist that could service the request.\n   */\n  async #getSnapAccountId(\n    connectedAddresses: CaipAccountId[],\n    scope: CaipChainId,\n    request: JsonRpcRequest,\n  ) {\n    const accounts = this.#messenger\n      .call('AccountsController:listMultichainAccounts', scope)\n      .filter(\n        (\n          account: InternalAccount,\n        ): account is InternalAccount & {\n          metadata: Required<InternalAccount['metadata']>;\n        } =>\n          Boolean(account.metadata.snap?.enabled) &&\n          account.methods.includes(request.method),\n      );\n\n    // If no accounts can service the request, return null.\n    if (accounts.length === 0) {\n      return null;\n    }\n\n    const resolutionSnapId = accounts[0].metadata.snap.id;\n\n    // Attempt to resolve the address that should be used for signing.\n    const address = await this.#resolveRequestAddress(\n      resolutionSnapId,\n      scope,\n      request,\n    );\n\n    const parsedConnectedAddresses = connectedAddresses.map(\n      (connectedAddress) => parseCaipAccountId(connectedAddress).address,\n    );\n\n    // If we have a resolved address, try to find the selected account based on that\n    // otherwise, default to one of the connected accounts.\n    // TODO: Eventually let the user choose if we have more than one option for the account.\n    const selectedAccount = accounts.find(\n      (account) =>\n        parsedConnectedAddresses.includes(account.address) &&\n        (!address || account.address === address),\n    );\n\n    if (!selectedAccount) {\n      throw rpcErrors.invalidParams({\n        message: 'No available account found for request.',\n      });\n    }\n\n    return selectedAccount.id;\n  }\n\n  /**\n   * Get all protocol Snaps that can service a given CAIP-2 scope.\n   *\n   * Protocol Snaps are deemed fit to service a scope if they are runnable\n   * and have the proper permissions set for the scope.\n   *\n   * @param scope - A CAIP-2 scope.\n   * @returns A list of all the protocol Snaps available and their RPC methods.\n   */\n  #getProtocolSnaps(scope: CaipChainId) {\n    const allSnaps = this.#messenger.call('SnapController:getAll');\n    const filteredSnaps = getRunnableSnaps(allSnaps);\n\n    return filteredSnaps.reduce<ProtocolSnap[]>((accumulator, snap) => {\n      const permissions = this.#messenger.call(\n        'PermissionController:getPermissions',\n        snap.id,\n      );\n\n      if (permissions && hasProperty(permissions, SnapEndowments.Protocol)) {\n        const permission = permissions[SnapEndowments.Protocol];\n        const scopes = getProtocolCaveatScopes(permission);\n        if (scopes && hasProperty(scopes, scope)) {\n          accumulator.push({\n            snapId: snap.id,\n            methods: scopes[scope].methods,\n          });\n        }\n      }\n\n      return accumulator;\n    }, []);\n  }\n\n  /**\n   * Handle an incoming JSON-RPC request tied to a specific scope by routing\n   * to either a protocol Snap or an account Snap.\n   *\n   * Note: Addresses are considered case sensitive by the MultichainRouter as\n   * not all non-EVM chains are case insensitive.\n   *\n   * @param options - An options bag.\n   * @param options.connectedAddresses - Addresses currently connected to the origin.\n   * @param options.origin - The origin of the RPC request.\n   * @param options.request - The JSON-RPC request.\n   * @param options.scope - The CAIP-2 scope for the request.\n   * @returns The response from the chosen Snap.\n   * @throws If no handler was found.\n   */\n  async handleRequest({\n    connectedAddresses,\n    origin,\n    scope,\n    request: rawRequest,\n  }: {\n    connectedAddresses: CaipAccountId[];\n    origin: string;\n    scope: CaipChainId;\n    request: JsonRpcRequest;\n  }): Promise<Json> {\n    // Explicitly block EVM scopes, just in case.\n    assert(\n      !scope.startsWith(KnownCaipNamespace.Eip155) &&\n        !scope.startsWith('wallet:eip155'),\n    );\n\n    // Re-create the request to simplify and remove additional properties that may be present in MM middleware.\n    const request = {\n      jsonrpc: '2.0' as const,\n      id: rawRequest.id ?? nanoid(),\n      method: rawRequest.method,\n      ...(rawRequest.params ? { params: rawRequest.params } : {}),\n    };\n\n    const { method, params } = request;\n\n    // If the RPC request can be serviced by an account Snap, route it there.\n    const accountId = await this.#getSnapAccountId(\n      connectedAddresses,\n      scope,\n      request,\n    );\n\n    if (accountId) {\n      return this.#withSnapKeyring(async ({ keyring }) =>\n        keyring.submitRequest({\n          origin,\n          account: accountId,\n          scope,\n          method,\n          params: params as JsonRpcParams,\n        }),\n      );\n    }\n\n    // If the RPC request cannot be serviced by an account Snap,\n    // but has a protocol Snap available, route it there.\n    const protocolSnaps = this.#getProtocolSnaps(scope);\n    const protocolSnap = protocolSnaps.find((snap) =>\n      snap.methods.includes(method),\n    );\n\n    if (protocolSnap) {\n      return this.#messenger.call('SnapController:handleRequest', {\n        snapId: protocolSnap.snapId,\n        origin,\n        request: {\n          method: '',\n          params: {\n            request,\n            scope,\n          },\n        },\n        handler: HandlerType.OnProtocolRequest,\n      }) as Promise<Json>;\n    }\n\n    // If no compatible account or protocol Snaps were found, throw.\n    throw rpcErrors.methodNotFound();\n  }\n\n  /**\n   * Get a list of metadata for supported accounts for a given scope from the client.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns A list of metadata for the supported accounts.\n   */\n  #getSupportedAccountsMetadata(scope: CaipChainId): InternalAccount[] {\n    return this.#messenger\n      .call('AccountsController:listMultichainAccounts', scope)\n      .filter((account: InternalAccount) => account.metadata.snap?.enabled);\n  }\n\n  /**\n   * Get a list of supported methods for a given scope.\n   * This combines both protocol and account Snaps supported methods.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns A list of supported methods.\n   */\n  getSupportedMethods(scope: CaipChainId): string[] {\n    const accountMethods = this.#getSupportedAccountsMetadata(scope).flatMap(\n      (account) => account.methods,\n    );\n\n    const protocolMethods = this.#getProtocolSnaps(scope).flatMap(\n      (snap) => snap.methods,\n    );\n\n    return Array.from(new Set([...accountMethods, ...protocolMethods]));\n  }\n\n  /**\n   * Get a list of supported accounts for a given scope.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns A list of CAIP-10 addresses.\n   */\n  getSupportedAccounts(scope: CaipChainId): string[] {\n    return this.#getSupportedAccountsMetadata(scope).map(\n      (account) => `${scope}:${account.address}`,\n    );\n  }\n\n  /**\n   * Determine whether a given CAIP-2 scope is supported by the router.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns True if the router can service the scope, otherwise false.\n   */\n  isSupportedScope(scope: CaipChainId): boolean {\n    const hasAccountSnap = this.#messenger\n      .call('AccountsController:listMultichainAccounts', scope)\n      .some((account: InternalAccount) => account.metadata.snap?.enabled);\n    // We currently assume here that if one Snap exists that service the scope, we can service the scope generally.\n    return hasAccountSnap || this.#getProtocolSnaps(scope).length > 0;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"MultichainRouter.mjs","sourceRoot":"","sources":["../../src/multichain/MultichainRouter.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Messenger } from '@metamask/messenger';\nimport type { GetPermissions } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport {\n  getProtocolCaveatScopes,\n  SnapEndowments,\n} from '@metamask/snaps-rpc-methods';\nimport type { Json, JsonRpcRequest, SnapId } from '@metamask/snaps-sdk';\nimport type { InternalAccount } from '@metamask/snaps-utils';\nimport { HandlerType } from '@metamask/snaps-utils';\nimport type {\n  CaipAccountId,\n  CaipChainId,\n  JsonRpcParams,\n} from '@metamask/utils';\nimport {\n  assert,\n  hasProperty,\n  KnownCaipNamespace,\n  parseCaipAccountId,\n} from '@metamask/utils';\nimport { nanoid } from 'nanoid';\n\nimport { getRunnableSnaps } from '../snaps';\nimport type { GetAllSnaps, HandleSnapRequest } from '../snaps';\n\nexport type MultichainRouterHandleRequestAction = {\n  type: `${typeof name}:handleRequest`;\n  handler: MultichainRouter['handleRequest'];\n};\n\nexport type MultichainRouterGetSupportedMethodsAction = {\n  type: `${typeof name}:getSupportedMethods`;\n  handler: MultichainRouter['getSupportedMethods'];\n};\n\nexport type MultichainRouterGetSupportedAccountsAction = {\n  type: `${typeof name}:getSupportedAccounts`;\n  handler: MultichainRouter['getSupportedAccounts'];\n};\n\nexport type MultichainRouterIsSupportedScopeAction = {\n  type: `${typeof name}:isSupportedScope`;\n  handler: MultichainRouter['isSupportedScope'];\n};\n\ntype SnapKeyring = {\n  submitRequest: (request: {\n    origin: string;\n    account: string;\n    method: string;\n    params?: Json[] | Record<string, Json>;\n    scope: CaipChainId;\n  }) => Promise<Json>;\n  resolveAccountAddress: (\n    snapId: SnapId,\n    scope: CaipChainId,\n    request: Json,\n  ) => Promise<{ address: CaipAccountId } | null>;\n};\n\n// Expecting a bound function that calls KeyringController.withKeyring selecting the Snap keyring\nexport type WithSnapKeyringFunction = <ReturnType>(\n  operation: ({ keyring }: { keyring: SnapKeyring }) => Promise<ReturnType>,\n) => Promise<ReturnType>;\n\nexport type AccountsControllerListMultichainAccountsAction = {\n  type: `AccountsController:listMultichainAccounts`;\n  handler: (chainId?: CaipChainId) => InternalAccount[];\n};\n\nexport type MultichainRouterActions =\n  | MultichainRouterHandleRequestAction\n  | MultichainRouterGetSupportedMethodsAction\n  | MultichainRouterGetSupportedAccountsAction\n  | MultichainRouterIsSupportedScopeAction;\n\nexport type MultichainRouterAllowedActions =\n  | GetAllSnaps\n  | HandleSnapRequest\n  | GetPermissions\n  | AccountsControllerListMultichainAccountsAction;\n\nexport type MultichainRouterEvents = never;\n\nexport type MultichainRouterMessenger = Messenger<\n  typeof name,\n  MultichainRouterActions | MultichainRouterAllowedActions\n>;\n\nexport type MultichainRouterArgs = {\n  messenger: MultichainRouterMessenger;\n  withSnapKeyring: WithSnapKeyringFunction;\n};\n\ntype ProtocolSnap = {\n  snapId: SnapId;\n  methods: string[];\n};\n\nconst name = 'MultichainRouter';\n\nexport class MultichainRouter {\n  name: typeof name = name;\n\n  state = null;\n\n  readonly #messenger: MultichainRouterMessenger;\n\n  readonly #withSnapKeyring: WithSnapKeyringFunction;\n\n  constructor({ messenger, withSnapKeyring }: MultichainRouterArgs) {\n    this.#messenger = messenger;\n    this.#withSnapKeyring = withSnapKeyring;\n\n    this.#messenger.registerActionHandler(\n      `${name}:handleRequest`,\n      async (...args) => this.handleRequest(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${name}:getSupportedMethods`,\n      (...args) => this.getSupportedMethods(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${name}:getSupportedAccounts`,\n      (...args) => this.getSupportedAccounts(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${name}:isSupportedScope`,\n      (...args) => this.isSupportedScope(...args),\n    );\n  }\n\n  /**\n   * Attempts to resolve the account address to use for a given request by inspecting the request itself.\n   *\n   * The request is sent to to an account Snap via the SnapKeyring that will attempt this resolution.\n   *\n   * @param snapId - The ID of the Snap to send the request to.\n   * @param scope - The CAIP-2 scope for the request.\n   * @param request - The JSON-RPC request.\n   * @returns The resolved address if found, otherwise null.\n   * @throws If the invocation of the SnapKeyring fails.\n   */\n  async #resolveRequestAddress(\n    snapId: SnapId,\n    scope: CaipChainId,\n    request: JsonRpcRequest,\n  ) {\n    try {\n      const result = await this.#withSnapKeyring(async ({ keyring }) =>\n        keyring.resolveAccountAddress(snapId, scope, request),\n      );\n      const address = result?.address;\n      return address ? parseCaipAccountId(address).address : null;\n    } catch {\n      throw rpcErrors.internal();\n    }\n  }\n\n  /**\n   * Get the account ID of the account that should service the RPC request via an account Snap.\n   *\n   * This function checks whether any accounts exist that can service a given request by\n   * using a combination of the resolveAccountAddress functionality and the connected accounts.\n   *\n   * If an account is expected to service this request but none is found, the function will throw.\n   *\n   * @param connectedAddresses - The CAIP-10 addresses connected to the requesting origin.\n   * @param scope - The CAIP-2 scope for the request.\n   * @param request - The JSON-RPC request.\n   * @returns An account ID if found, otherwise null.\n   * @throws If no account is found, but the accounts exist that could service the request.\n   */\n  async #getSnapAccountId(\n    connectedAddresses: CaipAccountId[],\n    scope: CaipChainId,\n    request: JsonRpcRequest,\n  ) {\n    const accounts = this.#messenger\n      .call('AccountsController:listMultichainAccounts', scope)\n      .filter(\n        (\n          account: InternalAccount,\n        ): account is InternalAccount & {\n          metadata: Required<InternalAccount['metadata']>;\n        } =>\n          Boolean(account.metadata.snap?.enabled) &&\n          account.methods.includes(request.method),\n      );\n\n    // If no accounts can service the request, return null.\n    if (accounts.length === 0) {\n      return null;\n    }\n\n    const resolutionSnapId = accounts[0].metadata.snap.id;\n\n    // Attempt to resolve the address that should be used for signing.\n    const address = await this.#resolveRequestAddress(\n      resolutionSnapId,\n      scope,\n      request,\n    );\n\n    const parsedConnectedAddresses = connectedAddresses.map(\n      (connectedAddress) => parseCaipAccountId(connectedAddress).address,\n    );\n\n    // If we have a resolved address, try to find the selected account based on that\n    // otherwise, default to one of the connected accounts.\n    // TODO: Eventually let the user choose if we have more than one option for the account.\n    const selectedAccount = accounts.find(\n      (account) =>\n        parsedConnectedAddresses.includes(account.address) &&\n        (!address || account.address === address),\n    );\n\n    if (!selectedAccount) {\n      throw rpcErrors.invalidParams({\n        message: 'No available account found for request.',\n      });\n    }\n\n    return selectedAccount.id;\n  }\n\n  /**\n   * Get all protocol Snaps that can service a given CAIP-2 scope.\n   *\n   * Protocol Snaps are deemed fit to service a scope if they are runnable\n   * and have the proper permissions set for the scope.\n   *\n   * @param scope - A CAIP-2 scope.\n   * @returns A list of all the protocol Snaps available and their RPC methods.\n   */\n  #getProtocolSnaps(scope: CaipChainId) {\n    const allSnaps = this.#messenger.call('SnapController:getAll');\n    const filteredSnaps = getRunnableSnaps(allSnaps);\n\n    return filteredSnaps.reduce<ProtocolSnap[]>((accumulator, snap) => {\n      const permissions = this.#messenger.call(\n        'PermissionController:getPermissions',\n        snap.id,\n      );\n\n      if (permissions && hasProperty(permissions, SnapEndowments.Protocol)) {\n        const permission = permissions[SnapEndowments.Protocol];\n        const scopes = getProtocolCaveatScopes(permission);\n        if (scopes && hasProperty(scopes, scope)) {\n          accumulator.push({\n            snapId: snap.id,\n            methods: scopes[scope].methods,\n          });\n        }\n      }\n\n      return accumulator;\n    }, []);\n  }\n\n  /**\n   * Handle an incoming JSON-RPC request tied to a specific scope by routing\n   * to either a protocol Snap or an account Snap.\n   *\n   * Note: Addresses are considered case sensitive by the MultichainRouter as\n   * not all non-EVM chains are case insensitive.\n   *\n   * @param options - An options bag.\n   * @param options.connectedAddresses - Addresses currently connected to the origin.\n   * @param options.origin - The origin of the RPC request.\n   * @param options.request - The JSON-RPC request.\n   * @param options.scope - The CAIP-2 scope for the request.\n   * @returns The response from the chosen Snap.\n   * @throws If no handler was found.\n   */\n  async handleRequest({\n    connectedAddresses,\n    origin,\n    scope,\n    request: rawRequest,\n  }: {\n    connectedAddresses: CaipAccountId[];\n    origin: string;\n    scope: CaipChainId;\n    request: JsonRpcRequest;\n  }): Promise<Json> {\n    // Explicitly block EVM scopes, just in case.\n    assert(\n      !scope.startsWith(KnownCaipNamespace.Eip155) &&\n        !scope.startsWith('wallet:eip155'),\n    );\n\n    // Re-create the request to simplify and remove additional properties that may be present in MM middleware.\n    const request = {\n      jsonrpc: '2.0' as const,\n      id: rawRequest.id ?? nanoid(),\n      method: rawRequest.method,\n      ...(rawRequest.params ? { params: rawRequest.params } : {}),\n    };\n\n    const { method, params } = request;\n\n    // If the RPC request can be serviced by an account Snap, route it there.\n    const accountId = await this.#getSnapAccountId(\n      connectedAddresses,\n      scope,\n      request,\n    );\n\n    if (accountId) {\n      return this.#withSnapKeyring(async ({ keyring }) =>\n        keyring.submitRequest({\n          origin,\n          account: accountId,\n          scope,\n          method,\n          params: params as JsonRpcParams,\n        }),\n      );\n    }\n\n    // If the RPC request cannot be serviced by an account Snap,\n    // but has a protocol Snap available, route it there.\n    const protocolSnaps = this.#getProtocolSnaps(scope);\n    const protocolSnap = protocolSnaps.find((snap) =>\n      snap.methods.includes(method),\n    );\n\n    if (protocolSnap) {\n      return this.#messenger.call('SnapController:handleRequest', {\n        snapId: protocolSnap.snapId,\n        origin,\n        request: {\n          method: '',\n          params: {\n            request,\n            scope,\n          },\n        },\n        handler: HandlerType.OnProtocolRequest,\n      }) as Promise<Json>;\n    }\n\n    // If no compatible account or protocol Snaps were found, throw.\n    throw rpcErrors.methodNotFound();\n  }\n\n  /**\n   * Get a list of metadata for supported accounts for a given scope from the client.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns A list of metadata for the supported accounts.\n   */\n  #getSupportedAccountsMetadata(scope: CaipChainId): InternalAccount[] {\n    return this.#messenger\n      .call('AccountsController:listMultichainAccounts', scope)\n      .filter((account: InternalAccount) => account.metadata.snap?.enabled);\n  }\n\n  /**\n   * Get a list of supported methods for a given scope.\n   * This combines both protocol and account Snaps supported methods.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns A list of supported methods.\n   */\n  getSupportedMethods(scope: CaipChainId): string[] {\n    const accountMethods = this.#getSupportedAccountsMetadata(scope).flatMap(\n      (account) => account.methods,\n    );\n\n    const protocolMethods = this.#getProtocolSnaps(scope).flatMap(\n      (snap) => snap.methods,\n    );\n\n    return Array.from(new Set([...accountMethods, ...protocolMethods]));\n  }\n\n  /**\n   * Get a list of supported accounts for a given scope.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns A list of CAIP-10 addresses.\n   */\n  getSupportedAccounts(scope: CaipChainId): string[] {\n    return this.#getSupportedAccountsMetadata(scope).map(\n      (account) => `${scope}:${account.address}`,\n    );\n  }\n\n  /**\n   * Determine whether a given CAIP-2 scope is supported by the router.\n   *\n   * @param scope - The CAIP-2 scope.\n   * @returns True if the router can service the scope, otherwise false.\n   */\n  isSupportedScope(scope: CaipChainId): boolean {\n    const hasAccountSnap = this.#messenger\n      .call('AccountsController:listMultichainAccounts', scope)\n      .some((account: InternalAccount) => account.metadata.snap?.enabled);\n    // We currently assume here that if one Snap exists that service the scope, we can service the scope generally.\n    return hasAccountSnap || this.#getProtocolSnaps(scope).length > 0;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/services/ExecutionService.cjs.map b/dist/services/ExecutionService.cjs.map
index 0ddf849bd49a1aebfae80e234f018d257fd9489b..a44ebdc09944ae397e9169e03d43e728e8731c3e 100644
--- a/dist/services/ExecutionService.cjs.map
+++ b/dist/services/ExecutionService.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"ExecutionService.cjs","sourceRoot":"","sources":["../../src/services/ExecutionService.ts"],"names":[],"mappings":"","sourcesContent":["import type { RestrictedMessenger } from '@metamask/base-controller';\nimport type { SnapRpcHookArgs } from '@metamask/snaps-utils';\nimport type { Json } from '@metamask/utils';\n\ntype TerminateSnap = (snapId: string) => Promise<void>;\ntype TerminateAll = () => Promise<void>;\ntype ExecuteSnap = (snapData: SnapExecutionData) => Promise<unknown>;\n\ntype HandleRpcRequest = (\n  snapId: string,\n  options: SnapRpcHookArgs,\n) => Promise<unknown>;\n\nexport type ExecutionService = {\n  // These fields are required for modular initialisation of the execution\n  // service in the MetaMask extension.\n  name: 'ExecutionService';\n  state: null;\n\n  terminateSnap: TerminateSnap;\n  terminateAllSnaps: TerminateAll;\n  executeSnap: ExecuteSnap;\n  handleRpcRequest: HandleRpcRequest;\n};\n\nexport type SnapExecutionData = {\n  snapId: string;\n  sourceCode: string;\n  endowments: Json;\n};\n\nexport type SnapErrorJson = {\n  message: string;\n  code: number;\n  data?: Json;\n};\n\ntype ControllerName = 'ExecutionService';\n\nexport type ErrorMessageEvent = {\n  type: 'ExecutionService:unhandledError';\n  payload: [string, SnapErrorJson];\n};\n\nexport type OutboundRequest = {\n  type: 'ExecutionService:outboundRequest';\n  payload: [string];\n};\n\nexport type OutboundResponse = {\n  type: 'ExecutionService:outboundResponse';\n  payload: [string];\n};\n\nexport type ExecutionServiceEvents =\n  | ErrorMessageEvent\n  | OutboundRequest\n  | OutboundResponse;\n\n/**\n * Handles RPC request.\n */\nexport type HandleRpcRequestAction = {\n  type: `${ControllerName}:handleRpcRequest`;\n  handler: ExecutionService['handleRpcRequest'];\n};\n\n/**\n * Executes a given snap.\n */\nexport type ExecuteSnapAction = {\n  type: `${ControllerName}:executeSnap`;\n  handler: ExecutionService['executeSnap'];\n};\n\n/**\n * Terminates a given snap.\n */\nexport type TerminateSnapAction = {\n  type: `${ControllerName}:terminateSnap`;\n  handler: ExecutionService['terminateSnap'];\n};\n\n/**\n * Terminates all snaps.\n */\nexport type TerminateAllSnapsAction = {\n  type: `${ControllerName}:terminateAllSnaps`;\n  handler: ExecutionService['terminateAllSnaps'];\n};\n\nexport type ExecutionServiceActions =\n  | HandleRpcRequestAction\n  | ExecuteSnapAction\n  | TerminateSnapAction\n  | TerminateAllSnapsAction;\n\nexport type ExecutionServiceMessenger = RestrictedMessenger<\n  'ExecutionService',\n  ExecutionServiceActions,\n  ExecutionServiceEvents,\n  ExecutionServiceActions['type'],\n  ExecutionServiceEvents['type']\n>;\n"]}
\ No newline at end of file
+{"version":3,"file":"ExecutionService.cjs","sourceRoot":"","sources":["../../src/services/ExecutionService.ts"],"names":[],"mappings":"","sourcesContent":["import type { Messenger } from '@metamask/messenger';\nimport type { SnapRpcHookArgs } from '@metamask/snaps-utils';\nimport type { Json } from '@metamask/utils';\n\ntype TerminateSnap = (snapId: string) => Promise<void>;\ntype TerminateAll = () => Promise<void>;\ntype ExecuteSnap = (snapData: SnapExecutionData) => Promise<unknown>;\n\ntype HandleRpcRequest = (\n  snapId: string,\n  options: SnapRpcHookArgs,\n) => Promise<unknown>;\n\nexport type ExecutionService = {\n  // These fields are required for modular initialisation of the execution\n  // service in the MetaMask extension.\n  name: 'ExecutionService';\n  state: null;\n\n  terminateSnap: TerminateSnap;\n  terminateAllSnaps: TerminateAll;\n  executeSnap: ExecuteSnap;\n  handleRpcRequest: HandleRpcRequest;\n};\n\nexport type SnapExecutionData = {\n  snapId: string;\n  sourceCode: string;\n  endowments: Json;\n};\n\nexport type SnapErrorJson = {\n  message: string;\n  code: number;\n  data?: Json;\n};\n\ntype ControllerName = 'ExecutionService';\n\nexport type ErrorMessageEvent = {\n  type: 'ExecutionService:unhandledError';\n  payload: [string, SnapErrorJson];\n};\n\nexport type OutboundRequest = {\n  type: 'ExecutionService:outboundRequest';\n  payload: [string];\n};\n\nexport type OutboundResponse = {\n  type: 'ExecutionService:outboundResponse';\n  payload: [string];\n};\n\nexport type ExecutionServiceEvents =\n  | ErrorMessageEvent\n  | OutboundRequest\n  | OutboundResponse;\n\n/**\n * Handles RPC request.\n */\nexport type HandleRpcRequestAction = {\n  type: `${ControllerName}:handleRpcRequest`;\n  handler: ExecutionService['handleRpcRequest'];\n};\n\n/**\n * Executes a given snap.\n */\nexport type ExecuteSnapAction = {\n  type: `${ControllerName}:executeSnap`;\n  handler: ExecutionService['executeSnap'];\n};\n\n/**\n * Terminates a given snap.\n */\nexport type TerminateSnapAction = {\n  type: `${ControllerName}:terminateSnap`;\n  handler: ExecutionService['terminateSnap'];\n};\n\n/**\n * Terminates all snaps.\n */\nexport type TerminateAllSnapsAction = {\n  type: `${ControllerName}:terminateAllSnaps`;\n  handler: ExecutionService['terminateAllSnaps'];\n};\n\nexport type ExecutionServiceActions =\n  | HandleRpcRequestAction\n  | ExecuteSnapAction\n  | TerminateSnapAction\n  | TerminateAllSnapsAction;\n\nexport type ExecutionServiceMessenger = Messenger<\n  'ExecutionService',\n  ExecutionServiceActions,\n  ExecutionServiceEvents\n>;\n"]}
\ No newline at end of file
diff --git a/dist/services/ExecutionService.d.cts b/dist/services/ExecutionService.d.cts
index a50978ca3eca07b315df147bb1f022921e4f4438..d3a3363ea4307649b3f477730215de044bd940c2 100644
--- a/dist/services/ExecutionService.d.cts
+++ b/dist/services/ExecutionService.d.cts
@@ -1,4 +1,4 @@
-import type { RestrictedMessenger } from "@metamask/base-controller";
+import type { Messenger } from "@metamask/messenger";
 import type { SnapRpcHookArgs } from "@metamask/snaps-utils";
 import type { Json } from "@metamask/utils";
 type TerminateSnap = (snapId: string) => Promise<void>;
@@ -66,6 +66,6 @@ export type TerminateAllSnapsAction = {
     handler: ExecutionService['terminateAllSnaps'];
 };
 export type ExecutionServiceActions = HandleRpcRequestAction | ExecuteSnapAction | TerminateSnapAction | TerminateAllSnapsAction;
-export type ExecutionServiceMessenger = RestrictedMessenger<'ExecutionService', ExecutionServiceActions, ExecutionServiceEvents, ExecutionServiceActions['type'], ExecutionServiceEvents['type']>;
+export type ExecutionServiceMessenger = Messenger<'ExecutionService', ExecutionServiceActions, ExecutionServiceEvents>;
 export {};
 //# sourceMappingURL=ExecutionService.d.cts.map
\ No newline at end of file
diff --git a/dist/services/ExecutionService.d.cts.map b/dist/services/ExecutionService.d.cts.map
index 181a5f0fd7dc032eb4e70e1345fafdae54bb95f1..cc0c8329da8e638935d9d5fa267284781c8e4710 100644
--- a/dist/services/ExecutionService.d.cts.map
+++ b/dist/services/ExecutionService.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"ExecutionService.d.cts","sourceRoot":"","sources":["../../src/services/ExecutionService.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,mBAAmB,EAAE,kCAAkC;AACrE,OAAO,KAAK,EAAE,eAAe,EAAE,8BAA8B;AAC7D,OAAO,KAAK,EAAE,IAAI,EAAE,wBAAwB;AAE5C,KAAK,aAAa,GAAG,CAAC,MAAM,EAAE,MAAM,KAAK,OAAO,CAAC,IAAI,CAAC,CAAC;AACvD,KAAK,YAAY,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC;AACxC,KAAK,WAAW,GAAG,CAAC,QAAQ,EAAE,iBAAiB,KAAK,OAAO,CAAC,OAAO,CAAC,CAAC;AAErE,KAAK,gBAAgB,GAAG,CACtB,MAAM,EAAE,MAAM,EACd,OAAO,EAAE,eAAe,KACrB,OAAO,CAAC,OAAO,CAAC,CAAC;AAEtB,MAAM,MAAM,gBAAgB,GAAG;IAG7B,IAAI,EAAE,kBAAkB,CAAC;IACzB,KAAK,EAAE,IAAI,CAAC;IAEZ,aAAa,EAAE,aAAa,CAAC;IAC7B,iBAAiB,EAAE,YAAY,CAAC;IAChC,WAAW,EAAE,WAAW,CAAC;IACzB,gBAAgB,EAAE,gBAAgB,CAAC;CACpC,CAAC;AAEF,MAAM,MAAM,iBAAiB,GAAG;IAC9B,MAAM,EAAE,MAAM,CAAC;IACf,UAAU,EAAE,MAAM,CAAC;IACnB,UAAU,EAAE,IAAI,CAAC;CAClB,CAAC;AAEF,MAAM,MAAM,aAAa,GAAG;IAC1B,OAAO,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,CAAC,EAAE,IAAI,CAAC;CACb,CAAC;AAEF,KAAK,cAAc,GAAG,kBAAkB,CAAC;AAEzC,MAAM,MAAM,iBAAiB,GAAG;IAC9B,IAAI,EAAE,iCAAiC,CAAC;IACxC,OAAO,EAAE,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC;CAClC,CAAC;AAEF,MAAM,MAAM,eAAe,GAAG;IAC5B,IAAI,EAAE,kCAAkC,CAAC;IACzC,OAAO,EAAE,CAAC,MAAM,CAAC,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,gBAAgB,GAAG;IAC7B,IAAI,EAAE,mCAAmC,CAAC;IAC1C,OAAO,EAAE,CAAC,MAAM,CAAC,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,sBAAsB,GAC9B,iBAAiB,GACjB,eAAe,GACf,gBAAgB,CAAC;AAErB;;GAEG;AACH,MAAM,MAAM,sBAAsB,GAAG;IACnC,IAAI,EAAE,GAAG,cAAc,mBAAmB,CAAC;IAC3C,OAAO,EAAE,gBAAgB,CAAC,kBAAkB,CAAC,CAAC;CAC/C,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,iBAAiB,GAAG;IAC9B,IAAI,EAAE,GAAG,cAAc,cAAc,CAAC;IACtC,OAAO,EAAE,gBAAgB,CAAC,aAAa,CAAC,CAAC;CAC1C,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,mBAAmB,GAAG;IAChC,IAAI,EAAE,GAAG,cAAc,gBAAgB,CAAC;IACxC,OAAO,EAAE,gBAAgB,CAAC,eAAe,CAAC,CAAC;CAC5C,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,uBAAuB,GAAG;IACpC,IAAI,EAAE,GAAG,cAAc,oBAAoB,CAAC;IAC5C,OAAO,EAAE,gBAAgB,CAAC,mBAAmB,CAAC,CAAC;CAChD,CAAC;AAEF,MAAM,MAAM,uBAAuB,GAC/B,sBAAsB,GACtB,iBAAiB,GACjB,mBAAmB,GACnB,uBAAuB,CAAC;AAE5B,MAAM,MAAM,yBAAyB,GAAG,mBAAmB,CACzD,kBAAkB,EAClB,uBAAuB,EACvB,sBAAsB,EACtB,uBAAuB,CAAC,MAAM,CAAC,EAC/B,sBAAsB,CAAC,MAAM,CAAC,CAC/B,CAAC"}
\ No newline at end of file
+{"version":3,"file":"ExecutionService.d.cts","sourceRoot":"","sources":["../../src/services/ExecutionService.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,SAAS,EAAE,4BAA4B;AACrD,OAAO,KAAK,EAAE,eAAe,EAAE,8BAA8B;AAC7D,OAAO,KAAK,EAAE,IAAI,EAAE,wBAAwB;AAE5C,KAAK,aAAa,GAAG,CAAC,MAAM,EAAE,MAAM,KAAK,OAAO,CAAC,IAAI,CAAC,CAAC;AACvD,KAAK,YAAY,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC;AACxC,KAAK,WAAW,GAAG,CAAC,QAAQ,EAAE,iBAAiB,KAAK,OAAO,CAAC,OAAO,CAAC,CAAC;AAErE,KAAK,gBAAgB,GAAG,CACtB,MAAM,EAAE,MAAM,EACd,OAAO,EAAE,eAAe,KACrB,OAAO,CAAC,OAAO,CAAC,CAAC;AAEtB,MAAM,MAAM,gBAAgB,GAAG;IAG7B,IAAI,EAAE,kBAAkB,CAAC;IACzB,KAAK,EAAE,IAAI,CAAC;IAEZ,aAAa,EAAE,aAAa,CAAC;IAC7B,iBAAiB,EAAE,YAAY,CAAC;IAChC,WAAW,EAAE,WAAW,CAAC;IACzB,gBAAgB,EAAE,gBAAgB,CAAC;CACpC,CAAC;AAEF,MAAM,MAAM,iBAAiB,GAAG;IAC9B,MAAM,EAAE,MAAM,CAAC;IACf,UAAU,EAAE,MAAM,CAAC;IACnB,UAAU,EAAE,IAAI,CAAC;CAClB,CAAC;AAEF,MAAM,MAAM,aAAa,GAAG;IAC1B,OAAO,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,CAAC,EAAE,IAAI,CAAC;CACb,CAAC;AAEF,KAAK,cAAc,GAAG,kBAAkB,CAAC;AAEzC,MAAM,MAAM,iBAAiB,GAAG;IAC9B,IAAI,EAAE,iCAAiC,CAAC;IACxC,OAAO,EAAE,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC;CAClC,CAAC;AAEF,MAAM,MAAM,eAAe,GAAG;IAC5B,IAAI,EAAE,kCAAkC,CAAC;IACzC,OAAO,EAAE,CAAC,MAAM,CAAC,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,gBAAgB,GAAG;IAC7B,IAAI,EAAE,mCAAmC,CAAC;IAC1C,OAAO,EAAE,CAAC,MAAM,CAAC,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,sBAAsB,GAC9B,iBAAiB,GACjB,eAAe,GACf,gBAAgB,CAAC;AAErB;;GAEG;AACH,MAAM,MAAM,sBAAsB,GAAG;IACnC,IAAI,EAAE,GAAG,cAAc,mBAAmB,CAAC;IAC3C,OAAO,EAAE,gBAAgB,CAAC,kBAAkB,CAAC,CAAC;CAC/C,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,iBAAiB,GAAG;IAC9B,IAAI,EAAE,GAAG,cAAc,cAAc,CAAC;IACtC,OAAO,EAAE,gBAAgB,CAAC,aAAa,CAAC,CAAC;CAC1C,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,mBAAmB,GAAG;IAChC,IAAI,EAAE,GAAG,cAAc,gBAAgB,CAAC;IACxC,OAAO,EAAE,gBAAgB,CAAC,eAAe,CAAC,CAAC;CAC5C,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,uBAAuB,GAAG;IACpC,IAAI,EAAE,GAAG,cAAc,oBAAoB,CAAC;IAC5C,OAAO,EAAE,gBAAgB,CAAC,mBAAmB,CAAC,CAAC;CAChD,CAAC;AAEF,MAAM,MAAM,uBAAuB,GAC/B,sBAAsB,GACtB,iBAAiB,GACjB,mBAAmB,GACnB,uBAAuB,CAAC;AAE5B,MAAM,MAAM,yBAAyB,GAAG,SAAS,CAC/C,kBAAkB,EAClB,uBAAuB,EACvB,sBAAsB,CACvB,CAAC"}
\ No newline at end of file
diff --git a/dist/services/ExecutionService.d.mts b/dist/services/ExecutionService.d.mts
index 7a3a54a4071c30b1d1a5e92b1f93d52ed1ce07d4..e9c9e2e093fe07abb72dda458492713030bd484a 100644
--- a/dist/services/ExecutionService.d.mts
+++ b/dist/services/ExecutionService.d.mts
@@ -1,4 +1,4 @@
-import type { RestrictedMessenger } from "@metamask/base-controller";
+import type { Messenger } from "@metamask/messenger";
 import type { SnapRpcHookArgs } from "@metamask/snaps-utils";
 import type { Json } from "@metamask/utils";
 type TerminateSnap = (snapId: string) => Promise<void>;
@@ -66,6 +66,6 @@ export type TerminateAllSnapsAction = {
     handler: ExecutionService['terminateAllSnaps'];
 };
 export type ExecutionServiceActions = HandleRpcRequestAction | ExecuteSnapAction | TerminateSnapAction | TerminateAllSnapsAction;
-export type ExecutionServiceMessenger = RestrictedMessenger<'ExecutionService', ExecutionServiceActions, ExecutionServiceEvents, ExecutionServiceActions['type'], ExecutionServiceEvents['type']>;
+export type ExecutionServiceMessenger = Messenger<'ExecutionService', ExecutionServiceActions, ExecutionServiceEvents>;
 export {};
 //# sourceMappingURL=ExecutionService.d.mts.map
\ No newline at end of file
diff --git a/dist/services/ExecutionService.d.mts.map b/dist/services/ExecutionService.d.mts.map
index bd5464c56d9d3e37764436114c2d8ca266cd7d0c..50c9fa77aac7cf51ac49e75eade6c93eb6fe9d2d 100644
--- a/dist/services/ExecutionService.d.mts.map
+++ b/dist/services/ExecutionService.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"ExecutionService.d.mts","sourceRoot":"","sources":["../../src/services/ExecutionService.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,mBAAmB,EAAE,kCAAkC;AACrE,OAAO,KAAK,EAAE,eAAe,EAAE,8BAA8B;AAC7D,OAAO,KAAK,EAAE,IAAI,EAAE,wBAAwB;AAE5C,KAAK,aAAa,GAAG,CAAC,MAAM,EAAE,MAAM,KAAK,OAAO,CAAC,IAAI,CAAC,CAAC;AACvD,KAAK,YAAY,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC;AACxC,KAAK,WAAW,GAAG,CAAC,QAAQ,EAAE,iBAAiB,KAAK,OAAO,CAAC,OAAO,CAAC,CAAC;AAErE,KAAK,gBAAgB,GAAG,CACtB,MAAM,EAAE,MAAM,EACd,OAAO,EAAE,eAAe,KACrB,OAAO,CAAC,OAAO,CAAC,CAAC;AAEtB,MAAM,MAAM,gBAAgB,GAAG;IAG7B,IAAI,EAAE,kBAAkB,CAAC;IACzB,KAAK,EAAE,IAAI,CAAC;IAEZ,aAAa,EAAE,aAAa,CAAC;IAC7B,iBAAiB,EAAE,YAAY,CAAC;IAChC,WAAW,EAAE,WAAW,CAAC;IACzB,gBAAgB,EAAE,gBAAgB,CAAC;CACpC,CAAC;AAEF,MAAM,MAAM,iBAAiB,GAAG;IAC9B,MAAM,EAAE,MAAM,CAAC;IACf,UAAU,EAAE,MAAM,CAAC;IACnB,UAAU,EAAE,IAAI,CAAC;CAClB,CAAC;AAEF,MAAM,MAAM,aAAa,GAAG;IAC1B,OAAO,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,CAAC,EAAE,IAAI,CAAC;CACb,CAAC;AAEF,KAAK,cAAc,GAAG,kBAAkB,CAAC;AAEzC,MAAM,MAAM,iBAAiB,GAAG;IAC9B,IAAI,EAAE,iCAAiC,CAAC;IACxC,OAAO,EAAE,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC;CAClC,CAAC;AAEF,MAAM,MAAM,eAAe,GAAG;IAC5B,IAAI,EAAE,kCAAkC,CAAC;IACzC,OAAO,EAAE,CAAC,MAAM,CAAC,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,gBAAgB,GAAG;IAC7B,IAAI,EAAE,mCAAmC,CAAC;IAC1C,OAAO,EAAE,CAAC,MAAM,CAAC,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,sBAAsB,GAC9B,iBAAiB,GACjB,eAAe,GACf,gBAAgB,CAAC;AAErB;;GAEG;AACH,MAAM,MAAM,sBAAsB,GAAG;IACnC,IAAI,EAAE,GAAG,cAAc,mBAAmB,CAAC;IAC3C,OAAO,EAAE,gBAAgB,CAAC,kBAAkB,CAAC,CAAC;CAC/C,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,iBAAiB,GAAG;IAC9B,IAAI,EAAE,GAAG,cAAc,cAAc,CAAC;IACtC,OAAO,EAAE,gBAAgB,CAAC,aAAa,CAAC,CAAC;CAC1C,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,mBAAmB,GAAG;IAChC,IAAI,EAAE,GAAG,cAAc,gBAAgB,CAAC;IACxC,OAAO,EAAE,gBAAgB,CAAC,eAAe,CAAC,CAAC;CAC5C,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,uBAAuB,GAAG;IACpC,IAAI,EAAE,GAAG,cAAc,oBAAoB,CAAC;IAC5C,OAAO,EAAE,gBAAgB,CAAC,mBAAmB,CAAC,CAAC;CAChD,CAAC;AAEF,MAAM,MAAM,uBAAuB,GAC/B,sBAAsB,GACtB,iBAAiB,GACjB,mBAAmB,GACnB,uBAAuB,CAAC;AAE5B,MAAM,MAAM,yBAAyB,GAAG,mBAAmB,CACzD,kBAAkB,EAClB,uBAAuB,EACvB,sBAAsB,EACtB,uBAAuB,CAAC,MAAM,CAAC,EAC/B,sBAAsB,CAAC,MAAM,CAAC,CAC/B,CAAC"}
\ No newline at end of file
+{"version":3,"file":"ExecutionService.d.mts","sourceRoot":"","sources":["../../src/services/ExecutionService.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,SAAS,EAAE,4BAA4B;AACrD,OAAO,KAAK,EAAE,eAAe,EAAE,8BAA8B;AAC7D,OAAO,KAAK,EAAE,IAAI,EAAE,wBAAwB;AAE5C,KAAK,aAAa,GAAG,CAAC,MAAM,EAAE,MAAM,KAAK,OAAO,CAAC,IAAI,CAAC,CAAC;AACvD,KAAK,YAAY,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC;AACxC,KAAK,WAAW,GAAG,CAAC,QAAQ,EAAE,iBAAiB,KAAK,OAAO,CAAC,OAAO,CAAC,CAAC;AAErE,KAAK,gBAAgB,GAAG,CACtB,MAAM,EAAE,MAAM,EACd,OAAO,EAAE,eAAe,KACrB,OAAO,CAAC,OAAO,CAAC,CAAC;AAEtB,MAAM,MAAM,gBAAgB,GAAG;IAG7B,IAAI,EAAE,kBAAkB,CAAC;IACzB,KAAK,EAAE,IAAI,CAAC;IAEZ,aAAa,EAAE,aAAa,CAAC;IAC7B,iBAAiB,EAAE,YAAY,CAAC;IAChC,WAAW,EAAE,WAAW,CAAC;IACzB,gBAAgB,EAAE,gBAAgB,CAAC;CACpC,CAAC;AAEF,MAAM,MAAM,iBAAiB,GAAG;IAC9B,MAAM,EAAE,MAAM,CAAC;IACf,UAAU,EAAE,MAAM,CAAC;IACnB,UAAU,EAAE,IAAI,CAAC;CAClB,CAAC;AAEF,MAAM,MAAM,aAAa,GAAG;IAC1B,OAAO,EAAE,MAAM,CAAC;IAChB,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,CAAC,EAAE,IAAI,CAAC;CACb,CAAC;AAEF,KAAK,cAAc,GAAG,kBAAkB,CAAC;AAEzC,MAAM,MAAM,iBAAiB,GAAG;IAC9B,IAAI,EAAE,iCAAiC,CAAC;IACxC,OAAO,EAAE,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC;CAClC,CAAC;AAEF,MAAM,MAAM,eAAe,GAAG;IAC5B,IAAI,EAAE,kCAAkC,CAAC;IACzC,OAAO,EAAE,CAAC,MAAM,CAAC,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,gBAAgB,GAAG;IAC7B,IAAI,EAAE,mCAAmC,CAAC;IAC1C,OAAO,EAAE,CAAC,MAAM,CAAC,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,sBAAsB,GAC9B,iBAAiB,GACjB,eAAe,GACf,gBAAgB,CAAC;AAErB;;GAEG;AACH,MAAM,MAAM,sBAAsB,GAAG;IACnC,IAAI,EAAE,GAAG,cAAc,mBAAmB,CAAC;IAC3C,OAAO,EAAE,gBAAgB,CAAC,kBAAkB,CAAC,CAAC;CAC/C,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,iBAAiB,GAAG;IAC9B,IAAI,EAAE,GAAG,cAAc,cAAc,CAAC;IACtC,OAAO,EAAE,gBAAgB,CAAC,aAAa,CAAC,CAAC;CAC1C,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,mBAAmB,GAAG;IAChC,IAAI,EAAE,GAAG,cAAc,gBAAgB,CAAC;IACxC,OAAO,EAAE,gBAAgB,CAAC,eAAe,CAAC,CAAC;CAC5C,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,uBAAuB,GAAG;IACpC,IAAI,EAAE,GAAG,cAAc,oBAAoB,CAAC;IAC5C,OAAO,EAAE,gBAAgB,CAAC,mBAAmB,CAAC,CAAC;CAChD,CAAC;AAEF,MAAM,MAAM,uBAAuB,GAC/B,sBAAsB,GACtB,iBAAiB,GACjB,mBAAmB,GACnB,uBAAuB,CAAC;AAE5B,MAAM,MAAM,yBAAyB,GAAG,SAAS,CAC/C,kBAAkB,EAClB,uBAAuB,EACvB,sBAAsB,CACvB,CAAC"}
\ No newline at end of file
diff --git a/dist/services/ExecutionService.mjs.map b/dist/services/ExecutionService.mjs.map
index e0b2699ee1bae7b7e52256b24926da1ece1e0656..f8ee906c8f743be3a38d8f135087e87746c67c53 100644
--- a/dist/services/ExecutionService.mjs.map
+++ b/dist/services/ExecutionService.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"ExecutionService.mjs","sourceRoot":"","sources":["../../src/services/ExecutionService.ts"],"names":[],"mappings":"","sourcesContent":["import type { RestrictedMessenger } from '@metamask/base-controller';\nimport type { SnapRpcHookArgs } from '@metamask/snaps-utils';\nimport type { Json } from '@metamask/utils';\n\ntype TerminateSnap = (snapId: string) => Promise<void>;\ntype TerminateAll = () => Promise<void>;\ntype ExecuteSnap = (snapData: SnapExecutionData) => Promise<unknown>;\n\ntype HandleRpcRequest = (\n  snapId: string,\n  options: SnapRpcHookArgs,\n) => Promise<unknown>;\n\nexport type ExecutionService = {\n  // These fields are required for modular initialisation of the execution\n  // service in the MetaMask extension.\n  name: 'ExecutionService';\n  state: null;\n\n  terminateSnap: TerminateSnap;\n  terminateAllSnaps: TerminateAll;\n  executeSnap: ExecuteSnap;\n  handleRpcRequest: HandleRpcRequest;\n};\n\nexport type SnapExecutionData = {\n  snapId: string;\n  sourceCode: string;\n  endowments: Json;\n};\n\nexport type SnapErrorJson = {\n  message: string;\n  code: number;\n  data?: Json;\n};\n\ntype ControllerName = 'ExecutionService';\n\nexport type ErrorMessageEvent = {\n  type: 'ExecutionService:unhandledError';\n  payload: [string, SnapErrorJson];\n};\n\nexport type OutboundRequest = {\n  type: 'ExecutionService:outboundRequest';\n  payload: [string];\n};\n\nexport type OutboundResponse = {\n  type: 'ExecutionService:outboundResponse';\n  payload: [string];\n};\n\nexport type ExecutionServiceEvents =\n  | ErrorMessageEvent\n  | OutboundRequest\n  | OutboundResponse;\n\n/**\n * Handles RPC request.\n */\nexport type HandleRpcRequestAction = {\n  type: `${ControllerName}:handleRpcRequest`;\n  handler: ExecutionService['handleRpcRequest'];\n};\n\n/**\n * Executes a given snap.\n */\nexport type ExecuteSnapAction = {\n  type: `${ControllerName}:executeSnap`;\n  handler: ExecutionService['executeSnap'];\n};\n\n/**\n * Terminates a given snap.\n */\nexport type TerminateSnapAction = {\n  type: `${ControllerName}:terminateSnap`;\n  handler: ExecutionService['terminateSnap'];\n};\n\n/**\n * Terminates all snaps.\n */\nexport type TerminateAllSnapsAction = {\n  type: `${ControllerName}:terminateAllSnaps`;\n  handler: ExecutionService['terminateAllSnaps'];\n};\n\nexport type ExecutionServiceActions =\n  | HandleRpcRequestAction\n  | ExecuteSnapAction\n  | TerminateSnapAction\n  | TerminateAllSnapsAction;\n\nexport type ExecutionServiceMessenger = RestrictedMessenger<\n  'ExecutionService',\n  ExecutionServiceActions,\n  ExecutionServiceEvents,\n  ExecutionServiceActions['type'],\n  ExecutionServiceEvents['type']\n>;\n"]}
\ No newline at end of file
+{"version":3,"file":"ExecutionService.mjs","sourceRoot":"","sources":["../../src/services/ExecutionService.ts"],"names":[],"mappings":"","sourcesContent":["import type { Messenger } from '@metamask/messenger';\nimport type { SnapRpcHookArgs } from '@metamask/snaps-utils';\nimport type { Json } from '@metamask/utils';\n\ntype TerminateSnap = (snapId: string) => Promise<void>;\ntype TerminateAll = () => Promise<void>;\ntype ExecuteSnap = (snapData: SnapExecutionData) => Promise<unknown>;\n\ntype HandleRpcRequest = (\n  snapId: string,\n  options: SnapRpcHookArgs,\n) => Promise<unknown>;\n\nexport type ExecutionService = {\n  // These fields are required for modular initialisation of the execution\n  // service in the MetaMask extension.\n  name: 'ExecutionService';\n  state: null;\n\n  terminateSnap: TerminateSnap;\n  terminateAllSnaps: TerminateAll;\n  executeSnap: ExecuteSnap;\n  handleRpcRequest: HandleRpcRequest;\n};\n\nexport type SnapExecutionData = {\n  snapId: string;\n  sourceCode: string;\n  endowments: Json;\n};\n\nexport type SnapErrorJson = {\n  message: string;\n  code: number;\n  data?: Json;\n};\n\ntype ControllerName = 'ExecutionService';\n\nexport type ErrorMessageEvent = {\n  type: 'ExecutionService:unhandledError';\n  payload: [string, SnapErrorJson];\n};\n\nexport type OutboundRequest = {\n  type: 'ExecutionService:outboundRequest';\n  payload: [string];\n};\n\nexport type OutboundResponse = {\n  type: 'ExecutionService:outboundResponse';\n  payload: [string];\n};\n\nexport type ExecutionServiceEvents =\n  | ErrorMessageEvent\n  | OutboundRequest\n  | OutboundResponse;\n\n/**\n * Handles RPC request.\n */\nexport type HandleRpcRequestAction = {\n  type: `${ControllerName}:handleRpcRequest`;\n  handler: ExecutionService['handleRpcRequest'];\n};\n\n/**\n * Executes a given snap.\n */\nexport type ExecuteSnapAction = {\n  type: `${ControllerName}:executeSnap`;\n  handler: ExecutionService['executeSnap'];\n};\n\n/**\n * Terminates a given snap.\n */\nexport type TerminateSnapAction = {\n  type: `${ControllerName}:terminateSnap`;\n  handler: ExecutionService['terminateSnap'];\n};\n\n/**\n * Terminates all snaps.\n */\nexport type TerminateAllSnapsAction = {\n  type: `${ControllerName}:terminateAllSnaps`;\n  handler: ExecutionService['terminateAllSnaps'];\n};\n\nexport type ExecutionServiceActions =\n  | HandleRpcRequestAction\n  | ExecuteSnapAction\n  | TerminateSnapAction\n  | TerminateAllSnapsAction;\n\nexport type ExecutionServiceMessenger = Messenger<\n  'ExecutionService',\n  ExecutionServiceActions,\n  ExecutionServiceEvents\n>;\n"]}
\ No newline at end of file
diff --git a/dist/snaps/SnapController.cjs b/dist/snaps/SnapController.cjs
index e7e414ef0bd5af4836790a81af9f28d3704f4c97..524d2b137abdd9512b3ad6252fd2c9a53891dc5b 100644
--- a/dist/snaps/SnapController.cjs
+++ b/dist/snaps/SnapController.cjs
@@ -2,7 +2,7 @@
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.SnapController = exports.SNAP_APPROVAL_RESULT = exports.SNAP_APPROVAL_UPDATE = exports.SNAP_APPROVAL_INSTALL = exports.controllerName = void 0;
 const approval_controller_1 = require("@metamask/approval-controller");
-const base_controller_1 = require("@metamask/base-controller");
+const next_1 = require("@metamask/base-controller/next");
 const permission_controller_1 = require("@metamask/permission-controller");
 const rpc_errors_1 = require("@metamask/rpc-errors");
 const snaps_rpc_methods_1 = require("@metamask/snaps-rpc-methods");
@@ -59,7 +59,7 @@ function truncateSnap(snap) {
  * - Authorize: Requests the snap's required permissions from the user.
  * - Start: Initializes the snap in its SES realm with the authorized permissions.
  */
-class SnapController extends base_controller_1.BaseController {
+class SnapController extends next_1.BaseController {
     #closeAllConnections;
     #dynamicPermissions;
     #environmentEndowmentPermissions;
@@ -90,13 +90,13 @@ class SnapController extends base_controller_1.BaseController {
                 snapStates: {
                     includeInStateLogs: false,
                     persist: true,
-                    anonymous: false,
+                    includeInDebugSnapshot: false,
                     usedInUi: false,
                 },
                 unencryptedSnapStates: {
                     includeInStateLogs: false,
                     persist: true,
-                    anonymous: false,
+                    includeInDebugSnapshot: false,
                     usedInUi: false,
                 },
                 snaps: {
@@ -127,7 +127,7 @@ class SnapController extends base_controller_1.BaseController {
                             return memo;
                         }, {}));
                     },
-                    anonymous: false,
+                    includeInDebugSnapshot: false,
                     // TODO: Ensure larger snap properties are not sent to the UI
                     // Currently these are stripped out manually in the extension
                     usedInUi: true,
@@ -162,21 +162,21 @@ class SnapController extends base_controller_1.BaseController {
         this.#trackEvent = trackEvent;
         this.#pollForLastRequestStatus();
         /* eslint-disable @typescript-eslint/unbound-method */
-        this.messagingSystem.subscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
-        this.messagingSystem.subscribe('ExecutionService:outboundRequest', this._onOutboundRequest);
-        this.messagingSystem.subscribe('ExecutionService:outboundResponse', this._onOutboundResponse);
+        this.messenger.subscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
+        this.messenger.subscribe('ExecutionService:outboundRequest', this._onOutboundRequest);
+        this.messenger.subscribe('ExecutionService:outboundResponse', this._onOutboundResponse);
         /* eslint-enable @typescript-eslint/unbound-method */
-        this.messagingSystem.subscribe('SnapController:snapInstalled', ({ id }, origin) => {
+        this.messenger.subscribe('SnapController:snapInstalled', ({ id }, origin) => {
             this.#callLifecycleHook(origin, id, snaps_utils_1.HandlerType.OnInstall).catch((error) => {
                 (0, snaps_utils_1.logError)(`Error when calling \`onInstall\` lifecycle hook for snap "${id}": ${(0, snaps_sdk_1.getErrorMessage)(error)}`);
             });
         });
-        this.messagingSystem.subscribe('SnapController:snapUpdated', ({ id }, _oldVersion, origin) => {
+        this.messenger.subscribe('SnapController:snapUpdated', ({ id }, _oldVersion, origin) => {
             this.#callLifecycleHook(origin, id, snaps_utils_1.HandlerType.OnUpdate).catch((error) => {
                 (0, snaps_utils_1.logError)(`Error when calling \`onUpdate\` lifecycle hook for snap "${id}": ${(0, snaps_sdk_1.getErrorMessage)(error)}`);
             });
         });
-        this.messagingSystem.subscribe('KeyringController:lock', this.#handleLock.bind(this));
+        this.messenger.subscribe('KeyringController:lock', this.#handleLock.bind(this));
         this.#initializeStateMachine();
         this.#registerMessageHandlers();
         Object.values(this.state?.snaps ?? {}).forEach((snap) => this.#setupRuntime(snap.id));
@@ -184,7 +184,7 @@ class SnapController extends base_controller_1.BaseController {
             this.#handlePreinstalledSnaps(this.#preinstalledSnaps);
         }
         this.#trackSnapExport = (0, utils_2.throttleTracking)((snapId, handler, success, origin) => {
-            const snapMetadata = this.messagingSystem.call('SnapsRegistry:getMetadata', snapId);
+            const snapMetadata = this.messenger.call('SnapsRegistry:getMetadata', snapId);
             this.#trackEvent({
                 event: 'Snap Export Used',
                 category: 'Snaps',
@@ -267,29 +267,29 @@ class SnapController extends base_controller_1.BaseController {
      * actions.
      */
     #registerMessageHandlers() {
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:init`, (...args) => this.init(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:clearSnapState`, (...args) => this.clearSnapState(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:get`, (...args) => this.get(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:getSnapState`, async (...args) => this.getSnapState(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:handleRequest`, async (...args) => this.handleRequest(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:has`, (...args) => this.has(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:updateRegistry`, async () => this.updateRegistry());
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:updateSnapState`, async (...args) => this.updateSnapState(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:enable`, (...args) => this.enableSnap(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:disable`, async (...args) => this.disableSnap(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:remove`, async (...args) => this.removeSnap(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:getPermitted`, (...args) => this.getPermittedSnaps(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:install`, async (...args) => this.installSnaps(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:getAll`, (...args) => this.getAllSnaps(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:getRunnableSnaps`, (...args) => this.getRunnableSnaps(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:incrementActiveReferences`, (...args) => this.incrementActiveReferences(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:decrementActiveReferences`, (...args) => this.decrementActiveReferences(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:disconnectOrigin`, (...args) => this.removeSnapFromSubject(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:revokeDynamicPermissions`, (...args) => this.revokeDynamicSnapPermissions(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:getFile`, async (...args) => this.getSnapFile(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:stopAllSnaps`, async (...args) => this.stopAllSnaps(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:isMinimumPlatformVersion`, (...args) => this.isMinimumPlatformVersion(...args));
-        this.messagingSystem.registerActionHandler(`${exports.controllerName}:setClientActive`, (...args) => this.setClientActive(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:init`, (...args) => this.init(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:clearSnapState`, (...args) => this.clearSnapState(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:get`, (...args) => this.get(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:getSnapState`, async (...args) => this.getSnapState(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:handleRequest`, async (...args) => this.handleRequest(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:has`, (...args) => this.has(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:updateRegistry`, async () => this.updateRegistry());
+        this.messenger.registerActionHandler(`${exports.controllerName}:updateSnapState`, async (...args) => this.updateSnapState(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:enable`, (...args) => this.enableSnap(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:disable`, async (...args) => this.disableSnap(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:remove`, async (...args) => this.removeSnap(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:getPermitted`, (...args) => this.getPermittedSnaps(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:install`, async (...args) => this.installSnaps(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:getAll`, (...args) => this.getAllSnaps(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:getRunnableSnaps`, (...args) => this.getRunnableSnaps(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:incrementActiveReferences`, (...args) => this.incrementActiveReferences(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:decrementActiveReferences`, (...args) => this.decrementActiveReferences(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:disconnectOrigin`, (...args) => this.removeSnapFromSubject(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:revokeDynamicPermissions`, (...args) => this.revokeDynamicSnapPermissions(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:getFile`, async (...args) => this.getSnapFile(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:stopAllSnaps`, async (...args) => this.stopAllSnaps(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:isMinimumPlatformVersion`, (...args) => this.isMinimumPlatformVersion(...args));
+        this.messenger.registerActionHandler(`${exports.controllerName}:setClientActive`, (...args) => this.setClientActive(...args));
     }
     /**
      * Initialise the SnapController.
@@ -359,10 +359,10 @@ class SnapController extends base_controller_1.BaseController {
             this.#setupRuntime(snapId);
             // Emit events
             if (isUpdate) {
-                this.messagingSystem.publish('SnapController:snapUpdated', this.getTruncatedExpect(snapId), existingSnap.version, constants_1.METAMASK_ORIGIN, true);
+                this.messenger.publish('SnapController:snapUpdated', this.getTruncatedExpect(snapId), existingSnap.version, constants_1.METAMASK_ORIGIN, true);
             }
             else {
-                this.messagingSystem.publish('SnapController:snapInstalled', this.getTruncatedExpect(snapId), constants_1.METAMASK_ORIGIN, true);
+                this.messenger.publish('SnapController:snapInstalled', this.getTruncatedExpect(snapId), constants_1.METAMASK_ORIGIN, true);
             }
         }
     }
@@ -384,8 +384,8 @@ class SnapController extends base_controller_1.BaseController {
      */
     async updateRegistry() {
         this.#assertCanUsePlatform();
-        await this.messagingSystem.call('SnapsRegistry:update');
-        const blockedSnaps = await this.messagingSystem.call('SnapsRegistry:get', Object.values(this.state.snaps).reduce((blockListArg, snap) => {
+        await this.messenger.call('SnapsRegistry:update');
+        const blockedSnaps = await this.messenger.call('SnapsRegistry:get', Object.values(this.state.snaps).reduce((blockListArg, snap) => {
             blockListArg[snap.id] = {
                 version: snap.version,
                 checksum: snap.manifest.source.shasum,
@@ -444,7 +444,7 @@ class SnapController extends base_controller_1.BaseController {
         catch (error) {
             (0, snaps_utils_1.logError)(`Encountered error when stopping blocked snap "${snapId}".`, error);
         }
-        this.messagingSystem.publish(`${exports.controllerName}:snapBlocked`, snapId, blockedSnapInfo);
+        this.messenger.publish(`${exports.controllerName}:snapBlocked`, snapId, blockedSnapInfo);
     }
     /**
      * Unblocks a snap so that it can be enabled and started again. Emits
@@ -461,10 +461,10 @@ class SnapController extends base_controller_1.BaseController {
             state.snaps[snapId].blocked = false;
             delete state.snaps[snapId].blockInformation;
         });
-        this.messagingSystem.publish(`${exports.controllerName}:snapUnblocked`, snapId);
+        this.messenger.publish(`${exports.controllerName}:snapUnblocked`, snapId);
     }
     async #assertIsInstallAllowed(snapId, { platformVersion, ...snapInfo }) {
-        const results = await this.messagingSystem.call('SnapsRegistry:get', {
+        const results = await this.messenger.call('SnapsRegistry:get', {
             [snapId]: snapInfo,
         });
         const result = results[snapId];
@@ -581,7 +581,7 @@ class SnapController extends base_controller_1.BaseController {
         this.update((state) => {
             state.snaps[snapId].enabled = true;
         });
-        this.messagingSystem.publish('SnapController:snapEnabled', this.getTruncatedExpect(snapId));
+        this.messenger.publish('SnapController:snapEnabled', this.getTruncatedExpect(snapId));
     }
     /**
      * Disables the given snap. A snap can only be started if it is enabled.
@@ -599,7 +599,7 @@ class SnapController extends base_controller_1.BaseController {
         if (this.isRunning(snapId)) {
             await this.stopSnap(snapId, snaps_utils_1.SnapStatusEvents.Stop);
         }
-        this.messagingSystem.publish('SnapController:snapDisabled', this.getTruncatedExpect(snapId));
+        this.messenger.publish('SnapController:snapDisabled', this.getTruncatedExpect(snapId));
     }
     /**
      * Stops the given snap, removes all hooks, closes all connections, and
@@ -659,7 +659,7 @@ class SnapController extends base_controller_1.BaseController {
      * @param snapId - The snap to terminate.
      */
     async #terminateSnap(snapId) {
-        await this.messagingSystem.call('ExecutionService:terminateSnap', snapId);
+        await this.messenger.call('ExecutionService:terminateSnap', snapId);
         // Hack to give up execution for a bit to let gracefully terminating Snaps return.
         await new Promise((resolve) => setTimeout(resolve, 1));
         const runtime = this.#getRuntimeExpect(snapId);
@@ -669,7 +669,7 @@ class SnapController extends base_controller_1.BaseController {
             .forEach((pendingRequest) => pendingRequest.timer.finish());
         // Hack to give up execution for a bit to let timed out requests return.
         await new Promise((resolve) => setTimeout(resolve, 1));
-        this.messagingSystem.publish('SnapController:snapTerminated', this.getTruncatedExpect(snapId));
+        this.messenger.publish('SnapController:snapTerminated', this.getTruncatedExpect(snapId));
     }
     /**
      * Returns whether the given snap is running.
@@ -1054,7 +1054,7 @@ class SnapController extends base_controller_1.BaseController {
             });
             // If the snap has been fully installed before, also emit snapUninstalled.
             if (snap.status !== snaps_utils_1.SnapStatus.Installing) {
-                this.messagingSystem.publish(`SnapController:snapUninstalled`, truncated);
+                this.messenger.publish(`SnapController:snapUninstalled`, truncated);
             }
         }));
     }
@@ -1070,7 +1070,7 @@ class SnapController extends base_controller_1.BaseController {
         }
     }
     #addSnapToSubject(origin, snapId) {
-        const subjectPermissions = this.messagingSystem.call('PermissionController:getPermissions', origin);
+        const subjectPermissions = this.messenger.call('PermissionController:getPermissions', origin);
         const existingCaveat = subjectPermissions?.[snaps_rpc_methods_1.WALLET_SNAP_PERMISSION_KEY]?.caveats?.find((caveat) => caveat.type === snaps_utils_1.SnapCaveatType.SnapIds);
         const subjectHasSnap = Boolean(existingCaveat?.value?.[snapId]);
         // If the subject is already connected to the snap, this is a no-op.
@@ -1079,7 +1079,7 @@ class SnapController extends base_controller_1.BaseController {
         }
         // If an existing caveat exists, we add the snap to that.
         if (existingCaveat) {
-            this.messagingSystem.call('PermissionController:updateCaveat', origin, snaps_rpc_methods_1.WALLET_SNAP_PERMISSION_KEY, snaps_utils_1.SnapCaveatType.SnapIds, { ...existingCaveat.value, [snapId]: {} });
+            this.messenger.call('PermissionController:updateCaveat', origin, snaps_rpc_methods_1.WALLET_SNAP_PERMISSION_KEY, snaps_utils_1.SnapCaveatType.SnapIds, { ...existingCaveat.value, [snapId]: {} });
             return;
         }
         const approvedPermissions = {
@@ -1094,7 +1094,7 @@ class SnapController extends base_controller_1.BaseController {
                 ],
             },
         };
-        this.messagingSystem.call('PermissionController:grantPermissions', {
+        this.messenger.call('PermissionController:grantPermissions', {
             approvedPermissions,
             subject: { origin },
         });
@@ -1106,7 +1106,7 @@ class SnapController extends base_controller_1.BaseController {
      * @param snapId - The id of the snap to remove.
      */
     removeSnapFromSubject(origin, snapId) {
-        const subjectPermissions = this.messagingSystem.call('PermissionController:getPermissions', origin);
+        const subjectPermissions = this.messenger.call('PermissionController:getPermissions', origin);
         const snapIdsCaveat = subjectPermissions?.[snaps_rpc_methods_1.WALLET_SNAP_PERMISSION_KEY]?.caveats?.find((caveat) => caveat.type === snaps_utils_1.SnapCaveatType.SnapIds);
         if (!snapIdsCaveat) {
             return;
@@ -1118,10 +1118,10 @@ class SnapController extends base_controller_1.BaseController {
             };
             delete newCaveatValue[snapId];
             if (Object.keys(newCaveatValue).length > 0) {
-                this.messagingSystem.call('PermissionController:updateCaveat', origin, snaps_rpc_methods_1.WALLET_SNAP_PERMISSION_KEY, snaps_utils_1.SnapCaveatType.SnapIds, newCaveatValue);
+                this.messenger.call('PermissionController:updateCaveat', origin, snaps_rpc_methods_1.WALLET_SNAP_PERMISSION_KEY, snaps_utils_1.SnapCaveatType.SnapIds, newCaveatValue);
             }
             else {
-                this.messagingSystem.call('PermissionController:revokePermissions', {
+                this.messenger.call('PermissionController:revokePermissions', {
                     [origin]: [snaps_rpc_methods_1.WALLET_SNAP_PERMISSION_KEY],
                 });
             }
@@ -1136,7 +1136,7 @@ class SnapController extends base_controller_1.BaseController {
      */
     revokeDynamicSnapPermissions(snapId, permissionNames) {
         (0, utils_1.assert)(permissionNames.every((permissionName) => this.#dynamicPermissions.includes(permissionName)), 'Non-dynamic permissions cannot be revoked');
-        this.messagingSystem.call('PermissionController:revokePermissions', {
+        this.messenger.call('PermissionController:revokePermissions', {
             [snapId]: permissionNames,
         });
     }
@@ -1146,7 +1146,7 @@ class SnapController extends base_controller_1.BaseController {
      * @param snapId - The id of the Snap.
      */
     #removeSnapFromSubjects(snapId) {
-        const subjects = this.messagingSystem.call('PermissionController:getSubjectNames');
+        const subjects = this.messenger.call('PermissionController:getSubjectNames');
         for (const subject of subjects) {
             this.removeSnapFromSubject(subject, snapId);
         }
@@ -1157,8 +1157,8 @@ class SnapController extends base_controller_1.BaseController {
      * @param snapId - The snap ID.
      */
     #revokeAllSnapPermissions(snapId) {
-        if (this.messagingSystem.call('PermissionController:hasPermissions', snapId)) {
-            this.messagingSystem.call('PermissionController:revokeAllPermissions', snapId);
+        if (this.messenger.call('PermissionController:hasPermissions', snapId)) {
+            this.messenger.call('PermissionController:revokeAllPermissions', snapId);
         }
     }
     /**
@@ -1203,7 +1203,7 @@ class SnapController extends base_controller_1.BaseController {
      * @returns The serialized permitted snaps for the origin.
      */
     getPermittedSnaps(origin) {
-        const permissions = this.messagingSystem.call('PermissionController:getPermissions', origin) ?? {};
+        const permissions = this.messenger.call('PermissionController:getPermissions', origin) ?? {};
         const snaps = permissions[snaps_rpc_methods_1.WALLET_SNAP_PERMISSION_KEY]?.caveats?.find((caveat) => caveat.type === snaps_utils_1.SnapCaveatType.SnapIds)?.value ?? {};
         return Object.keys(snaps).reduce((permittedSnaps, snapId) => {
             const snap = this.get(snapId);
@@ -1266,8 +1266,8 @@ class SnapController extends base_controller_1.BaseController {
                 result[snapId] = await this.#processRequestedSnap(origin, snapId, location, version);
             }
             // Once we finish all installs / updates, emit events.
-            pendingInstalls.forEach((snapId) => this.messagingSystem.publish(`SnapController:snapInstalled`, this.getTruncatedExpect(snapId), origin, false));
-            pendingUpdates.forEach(({ snapId, oldVersion }) => this.messagingSystem.publish(`SnapController:snapUpdated`, this.getTruncatedExpect(snapId), oldVersion, origin, false));
+            pendingInstalls.forEach((snapId) => this.messenger.publish(`SnapController:snapInstalled`, this.getTruncatedExpect(snapId), origin, false));
+            pendingUpdates.forEach(({ snapId, oldVersion }) => this.messenger.publish(`SnapController:snapUpdated`, this.getTruncatedExpect(snapId), oldVersion, origin, false));
             snapIds.forEach((snapId) => this.#rollbackSnapshots.delete(snapId));
         }
         catch (error) {
@@ -1312,7 +1312,7 @@ class SnapController extends base_controller_1.BaseController {
             snapId,
             type: exports.SNAP_APPROVAL_INSTALL,
         });
-        this.messagingSystem.publish('SnapController:snapInstallStarted', snapId, origin, false);
+        this.messenger.publish('SnapController:snapInstallStarted', snapId, origin, false);
         // Existing snaps must be stopped before overwriting
         if (existingSnap && this.isRunning(snapId)) {
             await this.stopSnap(snapId, snaps_utils_1.SnapStatusEvents.Stop);
@@ -1353,13 +1353,13 @@ class SnapController extends base_controller_1.BaseController {
                 type: exports.SNAP_APPROVAL_INSTALL,
                 error: errorString,
             });
-            this.messagingSystem.publish('SnapController:snapInstallFailed', snapId, origin, false, errorString);
+            this.messenger.publish('SnapController:snapInstallFailed', snapId, origin, false, errorString);
             throw error;
         }
     }
     #createApproval({ origin, snapId, type, }) {
         const id = (0, nanoid_1.nanoid)();
-        const promise = this.messagingSystem.call('ApprovalController:addRequest', {
+        const promise = this.messenger.call('ApprovalController:addRequest', {
             origin,
             id,
             type,
@@ -1376,7 +1376,7 @@ class SnapController extends base_controller_1.BaseController {
     }
     #updateApproval(id, requestState) {
         try {
-            this.messagingSystem.call('ApprovalController:updateRequestState', {
+            this.messenger.call('ApprovalController:updateRequestState', {
                 id,
                 requestState,
             });
@@ -1422,7 +1422,7 @@ class SnapController extends base_controller_1.BaseController {
                 type: exports.SNAP_APPROVAL_UPDATE,
             });
         try {
-            this.messagingSystem.publish('SnapController:snapInstallStarted', snapId, origin, true);
+            this.messenger.publish('SnapController:snapInstallStarted', snapId, origin, true);
             const oldManifest = snap.manifest;
             const newSnap = await (0, utils_2.fetchSnap)(snapId, location);
             const { sourceCode: sourceCodeFile, manifest: manifestFile } = newSnap;
@@ -1530,12 +1530,12 @@ class SnapController extends base_controller_1.BaseController {
                     type: exports.SNAP_APPROVAL_UPDATE,
                 });
             }
-            this.messagingSystem.publish('SnapController:snapInstallFailed', snapId, origin, true, errorString);
+            this.messenger.publish('SnapController:snapInstallFailed', snapId, origin, true, errorString);
             throw error;
         }
     }
     async #resolveAllowlistVersion(snapId, versionRange) {
-        return await this.messagingSystem.call('SnapsRegistry:resolveVersion', snapId, versionRange);
+        return await this.messenger.call('SnapsRegistry:resolveVersion', snapId, versionRange);
     }
     /**
      * Returns a promise representing the complete installation of the requested snap.
@@ -1598,7 +1598,7 @@ class SnapController extends base_controller_1.BaseController {
         }
         try {
             const runtime = this.#getRuntimeExpect(snapId);
-            const result = await this.messagingSystem.call('ExecutionService:executeSnap', {
+            const result = await this.messenger.call('ExecutionService:executeSnap', {
                 ...snapData,
                 endowments: await this.#getEndowments(snapId),
             });
@@ -1626,8 +1626,8 @@ class SnapController extends base_controller_1.BaseController {
     async #getEndowments(snapId) {
         let allEndowments = [];
         for (const permissionName of this.#environmentEndowmentPermissions) {
-            if (this.messagingSystem.call('PermissionController:hasPermission', snapId, permissionName)) {
-                const endowments = await this.messagingSystem.call('PermissionController:getEndowments', snapId, permissionName);
+            if (this.messenger.call('PermissionController:hasPermission', snapId, permissionName)) {
+                const endowments = await this.messenger.call('PermissionController:getEndowments', snapId, permissionName);
                 if (endowments) {
                     // We don't have any guarantees about the type of the endowments
                     // value, so we have to guard at runtime.
@@ -1727,7 +1727,7 @@ class SnapController extends base_controller_1.BaseController {
         // In case the Snap uses a localized manifest, we need to get the
         // proposed name from the localized manifest.
         const { proposedName } = (0, snaps_utils_1.getLocalizedSnapManifest)(manifest.result, 'en', localizedFiles);
-        this.messagingSystem.call('SubjectMetadataController:addSubjectMetadata', {
+        this.messenger.call('SubjectMetadataController:addSubjectMetadata', {
             subjectType: permission_controller_1.SubjectType.Snap,
             name: proposedName,
             origin: snap.id,
@@ -1813,11 +1813,11 @@ class SnapController extends base_controller_1.BaseController {
             clearTimeout(this.#timeoutForLastRequestStatus);
         }
         /* eslint-disable @typescript-eslint/unbound-method */
-        this.messagingSystem.unsubscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
-        this.messagingSystem.unsubscribe('ExecutionService:outboundRequest', this._onOutboundRequest);
-        this.messagingSystem.unsubscribe('ExecutionService:outboundResponse', this._onOutboundResponse);
-        this.messagingSystem.clearEventSubscriptions('SnapController:snapInstalled');
-        this.messagingSystem.clearEventSubscriptions('SnapController:snapUpdated');
+        this.messenger.unsubscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
+        this.messenger.unsubscribe('ExecutionService:outboundRequest', this._onOutboundRequest);
+        this.messenger.unsubscribe('ExecutionService:outboundResponse', this._onOutboundResponse);
+        this.messenger.clearEventSubscriptions('SnapController:snapInstalled');
+        this.messenger.clearEventSubscriptions('SnapController:snapUpdated');
         /* eslint-enable @typescript-eslint/unbound-method */
     }
     /**
@@ -1843,7 +1843,7 @@ class SnapController extends base_controller_1.BaseController {
         (0, utils_1.assertIsJsonRpcRequest)(request);
         const permissionName = snaps_rpc_methods_1.handlerEndowments[handlerType];
         (0, utils_1.assert)(typeof permissionName === 'string' || permissionName === null, "'permissionName' must be either a string or null.");
-        const permissions = this.messagingSystem.call('PermissionController:getPermissions', snapId);
+        const permissions = this.messenger.call('PermissionController:getPermissions', snapId);
         // If permissionName is null, the handler does not require a permission.
         if (permissionName !== null &&
             (!permissions || !(0, utils_1.hasProperty)(permissions, permissionName))) {
@@ -1855,7 +1855,7 @@ class SnapController extends base_controller_1.BaseController {
         if (permissionName === snaps_rpc_methods_1.SnapEndowments.Rpc ||
             permissionName === snaps_rpc_methods_1.SnapEndowments.Keyring) {
             (0, utils_1.assert)(handlerPermissions);
-            const subject = this.messagingSystem.call('SubjectMetadataController:getSubjectMetadata', origin);
+            const subject = this.messenger.call('SubjectMetadataController:getSubjectMetadata', origin);
             const origins = permissionName === snaps_rpc_methods_1.SnapEndowments.Rpc
                 ? (0, snaps_rpc_methods_1.getRpcCaveatOrigins)(handlerPermissions)
                 : (0, snaps_rpc_methods_1.getKeyringCaveatOrigins)(handlerPermissions);
@@ -1893,7 +1893,7 @@ class SnapController extends base_controller_1.BaseController {
         const transformedRequest = this.#transformSnapRpcRequest(snapId, handlerType, request);
         const timer = new Timer_1.Timer(timeout);
         this.#recordSnapRpcRequestStart(snapId, transformedRequest.id, timer);
-        const handleRpcRequestPromise = this.messagingSystem.call('ExecutionService:handleRpcRequest', snapId, { origin, handler: handlerType, request: transformedRequest });
+        const handleRpcRequestPromise = this.messenger.call('ExecutionService:handleRpcRequest', snapId, { origin, handler: handlerType, request: transformedRequest });
         // This will either get the result or reject due to the timeout.
         try {
             const result = await (0, utils_2.withTimeout)(handleRpcRequestPromise, timer);
@@ -1957,11 +1957,11 @@ class SnapController extends base_controller_1.BaseController {
      * @returns An identifier that can be used to identify the interface.
      */
     async #createInterface(snapId, content, contentType) {
-        return this.messagingSystem.call('SnapInterfaceController:createInterface', snapId, content, undefined, contentType);
+        return this.messenger.call('SnapInterfaceController:createInterface', snapId, content, undefined, contentType);
     }
     #assertInterfaceExists(snapId, id) {
         // This will throw if the interface isn't accessible, but we assert nevertheless.
-        (0, utils_1.assert)(this.messagingSystem.call('SnapInterfaceController:getInterface', snapId, id));
+        (0, utils_1.assert)(this.messenger.call('SnapInterfaceController:getInterface', snapId, id));
     }
     /**
      * Transform a RPC response if necessary.
@@ -2015,7 +2015,7 @@ class SnapController extends base_controller_1.BaseController {
      * @returns The transformed result.
      */
     #transformOnAssetsLookupResult(snapId, { params: requestedParams }, { assets }) {
-        const permissions = this.messagingSystem.call('PermissionController:getPermissions', snapId);
+        const permissions = this.messenger.call('PermissionController:getPermissions', snapId);
         // We know the permissions are guaranteed to be set here.
         (0, utils_1.assert)(permissions);
         const permission = permissions[snaps_rpc_methods_1.SnapEndowments.Assets];
@@ -2098,7 +2098,7 @@ class SnapController extends base_controller_1.BaseController {
             case snaps_utils_1.HandlerType.OnUserInput: {
                 (0, utils_1.assert)(request.params && (0, utils_1.hasProperty)(request.params, 'id'));
                 const interfaceId = request.params.id;
-                const { context } = this.messagingSystem.call('SnapInterfaceController:getInterface', snapId, interfaceId);
+                const { context } = this.messenger.call('SnapInterfaceController:getInterface', snapId, interfaceId);
                 return {
                     ...request,
                     params: { ...request.params, context },
@@ -2254,7 +2254,7 @@ class SnapController extends base_controller_1.BaseController {
         // Calling this in reverse order to undo the changes
         this.#handleInitialConnections(snapId, newInitialConnections ?? null, previousInitialConnections ?? {});
         const truncatedSnap = this.getTruncatedExpect(snapId);
-        this.messagingSystem.publish('SnapController:snapRolledback', truncatedSnap, rollbackSnapshot.newVersion);
+        this.messenger.publish('SnapController:snapRolledback', truncatedSnap, rollbackSnapshot.newVersion);
         this.#rollbackSnapshots.delete(snapId);
     }
     /**
@@ -2304,7 +2304,7 @@ class SnapController extends base_controller_1.BaseController {
         });
     }
     #calculatePermissionsChange(snapId, desiredPermissionsSet) {
-        const oldPermissions = this.messagingSystem.call('PermissionController:getPermissions', snapId) ?? {};
+        const oldPermissions = this.messenger.call('PermissionController:getPermissions', snapId) ?? {};
         const newPermissions = (0, utils_2.permissionsDiff)(desiredPermissionsSet, oldPermissions);
         // TODO(ritave): The assumption that these are unused only holds so long as we do not
         //               permit dynamic permission requests.
@@ -2315,7 +2315,7 @@ class SnapController extends base_controller_1.BaseController {
         return { newPermissions, unusedPermissions, approvedPermissions };
     }
     #isSubjectConnectedToSnap(snapId, origin) {
-        const subjectPermissions = this.messagingSystem.call('PermissionController:getPermissions', origin);
+        const subjectPermissions = this.messenger.call('PermissionController:getPermissions', origin);
         const existingCaveat = subjectPermissions?.[snaps_rpc_methods_1.WALLET_SNAP_PERMISSION_KEY]?.caveats?.find((caveat) => caveat.type === snaps_utils_1.SnapCaveatType.SnapIds);
         return Boolean(existingCaveat?.value?.[snapId]);
     }
@@ -2347,8 +2347,8 @@ class SnapController extends base_controller_1.BaseController {
         if (Object.keys(newPermissions).includes(snaps_rpc_methods_1.SnapEndowments.EthereumProvider)) {
             // This will return the globally selected network if the Snap doesn't have
             // one set.
-            const networkClientId = this.messagingSystem.call('SelectedNetworkController:getNetworkClientIdForDomain', snapId);
-            const { configuration } = this.messagingSystem.call('NetworkController:getNetworkClientById', networkClientId);
+            const networkClientId = this.messenger.call('SelectedNetworkController:getNetworkClientIdForDomain', snapId);
+            const { configuration } = this.messenger.call('NetworkController:getNetworkClientById', networkClientId);
             const chainId = (0, utils_1.hexToNumber)(configuration.chainId);
             // This needs to be assigned to have proper type inference.
             const modifiedPermissions = {
@@ -2389,13 +2389,13 @@ class SnapController extends base_controller_1.BaseController {
     #updatePermissions({ snapId, unusedPermissions = {}, newPermissions = {}, requestData, }) {
         const unusedPermissionsKeys = Object.keys(unusedPermissions);
         if ((0, utils_1.isNonEmptyArray)(unusedPermissionsKeys)) {
-            this.messagingSystem.call('PermissionController:revokePermissions', {
+            this.messenger.call('PermissionController:revokePermissions', {
                 [snapId]: unusedPermissionsKeys,
             });
         }
         if ((0, utils_1.isNonEmptyArray)(Object.keys(newPermissions))) {
             const approvedPermissions = this.#getPermissionsToGrant(snapId, newPermissions);
-            this.messagingSystem.call('PermissionController:grantPermissions', {
+            this.messenger.call('PermissionController:grantPermissions', {
                 approvedPermissions,
                 subject: { origin: snapId },
                 requestData,
@@ -2437,7 +2437,7 @@ class SnapController extends base_controller_1.BaseController {
     #callLifecycleHooks(origin, handler) {
         const snaps = this.getRunnableSnaps();
         for (const { id } of snaps) {
-            const hasLifecycleHooksEndowment = this.messagingSystem.call('PermissionController:hasPermission', id, snaps_rpc_methods_1.SnapEndowments.LifecycleHooks);
+            const hasLifecycleHooksEndowment = this.messenger.call('PermissionController:hasPermission', id, snaps_rpc_methods_1.SnapEndowments.LifecycleHooks);
             if (!hasLifecycleHooksEndowment) {
                 continue;
             }
@@ -2460,7 +2460,7 @@ class SnapController extends base_controller_1.BaseController {
     async #callLifecycleHook(origin, snapId, handler) {
         const permissionName = snaps_rpc_methods_1.handlerEndowments[handler];
         (0, utils_1.assert)(permissionName, 'Lifecycle hook must have an endowment.');
-        const hasPermission = this.messagingSystem.call('PermissionController:hasPermission', snapId, permissionName);
+        const hasPermission = this.messenger.call('PermissionController:hasPermission', snapId, permissionName);
         if (!hasPermission) {
             return;
         }
diff --git a/dist/snaps/SnapController.cjs.map b/dist/snaps/SnapController.cjs.map
index 592d85d753cae450352d8ed0f9e61fe926e72c1f..1461cdf39c5521a96800d9f8cbc52bd3ce855a1b 100644
--- a/dist/snaps/SnapController.cjs.map
+++ b/dist/snaps/SnapController.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"SnapController.cjs","sourceRoot":"","sources":["../../src/snaps/SnapController.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ORIGIN_METAMASK,\n  type AddApprovalRequest,\n  type UpdateRequestState,\n} from '@metamask/approval-controller';\nimport type {\n  RestrictedMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { CryptographicFunctions } from '@metamask/key-tree';\nimport type {\n  Caveat,\n  GetEndowments,\n  GetPermissions,\n  GetSubjectMetadata,\n  AddSubjectMetadata,\n  GetSubjects,\n  GrantPermissions,\n  HasPermission,\n  HasPermissions,\n  PermissionConstraint,\n  PermissionsRequest,\n  RequestedPermissions,\n  RevokeAllPermissions,\n  RevokePermissionForAllSubjects,\n  RevokePermissions,\n  SubjectPermissions,\n  UpdateCaveat,\n  ValidPermission,\n} from '@metamask/permission-controller';\nimport { SubjectType } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { BlockReason } from '@metamask/snaps-registry';\nimport {\n  WALLET_SNAP_PERMISSION_KEY,\n  getMaxRequestTimeCaveat,\n  handlerEndowments,\n  SnapEndowments,\n  getKeyringCaveatOrigins,\n  getRpcCaveatOrigins,\n  processSnapPermissions,\n  getEncryptionEntropy,\n  getChainIdsCaveat,\n} from '@metamask/snaps-rpc-methods';\nimport type {\n  RequestSnapsParams,\n  RequestSnapsResult,\n  SnapId,\n  ComponentOrElement,\n  ContentType,\n  OnAssetsLookupResponse,\n  OnAssetsConversionResponse,\n  OnAssetsConversionArguments,\n  AssetConversion,\n  OnAssetsLookupArguments,\n  OnAssetsMarketDataArguments,\n  OnAssetsMarketDataResponse,\n  AssetMarketData,\n  AssetMetadata,\n  EmptyObject,\n} from '@metamask/snaps-sdk';\nimport {\n  AuxiliaryFileEncoding,\n  getErrorMessage,\n  OnAssetsLookupResponseStruct,\n} from '@metamask/snaps-sdk';\nimport type {\n  FetchedSnapFiles,\n  InitialConnections,\n  PersistedSnap,\n  Snap,\n  SnapManifest,\n  SnapPermissions,\n  SnapRpcHookArgs,\n  StatusContext,\n  StatusEvents,\n  StatusStates,\n  TruncatedSnap,\n  TruncatedSnapFields,\n} from '@metamask/snaps-utils';\nimport {\n  logWarning,\n  getPlatformVersion,\n  assertIsSnapManifest,\n  assertIsValidSnapId,\n  DEFAULT_ENDOWMENTS,\n  encodeAuxiliaryFile,\n  HandlerType,\n  isOriginAllowed,\n  logError,\n  normalizeRelative,\n  OnTransactionResponseStruct,\n  OnSignatureResponseStruct,\n  resolveVersionRange,\n  SnapCaveatType,\n  SnapStatus,\n  SnapStatusEvents,\n  unwrapError,\n  OnHomePageResponseStruct,\n  getValidatedLocalizationFiles,\n  VirtualFile,\n  NpmSnapFileNames,\n  OnNameLookupResponseStruct,\n  getLocalizedSnapManifest,\n  MAX_FILE_SIZE,\n  OnSettingsPageResponseStruct,\n  isValidUrl,\n  OnAssetHistoricalPriceResponseStruct,\n  OnAssetsConversionResponseStruct,\n  OnAssetsMarketDataResponseStruct,\n} from '@metamask/snaps-utils';\nimport type {\n  Json,\n  NonEmptyArray,\n  SemVerRange,\n  CaipAssetType,\n  JsonRpcRequest,\n  Hex,\n  SemVerVersion,\n  CaipAssetTypeOrId,\n} from '@metamask/utils';\nimport {\n  hexToNumber,\n  assert,\n  assertIsJsonRpcRequest,\n  assertStruct,\n  Duration,\n  gtRange,\n  gtVersion,\n  hasProperty,\n  inMilliseconds,\n  isNonEmptyArray,\n  satisfiesVersionRange,\n  timeSince,\n  createDeferredPromise,\n} from '@metamask/utils';\nimport type { StateMachine } from '@xstate/fsm';\nimport { createMachine, interpret } from '@xstate/fsm';\nimport { Mutex } from 'async-mutex';\nimport type { Patch } from 'immer';\nimport { nanoid } from 'nanoid';\nimport { gt, gte } from 'semver';\n\nimport {\n  ALLOWED_PERMISSIONS,\n  CLIENT_ONLY_HANDLERS,\n  LEGACY_ENCRYPTION_KEY_DERIVATION_OPTIONS,\n  METAMASK_ORIGIN,\n  STATE_DEBOUNCE_TIMEOUT,\n} from './constants';\nimport type { SnapLocation } from './location';\nimport { detectSnapLocation } from './location';\nimport type {\n  GetMetadata,\n  GetResult,\n  ResolveVersion,\n  SnapsRegistryInfo,\n  SnapsRegistryRequest,\n  Update,\n} from './registry';\nimport { SnapsRegistryStatus } from './registry';\nimport { getRunnableSnaps } from './selectors';\nimport { Timer } from './Timer';\nimport { forceStrict, validateMachine } from '../fsm';\nimport type { CreateInterface, GetInterface } from '../interface';\nimport { log } from '../logging';\nimport type {\n  ExecuteSnapAction,\n  ExecutionServiceEvents,\n  HandleRpcRequestAction,\n  SnapErrorJson,\n  TerminateSnapAction,\n} from '../services';\nimport type {\n  EncryptionResult,\n  ExportableKeyEncryptor,\n  KeyDerivationOptions,\n} from '../types';\nimport {\n  debouncePersistState,\n  fetchSnap,\n  hasTimedOut,\n  permissionsDiff,\n  setDiff,\n  throttleTracking,\n  withTimeout,\n  isTrackableHandler,\n  isLocalSnapId,\n} from '../utils';\n\nexport const controllerName = 'SnapController';\n\n// TODO: Figure out how to name these\nexport const SNAP_APPROVAL_INSTALL = 'wallet_installSnap';\nexport const SNAP_APPROVAL_UPDATE = 'wallet_updateSnap';\nexport const SNAP_APPROVAL_RESULT = 'wallet_installSnapResult';\n\nconst TRUNCATED_SNAP_PROPERTIES = new Set<TruncatedSnapFields>([\n  'initialPermissions',\n  'id',\n  'version',\n  'enabled',\n  'blocked',\n]);\n\nexport type PendingRequest = {\n  requestId: unknown;\n  timer: Timer;\n};\n\nexport type PreinstalledSnapFile = {\n  path: string;\n  value: string | Uint8Array;\n};\n\nexport type PreinstalledSnap = {\n  snapId: SnapId;\n  manifest: SnapManifest;\n  files: PreinstalledSnapFile[];\n  removable?: boolean;\n  hidden?: boolean;\n  hideSnapBranding?: boolean;\n};\n\n/**\n * A wrapper type for any data stored during runtime of Snaps.\n * It is not persisted in state as it contains non-serializable data and is only relevant for the\n * current session.\n */\nexport type SnapRuntimeData = {\n  /**\n   * A promise that resolves when the Snap has finished installing\n   */\n  installPromise: null | Promise<PersistedSnap>;\n\n  /**\n   * A promise that resolves when the Snap has finished booting\n   */\n  startPromise: null | Promise<void>;\n\n  /**\n   * A promise that resolves when the Snap has finished stopping\n   */\n  stopPromise: null | Promise<void>;\n\n  /**\n   * A Unix timestamp for the last time the Snap received an RPC request\n   */\n  lastRequest: null | number;\n\n  /**\n   * The current number of active references where this Snap is being used\n   */\n  activeReferences: number;\n\n  /**\n   * The current pending inbound requests, meaning requests that are processed by snaps.\n   */\n  pendingInboundRequests: PendingRequest[];\n\n  /**\n   * The current pending outbound requests, meaning requests made from snaps towards the MetaMask\n   * extension.\n   */\n  pendingOutboundRequests: number;\n\n  /**\n   * The finite state machine interpreter for possible states that the Snap can be in such as\n   * stopped, running, blocked\n   *\n   * @see {@link SnapController:constructor}\n   */\n  interpreter: StateMachine.Service<StatusContext, StatusEvents, StatusStates>;\n\n  /**\n   * Cached encryption key used for state encryption.\n   */\n  encryptionKey: string | null;\n\n  /**\n   * Cached encryption salt used for state encryption.\n   */\n  encryptionSalt: string | null;\n\n  /**\n   * Cached encrypted state of the Snap.\n   */\n  state?: Record<string, Json> | null;\n\n  /**\n   * Cached unencrypted state of the Snap.\n   */\n  unencryptedState?: Record<string, Json> | null;\n\n  /**\n   * A mutex to prevent concurrent state updates.\n   */\n  stateMutex: Mutex;\n\n  /**\n   * A mutex to prevent concurrent state decryption.\n   */\n  getStateMutex: Mutex;\n};\n\nexport type SnapError = {\n  message: string;\n  code: number;\n  data?: Json;\n};\n\n// Types that probably should be defined elsewhere in prod\ntype CloseAllConnectionsFunction = (origin: string) => void;\ntype StoredSnaps = Record<SnapId, Snap>;\n\nexport type SnapControllerState = {\n  snaps: StoredSnaps;\n  snapStates: Record<SnapId, string | null>;\n  unencryptedSnapStates: Record<SnapId, string | null>;\n};\n\nexport type PersistedSnapControllerState = SnapControllerState & {\n  snaps: Record<SnapId, PersistedSnap>;\n  snapStates: Record<SnapId, string>;\n};\n\ntype RollbackSnapshot = {\n  statePatches: Patch[];\n  permissions: {\n    revoked?: SubjectPermissions<ValidPermission<string, Caveat<string, any>>>;\n    granted?: RequestedPermissions;\n    requestData?: Record<string, unknown>;\n  };\n  previousInitialConnections?: Record<string, EmptyObject> | null;\n  newInitialConnections?: Record<string, EmptyObject>;\n  newVersion: string;\n};\n\ntype PendingApproval = {\n  id: string;\n  promise: Promise<unknown>;\n};\n\n// Controller Messenger Actions\n\n/**\n * Initialise the SnapController. This should be called after all controllers\n * are created.\n */\nexport type SnapControllerInitAction = {\n  type: `${typeof controllerName}:init`;\n  handler: SnapController['init'];\n};\n\n/**\n * Gets the specified Snap from state.\n */\nexport type GetSnap = {\n  type: `${typeof controllerName}:get`;\n  handler: SnapController['get'];\n};\n\n/**\n * Handles sending an inbound request to a snap and returns its result.\n */\nexport type HandleSnapRequest = {\n  type: `${typeof controllerName}:handleRequest`;\n  handler: SnapController['handleRequest'];\n};\n\n/**\n * Gets the specified Snap's persisted state.\n */\nexport type GetSnapState = {\n  type: `${typeof controllerName}:getSnapState`;\n  handler: SnapController['getSnapState'];\n};\n\n/**\n * Checks if the specified snap exists in state.\n */\nexport type HasSnap = {\n  type: `${typeof controllerName}:has`;\n  handler: SnapController['has'];\n};\n\n/**\n * Updates the specified Snap's persisted state.\n */\nexport type UpdateSnapState = {\n  type: `${typeof controllerName}:updateSnapState`;\n  handler: SnapController['updateSnapState'];\n};\n\n/**\n * Clears the specified Snap's persisted state.\n */\nexport type ClearSnapState = {\n  type: `${typeof controllerName}:clearSnapState`;\n  handler: SnapController['clearSnapState'];\n};\n\n/**\n * Checks all installed snaps against the blocklist.\n */\nexport type UpdateRegistry = {\n  type: `${typeof controllerName}:updateRegistry`;\n  handler: SnapController['updateRegistry'];\n};\n\nexport type EnableSnap = {\n  type: `${typeof controllerName}:enable`;\n  handler: SnapController['enableSnap'];\n};\n\nexport type DisableSnap = {\n  type: `${typeof controllerName}:disable`;\n  handler: SnapController['disableSnap'];\n};\n\nexport type RemoveSnap = {\n  type: `${typeof controllerName}:remove`;\n  handler: SnapController['removeSnap'];\n};\n\nexport type GetPermittedSnaps = {\n  type: `${typeof controllerName}:getPermitted`;\n  handler: SnapController['getPermittedSnaps'];\n};\n\nexport type GetAllSnaps = {\n  type: `${typeof controllerName}:getAll`;\n  handler: SnapController['getAllSnaps'];\n};\n\nexport type GetRunnableSnaps = {\n  type: `${typeof controllerName}:getRunnableSnaps`;\n  handler: SnapController['getRunnableSnaps'];\n};\n\nexport type StopAllSnaps = {\n  type: `${typeof controllerName}:stopAllSnaps`;\n  handler: SnapController['stopAllSnaps'];\n};\n\nexport type IncrementActiveReferences = {\n  type: `${typeof controllerName}:incrementActiveReferences`;\n  handler: SnapController['incrementActiveReferences'];\n};\n\nexport type DecrementActiveReferences = {\n  type: `${typeof controllerName}:decrementActiveReferences`;\n  handler: SnapController['decrementActiveReferences'];\n};\n\nexport type InstallSnaps = {\n  type: `${typeof controllerName}:install`;\n  handler: SnapController['installSnaps'];\n};\n\nexport type DisconnectOrigin = {\n  type: `${typeof controllerName}:disconnectOrigin`;\n  handler: SnapController['removeSnapFromSubject'];\n};\n\nexport type RevokeDynamicPermissions = {\n  type: `${typeof controllerName}:revokeDynamicPermissions`;\n  handler: SnapController['revokeDynamicSnapPermissions'];\n};\n\nexport type GetSnapFile = {\n  type: `${typeof controllerName}:getFile`;\n  handler: SnapController['getSnapFile'];\n};\n\nexport type IsMinimumPlatformVersion = {\n  type: `${typeof controllerName}:isMinimumPlatformVersion`;\n  handler: SnapController['isMinimumPlatformVersion'];\n};\n\nexport type SetClientActive = {\n  type: `${typeof controllerName}:setClientActive`;\n  handler: SnapController['setClientActive'];\n};\n\nexport type SnapControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapControllerState\n>;\n\nexport type SnapControllerActions =\n  | SnapControllerInitAction\n  | ClearSnapState\n  | GetSnap\n  | GetSnapState\n  | HandleSnapRequest\n  | HasSnap\n  | UpdateRegistry\n  | UpdateSnapState\n  | EnableSnap\n  | DisableSnap\n  | RemoveSnap\n  | GetPermittedSnaps\n  | InstallSnaps\n  | GetAllSnaps\n  | GetRunnableSnaps\n  | IncrementActiveReferences\n  | DecrementActiveReferences\n  | DisconnectOrigin\n  | RevokeDynamicPermissions\n  | GetSnapFile\n  | SnapControllerGetStateAction\n  | StopAllSnaps\n  | IsMinimumPlatformVersion\n  | SetClientActive;\n\n// Controller Messenger Events\n\nexport type SnapStateChange = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [SnapControllerState, Patch[]];\n};\n\n/**\n * Emitted when an installed snap has been blocked.\n */\nexport type SnapBlocked = {\n  type: `${typeof controllerName}:snapBlocked`;\n  payload: [snapId: string, blockedSnapInfo?: BlockReason];\n};\n\n/**\n * Emitted when a snap installation or update is started.\n */\nexport type SnapInstallStarted = {\n  type: `${typeof controllerName}:snapInstallStarted`;\n  payload: [snapId: SnapId, origin: string, isUpdate: boolean];\n};\n\n/**\n * Emitted when a snap installation or update failed.\n */\nexport type SnapInstallFailed = {\n  type: `${typeof controllerName}:snapInstallFailed`;\n  payload: [snapId: SnapId, origin: string, isUpdate: boolean, error: string];\n};\n\n/**\n * Emitted when a snap has been started after being added and authorized during\n * installation.\n */\nexport type SnapInstalled = {\n  type: `${typeof controllerName}:snapInstalled`;\n  payload: [snap: TruncatedSnap, origin: string, preinstalled: boolean];\n};\n\n/**\n * Emitted when a snap that has previously been fully installed, is uninstalled.\n */\nexport type SnapUninstalled = {\n  type: `${typeof controllerName}:snapUninstalled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when an installed snap has been unblocked.\n */\nexport type SnapUnblocked = {\n  type: `${typeof controllerName}:snapUnblocked`;\n  payload: [snapId: string];\n};\n\n/**\n * Emitted when a snap is updated.\n */\nexport type SnapUpdated = {\n  type: `${typeof controllerName}:snapUpdated`;\n  payload: [\n    snap: TruncatedSnap,\n    oldVersion: string,\n    origin: string,\n    preinstalled: boolean,\n  ];\n};\n\n/**\n * Emitted when a snap is rolled back.\n */\nexport type SnapRolledback = {\n  type: `${typeof controllerName}:snapRolledback`;\n  payload: [snap: TruncatedSnap, failedVersion: string];\n};\n\n/**\n * Emitted when a Snap is terminated. This is different from the snap being\n * stopped as it can also be triggered when a snap fails initialization.\n */\nexport type SnapTerminated = {\n  type: `${typeof controllerName}:snapTerminated`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when a Snap is enabled by a user.\n * This is not emitted by default when installing a snap.\n */\nexport type SnapEnabled = {\n  type: `${typeof controllerName}:snapEnabled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when a Snap is disabled by a user.\n */\nexport type SnapDisabled = {\n  type: `${typeof controllerName}:snapDisabled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when there is a state change.\n */\nexport type SnapControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  SnapControllerState\n>;\n\ntype KeyringControllerLock = {\n  type: 'KeyringController:lock';\n  payload: [];\n};\n\nexport type SnapControllerEvents =\n  | SnapBlocked\n  | SnapInstalled\n  | SnapUninstalled\n  | SnapInstallStarted\n  | SnapInstallFailed\n  | SnapStateChange\n  | SnapUnblocked\n  | SnapUpdated\n  | SnapRolledback\n  | SnapTerminated\n  | SnapEnabled\n  | SnapDisabled\n  | SnapControllerStateChangeEvent;\n\ntype NetworkControllerGetNetworkClientById = {\n  type: `NetworkController:getNetworkClientById`;\n  handler: (customNetworkClientId: string) => {\n    configuration: {\n      chainId: Hex;\n    };\n  };\n};\n\ntype SelectedNetworkControllerGetNetworkClientIdForDomain = {\n  type: `SelectedNetworkController:getNetworkClientIdForDomain`;\n  handler: (domain: string) => string;\n};\n\nexport type AllowedActions =\n  | GetEndowments\n  | GetPermissions\n  | GetSubjects\n  | GetSubjectMetadata\n  | AddSubjectMetadata\n  | HasPermission\n  | HasPermissions\n  | RevokePermissions\n  | RevokeAllPermissions\n  | RevokePermissionForAllSubjects\n  | GrantPermissions\n  | AddApprovalRequest\n  | HandleRpcRequestAction\n  | ExecuteSnapAction\n  | TerminateSnapAction\n  | UpdateCaveat\n  | UpdateRequestState\n  | GetResult\n  | GetMetadata\n  | Update\n  | ResolveVersion\n  | CreateInterface\n  | GetInterface\n  | NetworkControllerGetNetworkClientById\n  | SelectedNetworkControllerGetNetworkClientIdForDomain;\n\nexport type AllowedEvents =\n  | ExecutionServiceEvents\n  | SnapInstalled\n  | SnapUpdated\n  | KeyringControllerLock;\n\ntype SnapControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  SnapControllerActions | AllowedActions,\n  SnapControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\ntype FeatureFlags = {\n  requireAllowlist?: boolean;\n  allowLocalSnaps?: boolean;\n  disableSnapInstallation?: boolean;\n  rejectInvalidPlatformVersion?: boolean;\n\n  /**\n   * Force any local Snap to be treated as a preinstalled Snap.\n   *\n   * This should only be used for local testing, and should not be enabled in\n   * any production builds (including beta and Flask).\n   */\n  forcePreinstalledSnaps?: boolean;\n\n  /**\n   * Automatically update preinstalled Snaps \"over the air\",\n   * when a new version of the Snap is added to the registry.\n   */\n  autoUpdatePreinstalledSnaps?: boolean;\n};\n\ntype DynamicFeatureFlags = {\n  disableSnaps?: boolean;\n};\n\ntype SnapControllerArgs = {\n  /**\n   * A teardown function that allows the host to clean up its instrumentation\n   * for a running snap.\n   */\n  closeAllConnections?: CloseAllConnectionsFunction;\n\n  /**\n   * A list of permissions that are allowed to be dynamic, meaning they can be revoked from the snap whenever.\n   */\n  dynamicPermissions?: string[];\n\n  /**\n   * The names of endowment permissions whose values are the names of JavaScript\n   * APIs that will be added to the snap execution environment at runtime.\n   */\n  environmentEndowmentPermissions?: string[];\n\n  /**\n   * Excluded permissions with its associated error message used to forbid certain permissions.\n   */\n  excludedPermissions?: Record<string, string>;\n\n  /**\n   * The function that will be used by the controller fo make network requests.\n   * Should be compatible with {@link fetch}.\n   */\n  fetchFunction?: typeof fetch;\n\n  /**\n   * Flags that enable or disable features in the controller.\n   * See {@link FeatureFlags}.\n   */\n  featureFlags: FeatureFlags;\n\n  /**\n   * How frequently to check whether a snap is idle.\n   */\n  idleTimeCheckInterval?: number;\n\n  /**\n   * The maximum amount of time that a snap may be idle.\n   */\n  maxIdleTime?: number;\n\n  /**\n   * The controller messenger.\n   */\n  messenger: SnapControllerMessenger;\n\n  /**\n   * The maximum amount of time a snap may take to process an RPC request,\n   * unless it is permitted to take longer.\n   */\n  maxRequestTime?: number;\n\n  /**\n   * The npm registry URL that will be used to fetch published snaps.\n   */\n  npmRegistryUrl?: string;\n\n  /**\n   * Persisted state that will be used for rehydration.\n   */\n  state?: PersistedSnapControllerState;\n\n  /**\n   * A function that takes Snap Id and converts it into a class that fetches files.\n   *\n   * Used for test overrides.\n   */\n  detectSnapLocation?: typeof detectSnapLocation;\n\n  /**\n   * A list of snaps to be preinstalled into the SnapController state on initialization.\n   */\n  preinstalledSnaps?: PreinstalledSnap[] | null;\n\n  /**\n   * A utility object containing functions required for state encryption.\n   */\n  encryptor: ExportableKeyEncryptor;\n\n  /**\n   * A hook to access the mnemonic seed of the user's primary keyring.\n   *\n   * @returns The mnemonic seed as bytes.\n   */\n  getMnemonicSeed: () => Promise<Uint8Array>;\n\n  /**\n   * A hook to get dynamic feature flags at runtime.\n   *\n   * @returns The feature flags.\n   */\n  getFeatureFlags: () => DynamicFeatureFlags;\n\n  /**\n   * The cryptographic functions to use for the client. This may be an empty\n   * object to fall back to the default cryptographic functions.\n   */\n  clientCryptography?: CryptographicFunctions;\n\n  /**\n   * MetaMetrics event tracking hook.\n   */\n  trackEvent: TrackEventHook;\n};\n\ntype AddSnapArgs = {\n  id: SnapId;\n  origin: string;\n  location: SnapLocation;\n  versionRange: SemVerRange;\n};\n\n// When we set a snap, we need all required properties to be present and\n// validated.\ntype SetSnapArgs = Omit<AddSnapArgs, 'location' | 'versionRange'> & {\n  files: FetchedSnapFiles;\n  isUpdate?: boolean;\n  removable?: boolean;\n  preinstalled?: boolean;\n  hidden?: boolean;\n  hideSnapBranding?: boolean;\n};\n\ntype TrackingEventPayload = {\n  event: string;\n  category: string;\n  properties: Record<string, Json | undefined>;\n};\n\ntype TrackEventHook = (event: TrackingEventPayload) => void;\n\nconst defaultState: SnapControllerState = {\n  snaps: {},\n  snapStates: {},\n  unencryptedSnapStates: {},\n};\n\n/**\n * Truncates the properties of a snap to only ones that are easily serializable.\n *\n * @param snap - The snap to truncate.\n * @returns Object with serializable snap properties.\n */\nfunction truncateSnap(snap: Snap): TruncatedSnap {\n  const truncatedSnap = Object.keys(snap).reduce<Partial<TruncatedSnap>>(\n    (serialized, key) => {\n      if (TRUNCATED_SNAP_PROPERTIES.has(key as any)) {\n        serialized[key as keyof TruncatedSnap] = snap[\n          key as keyof TruncatedSnap\n        ] as any;\n      }\n\n      return serialized;\n    },\n    {},\n  );\n\n  return truncatedSnap as TruncatedSnap;\n}\n\n/*\n * A snap is initialized in three phases:\n * - Add: Loads the snap from a remote source and parses it.\n * - Authorize: Requests the snap's required permissions from the user.\n * - Start: Initializes the snap in its SES realm with the authorized permissions.\n */\n\nexport class SnapController extends BaseController<\n  typeof controllerName,\n  SnapControllerState,\n  SnapControllerMessenger\n> {\n  readonly #closeAllConnections?: CloseAllConnectionsFunction;\n\n  readonly #dynamicPermissions: string[];\n\n  readonly #environmentEndowmentPermissions: string[];\n\n  readonly #excludedPermissions: Record<string, string>;\n\n  readonly #featureFlags: FeatureFlags;\n\n  readonly #fetchFunction: typeof fetch;\n\n  readonly #idleTimeCheckInterval: number;\n\n  readonly #maxIdleTime: number;\n\n  // This property cannot be hash private yet because of tests.\n  // eslint-disable-next-line no-restricted-syntax\n  private readonly maxRequestTime: number;\n\n  readonly #encryptor: ExportableKeyEncryptor;\n\n  readonly #getMnemonicSeed: () => Promise<Uint8Array>;\n\n  readonly #getFeatureFlags: () => DynamicFeatureFlags;\n\n  readonly #clientCryptography: CryptographicFunctions | undefined;\n\n  readonly #detectSnapLocation: typeof detectSnapLocation;\n\n  readonly #snapsRuntimeData: Map<SnapId, SnapRuntimeData>;\n\n  readonly #rollbackSnapshots: Map<string, RollbackSnapshot>;\n\n  #timeoutForLastRequestStatus?: number;\n\n  #statusMachine!: StateMachine.Machine<\n    StatusContext,\n    StatusEvents,\n    StatusStates\n  >;\n\n  readonly #preinstalledSnaps: PreinstalledSnap[] | null;\n\n  readonly #trackEvent: TrackEventHook;\n\n  readonly #trackSnapExport: ReturnType<typeof throttleTracking>;\n\n  constructor({\n    closeAllConnections,\n    messenger,\n    state,\n    dynamicPermissions = ['eth_accounts'],\n    environmentEndowmentPermissions = [],\n    excludedPermissions = {},\n    idleTimeCheckInterval = inMilliseconds(5, Duration.Second),\n    maxIdleTime = inMilliseconds(30, Duration.Second),\n    maxRequestTime = inMilliseconds(60, Duration.Second),\n    fetchFunction = globalThis.fetch.bind(undefined),\n    featureFlags = {},\n    detectSnapLocation: detectSnapLocationFunction = detectSnapLocation,\n    preinstalledSnaps = null,\n    encryptor,\n    getMnemonicSeed,\n    getFeatureFlags = () => ({}),\n    clientCryptography,\n    trackEvent,\n  }: SnapControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        snapStates: {\n          includeInStateLogs: false,\n          persist: true,\n          anonymous: false,\n          usedInUi: false,\n        },\n        unencryptedSnapStates: {\n          includeInStateLogs: false,\n          persist: true,\n          anonymous: false,\n          usedInUi: false,\n        },\n        snaps: {\n          includeInStateLogs: (snaps) => {\n            // Delete larger snap properties\n            return Object.values(snaps).reduce<Record<SnapId, Partial<Snap>>>(\n              (acc, snap) => {\n                const snapCopy: Partial<Snap> = { ...snap };\n                delete snapCopy.sourceCode;\n                delete snapCopy.auxiliaryFiles;\n                acc[snap.id] = snapCopy;\n                return acc;\n              },\n              {},\n            );\n          },\n          persist: (snaps) => {\n            return (\n              Object.values(snaps)\n                // We should not persist snaps that are in the installing state,\n                // since they haven't completed installation and would be unusable\n                .filter((snap) => snap.status !== SnapStatus.Installing)\n                .map((snap) => {\n                  return {\n                    ...snap,\n                    // At the time state is rehydrated, no snap will be running.\n                    status: SnapStatus.Stopped,\n                  };\n                })\n                .reduce((memo: Record<SnapId, Snap>, snap) => {\n                  memo[snap.id] = snap;\n                  return memo;\n                }, {})\n            );\n          },\n          anonymous: false,\n          // TODO: Ensure larger snap properties are not sent to the UI\n          // Currently these are stripped out manually in the extension\n          usedInUi: true,\n        },\n      },\n      name: controllerName,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n\n    this.#closeAllConnections = closeAllConnections;\n    this.#dynamicPermissions = dynamicPermissions;\n    this.#environmentEndowmentPermissions = environmentEndowmentPermissions;\n    this.#excludedPermissions = excludedPermissions;\n    this.#featureFlags = featureFlags;\n    this.#fetchFunction = fetchFunction;\n    this.#idleTimeCheckInterval = idleTimeCheckInterval;\n    this.#maxIdleTime = maxIdleTime;\n    this.maxRequestTime = maxRequestTime;\n    this.#detectSnapLocation = detectSnapLocationFunction;\n    this.#encryptor = encryptor;\n    this.#getMnemonicSeed = getMnemonicSeed;\n    this.#getFeatureFlags = getFeatureFlags;\n    this.#clientCryptography = clientCryptography;\n    this.#preinstalledSnaps = preinstalledSnaps;\n    this._onUnhandledSnapError = this._onUnhandledSnapError.bind(this);\n    this._onOutboundRequest = this._onOutboundRequest.bind(this);\n    this._onOutboundResponse = this._onOutboundResponse.bind(this);\n    this.#rollbackSnapshots = new Map();\n    this.#snapsRuntimeData = new Map();\n    this.#trackEvent = trackEvent;\n\n    this.#pollForLastRequestStatus();\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.subscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messagingSystem.subscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messagingSystem.subscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapInstalled',\n      ({ id }, origin) => {\n        this.#callLifecycleHook(origin, id, HandlerType.OnInstall).catch(\n          (error) => {\n            logError(\n              `Error when calling \\`onInstall\\` lifecycle hook for snap \"${id}\": ${getErrorMessage(\n                error,\n              )}`,\n            );\n          },\n        );\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapUpdated',\n      ({ id }, _oldVersion, origin) => {\n        this.#callLifecycleHook(origin, id, HandlerType.OnUpdate).catch(\n          (error) => {\n            logError(\n              `Error when calling \\`onUpdate\\` lifecycle hook for snap \"${id}\": ${getErrorMessage(\n                error,\n              )}`,\n            );\n          },\n        );\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'KeyringController:lock',\n      this.#handleLock.bind(this),\n    );\n\n    this.#initializeStateMachine();\n    this.#registerMessageHandlers();\n\n    Object.values(this.state?.snaps ?? {}).forEach((snap) =>\n      this.#setupRuntime(snap.id),\n    );\n\n    if (this.#preinstalledSnaps) {\n      this.#handlePreinstalledSnaps(this.#preinstalledSnaps);\n    }\n\n    this.#trackSnapExport = throttleTracking(\n      (snapId: SnapId, handler: string, success: boolean, origin: string) => {\n        const snapMetadata = this.messagingSystem.call(\n          'SnapsRegistry:getMetadata',\n          snapId,\n        );\n        this.#trackEvent({\n          event: 'Snap Export Used',\n          category: 'Snaps',\n          properties: {\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            snap_id: snapId,\n            export: handler,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            snap_category: snapMetadata?.category,\n            success,\n            origin,\n          },\n        });\n      },\n    );\n  }\n\n  /**\n   * We track status of a Snap using a finite-state-machine.\n   * It keeps track of whether the snap is started / stopped / etc.\n   *\n   * @see {@link SnapController.transition} for interacting with the machine.\n   */\n  // We initialize the machine in the instance because the status is currently tightly coupled\n  // with the SnapController - the guard checks for enabled status inside the SnapController state.\n  // In the future, side-effects could be added to the machine during transitions.\n  #initializeStateMachine() {\n    const disableGuard = ({ snapId }: StatusContext) => {\n      return this.getExpect(snapId).enabled;\n    };\n\n    const statusConfig: StateMachine.Config<\n      StatusContext,\n      StatusEvents,\n      StatusStates\n    > = {\n      initial: SnapStatus.Installing,\n      states: {\n        [SnapStatus.Installing]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n          },\n        },\n        [SnapStatus.Updating]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Stop]: SnapStatus.Stopped,\n          },\n        },\n        [SnapStatus.Running]: {\n          on: {\n            [SnapStatusEvents.Stop]: SnapStatus.Stopped,\n            [SnapStatusEvents.Crash]: SnapStatus.Crashed,\n          },\n        },\n        [SnapStatus.Stopped]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Update]: SnapStatus.Updating,\n          },\n        },\n        [SnapStatus.Crashed]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Update]: SnapStatus.Updating,\n          },\n        },\n      },\n    };\n    this.#statusMachine = createMachine(statusConfig);\n    validateMachine(this.#statusMachine);\n  }\n\n  /**\n   * Constructor helper for registering the controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers(): void {\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:init`,\n      (...args) => this.init(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:clearSnapState`,\n      (...args) => this.clearSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:get`,\n      (...args) => this.get(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getSnapState`,\n      async (...args) => this.getSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:handleRequest`,\n      async (...args) => this.handleRequest(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:has`,\n      (...args) => this.has(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateRegistry`,\n      async () => this.updateRegistry(),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateSnapState`,\n      async (...args) => this.updateSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:enable`,\n      (...args) => this.enableSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:disable`,\n      async (...args) => this.disableSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:remove`,\n      async (...args) => this.removeSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getPermitted`,\n      (...args) => this.getPermittedSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:install`,\n      async (...args) => this.installSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getAll`,\n      (...args) => this.getAllSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getRunnableSnaps`,\n      (...args) => this.getRunnableSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:incrementActiveReferences`,\n      (...args) => this.incrementActiveReferences(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:decrementActiveReferences`,\n      (...args) => this.decrementActiveReferences(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:disconnectOrigin`,\n      (...args) => this.removeSnapFromSubject(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:revokeDynamicPermissions`,\n      (...args) => this.revokeDynamicSnapPermissions(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getFile`,\n      async (...args) => this.getSnapFile(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:stopAllSnaps`,\n      async (...args) => this.stopAllSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:isMinimumPlatformVersion`,\n      (...args) => this.isMinimumPlatformVersion(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:setClientActive`,\n      (...args) => this.setClientActive(...args),\n    );\n  }\n\n  /**\n   * Initialise the SnapController.\n   *\n   * Currently this method calls the `onStart` lifecycle hook for all\n   * runnable Snaps.\n   */\n  init() {\n    this.#callLifecycleHooks(METAMASK_ORIGIN, HandlerType.OnStart);\n  }\n\n  #handlePreinstalledSnaps(preinstalledSnaps: PreinstalledSnap[]) {\n    for (const {\n      snapId,\n      manifest,\n      files,\n      removable,\n      hidden,\n      hideSnapBranding,\n    } of preinstalledSnaps) {\n      const existingSnap = this.get(snapId);\n      const isAlreadyInstalled = existingSnap !== undefined;\n      const isUpdate =\n        isAlreadyInstalled && gtVersion(manifest.version, existingSnap.version);\n\n      // Disallow downgrades and overwriting non preinstalled snaps\n      if (\n        isAlreadyInstalled &&\n        (!isUpdate || existingSnap.preinstalled !== true)\n      ) {\n        continue;\n      }\n\n      const manifestFile = new VirtualFile<SnapManifest>({\n        path: NpmSnapFileNames.Manifest,\n        value: JSON.stringify(manifest),\n        result: manifest,\n      });\n\n      const virtualFiles = files.map(\n        ({ path, value }) => new VirtualFile({ value, path }),\n      );\n      const { filePath, iconPath } = manifest.source.location.npm;\n      const sourceCode = virtualFiles.find((file) => file.path === filePath);\n      const svgIcon = iconPath\n        ? virtualFiles.find((file) => file.path === iconPath)\n        : undefined;\n\n      assert(sourceCode, 'Source code not provided for preinstalled snap.');\n\n      assert(\n        !iconPath || (iconPath && svgIcon),\n        'Icon not provided for preinstalled snap.',\n      );\n\n      assert(\n        manifest.source.files === undefined,\n        'Auxiliary files are not currently supported for preinstalled snaps.',\n      );\n\n      const localizationFiles =\n        manifest.source.locales?.map((path) =>\n          virtualFiles.find((file) => file.path === path),\n        ) ?? [];\n\n      const validatedLocalizationFiles = getValidatedLocalizationFiles(\n        localizationFiles.filter(Boolean) as VirtualFile[],\n      );\n\n      assert(\n        localizationFiles.length === validatedLocalizationFiles.length,\n        'Missing localization files for preinstalled snap.',\n      );\n\n      const filesObject: FetchedSnapFiles = {\n        manifest: manifestFile,\n        sourceCode,\n        svgIcon,\n        auxiliaryFiles: [],\n        localizationFiles: validatedLocalizationFiles,\n      };\n\n      // Add snap to the SnapController state\n      this.#set({\n        id: snapId,\n        origin: METAMASK_ORIGIN,\n        files: filesObject,\n        removable,\n        hidden,\n        hideSnapBranding,\n        preinstalled: true,\n      });\n\n      // Setup permissions\n      const processedPermissions = processSnapPermissions(\n        manifest.initialPermissions,\n      );\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      const { newPermissions, unusedPermissions } =\n        this.#calculatePermissionsChange(snapId, processedPermissions);\n\n      this.#updatePermissions({ snapId, newPermissions, unusedPermissions });\n\n      if (manifest.initialConnections) {\n        this.#handleInitialConnections(\n          snapId,\n          existingSnap?.initialConnections ?? null,\n          manifest.initialConnections,\n        );\n      }\n\n      // Set status\n      this.update((state) => {\n        state.snaps[snapId].status = SnapStatus.Stopped;\n      });\n\n      this.#setupRuntime(snapId);\n\n      // Emit events\n      if (isUpdate) {\n        this.messagingSystem.publish(\n          'SnapController:snapUpdated',\n          this.getTruncatedExpect(snapId),\n          existingSnap.version,\n          METAMASK_ORIGIN,\n          true,\n        );\n      } else {\n        this.messagingSystem.publish(\n          'SnapController:snapInstalled',\n          this.getTruncatedExpect(snapId),\n          METAMASK_ORIGIN,\n          true,\n        );\n      }\n    }\n  }\n\n  #pollForLastRequestStatus() {\n    this.#timeoutForLastRequestStatus = setTimeout(() => {\n      this.#stopSnapsLastRequestPastMax().catch((error) => {\n        // TODO: Decide how to handle errors.\n        logError(error);\n      });\n\n      this.#pollForLastRequestStatus();\n    }, this.#idleTimeCheckInterval) as unknown as number;\n  }\n\n  /**\n   * Checks all installed snaps against the block list and\n   * blocks/unblocks snaps as appropriate. See {@link SnapController.blockSnap}\n   * for more information.\n   *\n   * Also updates any preinstalled Snaps to the latest allowlisted version.\n   */\n  async updateRegistry(): Promise<void> {\n    this.#assertCanUsePlatform();\n    await this.messagingSystem.call('SnapsRegistry:update');\n\n    const blockedSnaps = await this.messagingSystem.call(\n      'SnapsRegistry:get',\n      Object.values(this.state.snaps).reduce<SnapsRegistryRequest>(\n        (blockListArg, snap) => {\n          blockListArg[snap.id] = {\n            version: snap.version,\n            checksum: snap.manifest.source.shasum,\n          };\n          return blockListArg;\n        },\n        {},\n      ),\n    );\n\n    await Promise.all(\n      Object.entries(blockedSnaps).map(async ([snapId, { status, reason }]) => {\n        if (status === SnapsRegistryStatus.Blocked) {\n          return this.#blockSnap(snapId as SnapId, reason);\n        }\n\n        return this.#unblockSnap(snapId as SnapId);\n      }),\n    );\n\n    if (!this.#featureFlags.autoUpdatePreinstalledSnaps) {\n      return;\n    }\n\n    const preinstalledVersionRange = '*' as SemVerRange;\n\n    await Promise.allSettled(\n      Object.values(this.state.snaps)\n        .filter((snap) => snap.preinstalled)\n        .map(async (snap) => {\n          const resolvedVersion = await this.#resolveAllowlistVersion(\n            snap.id,\n            preinstalledVersionRange,\n          );\n\n          if (\n            resolvedVersion !== preinstalledVersionRange &&\n            gtVersion(resolvedVersion as unknown as SemVerVersion, snap.version)\n          ) {\n            const location = this.#detectSnapLocation(snap.id, {\n              versionRange: resolvedVersion,\n              fetch: this.#fetchFunction,\n              allowLocal: false,\n            });\n\n            await this.#updateSnap({\n              origin: ORIGIN_METAMASK,\n              snapId: snap.id,\n              location,\n              versionRange: resolvedVersion,\n              automaticUpdate: true,\n            });\n          }\n        }),\n    );\n  }\n\n  /**\n   * Blocks an installed snap and prevents it from being started again. Emits\n   * {@link SnapBlocked}. Does nothing if the snap is not installed.\n   *\n   * @param snapId - The snap to block.\n   * @param blockedSnapInfo - Information detailing why the snap is blocked.\n   */\n  async #blockSnap(\n    snapId: SnapId,\n    blockedSnapInfo?: BlockReason,\n  ): Promise<void> {\n    if (!this.has(snapId)) {\n      return;\n    }\n\n    try {\n      this.update((state: any) => {\n        state.snaps[snapId].blocked = true;\n        state.snaps[snapId].blockInformation = blockedSnapInfo;\n      });\n\n      await this.disableSnap(snapId);\n    } catch (error) {\n      logError(\n        `Encountered error when stopping blocked snap \"${snapId}\".`,\n        error,\n      );\n    }\n\n    this.messagingSystem.publish(\n      `${controllerName}:snapBlocked`,\n      snapId,\n      blockedSnapInfo,\n    );\n  }\n\n  /**\n   * Unblocks a snap so that it can be enabled and started again. Emits\n   * {@link SnapUnblocked}. Does nothing if the snap is not installed or already\n   * unblocked.\n   *\n   * @param snapId - The id of the snap to unblock.\n   */\n  #unblockSnap(snapId: SnapId) {\n    if (!this.has(snapId) || !this.state.snaps[snapId].blocked) {\n      return;\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].blocked = false;\n      delete state.snaps[snapId].blockInformation;\n    });\n\n    this.messagingSystem.publish(`${controllerName}:snapUnblocked`, snapId);\n  }\n\n  async #assertIsInstallAllowed(\n    snapId: SnapId,\n    {\n      platformVersion,\n      ...snapInfo\n    }: SnapsRegistryInfo & {\n      permissions: SnapPermissions;\n      platformVersion: string | undefined;\n    },\n  ) {\n    const results = await this.messagingSystem.call('SnapsRegistry:get', {\n      [snapId]: snapInfo,\n    });\n\n    const result = results[snapId];\n    if (result.status === SnapsRegistryStatus.Blocked) {\n      throw new Error(\n        `Cannot install version \"${\n          snapInfo.version\n        }\" of snap \"${snapId}\": The version is blocked. ${\n          result.reason?.explanation ?? ''\n        }`,\n      );\n    }\n\n    const isAllowlistingRequired = Object.keys(snapInfo.permissions).some(\n      (permission) => !ALLOWED_PERMISSIONS.includes(permission),\n    );\n\n    if (\n      this.#featureFlags.requireAllowlist &&\n      isAllowlistingRequired &&\n      result.status !== SnapsRegistryStatus.Verified\n    ) {\n      throw new Error(\n        `Cannot install version \"${snapInfo.version}\" of snap \"${snapId}\": ${\n          result.status === SnapsRegistryStatus.Unavailable\n            ? 'The registry is temporarily unavailable.'\n            : 'The snap is not on the allowlist.'\n        }`,\n      );\n    }\n\n    this.#validatePlatformVersion(snapId, platformVersion);\n  }\n\n  /**\n   * Asserts whether new Snaps are allowed to be installed.\n   */\n  #assertCanInstallSnaps() {\n    assert(\n      this.#featureFlags.disableSnapInstallation !== true,\n      'Installing Snaps is currently disabled in this version of MetaMask.',\n    );\n  }\n\n  /**\n   * Asserts whether the Snaps platform is allowed to run.\n   */\n  #assertCanUsePlatform() {\n    const flags = this.#getFeatureFlags();\n    assert(\n      flags.disableSnaps !== true,\n      'The Snaps platform requires basic functionality to be used. Enable basic functionality in the settings to use the Snaps platform.',\n    );\n  }\n\n  async #stopSnapsLastRequestPastMax() {\n    const entries = [...this.#snapsRuntimeData.entries()];\n    return Promise.all(\n      entries\n        .filter(\n          ([_snapId, runtime]) =>\n            runtime.activeReferences === 0 &&\n            runtime.pendingInboundRequests.length === 0 &&\n            runtime.lastRequest &&\n            this.#maxIdleTime &&\n            timeSince(runtime.lastRequest) > this.#maxIdleTime,\n        )\n        .map(async ([snapId]) => this.stopSnap(snapId, SnapStatusEvents.Stop)),\n    );\n  }\n\n  _onUnhandledSnapError(snapId: string, error: SnapErrorJson) {\n    // Log the error that caused the crash\n    // so it gets raised to the developer for debugging purposes.\n    logError(`Unhandled error from \"${snapId}\":`, error);\n    this.stopSnap(snapId as SnapId, SnapStatusEvents.Crash).catch(\n      (stopSnapError) => {\n        // TODO: Decide how to handle errors.\n        logError(stopSnapError);\n      },\n    );\n  }\n\n  _onOutboundRequest(snapId: string) {\n    const runtime = this.#getRuntimeExpect(snapId as SnapId);\n    // Ideally we would only pause the pending request that is making the outbound request\n    // but right now we don't have a way to know which request initiated the outbound request\n    runtime.pendingInboundRequests\n      .filter((pendingRequest) => pendingRequest.timer.status === 'running')\n      .forEach((pendingRequest) => pendingRequest.timer.pause());\n    runtime.pendingOutboundRequests += 1;\n  }\n\n  _onOutboundResponse(snapId: string) {\n    const runtime = this.#getRuntimeExpect(snapId as SnapId);\n    runtime.pendingOutboundRequests -= 1;\n    if (runtime.pendingOutboundRequests === 0) {\n      runtime.pendingInboundRequests\n        .filter((pendingRequest) => pendingRequest.timer.status === 'paused')\n        .forEach((pendingRequest) => pendingRequest.timer.resume());\n    }\n  }\n\n  /**\n   * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out\n   * the next state. This transition function uses a very minimal subset of XState conventions:\n   * - supports initial state\n   * - .on supports raw event target string\n   * - .on supports {target, cond} object\n   * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event,\n   * context) => boolean`\n   *\n   * @param snapId - The id of the snap to transition.\n   * @param event - The event enum to use to transition.\n   */\n  #transition(snapId: SnapId, event: StatusEvents | StatusEvents['type']) {\n    const { interpreter } = this.#getRuntimeExpect(snapId);\n    interpreter.send(event);\n    this.update((state: any) => {\n      state.snaps[snapId].status = interpreter.state.value;\n    });\n  }\n\n  /**\n   * Starts the given snap. Throws an error if no such snap exists\n   * or if it is already running.\n   *\n   * @param snapId - The id of the Snap to start.\n   */\n  async startSnap(snapId: SnapId): Promise<void> {\n    this.#assertCanUsePlatform();\n    const snap = this.state.snaps[snapId];\n\n    if (!snap.enabled) {\n      throw new Error(`Snap \"${snapId}\" is disabled.`);\n    }\n\n    await this.#startSnap({\n      snapId,\n      sourceCode: snap.sourceCode,\n    });\n  }\n\n  /**\n   * Enables the given snap. A snap can only be started if it is enabled. A snap\n   * can only be enabled if it isn't blocked.\n   *\n   * @param snapId - The id of the Snap to enable.\n   */\n  enableSnap(snapId: SnapId): void {\n    this.getExpect(snapId);\n\n    if (this.state.snaps[snapId].blocked) {\n      throw new Error(`Snap \"${snapId}\" is blocked and cannot be enabled.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = true;\n    });\n\n    this.messagingSystem.publish(\n      'SnapController:snapEnabled',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Disables the given snap. A snap can only be started if it is enabled.\n   *\n   * @param snapId - The id of the Snap to disable.\n   * @returns A promise that resolves once the snap has been disabled.\n   */\n  async disableSnap(snapId: SnapId): Promise<void> {\n    if (!this.has(snapId)) {\n      throw new Error(`Snap \"${snapId}\" not found.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = false;\n    });\n\n    if (this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    this.messagingSystem.publish(\n      'SnapController:snapDisabled',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Stops the given snap, removes all hooks, closes all connections, and\n   * terminates its worker.\n   *\n   * @param snapId - The id of the Snap to stop.\n   * @param statusEvent - The Snap status event that caused the snap to be\n   * stopped.\n   */\n  public async stopSnap(\n    snapId: SnapId,\n    statusEvent:\n      | SnapStatusEvents.Stop\n      | SnapStatusEvents.Crash = SnapStatusEvents.Stop,\n  ): Promise<void> {\n    const runtime = this.#getRuntime(snapId);\n    if (!runtime) {\n      throw new Error(`The snap \"${snapId}\" is not running.`);\n    }\n\n    // If we are already stopping, wait for that to finish.\n    if (runtime.stopPromise) {\n      await runtime.stopPromise;\n      return;\n    }\n\n    // Flag that the Snap is actively stopping, this prevents other calls to stopSnap\n    // while we are handling termination of the Snap\n    const { promise, resolve } = createDeferredPromise();\n    runtime.stopPromise = promise;\n\n    try {\n      if (this.isRunning(snapId)) {\n        this.#closeAllConnections?.(snapId);\n        await this.#terminateSnap(snapId);\n      }\n    } finally {\n      // Reset request tracking\n      runtime.lastRequest = null;\n      runtime.pendingInboundRequests = [];\n      runtime.pendingOutboundRequests = 0;\n      runtime.stopPromise = null;\n      if (this.isRunning(snapId)) {\n        this.#transition(snapId, statusEvent);\n      }\n      resolve();\n    }\n  }\n\n  /**\n   * Stops all running snaps, removes all hooks, closes all connections, and\n   * terminates their workers.\n   *\n   * @param statusEvent - The Snap status event that caused the snap to be\n   * stopped.\n   */\n  public async stopAllSnaps(\n    statusEvent:\n      | SnapStatusEvents.Stop\n      | SnapStatusEvents.Crash = SnapStatusEvents.Stop,\n  ): Promise<void> {\n    const snaps = Object.values(this.state.snaps).filter((snap) =>\n      this.isRunning(snap.id),\n    );\n    const promises = snaps.map(async (snap) =>\n      this.stopSnap(snap.id, statusEvent),\n    );\n    await Promise.allSettled(promises);\n  }\n\n  /**\n   * Terminates the specified snap and emits the `snapTerminated` event.\n   *\n   * @param snapId - The snap to terminate.\n   */\n  async #terminateSnap(snapId: SnapId) {\n    await this.messagingSystem.call('ExecutionService:terminateSnap', snapId);\n\n    // Hack to give up execution for a bit to let gracefully terminating Snaps return.\n    await new Promise((resolve) => setTimeout(resolve, 1));\n\n    const runtime = this.#getRuntimeExpect(snapId);\n    // Unresponsive requests may still be timed, time them out.\n    runtime.pendingInboundRequests\n      .filter((pendingRequest) => pendingRequest.timer.status !== 'finished')\n      .forEach((pendingRequest) => pendingRequest.timer.finish());\n\n    // Hack to give up execution for a bit to let timed out requests return.\n    await new Promise((resolve) => setTimeout(resolve, 1));\n\n    this.messagingSystem.publish(\n      'SnapController:snapTerminated',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Returns whether the given snap is running.\n   * Throws an error if the snap doesn't exist.\n   *\n   * @param snapId - The id of the Snap to check.\n   * @returns `true` if the snap is running, otherwise `false`.\n   */\n  isRunning(snapId: SnapId): boolean {\n    return this.getExpect(snapId).status === 'running';\n  }\n\n  /**\n   * Returns whether the given snap has been added to state.\n   *\n   * @param snapId - The id of the Snap to check for.\n   * @returns `true` if the snap exists in the controller state, otherwise `false`.\n   */\n  has(snapId: SnapId): boolean {\n    return Boolean(this.get(snapId));\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, including all data.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns The entire snap object from the controller state.\n   */\n  get(snapId: string): Snap | undefined {\n    return this.state.snaps[snapId as SnapId];\n  }\n\n  /**\n   * Gets the snap with the given id, throws if doesn't.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @see {@link SnapController.get}\n   * @throws {@link Error}. If the snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns The entire snap object.\n   */\n  getExpect(snapId: SnapId): Snap {\n    const snap = this.get(snapId);\n    assert(snap !== undefined, `Snap \"${snapId}\" not found.`);\n    return snap;\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, excluding any\n   * non-serializable or expensive-to-serialize data.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  // TODO(ritave): this.get returns undefined, this.getTruncated returns null\n  getTruncated(snapId: SnapId): TruncatedSnap | null {\n    const snap = this.get(snapId);\n\n    return snap ? truncateSnap(snap) : null;\n  }\n\n  /**\n   * Gets the snap with the given id, throw if it doesn't exist.\n   *\n   * @throws {@link Error}. If snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  getTruncatedExpect(snapId: SnapId): TruncatedSnap {\n    return truncateSnap(this.getExpect(snapId));\n  }\n\n  /**\n   * Check if a given Snap has a cached encryption key stored in the runtime.\n   *\n   * @param snapId - The Snap ID.\n   * @param runtime - The Snap runtime data.\n   * @returns True if the Snap has a cached encryption key, otherwise false.\n   */\n  #hasCachedEncryptionKey(\n    snapId: SnapId,\n    runtime = this.#getRuntimeExpect(snapId),\n  ): runtime is SnapRuntimeData & {\n    encryptionKey: string;\n    encryptionSalt: string;\n  } {\n    return runtime.encryptionKey !== null && runtime.encryptionSalt !== null;\n  }\n\n  /**\n   * Generate an encryption key to be used for state encryption for a given Snap.\n   *\n   * @param options - An options bag.\n   * @param options.snapId - The Snap ID.\n   * @param options.salt - A salt to be used for the encryption key.\n   * @param options.useCache - Whether to use caching or not.\n   * @param options.keyMetadata - Optional metadata about how to derive the encryption key.\n   * @returns An encryption key.\n   */\n  async #getSnapEncryptionKey({\n    snapId,\n    salt: passedSalt,\n    useCache,\n    keyMetadata,\n  }: {\n    snapId: SnapId;\n    salt?: string;\n    useCache: boolean;\n    keyMetadata?: KeyDerivationOptions;\n  }): Promise<{ key: unknown; salt: string }> {\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (this.#hasCachedEncryptionKey(snapId, runtime) && useCache) {\n      return {\n        key: await this.#encryptor.importKey(runtime.encryptionKey),\n        salt: runtime.encryptionSalt,\n      };\n    }\n\n    const salt = passedSalt ?? this.#encryptor.generateSalt();\n    const seed = await this.#getMnemonicSeed();\n\n    const entropy = await getEncryptionEntropy({\n      snapId,\n      seed,\n      cryptographicFunctions: this.#clientCryptography,\n    });\n\n    const encryptionKey = await this.#encryptor.keyFromPassword(\n      entropy,\n      salt,\n      true,\n      keyMetadata,\n    );\n    const exportedKey = await this.#encryptor.exportKey(encryptionKey);\n\n    // Cache exported encryption key in runtime\n    if (useCache) {\n      runtime.encryptionKey = exportedKey;\n      runtime.encryptionSalt = salt;\n    }\n    return { key: encryptionKey, salt };\n  }\n\n  /**\n   * Decrypt the encrypted state for a given Snap.\n   *\n   * @param snapId - The Snap ID.\n   * @param state - The encrypted state as a string.\n   * @returns A valid JSON object derived from the encrypted state.\n   * @throws If the decryption fails or the decrypted state is not valid JSON.\n   */\n  async #decryptSnapState(snapId: SnapId, state: string) {\n    try {\n      // We assume that the state string here is valid JSON since we control serialization.\n      // This lets us skip JSON validation.\n      const parsed = JSON.parse(state) as EncryptionResult;\n      const { salt, keyMetadata } = parsed;\n\n      // We only cache encryption keys if they are already cached or if the encryption key is using the latest key derivation params.\n      const useCache =\n        this.#hasCachedEncryptionKey(snapId) ||\n        this.#encryptor.isVaultUpdated(state);\n\n      const { key } = await this.#getSnapEncryptionKey({\n        snapId,\n        salt,\n        useCache,\n        // When decrypting state we expect key metadata to be present.\n        // If it isn't present, we assume that the Snap state we are decrypting is old enough to use the legacy encryption params.\n        keyMetadata: keyMetadata ?? LEGACY_ENCRYPTION_KEY_DERIVATION_OPTIONS,\n      });\n      const decryptedState = await this.#encryptor.decryptWithKey(key, parsed);\n\n      // We assume this to be valid JSON, since all RPC requests from a Snap are validated and sanitized.\n      return decryptedState as Record<string, Json>;\n    } catch {\n      throw rpcErrors.internal({\n        message: 'Failed to decrypt snap state, the state must be corrupted.',\n      });\n    }\n  }\n\n  /**\n   * Encrypt a JSON state object for a given Snap.\n   *\n   * Note: This function does not assert the validity of the object,\n   * please ensure only valid JSON is passed to it.\n   *\n   * @param snapId - The Snap ID.\n   * @param state - The state object.\n   * @returns A string containing the encrypted JSON object.\n   */\n  async #encryptSnapState(snapId: SnapId, state: Record<string, Json>) {\n    const { key, salt } = await this.#getSnapEncryptionKey({\n      snapId,\n      useCache: true,\n    });\n    const encryptedState = await this.#encryptor.encryptWithKey(key, state);\n\n    encryptedState.salt = salt;\n    return JSON.stringify(encryptedState);\n  }\n\n  /**\n   * Get the new Snap state to persist based on the given state and encryption\n   * flag.\n   *\n   * - If the state is null, return null.\n   * - If the state should be encrypted, return the encrypted state.\n   * - Otherwise, if the state should not be encrypted, return the JSON-\n   * stringified state.\n   *\n   * @param snapId - The Snap ID.\n   * @param state - The state to persist.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or\n   * not.\n   * @returns The state to persist.\n   */\n  async #getStateToPersist(\n    snapId: SnapId,\n    state: Record<string, Json> | null,\n    encrypted: boolean,\n  ) {\n    if (state === null) {\n      return null;\n    }\n\n    if (encrypted) {\n      return await this.#encryptSnapState(snapId, state);\n    }\n\n    return JSON.stringify(state);\n  }\n\n  /**\n   * Persist the state of a Snap.\n   *\n   * This function is debounced per Snap, meaning that multiple calls to this\n   * function for the same Snap will only result in one state update. It also\n   * uses a mutex to ensure that only one state update per Snap is processed at\n   * a time, avoiding possible race conditions.\n   *\n   * @param snapId - The Snap ID.\n   * @param newSnapState - The new state of the Snap.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or\n   * not.\n   */\n  readonly #persistSnapState = debouncePersistState(\n    (\n      snapId: SnapId,\n      newSnapState: Record<string, Json> | null,\n      encrypted: boolean,\n    ) => {\n      const runtime = this.#getRuntimeExpect(snapId);\n      runtime.stateMutex\n        .runExclusive(async () => {\n          const newState = await this.#getStateToPersist(\n            snapId,\n            newSnapState,\n            encrypted,\n          );\n\n          if (encrypted) {\n            return this.update((state) => {\n              state.snapStates[snapId] = newState;\n            });\n          }\n\n          return this.update((state) => {\n            state.unencryptedSnapStates[snapId] = newState;\n          });\n        })\n        .catch(logError);\n    },\n    STATE_DEBOUNCE_TIMEOUT,\n  );\n\n  /**\n   * Updates the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be updated.\n   * @param newSnapState - The new state of the snap.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   */\n  async updateSnapState(\n    snapId: SnapId,\n    newSnapState: Record<string, Json>,\n    encrypted: boolean,\n  ) {\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (encrypted) {\n      runtime.state = newSnapState;\n    } else {\n      runtime.unencryptedState = newSnapState;\n    }\n\n    this.#persistSnapState(snapId, newSnapState, encrypted);\n  }\n\n  /**\n   * Clears the state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be cleared.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   */\n  clearSnapState(snapId: SnapId, encrypted: boolean) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    if (encrypted) {\n      runtime.state = null;\n    } else {\n      runtime.unencryptedState = null;\n    }\n\n    this.#persistSnapState(snapId, null, encrypted);\n  }\n\n  /**\n   * Gets the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state to get.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   * @returns The requested snap state or null if no state exists.\n   */\n  async getSnapState(snapId: SnapId, encrypted: boolean): Promise<Json> {\n    const runtime = this.#getRuntimeExpect(snapId);\n    return await runtime.getStateMutex.runExclusive(async () => {\n      const cachedState = encrypted ? runtime.state : runtime.unencryptedState;\n\n      if (cachedState !== undefined) {\n        return cachedState;\n      }\n\n      const state = encrypted\n        ? this.state.snapStates[snapId]\n        : this.state.unencryptedSnapStates[snapId];\n\n      if (state === null || state === undefined) {\n        return null;\n      }\n\n      if (!encrypted) {\n        // For performance reasons, we do not validate that the state is JSON,\n        // since we control serialization.\n        const json = JSON.parse(state);\n        runtime.unencryptedState = json;\n\n        return json;\n      }\n\n      const decrypted = await this.#decryptSnapState(snapId, state);\n      // eslint-disable-next-line require-atomic-updates\n      runtime.state = decrypted;\n\n      return decrypted;\n    });\n  }\n\n  /**\n   * Gets a static auxiliary snap file in a chosen file encoding.\n   *\n   * @param snapId - The id of the Snap whose state to get.\n   * @param path - The path to the requested file.\n   * @param encoding - An optional requested file encoding.\n   * @returns The file requested in the chosen file encoding or null if the file is not found.\n   */\n  async getSnapFile(\n    snapId: SnapId,\n    path: string,\n    encoding: AuxiliaryFileEncoding = AuxiliaryFileEncoding.Base64,\n  ): Promise<string | null> {\n    const snap = this.getExpect(snapId);\n    const normalizedPath = normalizeRelative(path);\n    const value = snap.auxiliaryFiles?.find(\n      (file) => file.path === normalizedPath,\n    )?.value;\n\n    if (!value) {\n      return null;\n    }\n\n    const encoded = await encodeAuxiliaryFile(value, encoding);\n\n    assert(\n      encoded.length < MAX_FILE_SIZE,\n      `Failed to encode static file to \"${encoding}\": Static files must be less than 64 MB when encoded.`,\n    );\n\n    return encoded;\n  }\n\n  /**\n   * Determine if a given Snap ID supports a given minimum version of the Snaps platform\n   * by inspecting the platformVersion in the Snap manifest.\n   *\n   * @param snapId - The Snap ID.\n   * @param version - The version.\n   * @returns True if the platform version is equal or greater to the passed version, false otherwise.\n   */\n  isMinimumPlatformVersion(snapId: SnapId, version: SemVerVersion): boolean {\n    const snap = this.getExpect(snapId);\n\n    const { platformVersion } = snap.manifest;\n\n    if (!platformVersion) {\n      return false;\n    }\n\n    return gte(platformVersion, version);\n  }\n\n  /**\n   * Completely clear the controller's state: delete all associated data,\n   * handlers, event listeners, and permissions; tear down all snap providers.\n   */\n  async clearState() {\n    const snapIds = Object.keys(this.state.snaps);\n\n    await this.stopAllSnaps();\n    snapIds.forEach((snapId) => this.#revokeAllSnapPermissions(snapId));\n\n    this.update((state) => {\n      state.snaps = {};\n      state.snapStates = {};\n      state.unencryptedSnapStates = {};\n    });\n\n    this.#snapsRuntimeData.clear();\n    this.#rollbackSnapshots.clear();\n\n    // We want to remove all snaps & permissions, except for preinstalled snaps\n    if (this.#preinstalledSnaps) {\n      this.#handlePreinstalledSnaps(this.#preinstalledSnaps);\n    }\n  }\n\n  /**\n   * Removes the given snap from state, and clears all associated handlers\n   * and listeners.\n   *\n   * @param snapId - The id of the Snap.\n   * @returns A promise that resolves once the snap has been removed.\n   */\n  async removeSnap(snapId: SnapId): Promise<void> {\n    return this.removeSnaps([snapId]);\n  }\n\n  /**\n   * Stops the given snaps, removes them from state, and clears all associated\n   * permissions, handlers, and listeners.\n   *\n   * @param snapIds - The ids of the Snaps.\n   */\n  async removeSnaps(snapIds: SnapId[]): Promise<void> {\n    if (!Array.isArray(snapIds)) {\n      throw new Error('Expected array of snap ids.');\n    }\n\n    snapIds.forEach((snapId) => {\n      const snap = this.getExpect(snapId);\n      assert(snap.removable !== false, `${snapId} is not removable.`);\n    });\n\n    await Promise.all(\n      snapIds.map(async (snapId) => {\n        const snap = this.getExpect(snapId);\n        const truncated = this.getTruncatedExpect(snapId);\n        // Disable the snap and revoke all of its permissions before deleting\n        // it. This ensures that the snap will not be restarted or otherwise\n        // affect the host environment while we are deleting it.\n        await this.disableSnap(snapId);\n        this.#revokeAllSnapPermissions(snapId);\n\n        this.#removeSnapFromSubjects(snapId);\n\n        this.#snapsRuntimeData.delete(snapId);\n\n        this.update((state: any) => {\n          delete state.snaps[snapId];\n          delete state.snapStates[snapId];\n          delete state.unencryptedSnapStates[snapId];\n        });\n\n        // If the snap has been fully installed before, also emit snapUninstalled.\n        if (snap.status !== SnapStatus.Installing) {\n          this.messagingSystem.publish(\n            `SnapController:snapUninstalled`,\n            truncated,\n          );\n        }\n      }),\n    );\n  }\n\n  #handleInitialConnections(\n    snapId: SnapId,\n    previousInitialConnections: InitialConnections | null,\n    initialConnections: InitialConnections,\n  ) {\n    if (previousInitialConnections) {\n      const revokedInitialConnections = setDiff(\n        previousInitialConnections,\n        initialConnections,\n      );\n\n      for (const origin of Object.keys(revokedInitialConnections)) {\n        this.removeSnapFromSubject(origin, snapId);\n      }\n    }\n\n    for (const origin of Object.keys(initialConnections)) {\n      this.#addSnapToSubject(origin, snapId);\n    }\n  }\n\n  #addSnapToSubject(origin: string, snapId: SnapId) {\n    const subjectPermissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const existingCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds);\n\n    const subjectHasSnap = Boolean(\n      (existingCaveat?.value as Record<string, Json>)?.[snapId],\n    );\n\n    // If the subject is already connected to the snap, this is a no-op.\n    if (subjectHasSnap) {\n      return;\n    }\n\n    // If an existing caveat exists, we add the snap to that.\n    if (existingCaveat) {\n      this.messagingSystem.call(\n        'PermissionController:updateCaveat',\n        origin,\n        WALLET_SNAP_PERMISSION_KEY,\n        SnapCaveatType.SnapIds,\n        { ...(existingCaveat.value as Record<string, Json>), [snapId]: {} },\n      );\n      return;\n    }\n\n    const approvedPermissions = {\n      [WALLET_SNAP_PERMISSION_KEY]: {\n        caveats: [\n          {\n            type: SnapCaveatType.SnapIds,\n            value: {\n              [snapId]: {},\n            },\n          },\n        ],\n      },\n    } as RequestedPermissions;\n\n    this.messagingSystem.call('PermissionController:grantPermissions', {\n      approvedPermissions,\n      subject: { origin },\n    });\n  }\n\n  /**\n   * Removes a snap's permission (caveat) from the specified subject.\n   *\n   * @param origin - The origin from which to remove the snap.\n   * @param snapId - The id of the snap to remove.\n   */\n  removeSnapFromSubject(origin: string, snapId: SnapId) {\n    const subjectPermissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const snapIdsCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds) as\n      | Caveat<string, Json>\n      | undefined;\n\n    if (!snapIdsCaveat) {\n      return;\n    }\n\n    const caveatHasSnap = Boolean(\n      (snapIdsCaveat.value as Record<string, Json>)?.[snapId],\n    );\n    if (caveatHasSnap) {\n      const newCaveatValue = {\n        ...(snapIdsCaveat.value as Record<string, Json>),\n      };\n      delete newCaveatValue[snapId];\n      if (Object.keys(newCaveatValue).length > 0) {\n        this.messagingSystem.call(\n          'PermissionController:updateCaveat',\n          origin,\n          WALLET_SNAP_PERMISSION_KEY,\n          SnapCaveatType.SnapIds,\n          newCaveatValue,\n        );\n      } else {\n        this.messagingSystem.call('PermissionController:revokePermissions', {\n          [origin]: [WALLET_SNAP_PERMISSION_KEY],\n        });\n      }\n    }\n  }\n\n  /**\n   * Checks if a list of permissions are dynamic and allowed to be revoked, if they are they will all be revoked.\n   *\n   * @param snapId - The snap ID.\n   * @param permissionNames - The names of the permissions.\n   * @throws If non-dynamic permissions are passed.\n   */\n  revokeDynamicSnapPermissions(\n    snapId: string,\n    permissionNames: NonEmptyArray<string>,\n  ) {\n    assert(\n      permissionNames.every((permissionName) =>\n        this.#dynamicPermissions.includes(permissionName),\n      ),\n      'Non-dynamic permissions cannot be revoked',\n    );\n    this.messagingSystem.call('PermissionController:revokePermissions', {\n      [snapId]: permissionNames,\n    });\n  }\n\n  /**\n   * Removes a snap's permission (caveat) from all subjects.\n   *\n   * @param snapId - The id of the Snap.\n   */\n  #removeSnapFromSubjects(snapId: SnapId) {\n    const subjects = this.messagingSystem.call(\n      'PermissionController:getSubjectNames',\n    );\n    for (const subject of subjects) {\n      this.removeSnapFromSubject(subject, snapId);\n    }\n  }\n\n  /**\n   * Safely revokes all permissions granted to a Snap.\n   *\n   * @param snapId - The snap ID.\n   */\n  #revokeAllSnapPermissions(snapId: string) {\n    if (\n      this.messagingSystem.call('PermissionController:hasPermissions', snapId)\n    ) {\n      this.messagingSystem.call(\n        'PermissionController:revokeAllPermissions',\n        snapId,\n      );\n    }\n  }\n\n  /**\n   * Handles incrementing the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced.\n   */\n  incrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.activeReferences += 1;\n  }\n\n  /**\n   * Handles decrement the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced..\n   */\n  decrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    assert(\n      runtime.activeReferences > 0,\n      'SnapController reference management is in an invalid state.',\n    );\n    runtime.activeReferences -= 1;\n  }\n\n  /**\n   * Gets all snaps in their truncated format.\n   *\n   * @returns All installed snaps in their truncated format.\n   */\n  getAllSnaps(): TruncatedSnap[] {\n    return Object.values(this.state.snaps).map(truncateSnap);\n  }\n\n  /**\n   * Gets all runnable snaps.\n   *\n   * @returns All runnable snaps.\n   */\n  getRunnableSnaps(): TruncatedSnap[] {\n    return getRunnableSnaps(this.getAllSnaps());\n  }\n\n  /**\n   * Gets the serialized permitted snaps of the given origin, if any.\n   *\n   * @param origin - The origin whose permitted snaps to retrieve.\n   * @returns The serialized permitted snaps for the origin.\n   */\n  getPermittedSnaps(origin: string): RequestSnapsResult {\n    const permissions =\n      this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        origin,\n      ) ?? {};\n    const snaps =\n      permissions[WALLET_SNAP_PERMISSION_KEY]?.caveats?.find(\n        (caveat) => caveat.type === SnapCaveatType.SnapIds,\n      )?.value ?? {};\n    return Object.keys(snaps).reduce<RequestSnapsResult>(\n      (permittedSnaps, snapId) => {\n        const snap = this.get(snapId);\n        const truncatedSnap = this.getTruncated(snapId as SnapId);\n\n        if (truncatedSnap && snap?.status !== SnapStatus.Installing) {\n          permittedSnaps[snapId] = truncatedSnap;\n        }\n        return permittedSnaps;\n      },\n      {},\n    );\n  }\n\n  /**\n   * Installs the snaps requested by the given origin, returning the snap\n   * object if the origin is permitted to install it, and an authorization error\n   * otherwise.\n   *\n   * @param origin - The origin that requested to install the snaps.\n   * @param requestedSnaps - The snaps to install.\n   * @returns An object of snap ids and snap objects, or errors if a\n   * snap couldn't be installed.\n   */\n  async installSnaps(\n    origin: string,\n    requestedSnaps: RequestSnapsParams,\n  ): Promise<RequestSnapsResult> {\n    this.#assertCanUsePlatform();\n\n    const result: RequestSnapsResult = {};\n\n    const snapIds = Object.keys(requestedSnaps);\n\n    const pendingUpdates = [];\n    const pendingInstalls = [];\n\n    try {\n      for (const [snapId, { version: rawVersion }] of Object.entries(\n        requestedSnaps,\n      )) {\n        assertIsValidSnapId(snapId);\n\n        const [error, version] = resolveVersionRange(rawVersion);\n\n        if (error) {\n          throw rpcErrors.invalidParams(\n            `The \"version\" field must be a valid SemVer version range if specified. Received: \"${\n              rawVersion as string\n            }\".`,\n          );\n        }\n\n        const location = this.#detectSnapLocation(snapId, {\n          versionRange: version,\n          fetch: this.#fetchFunction,\n          allowLocal: this.#featureFlags.allowLocalSnaps,\n          resolveVersion: async (range) =>\n            this.#featureFlags.requireAllowlist\n              ? await this.#resolveAllowlistVersion(snapId, range)\n              : range,\n        });\n\n        // Existing snaps may need to be updated, unless they should be re-installed (e.g. local snaps)\n        // Everything else is treated as an install\n        const isUpdate = this.has(snapId) && !location.shouldAlwaysReload;\n\n        if (isUpdate && this.#isValidUpdate(snapId, version)) {\n          const existingSnap = this.getExpect(snapId);\n          pendingUpdates.push({ snapId, oldVersion: existingSnap.version });\n          let rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n          if (rollbackSnapshot === undefined) {\n            rollbackSnapshot = this.#createRollbackSnapshot(snapId);\n            rollbackSnapshot.newVersion = version;\n          } else {\n            throw new Error('This snap is already being updated.');\n          }\n        } else if (!isUpdate) {\n          pendingInstalls.push(snapId);\n        }\n\n        result[snapId] = await this.#processRequestedSnap(\n          origin,\n          snapId,\n          location,\n          version,\n        );\n      }\n\n      // Once we finish all installs / updates, emit events.\n      pendingInstalls.forEach((snapId) =>\n        this.messagingSystem.publish(\n          `SnapController:snapInstalled`,\n          this.getTruncatedExpect(snapId),\n          origin,\n          false,\n        ),\n      );\n\n      pendingUpdates.forEach(({ snapId, oldVersion }) =>\n        this.messagingSystem.publish(\n          `SnapController:snapUpdated`,\n          this.getTruncatedExpect(snapId),\n          oldVersion,\n          origin,\n          false,\n        ),\n      );\n\n      snapIds.forEach((snapId) => this.#rollbackSnapshots.delete(snapId));\n    } catch (error) {\n      const installed = pendingInstalls.filter((snapId) => this.has(snapId));\n      await this.removeSnaps(installed);\n      const snapshottedSnaps = [...this.#rollbackSnapshots.keys()];\n      const snapsToRollback = pendingUpdates\n        .map(({ snapId }) => snapId)\n        .filter((snapId) => snapshottedSnaps.includes(snapId));\n      await this.#rollbackSnaps(snapsToRollback);\n\n      throw error;\n    }\n\n    return result;\n  }\n\n  /**\n   * Adds, authorizes, and runs the given snap with a snap provider.\n   * Results from this method should be efficiently serializable.\n   *\n   * @param origin - The origin requesting the snap.\n   * @param snapId - The id of the snap.\n   * @param location - The location implementation of the snap.\n   * @param versionRange - The semver range of the snap to install.\n   * @returns The resulting snap object, or an error if something went wrong.\n   */\n  async #processRequestedSnap(\n    origin: string,\n    snapId: SnapId,\n    location: SnapLocation,\n    versionRange: SemVerRange,\n  ): Promise<TruncatedSnap> {\n    const existingSnap = this.getTruncated(snapId);\n\n    // For devX we always re-install local snaps.\n    if (existingSnap && !location.shouldAlwaysReload) {\n      if (satisfiesVersionRange(existingSnap.version, versionRange)) {\n        return existingSnap;\n      }\n\n      return await this.#updateSnap({\n        origin,\n        snapId,\n        location,\n        versionRange,\n      });\n    }\n\n    this.#assertCanInstallSnaps();\n\n    let pendingApproval = this.#createApproval({\n      origin,\n      snapId,\n      type: SNAP_APPROVAL_INSTALL,\n    });\n\n    this.messagingSystem.publish(\n      'SnapController:snapInstallStarted',\n      snapId,\n      origin,\n      false,\n    );\n\n    // Existing snaps must be stopped before overwriting\n    if (existingSnap && this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    // Existing snaps that should be re-installed should not maintain their existing permissions\n    if (existingSnap && location.shouldAlwaysReload) {\n      this.#revokeAllSnapPermissions(snapId);\n    }\n\n    try {\n      const { sourceCode } = await this.#add({\n        origin,\n        id: snapId,\n        location,\n        versionRange,\n      });\n\n      await this.#authorize(snapId, pendingApproval);\n\n      pendingApproval = this.#createApproval({\n        origin,\n        snapId,\n        type: SNAP_APPROVAL_RESULT,\n      });\n\n      await this.#startSnap({\n        snapId,\n        sourceCode,\n      });\n\n      const truncated = this.getTruncatedExpect(snapId);\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        type: SNAP_APPROVAL_INSTALL,\n      });\n\n      return truncated;\n    } catch (error) {\n      logError(`Error when adding ${snapId}.`, error);\n\n      const errorString =\n        error instanceof Error ? error.message : error.toString();\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        type: SNAP_APPROVAL_INSTALL,\n        error: errorString,\n      });\n\n      this.messagingSystem.publish(\n        'SnapController:snapInstallFailed',\n        snapId,\n        origin,\n        false,\n        errorString,\n      );\n\n      throw error;\n    }\n  }\n\n  #createApproval({\n    origin,\n    snapId,\n    type,\n  }: {\n    origin: string;\n    snapId: SnapId;\n    type: string;\n  }): PendingApproval {\n    const id = nanoid();\n    const promise = this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        origin,\n        id,\n        type,\n        requestData: {\n          // Mirror previous installation metadata\n          metadata: { id, origin: snapId, dappOrigin: origin },\n          snapId,\n        },\n        requestState: {\n          loading: true,\n        },\n      },\n      true,\n    );\n\n    return { id, promise };\n  }\n\n  #updateApproval(id: string, requestState: Record<string, Json>) {\n    try {\n      this.messagingSystem.call('ApprovalController:updateRequestState', {\n        id,\n        requestState,\n      });\n    } catch {\n      // Do nothing\n    }\n  }\n\n  /**\n   * Updates an installed snap. The flow is similar to\n   * {@link SnapController.installSnaps}. The user will be asked if they want\n   * to update, then approve any permission changes, and finally the snap will\n   * be restarted.\n   *\n   * The update will fail if the user rejects any prompt or if the new version\n   * of the snap is blocked.\n   *\n   * If the original version of the snap was blocked and the update succeeded,\n   * the snap will be unblocked and enabled before it is restarted.\n   *\n   * @param options - An options bag.\n   * @param options.origin - The origin requesting the snap update.\n   * @param options.snapId - The id of the Snap to be updated.\n   * @param options.location - The location implementation of the snap.\n   * @param options.versionRange - A semver version range in which the maximum version will be chosen.\n   * @param options.automaticUpdate - An optional boolean flag to indicate whether this update should be done\n   * automatically.\n   * @returns The snap metadata if updated, `null` otherwise.\n   */\n  async #updateSnap({\n    origin,\n    snapId,\n    location,\n    versionRange,\n    automaticUpdate = false,\n  }: {\n    origin: string;\n    snapId: SnapId;\n    location: SnapLocation;\n    versionRange: SemVerRange;\n    automaticUpdate?: boolean;\n  }): Promise<TruncatedSnap> {\n    this.#assertCanInstallSnaps();\n    this.#assertCanUsePlatform();\n\n    const snap = this.getExpect(snapId);\n\n    const { preinstalled, removable, hidden, hideSnapBranding } = snap;\n\n    if (preinstalled && !automaticUpdate) {\n      throw new Error('Preinstalled Snaps cannot be manually updated.');\n    }\n\n    let pendingApproval = automaticUpdate\n      ? null\n      : this.#createApproval({\n          origin,\n          snapId,\n          type: SNAP_APPROVAL_UPDATE,\n        });\n\n    try {\n      this.messagingSystem.publish(\n        'SnapController:snapInstallStarted',\n        snapId,\n        origin,\n        true,\n      );\n\n      const oldManifest = snap.manifest;\n\n      const newSnap = await fetchSnap(snapId, location);\n      const { sourceCode: sourceCodeFile, manifest: manifestFile } = newSnap;\n\n      const manifest = manifestFile.result;\n\n      const newVersion = manifest.version;\n      if (!gtVersion(newVersion, snap.version)) {\n        throw rpcErrors.invalidParams(\n          `Snap \"${snapId}@${snap.version}\" is already installed. Couldn't update to a version inside requested \"${versionRange}\" range.`,\n        );\n      }\n\n      if (!satisfiesVersionRange(newVersion, versionRange)) {\n        throw new Error(\n          `Version mismatch. Manifest for \"${snapId}\" specifies version \"${newVersion}\" which doesn't satisfy requested version range \"${versionRange}\".`,\n        );\n      }\n\n      await this.#assertIsInstallAllowed(snapId, {\n        version: newVersion,\n        checksum: manifest.source.shasum,\n        permissions: manifest.initialPermissions,\n        platformVersion: manifest.platformVersion,\n      });\n\n      const processedPermissions = processSnapPermissions(\n        manifest.initialPermissions,\n      );\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      const { newPermissions, unusedPermissions, approvedPermissions } =\n        this.#calculatePermissionsChange(snapId, processedPermissions);\n\n      const { newConnections, unusedConnections, approvedConnections } =\n        this.#calculateConnectionsChange(\n          snapId,\n          oldManifest.initialConnections ?? {},\n          manifest.initialConnections ?? {},\n        );\n\n      let approvedNewPermissions;\n      let requestData;\n\n      if (pendingApproval) {\n        this.#updateApproval(pendingApproval.id, {\n          permissions: newPermissions,\n          newVersion: manifest.version,\n          newPermissions,\n          approvedPermissions,\n          unusedPermissions,\n          newConnections,\n          unusedConnections,\n          approvedConnections,\n          loading: false,\n        });\n\n        const { permissions, ...rest } =\n          (await pendingApproval.promise) as PermissionsRequest;\n\n        approvedNewPermissions = permissions;\n        requestData = rest;\n\n        pendingApproval = this.#createApproval({\n          origin,\n          snapId,\n          type: SNAP_APPROVAL_RESULT,\n        });\n      } else {\n        assert(automaticUpdate);\n        approvedNewPermissions = newPermissions;\n      }\n\n      if (this.isRunning(snapId)) {\n        await this.stopSnap(snapId, SnapStatusEvents.Stop);\n      }\n\n      this.#transition(snapId, SnapStatusEvents.Update);\n\n      this.#set({\n        origin,\n        id: snapId,\n        files: newSnap,\n        removable,\n        preinstalled,\n        hidden,\n        hideSnapBranding,\n        isUpdate: true,\n      });\n\n      this.#updatePermissions({\n        snapId,\n        unusedPermissions,\n        newPermissions: approvedNewPermissions,\n        requestData,\n      });\n\n      const previousInitialConnections = oldManifest.initialConnections ?? null;\n      const newInitialConnections = manifest.initialConnections ?? {};\n      this.#handleInitialConnections(\n        snapId,\n        previousInitialConnections,\n        newInitialConnections,\n      );\n\n      const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n      if (rollbackSnapshot !== undefined) {\n        rollbackSnapshot.permissions.revoked = unusedPermissions;\n        rollbackSnapshot.permissions.granted = approvedNewPermissions;\n        rollbackSnapshot.permissions.requestData = requestData;\n        rollbackSnapshot.previousInitialConnections =\n          previousInitialConnections;\n        rollbackSnapshot.newInitialConnections = newInitialConnections;\n      }\n\n      const sourceCode = sourceCodeFile.toString();\n\n      assert(\n        typeof sourceCode === 'string' && sourceCode.length > 0,\n        `Invalid source code for snap \"${snapId}\".`,\n      );\n\n      try {\n        await this.#startSnap({ snapId, sourceCode });\n      } catch {\n        throw new Error(`Snap ${snapId} crashed with updated source code.`);\n      }\n\n      const truncatedSnap = this.getTruncatedExpect(snapId);\n\n      if (pendingApproval) {\n        this.#updateApproval(pendingApproval.id, {\n          loading: false,\n          type: SNAP_APPROVAL_UPDATE,\n        });\n      }\n\n      return truncatedSnap;\n    } catch (error) {\n      logError(`Error when updating ${snapId},`, error);\n\n      const errorString =\n        error instanceof Error ? error.message : error.toString();\n\n      if (pendingApproval) {\n        this.#updateApproval(pendingApproval.id, {\n          loading: false,\n          error: errorString,\n          type: SNAP_APPROVAL_UPDATE,\n        });\n      }\n\n      this.messagingSystem.publish(\n        'SnapController:snapInstallFailed',\n        snapId,\n        origin,\n        true,\n        errorString,\n      );\n\n      throw error;\n    }\n  }\n\n  async #resolveAllowlistVersion(\n    snapId: SnapId,\n    versionRange: SemVerRange,\n  ): Promise<SemVerRange> {\n    return await this.messagingSystem.call(\n      'SnapsRegistry:resolveVersion',\n      snapId,\n      versionRange,\n    );\n  }\n\n  /**\n   * Returns a promise representing the complete installation of the requested snap.\n   * If the snap is already being installed, the previously pending promise will be returned.\n   *\n   * @param args - Object containing the snap id and either the URL of the snap's manifest,\n   * or the snap's manifest and source code. The object may also optionally contain a target\n   * version.\n   * @returns The resulting snap object.\n   */\n  async #add(args: AddSnapArgs): Promise<PersistedSnap> {\n    const { id: snapId, location, versionRange } = args;\n\n    this.#setupRuntime(snapId);\n    const runtime = this.#getRuntimeExpect(snapId);\n    if (!runtime.installPromise) {\n      log(`Adding snap: ${snapId}`);\n\n      // If fetching and setting the snap succeeds, this property will be set\n      // to null in the authorize() method.\n      runtime.installPromise = (async () => {\n        const fetchedSnap = await fetchSnap(snapId, location);\n        const manifest = fetchedSnap.manifest.result;\n        if (!satisfiesVersionRange(manifest.version, versionRange)) {\n          throw new Error(\n            `Version mismatch. Manifest for \"${snapId}\" specifies version \"${manifest.version}\" which doesn't satisfy requested version range \"${versionRange}\".`,\n          );\n        }\n\n        await this.#assertIsInstallAllowed(snapId, {\n          version: manifest.version,\n          checksum: manifest.source.shasum,\n          permissions: manifest.initialPermissions,\n          platformVersion: manifest.platformVersion,\n        });\n\n        const preinstalledArgs =\n          this.#featureFlags.forcePreinstalledSnaps && isLocalSnapId(snapId)\n            ? {\n                preinstalled: true,\n                hideSnapBranding: true,\n                hidden: false,\n              }\n            : {};\n\n        return this.#set({\n          ...args,\n          files: fetchedSnap,\n          id: snapId,\n          ...preinstalledArgs,\n        });\n      })();\n    }\n\n    try {\n      return await runtime.installPromise;\n    } catch (error) {\n      // Reset promise so users can retry installation in case the problem is\n      // temporary.\n      runtime.installPromise = null;\n      throw error;\n    }\n  }\n\n  async #startSnap(snapData: { snapId: SnapId; sourceCode: string }) {\n    const { snapId } = snapData;\n    if (this.isRunning(snapId)) {\n      throw new Error(`Snap \"${snapId}\" is already started.`);\n    }\n\n    try {\n      const runtime = this.#getRuntimeExpect(snapId);\n      const result = await this.messagingSystem.call(\n        'ExecutionService:executeSnap',\n        {\n          ...snapData,\n          endowments: await this.#getEndowments(snapId),\n        },\n      );\n\n      this.#transition(snapId, SnapStatusEvents.Start);\n      // We treat the initialization of the snap as the first request, for idle timing purposes.\n      runtime.lastRequest = Date.now();\n      return result;\n    } catch (error) {\n      await this.#terminateSnap(snapId);\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the names of all endowments that will be added to the Snap's\n   * Compartment when it executes. These should be the names of global\n   * JavaScript APIs accessible in the root realm of the execution environment.\n   *\n   * Throws an error if the endowment getter for a permission returns a truthy\n   * value that is not an array of strings.\n   *\n   * @param snapId - The id of the snap whose SES endowments to get.\n   * @returns An array of the names of the endowments.\n   */\n  async #getEndowments(snapId: string): Promise<string[]> {\n    let allEndowments: string[] = [];\n\n    for (const permissionName of this.#environmentEndowmentPermissions) {\n      if (\n        this.messagingSystem.call(\n          'PermissionController:hasPermission',\n          snapId,\n          permissionName,\n        )\n      ) {\n        const endowments = await this.messagingSystem.call(\n          'PermissionController:getEndowments',\n          snapId,\n          permissionName,\n        );\n\n        if (endowments) {\n          // We don't have any guarantees about the type of the endowments\n          // value, so we have to guard at runtime.\n          if (\n            !Array.isArray(endowments) ||\n            endowments.some((value) => typeof value !== 'string')\n          ) {\n            throw new Error('Expected an array of string endowment names.');\n          }\n\n          allEndowments = allEndowments.concat(endowments as string[]);\n        }\n      }\n    }\n\n    const dedupedEndowments = [\n      ...new Set([...DEFAULT_ENDOWMENTS, ...allEndowments]),\n    ];\n\n    if (\n      dedupedEndowments.length <\n      DEFAULT_ENDOWMENTS.length + allEndowments.length\n    ) {\n      logError(\n        `Duplicate endowments found for ${snapId}. Default endowments should not be requested.`,\n        allEndowments,\n      );\n    }\n    return dedupedEndowments;\n  }\n\n  /**\n   * Sets a snap in state. Called when a snap is installed or updated. Performs\n   * various validation checks on the received arguments, and will throw if\n   * validation fails.\n   *\n   * The snap will be enabled and unblocked by the time this method returns,\n   * regardless of its previous state.\n   *\n   * See {@link SnapController.add} and {@link SnapController.updateSnap} for\n   * usage.\n   *\n   * @param args - The add snap args.\n   * @returns The resulting snap object.\n   */\n  #set(args: SetSnapArgs): PersistedSnap {\n    const {\n      id: snapId,\n      origin,\n      files,\n      isUpdate = false,\n      removable,\n      preinstalled,\n      hidden,\n      hideSnapBranding,\n    } = args;\n\n    const {\n      manifest,\n      sourceCode: sourceCodeFile,\n      svgIcon,\n      auxiliaryFiles: rawAuxiliaryFiles,\n      localizationFiles,\n    } = files;\n\n    assertIsSnapManifest(manifest.result);\n    const { version } = manifest.result;\n\n    const sourceCode = sourceCodeFile.toString();\n\n    assert(\n      typeof sourceCode === 'string' && sourceCode.length > 0,\n      `Invalid source code for snap \"${snapId}\".`,\n    );\n\n    const auxiliaryFiles = rawAuxiliaryFiles.map((file) => {\n      assert(typeof file.data.base64 === 'string');\n      return {\n        path: file.path,\n        value: file.data.base64,\n      };\n    });\n\n    const snapsState = this.state.snaps;\n\n    const existingSnap = snapsState[snapId];\n\n    const previousVersionHistory = existingSnap?.versionHistory ?? [];\n    const versionHistory = [\n      ...previousVersionHistory,\n      {\n        version,\n        date: Date.now(),\n        origin,\n      },\n    ];\n\n    const localizedFiles = localizationFiles.map((file) => file.result);\n\n    const snap: Snap = {\n      // Restore relevant snap state if it exists\n      ...existingSnap,\n\n      // Note that the snap will be unblocked and enabled, regardless of its\n      // previous state.\n      blocked: false,\n      enabled: true,\n\n      removable,\n      preinstalled,\n      hidden,\n      hideSnapBranding,\n\n      id: snapId,\n      initialConnections: manifest.result.initialConnections,\n      initialPermissions: manifest.result.initialPermissions,\n      manifest: manifest.result,\n      status: this.#statusMachine.config.initial as StatusStates['value'],\n      sourceCode,\n      version,\n      versionHistory,\n      auxiliaryFiles,\n      localizationFiles: localizedFiles,\n    };\n\n    // If the snap was blocked, it isn't any longer\n    delete snap.blockInformation;\n\n    // store the snap back in state\n    const { inversePatches } = this.update((state: any) => {\n      state.snaps[snapId] = snap;\n    });\n\n    // checking for isUpdate here as this function is also used in\n    // the install flow, we do not care to create snapshots for installs\n    if (isUpdate) {\n      const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n      if (rollbackSnapshot !== undefined) {\n        rollbackSnapshot.statePatches = inversePatches;\n      }\n    }\n\n    // In case the Snap uses a localized manifest, we need to get the\n    // proposed name from the localized manifest.\n    const { proposedName } = getLocalizedSnapManifest(\n      manifest.result,\n      'en',\n      localizedFiles,\n    );\n\n    this.messagingSystem.call('SubjectMetadataController:addSubjectMetadata', {\n      subjectType: SubjectType.Snap,\n      name: proposedName,\n      origin: snap.id,\n      version,\n      svgIcon: svgIcon?.toString() ?? null,\n    });\n\n    return { ...snap, sourceCode };\n  }\n\n  #validateSnapPermissions(\n    processedPermissions: Record<string, Pick<PermissionConstraint, 'caveats'>>,\n  ) {\n    const permissionKeys = Object.keys(processedPermissions);\n    const handlerPermissions = Array.from(\n      new Set(Object.values(handlerEndowments)),\n    );\n\n    assert(\n      permissionKeys.some((key) => handlerPermissions.includes(key)),\n      `A snap must request at least one of the following permissions: ${handlerPermissions\n        .filter((handler) => handler !== null)\n        .join(', ')}.`,\n    );\n\n    const excludedPermissionErrors = permissionKeys.reduce<string[]>(\n      (errors, permission) => {\n        if (hasProperty(this.#excludedPermissions, permission)) {\n          errors.push(this.#excludedPermissions[permission]);\n        }\n\n        return errors;\n      },\n      [],\n    );\n\n    assert(\n      excludedPermissionErrors.length === 0,\n      `One or more permissions are not allowed:\\n${excludedPermissionErrors.join(\n        '\\n',\n      )}`,\n    );\n  }\n\n  /**\n   * Validate that the platform version specified in the manifest (if any) is\n   * compatible with the current platform version.\n   *\n   * @param snapId - The ID of the Snap.\n   * @param platformVersion - The platform version to validate against.\n   * @throws If the platform version is greater than the current platform\n   * version.\n   */\n  #validatePlatformVersion(\n    snapId: SnapId,\n    platformVersion: string | undefined,\n  ) {\n    if (platformVersion === undefined) {\n      return;\n    }\n\n    if (gt(platformVersion, getPlatformVersion())) {\n      const message = `The Snap \"${snapId}\" requires platform version \"${platformVersion}\" which is greater than the current platform version \"${getPlatformVersion()}\".`;\n\n      if (this.#featureFlags.rejectInvalidPlatformVersion) {\n        throw new Error(message);\n      }\n\n      logWarning(message);\n    }\n  }\n\n  /**\n   * Initiates a request for the given snap's initial permissions.\n   * Must be called in order. See processRequestedSnap.\n   *\n   * @param snapId - The id of the Snap.\n   * @param pendingApproval - Pending approval to update.\n   * @returns The snap's approvedPermissions.\n   */\n  async #authorize(\n    snapId: SnapId,\n    pendingApproval: PendingApproval,\n  ): Promise<void> {\n    log(`Authorizing snap: ${snapId}`);\n    const snapsState = this.state.snaps;\n    const snap = snapsState[snapId];\n    const { initialPermissions, initialConnections } = snap;\n\n    try {\n      const processedPermissions = processSnapPermissions(initialPermissions);\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        connections: initialConnections ?? {},\n        permissions: processedPermissions,\n      });\n\n      const { permissions: approvedPermissions, ...requestData } =\n        (await pendingApproval.promise) as PermissionsRequest;\n\n      this.#updatePermissions({\n        snapId,\n        newPermissions: approvedPermissions,\n        requestData,\n      });\n\n      if (snap.manifest.initialConnections) {\n        this.#handleInitialConnections(\n          snapId,\n          null,\n          snap.manifest.initialConnections,\n        );\n      }\n    } finally {\n      const runtime = this.#getRuntimeExpect(snapId);\n      runtime.installPromise = null;\n    }\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this.#timeoutForLastRequestStatus) {\n      clearTimeout(this.#timeoutForLastRequestStatus);\n    }\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n\n    this.messagingSystem.clearEventSubscriptions(\n      'SnapController:snapInstalled',\n    );\n\n    this.messagingSystem.clearEventSubscriptions('SnapController:snapUpdated');\n    /* eslint-enable @typescript-eslint/unbound-method */\n  }\n\n  /**\n   * Passes a JSON-RPC request object to the RPC handler function of a snap.\n   *\n   * @param options - A bag of options.\n   * @param options.snapId - The ID of the recipient snap.\n   * @param options.origin - The origin of the RPC request.\n   * @param options.handler - The handler to trigger on the snap for the request.\n   * @param options.request - The JSON-RPC request object.\n   * @returns The result of the JSON-RPC request.\n   */\n  async handleRequest({\n    snapId,\n    origin,\n    handler: handlerType,\n    request: rawRequest,\n  }: SnapRpcHookArgs & { snapId: SnapId }): Promise<unknown> {\n    this.#assertCanUsePlatform();\n\n    const snap = this.get(snapId);\n\n    assert(\n      snap,\n      `The Snap \"${snapId}\" is not installed. Please install it before invoking it.`,\n    );\n\n    assert(\n      origin === METAMASK_ORIGIN || isValidUrl(origin),\n      \"'origin' must be a valid URL or 'metamask'.\",\n    );\n\n    const request = {\n      jsonrpc: '2.0',\n      id: nanoid(),\n      ...rawRequest,\n    };\n\n    assertIsJsonRpcRequest(request);\n\n    const permissionName = handlerEndowments[handlerType];\n\n    assert(\n      typeof permissionName === 'string' || permissionName === null,\n      \"'permissionName' must be either a string or null.\",\n    );\n\n    const permissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n\n    // If permissionName is null, the handler does not require a permission.\n    if (\n      permissionName !== null &&\n      (!permissions || !hasProperty(permissions, permissionName))\n    ) {\n      throw new Error(\n        `Snap \"${snapId}\" is not permitted to use \"${permissionName}\".`,\n      );\n    }\n\n    const handlerPermissions = permissionName\n      ? (permissions as SubjectPermissions<PermissionConstraint>)[\n          permissionName\n        ]\n      : undefined;\n\n    if (\n      permissionName === SnapEndowments.Rpc ||\n      permissionName === SnapEndowments.Keyring\n    ) {\n      assert(handlerPermissions);\n\n      const subject = this.messagingSystem.call(\n        'SubjectMetadataController:getSubjectMetadata',\n        origin,\n      );\n\n      const origins =\n        permissionName === SnapEndowments.Rpc\n          ? getRpcCaveatOrigins(handlerPermissions)\n          : getKeyringCaveatOrigins(handlerPermissions);\n      assert(origins);\n\n      if (\n        !isOriginAllowed(\n          origins,\n          subject?.subjectType ?? SubjectType.Website,\n          origin,\n        )\n      ) {\n        throw new Error(\n          `Snap \"${snapId}\" is not permitted to handle requests from \"${origin}\".`,\n        );\n      }\n    }\n\n    if (\n      origin !== METAMASK_ORIGIN &&\n      CLIENT_ONLY_HANDLERS.includes(handlerType)\n    ) {\n      throw new Error(`\"${handlerType}\" can only be invoked by MetaMask.`);\n    }\n\n    if (!snap.enabled) {\n      throw new Error(`Snap \"${snapId}\" is disabled.`);\n    }\n\n    if (snap.status === SnapStatus.Installing) {\n      throw new Error(\n        `Snap \"${snapId}\" is currently being installed. Please try again later.`,\n      );\n    }\n\n    const timeout = this.#getExecutionTimeout(handlerPermissions);\n\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (runtime.stopPromise) {\n      await runtime.stopPromise;\n    }\n\n    if (!this.isRunning(snapId)) {\n      if (!runtime.startPromise) {\n        runtime.startPromise = this.startSnap(snapId);\n      }\n\n      try {\n        await runtime.startPromise;\n      } finally {\n        runtime.startPromise = null;\n      }\n    }\n\n    const transformedRequest = this.#transformSnapRpcRequest(\n      snapId,\n      handlerType,\n      request,\n    );\n\n    const timer = new Timer(timeout);\n    this.#recordSnapRpcRequestStart(snapId, transformedRequest.id, timer);\n\n    const handleRpcRequestPromise = this.messagingSystem.call(\n      'ExecutionService:handleRpcRequest',\n      snapId,\n      { origin, handler: handlerType, request: transformedRequest },\n    );\n\n    // This will either get the result or reject due to the timeout.\n    try {\n      const result = await withTimeout(handleRpcRequestPromise, timer);\n\n      if (result === hasTimedOut) {\n        const stopping =\n          runtime.stopPromise !== null || !this.isRunning(snapId);\n        throw new Error(\n          stopping\n            ? `${snapId} was stopped and the request was cancelled. This is likely because the Snap crashed.`\n            : `${snapId} failed to respond to the request in time.`,\n        );\n      }\n\n      await this.#assertSnapRpcResponse(snapId, handlerType, result);\n\n      const transformedResult = await this.#transformSnapRpcResponse(\n        snapId,\n        handlerType,\n        transformedRequest,\n        result,\n      );\n\n      this.#recordSnapRpcRequestFinish(\n        snapId,\n        transformedRequest.id,\n        handlerType,\n        origin,\n        true,\n      );\n\n      return transformedResult;\n    } catch (error) {\n      // We flag the RPC request as finished early since termination may affect pending requests\n      this.#recordSnapRpcRequestFinish(\n        snapId,\n        transformedRequest.id,\n        handlerType,\n        origin,\n        false,\n      );\n\n      const [jsonRpcError, handled] = unwrapError(error);\n\n      const stopping = runtime.stopPromise !== null || !this.isRunning(snapId);\n\n      if (!handled) {\n        if (!stopping) {\n          logError(\n            `\"${snapId}\" crashed due to an unhandled error:`,\n            jsonRpcError,\n          );\n        }\n        await this.stopSnap(snapId, SnapStatusEvents.Crash);\n      }\n\n      throw jsonRpcError;\n    }\n  }\n\n  /**\n   * Set the active state of the client. This will trigger the `onActive` or\n   * `onInactive` lifecycle hooks for all Snaps.\n   *\n   * @param active - A boolean indicating whether the client is active or not.\n   */\n  setClientActive(active: boolean) {\n    if (active) {\n      this.#callLifecycleHooks(METAMASK_ORIGIN, HandlerType.OnActive);\n    } else {\n      this.#callLifecycleHooks(METAMASK_ORIGIN, HandlerType.OnInactive);\n    }\n  }\n\n  /**\n   * Determine the execution timeout for a given handler permission.\n   *\n   * If no permission is specified or the permission itself has no execution timeout defined\n   * the constructor argument `maxRequestTime` will be used.\n   *\n   * @param permission - An optional permission constraint for the handler being called.\n   * @returns The execution timeout for the given handler.\n   */\n  #getExecutionTimeout(permission?: PermissionConstraint): number {\n    return getMaxRequestTimeCaveat(permission) ?? this.maxRequestTime;\n  }\n\n  /**\n   * Create a dynamic interface in the SnapInterfaceController.\n   *\n   * @param snapId - The snap ID.\n   * @param content - The initial interface content.\n   * @param contentType - The type of content.\n   * @returns An identifier that can be used to identify the interface.\n   */\n  async #createInterface(\n    snapId: SnapId,\n    content: ComponentOrElement,\n    contentType?: ContentType,\n  ): Promise<string> {\n    return this.messagingSystem.call(\n      'SnapInterfaceController:createInterface',\n      snapId,\n      content,\n      undefined,\n      contentType,\n    );\n  }\n\n  #assertInterfaceExists(snapId: SnapId, id: string) {\n    // This will throw if the interface isn't accessible, but we assert nevertheless.\n    assert(\n      this.messagingSystem.call(\n        'SnapInterfaceController:getInterface',\n        snapId,\n        id,\n      ),\n    );\n  }\n\n  /**\n   * Transform a RPC response if necessary.\n   *\n   * @param snapId - The snap ID of the snap that produced the result.\n   * @param handlerType - The handler type that produced the result.\n   * @param request - The request that returned the result.\n   * @param result - The response.\n   * @returns The transformed result if applicable, otherwise the original result.\n   */\n  async #transformSnapRpcResponse(\n    snapId: SnapId,\n    handlerType: HandlerType,\n    request: Record<string, unknown>,\n    result: unknown,\n  ) {\n    switch (handlerType) {\n      case HandlerType.OnTransaction:\n      case HandlerType.OnSignature:\n      case HandlerType.OnHomePage:\n      case HandlerType.OnSettingsPage: {\n        // Since this type has been asserted earlier we can cast\n        const castResult = result as Record<string, Json> | null;\n\n        // If a handler returns static content, we turn it into a dynamic UI\n        if (castResult && hasProperty(castResult, 'content')) {\n          const { content, ...rest } = castResult;\n          const id = await this.#createInterface(\n            snapId,\n            content as ComponentOrElement,\n          );\n\n          return { ...rest, id };\n        }\n        return result;\n      }\n      case HandlerType.OnAssetsLookup:\n        // We can cast since the request and result have already been validated.\n        return this.#transformOnAssetsLookupResult(\n          snapId,\n          request as { params: OnAssetsLookupArguments },\n          result as OnAssetsLookupResponse,\n        );\n\n      case HandlerType.OnAssetsConversion:\n        // We can cast since the request and result have already been validated.\n        return this.#transformOnAssetsConversionResult(\n          request as {\n            params: OnAssetsConversionArguments;\n          },\n          result as OnAssetsConversionResponse,\n        );\n\n      case HandlerType.OnAssetsMarketData:\n        // We can cast since the request and result have already been validated.\n        return this.#transformOnAssetsMarketDataResult(\n          request as { params: OnAssetsMarketDataArguments },\n          result as OnAssetsMarketDataResponse,\n        );\n\n      default:\n        return result;\n    }\n  }\n\n  /**\n   * Transform an RPC response coming from the `onAssetsLookup` handler.\n   *\n   * This filters out responses that are out of scope for the Snap based on\n   * its permissions and the incoming request.\n   *\n   * @param snapId - The snap ID of the snap that produced the result.\n   * @param request - The request that returned the result.\n   * @param request.params - The parameters for the request.\n   * @param result - The result.\n   * @param result.assets - The assets returned by the Snap.\n   * @returns The transformed result.\n   */\n  #transformOnAssetsLookupResult(\n    snapId: SnapId,\n    { params: requestedParams }: { params: OnAssetsLookupArguments },\n    { assets }: OnAssetsLookupResponse,\n  ) {\n    const permissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n    // We know the permissions are guaranteed to be set here.\n    assert(permissions);\n\n    const permission = permissions[SnapEndowments.Assets];\n    const scopes = getChainIdsCaveat(permission);\n    assert(scopes);\n\n    const { assets: requestedAssets } = requestedParams;\n\n    const filteredAssets = Object.keys(assets).reduce<\n      Record<CaipAssetType, AssetMetadata | null>\n    >((accumulator, assetType) => {\n      const castAssetType = assetType as CaipAssetTypeOrId;\n      const isValid =\n        scopes.some((scope) => castAssetType.startsWith(scope)) &&\n        requestedAssets.includes(castAssetType);\n      // Filter out unrequested assets and assets for scopes the Snap hasn't registered for.\n      if (isValid) {\n        accumulator[castAssetType] = assets[castAssetType];\n      }\n      return accumulator;\n    }, {});\n    return { assets: filteredAssets };\n  }\n\n  /**\n   * Transform an RPC response coming from the `onAssetsConversion` handler.\n   *\n   * This filters out responses that are out of scope for the Snap based on\n   * the incoming request.\n   *\n   * @param request - The request that returned the result.\n   * @param request.params - The parameters for the request.\n   * @param result - The result.\n   * @param result.conversionRates - The conversion rates returned by the Snap.\n   * @returns The transformed result.\n   */\n  #transformOnAssetsConversionResult(\n    { params: requestedParams }: { params: OnAssetsConversionArguments },\n    { conversionRates }: OnAssetsConversionResponse,\n  ) {\n    const { conversions: requestedConversions } = requestedParams;\n\n    const filteredConversionRates = requestedConversions.reduce<\n      Record<CaipAssetType, Record<CaipAssetType, AssetConversion>>\n    >((accumulator, conversion) => {\n      const rate = conversionRates[conversion.from]?.[conversion.to];\n      // Only include rates that were actually requested.\n      if (rate) {\n        accumulator[conversion.from] ??= {};\n        accumulator[conversion.from][conversion.to] = rate;\n      }\n      return accumulator;\n    }, {});\n    return { conversionRates: filteredConversionRates };\n  }\n\n  /**\n   * Transforms an RPC response coming from the `onAssetsMarketData` handler.\n   *\n   * This filters out responses that are out of scope for the Snap based on\n   * the incoming request.\n   *\n   * @param request - The request that returned the result.\n   * @param request.params - The parameters for the request.\n   * @param result - The result.\n   * @param result.marketData - The market data returned by the Snap.\n   * @returns The transformed result.\n   */\n  #transformOnAssetsMarketDataResult(\n    { params: requestedParams }: { params: OnAssetsMarketDataArguments },\n    { marketData }: OnAssetsMarketDataResponse,\n  ) {\n    const { assets: requestedAssets } = requestedParams;\n\n    const filteredMarketData = requestedAssets.reduce<\n      Record<CaipAssetTypeOrId, Record<CaipAssetType, AssetMarketData | null>>\n    >((accumulator, assets) => {\n      const result = marketData[assets.asset]?.[assets.unit];\n      // Only include rates that were actually requested.\n      if (result) {\n        accumulator[assets.asset] ??= {};\n        accumulator[assets.asset][assets.unit] = result;\n      }\n      return accumulator;\n    }, {});\n    return { marketData: filteredMarketData };\n  }\n\n  /**\n   * Transforms a JSON-RPC request before sending it to the Snap, if required for a given handler.\n   *\n   * @param snapId - The Snap ID.\n   * @param handlerType - The handler being called.\n   * @param request - The JSON-RPC request.\n   * @returns The potentially transformed JSON-RPC request.\n   */\n  #transformSnapRpcRequest(\n    snapId: SnapId,\n    handlerType: HandlerType,\n    request: JsonRpcRequest,\n  ) {\n    switch (handlerType) {\n      // For onUserInput we inject context, so the client doesn't have to worry about keeping it in sync.\n      case HandlerType.OnUserInput: {\n        assert(request.params && hasProperty(request.params, 'id'));\n\n        const interfaceId = request.params.id as string;\n        const { context } = this.messagingSystem.call(\n          'SnapInterfaceController:getInterface',\n          snapId,\n          interfaceId,\n        );\n\n        return {\n          ...request,\n          params: { ...request.params, context },\n        };\n      }\n\n      default:\n        return request;\n    }\n  }\n\n  /**\n   * Assert that the returned result of a Snap RPC call is the expected shape.\n   *\n   * @param snapId - The snap ID.\n   * @param handlerType - The handler type of the RPC Request.\n   * @param result - The result of the RPC request.\n   */\n  async #assertSnapRpcResponse(\n    snapId: SnapId,\n    handlerType: HandlerType,\n    result: unknown,\n  ) {\n    switch (handlerType) {\n      case HandlerType.OnTransaction: {\n        assertStruct(result, OnTransactionResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnSignature: {\n        assertStruct(result, OnSignatureResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnHomePage: {\n        assertStruct(result, OnHomePageResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnSettingsPage: {\n        assertStruct(result, OnSettingsPageResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnNameLookup:\n        assertStruct(result, OnNameLookupResponseStruct);\n        break;\n      case HandlerType.OnAssetsLookup:\n        assertStruct(result, OnAssetsLookupResponseStruct);\n        break;\n      case HandlerType.OnAssetsConversion:\n        assertStruct(result, OnAssetsConversionResponseStruct);\n        break;\n      case HandlerType.OnAssetHistoricalPrice:\n        assertStruct(result, OnAssetHistoricalPriceResponseStruct);\n        break;\n      case HandlerType.OnAssetsMarketData:\n        assertStruct(result, OnAssetsMarketDataResponseStruct);\n        break;\n      default:\n        break;\n    }\n  }\n\n  #recordSnapRpcRequestStart(snapId: SnapId, requestId: unknown, timer: Timer) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests.push({ requestId, timer });\n    runtime.lastRequest = null;\n  }\n\n  #recordSnapRpcRequestFinish(\n    snapId: SnapId,\n    requestId: unknown,\n    handlerType: HandlerType,\n    origin: string,\n    success: boolean,\n  ) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests = runtime.pendingInboundRequests.filter(\n      (request) => request.requestId !== requestId,\n    );\n\n    if (runtime.pendingInboundRequests.length === 0) {\n      runtime.lastRequest = Date.now();\n    }\n\n    const snap = this.get(snapId);\n\n    if (isTrackableHandler(handlerType) && !snap?.preinstalled) {\n      try {\n        this.#trackSnapExport(snapId, handlerType, success, origin);\n      } catch (error) {\n        logError(\n          `Error when calling MetaMetrics hook for snap \"${snap?.id}\": ${getErrorMessage(\n            error,\n          )}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Retrieves the rollback snapshot of a snap.\n   *\n   * @param snapId - The snap id.\n   * @returns A `RollbackSnapshot` or `undefined` if one doesn't exist.\n   */\n  #getRollbackSnapshot(snapId: SnapId): RollbackSnapshot | undefined {\n    return this.#rollbackSnapshots.get(snapId);\n  }\n\n  /**\n   * Creates a `RollbackSnapshot` that is used to help ensure\n   * atomicity in multiple snap updates.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If the snap exists before creation or if creation fails.\n   * @returns A `RollbackSnapshot`.\n   */\n  #createRollbackSnapshot(snapId: SnapId): RollbackSnapshot {\n    assert(\n      this.#rollbackSnapshots.get(snapId) === undefined,\n      `Snap \"${snapId}\" rollback snapshot already exists.`,\n    );\n\n    this.#rollbackSnapshots.set(snapId, {\n      statePatches: [],\n      permissions: {},\n      newVersion: '',\n    });\n\n    const newRollbackSnapshot = this.#rollbackSnapshots.get(snapId);\n\n    assert(\n      newRollbackSnapshot !== undefined,\n      `Snapshot creation failed for ${snapId}.`,\n    );\n    return newRollbackSnapshot;\n  }\n\n  /**\n   * Rolls back a snap to its previous state, permissions\n   * and source code based on the `RollbackSnapshot` that\n   * is captured during the update process. After rolling back,\n   * the function also emits an event indicating that the\n   * snap has been rolled back and it clears the snapshot\n   * for that snap.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If a snapshot does not exist.\n   */\n  async #rollbackSnap(snapId: SnapId) {\n    const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n    if (!rollbackSnapshot) {\n      throw new Error('A snapshot does not exist for this snap.');\n    }\n\n    await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    // Always set to stopped even if it wasn't running initially\n    if (this.get(snapId)?.status !== SnapStatus.Stopped) {\n      this.#transition(snapId, SnapStatusEvents.Stop);\n    }\n\n    const {\n      statePatches,\n      permissions,\n      previousInitialConnections,\n      newInitialConnections,\n    } = rollbackSnapshot;\n\n    if (statePatches?.length) {\n      this.applyPatches(statePatches);\n    }\n\n    // Reset snap status, as we may have been in another state when we stored state patches\n    // But now we are 100% in a stopped state\n    if (this.get(snapId)?.status !== SnapStatus.Stopped) {\n      this.update((state) => {\n        state.snaps[snapId].status = SnapStatus.Stopped;\n      });\n    }\n\n    this.#updatePermissions({\n      snapId,\n      unusedPermissions: permissions.granted,\n      newPermissions: permissions.revoked,\n      requestData: permissions.requestData,\n    });\n\n    // Calling this in reverse order to undo the changes\n    this.#handleInitialConnections(\n      snapId,\n      newInitialConnections ?? null,\n      previousInitialConnections ?? {},\n    );\n\n    const truncatedSnap = this.getTruncatedExpect(snapId);\n\n    this.messagingSystem.publish(\n      'SnapController:snapRolledback',\n      truncatedSnap,\n      rollbackSnapshot.newVersion,\n    );\n\n    this.#rollbackSnapshots.delete(snapId);\n  }\n\n  /**\n   * Iterates through an array of snap ids\n   * and calls `rollbackSnap` on them.\n   *\n   * @param snapIds - An array of snap ids.\n   */\n  async #rollbackSnaps(snapIds: SnapId[]) {\n    for (const snapId of snapIds) {\n      await this.#rollbackSnap(snapId);\n    }\n  }\n\n  #getRuntime(snapId: SnapId): SnapRuntimeData | undefined {\n    return this.#snapsRuntimeData.get(snapId);\n  }\n\n  #getRuntimeExpect(snapId: SnapId): SnapRuntimeData {\n    const runtime = this.#getRuntime(snapId);\n    assert(runtime !== undefined, `Snap \"${snapId}\" runtime data not found`);\n    return runtime;\n  }\n\n  #setupRuntime(snapId: SnapId) {\n    if (this.#snapsRuntimeData.has(snapId)) {\n      return;\n    }\n\n    const snap = this.get(snapId);\n    const interpreter = interpret(this.#statusMachine);\n    interpreter.start({\n      context: { snapId },\n      value:\n        snap?.status ??\n        (this.#statusMachine.config.initial as StatusStates['value']),\n    });\n\n    forceStrict(interpreter);\n\n    this.#snapsRuntimeData.set(snapId, {\n      lastRequest: null,\n      startPromise: null,\n      stopPromise: null,\n      installPromise: null,\n      encryptionKey: null,\n      encryptionSalt: null,\n      activeReferences: 0,\n      pendingInboundRequests: [],\n      pendingOutboundRequests: 0,\n      interpreter,\n      stateMutex: new Mutex(),\n      getStateMutex: new Mutex(),\n    });\n  }\n\n  #calculatePermissionsChange(\n    snapId: SnapId,\n    desiredPermissionsSet: Record<\n      string,\n      Pick<PermissionConstraint, 'caveats'>\n    >,\n  ): {\n    newPermissions: Record<string, Pick<PermissionConstraint, 'caveats'>>;\n    unusedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n    approvedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n  } {\n    const oldPermissions =\n      this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        snapId,\n      ) ?? {};\n\n    const newPermissions = permissionsDiff(\n      desiredPermissionsSet,\n      oldPermissions,\n    );\n    // TODO(ritave): The assumption that these are unused only holds so long as we do not\n    //               permit dynamic permission requests.\n    const unusedPermissions = permissionsDiff(\n      oldPermissions,\n      desiredPermissionsSet,\n    );\n\n    // It's a Set Intersection of oldPermissions and desiredPermissionsSet\n    // oldPermissions ∖ (oldPermissions ∖ desiredPermissionsSet) ⟺ oldPermissions ∩ desiredPermissionsSet\n    const approvedPermissions = permissionsDiff(\n      oldPermissions,\n      unusedPermissions,\n    );\n\n    return { newPermissions, unusedPermissions, approvedPermissions };\n  }\n\n  #isSubjectConnectedToSnap(snapId: SnapId, origin: string) {\n    const subjectPermissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const existingCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds);\n\n    return Boolean((existingCaveat?.value as Record<string, Json>)?.[snapId]);\n  }\n\n  #calculateConnectionsChange(\n    snapId: SnapId,\n    oldConnectionsSet: Record<string, Json>,\n    desiredConnectionsSet: Record<string, Json>,\n  ): {\n    newConnections: Record<string, Json>;\n    unusedConnections: Record<string, Json>;\n    approvedConnections: Record<string, Json>;\n  } {\n    // Filter out any origins that have been revoked since last install/update.\n    // That way they will be represented as new.\n    const filteredOldConnections = Object.keys(oldConnectionsSet)\n      .filter((origin) => this.#isSubjectConnectedToSnap(snapId, origin))\n      .reduce<Record<string, Json>>((accumulator, origin) => {\n        accumulator[origin] = oldConnectionsSet[origin];\n        return accumulator;\n      }, {});\n\n    const newConnections = setDiff(\n      desiredConnectionsSet,\n      filteredOldConnections,\n    );\n\n    const unusedConnections = setDiff(\n      filteredOldConnections,\n      desiredConnectionsSet,\n    );\n\n    // It's a Set Intersection of oldConnections and desiredConnectionsSet\n    // oldConnections ∖ (oldConnections ∖ desiredConnectionsSet) ⟺ oldConnections ∩ desiredConnectionsSet\n    const approvedConnections = setDiff(\n      filteredOldConnections,\n      unusedConnections,\n    );\n\n    return { newConnections, unusedConnections, approvedConnections };\n  }\n\n  /**\n   * Get the permissions to grant to a Snap following an install, update or\n   * rollback.\n   *\n   * @param snapId - The snap ID.\n   * @param newPermissions - The new permissions to be granted.\n   * @returns The permissions to grant to the Snap.\n   */\n  #getPermissionsToGrant(snapId: SnapId, newPermissions: RequestedPermissions) {\n    if (Object.keys(newPermissions).includes(SnapEndowments.EthereumProvider)) {\n      // This will return the globally selected network if the Snap doesn't have\n      // one set.\n      const networkClientId = this.messagingSystem.call(\n        'SelectedNetworkController:getNetworkClientIdForDomain',\n        snapId,\n      );\n\n      const { configuration } = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n\n      const chainId = hexToNumber(configuration.chainId);\n\n      // This needs to be assigned to have proper type inference.\n      const modifiedPermissions: RequestedPermissions = {\n        ...newPermissions,\n        'endowment:caip25': {\n          caveats: [\n            {\n              type: 'authorizedScopes',\n              value: {\n                requiredScopes: {},\n                optionalScopes: {\n                  [`eip155:${chainId}`]: {\n                    accounts: [],\n                  },\n                },\n                sessionProperties: {},\n                isMultichainOrigin: false,\n              },\n            },\n          ],\n        },\n      };\n\n      return modifiedPermissions;\n    }\n\n    return newPermissions;\n  }\n\n  /**\n   * Update the permissions for a snap following an install, update or rollback.\n   *\n   * Grants newly requested permissions and revokes unused/revoked permissions.\n   *\n   * @param args - An options bag.\n   * @param args.snapId - The snap ID.\n   * @param args.newPermissions - New permissions to be granted.\n   * @param args.unusedPermissions - Unused permissions to be revoked.\n   * @param args.requestData - Optional request data from an approval.\n   */\n  #updatePermissions({\n    snapId,\n    unusedPermissions = {},\n    newPermissions = {},\n    requestData,\n  }: {\n    snapId: SnapId;\n    newPermissions?:\n      | RequestedPermissions\n      | Record<string, Pick<PermissionConstraint, 'caveats'>>;\n    unusedPermissions?:\n      | RequestedPermissions\n      | SubjectPermissions<ValidPermission<string, Caveat<string, any>>>;\n    requestData?: Record<string, unknown>;\n  }) {\n    const unusedPermissionsKeys = Object.keys(unusedPermissions);\n    if (isNonEmptyArray(unusedPermissionsKeys)) {\n      this.messagingSystem.call('PermissionController:revokePermissions', {\n        [snapId]: unusedPermissionsKeys,\n      });\n    }\n\n    if (isNonEmptyArray(Object.keys(newPermissions))) {\n      const approvedPermissions = this.#getPermissionsToGrant(\n        snapId,\n        newPermissions,\n      );\n\n      this.messagingSystem.call('PermissionController:grantPermissions', {\n        approvedPermissions,\n        subject: { origin: snapId },\n        requestData,\n      });\n    }\n  }\n\n  /**\n   * Checks if a snap will pass version validation checks\n   * with the new version range that is requested. The first\n   * check that is done is to check if the existing snap version\n   * falls inside the requested range. If it does, we want to return\n   * false because we do not care to create a rollback snapshot in\n   * that scenario. The second check is to ensure that the current\n   * snap version is not greater than all possible versions in\n   * the requested version range. If it is, then we also want\n   * to return false in that scenario.\n   *\n   * @param snapId - The snap id.\n   * @param newVersionRange - The new version range being requested.\n   * @returns `true` if validation checks pass and `false` if they do not.\n   */\n  #isValidUpdate(snapId: SnapId, newVersionRange: SemVerRange): boolean {\n    const existingSnap = this.getExpect(snapId);\n\n    if (satisfiesVersionRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    if (gtRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Call a lifecycle hook for all runnable Snaps.\n   *\n   * @param origin - The origin of the request.\n   * @param handler - The lifecycle hook to call. This should be one of the\n   * supported lifecycle hooks.\n   */\n  #callLifecycleHooks(origin: string, handler: HandlerType) {\n    const snaps = this.getRunnableSnaps();\n    for (const { id } of snaps) {\n      const hasLifecycleHooksEndowment = this.messagingSystem.call(\n        'PermissionController:hasPermission',\n        id,\n        SnapEndowments.LifecycleHooks,\n      );\n\n      if (!hasLifecycleHooksEndowment) {\n        continue;\n      }\n\n      this.#callLifecycleHook(origin, id, handler).catch((error) => {\n        logError(\n          `Error calling lifecycle hook \"${handler}\" for Snap \"${id}\": ${getErrorMessage(\n            error,\n          )}`,\n        );\n      });\n    }\n  }\n\n  /**\n   * Call a lifecycle hook on a snap, if the snap has the\n   * `endowment:lifecycle-hooks` permission. If the snap does not have the\n   * permission, nothing happens.\n   *\n   * @param origin - The origin.\n   * @param snapId - The snap ID.\n   * @param handler - The lifecycle hook to call. This should be one of the\n   * supported lifecycle hooks.\n   * @private\n   */\n  async #callLifecycleHook(\n    origin: string,\n    snapId: SnapId,\n    handler: HandlerType,\n  ) {\n    const permissionName = handlerEndowments[handler];\n\n    assert(permissionName, 'Lifecycle hook must have an endowment.');\n\n    const hasPermission = this.messagingSystem.call(\n      'PermissionController:hasPermission',\n      snapId,\n      permissionName,\n    );\n\n    if (!hasPermission) {\n      return;\n    }\n\n    await this.handleRequest({\n      snapId,\n      handler,\n      origin,\n      request: {\n        jsonrpc: '2.0',\n        method: handler,\n      },\n    });\n  }\n\n  /**\n   * Handle the `KeyringController:lock` event.\n   *\n   * Currently this clears the cached encrypted state (if any) for all Snaps.\n   */\n  #handleLock() {\n    for (const runtime of this.#snapsRuntimeData.values()) {\n      runtime.encryptionKey = null;\n      runtime.encryptionSalt = null;\n      runtime.state = undefined;\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SnapController.cjs","sourceRoot":"","sources":["../../src/snaps/SnapController.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ORIGIN_METAMASK,\n  type AddApprovalRequest,\n  type UpdateRequestState,\n} from '@metamask/approval-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller/next';\nimport { BaseController } from '@metamask/base-controller/next';\nimport type { CryptographicFunctions } from '@metamask/key-tree';\nimport type { Messenger } from '@metamask/messenger';\nimport type {\n  Caveat,\n  GetEndowments,\n  GetPermissions,\n  GetSubjectMetadata,\n  AddSubjectMetadata,\n  GetSubjects,\n  GrantPermissions,\n  HasPermission,\n  HasPermissions,\n  PermissionConstraint,\n  PermissionsRequest,\n  RequestedPermissions,\n  RevokeAllPermissions,\n  RevokePermissionForAllSubjects,\n  RevokePermissions,\n  SubjectPermissions,\n  UpdateCaveat,\n  ValidPermission,\n} from '@metamask/permission-controller';\nimport { SubjectType } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { BlockReason } from '@metamask/snaps-registry';\nimport {\n  WALLET_SNAP_PERMISSION_KEY,\n  getMaxRequestTimeCaveat,\n  handlerEndowments,\n  SnapEndowments,\n  getKeyringCaveatOrigins,\n  getRpcCaveatOrigins,\n  processSnapPermissions,\n  getEncryptionEntropy,\n  getChainIdsCaveat,\n} from '@metamask/snaps-rpc-methods';\nimport type {\n  RequestSnapsParams,\n  RequestSnapsResult,\n  SnapId,\n  ComponentOrElement,\n  ContentType,\n  OnAssetsLookupResponse,\n  OnAssetsConversionResponse,\n  OnAssetsConversionArguments,\n  AssetConversion,\n  OnAssetsLookupArguments,\n  OnAssetsMarketDataArguments,\n  OnAssetsMarketDataResponse,\n  AssetMarketData,\n  AssetMetadata,\n  EmptyObject,\n} from '@metamask/snaps-sdk';\nimport {\n  AuxiliaryFileEncoding,\n  getErrorMessage,\n  OnAssetsLookupResponseStruct,\n} from '@metamask/snaps-sdk';\nimport type {\n  FetchedSnapFiles,\n  InitialConnections,\n  PersistedSnap,\n  Snap,\n  SnapManifest,\n  SnapPermissions,\n  SnapRpcHookArgs,\n  StatusContext,\n  StatusEvents,\n  StatusStates,\n  TruncatedSnap,\n  TruncatedSnapFields,\n} from '@metamask/snaps-utils';\nimport {\n  logWarning,\n  getPlatformVersion,\n  assertIsSnapManifest,\n  assertIsValidSnapId,\n  DEFAULT_ENDOWMENTS,\n  encodeAuxiliaryFile,\n  HandlerType,\n  isOriginAllowed,\n  logError,\n  normalizeRelative,\n  OnTransactionResponseStruct,\n  OnSignatureResponseStruct,\n  resolveVersionRange,\n  SnapCaveatType,\n  SnapStatus,\n  SnapStatusEvents,\n  unwrapError,\n  OnHomePageResponseStruct,\n  getValidatedLocalizationFiles,\n  VirtualFile,\n  NpmSnapFileNames,\n  OnNameLookupResponseStruct,\n  getLocalizedSnapManifest,\n  MAX_FILE_SIZE,\n  OnSettingsPageResponseStruct,\n  isValidUrl,\n  OnAssetHistoricalPriceResponseStruct,\n  OnAssetsConversionResponseStruct,\n  OnAssetsMarketDataResponseStruct,\n} from '@metamask/snaps-utils';\nimport type {\n  Json,\n  NonEmptyArray,\n  SemVerRange,\n  CaipAssetType,\n  JsonRpcRequest,\n  Hex,\n  SemVerVersion,\n  CaipAssetTypeOrId,\n} from '@metamask/utils';\nimport {\n  hexToNumber,\n  assert,\n  assertIsJsonRpcRequest,\n  assertStruct,\n  Duration,\n  gtRange,\n  gtVersion,\n  hasProperty,\n  inMilliseconds,\n  isNonEmptyArray,\n  satisfiesVersionRange,\n  timeSince,\n  createDeferredPromise,\n} from '@metamask/utils';\nimport type { StateMachine } from '@xstate/fsm';\nimport { createMachine, interpret } from '@xstate/fsm';\nimport { Mutex } from 'async-mutex';\nimport type { Patch } from 'immer';\nimport { nanoid } from 'nanoid';\nimport { gt, gte } from 'semver';\n\nimport {\n  ALLOWED_PERMISSIONS,\n  CLIENT_ONLY_HANDLERS,\n  LEGACY_ENCRYPTION_KEY_DERIVATION_OPTIONS,\n  METAMASK_ORIGIN,\n  STATE_DEBOUNCE_TIMEOUT,\n} from './constants';\nimport type { SnapLocation } from './location';\nimport { detectSnapLocation } from './location';\nimport type {\n  GetMetadata,\n  GetResult,\n  ResolveVersion,\n  SnapsRegistryInfo,\n  SnapsRegistryRequest,\n  Update,\n} from './registry';\nimport { SnapsRegistryStatus } from './registry';\nimport { getRunnableSnaps } from './selectors';\nimport { Timer } from './Timer';\nimport { forceStrict, validateMachine } from '../fsm';\nimport type { CreateInterface, GetInterface } from '../interface';\nimport { log } from '../logging';\nimport type {\n  ExecuteSnapAction,\n  ExecutionServiceEvents,\n  HandleRpcRequestAction,\n  SnapErrorJson,\n  TerminateSnapAction,\n} from '../services';\nimport type {\n  EncryptionResult,\n  ExportableKeyEncryptor,\n  KeyDerivationOptions,\n} from '../types';\nimport {\n  debouncePersistState,\n  fetchSnap,\n  hasTimedOut,\n  permissionsDiff,\n  setDiff,\n  throttleTracking,\n  withTimeout,\n  isTrackableHandler,\n  isLocalSnapId,\n} from '../utils';\n\nexport const controllerName = 'SnapController';\n\n// TODO: Figure out how to name these\nexport const SNAP_APPROVAL_INSTALL = 'wallet_installSnap';\nexport const SNAP_APPROVAL_UPDATE = 'wallet_updateSnap';\nexport const SNAP_APPROVAL_RESULT = 'wallet_installSnapResult';\n\nconst TRUNCATED_SNAP_PROPERTIES = new Set<TruncatedSnapFields>([\n  'initialPermissions',\n  'id',\n  'version',\n  'enabled',\n  'blocked',\n]);\n\nexport type PendingRequest = {\n  requestId: unknown;\n  timer: Timer;\n};\n\nexport type PreinstalledSnapFile = {\n  path: string;\n  value: string | Uint8Array;\n};\n\nexport type PreinstalledSnap = {\n  snapId: SnapId;\n  manifest: SnapManifest;\n  files: PreinstalledSnapFile[];\n  removable?: boolean;\n  hidden?: boolean;\n  hideSnapBranding?: boolean;\n};\n\n/**\n * A wrapper type for any data stored during runtime of Snaps.\n * It is not persisted in state as it contains non-serializable data and is only relevant for the\n * current session.\n */\nexport type SnapRuntimeData = {\n  /**\n   * A promise that resolves when the Snap has finished installing\n   */\n  installPromise: null | Promise<PersistedSnap>;\n\n  /**\n   * A promise that resolves when the Snap has finished booting\n   */\n  startPromise: null | Promise<void>;\n\n  /**\n   * A promise that resolves when the Snap has finished stopping\n   */\n  stopPromise: null | Promise<void>;\n\n  /**\n   * A Unix timestamp for the last time the Snap received an RPC request\n   */\n  lastRequest: null | number;\n\n  /**\n   * The current number of active references where this Snap is being used\n   */\n  activeReferences: number;\n\n  /**\n   * The current pending inbound requests, meaning requests that are processed by snaps.\n   */\n  pendingInboundRequests: PendingRequest[];\n\n  /**\n   * The current pending outbound requests, meaning requests made from snaps towards the MetaMask\n   * extension.\n   */\n  pendingOutboundRequests: number;\n\n  /**\n   * The finite state machine interpreter for possible states that the Snap can be in such as\n   * stopped, running, blocked\n   *\n   * @see {@link SnapController:constructor}\n   */\n  interpreter: StateMachine.Service<StatusContext, StatusEvents, StatusStates>;\n\n  /**\n   * Cached encryption key used for state encryption.\n   */\n  encryptionKey: string | null;\n\n  /**\n   * Cached encryption salt used for state encryption.\n   */\n  encryptionSalt: string | null;\n\n  /**\n   * Cached encrypted state of the Snap.\n   */\n  state?: Record<string, Json> | null;\n\n  /**\n   * Cached unencrypted state of the Snap.\n   */\n  unencryptedState?: Record<string, Json> | null;\n\n  /**\n   * A mutex to prevent concurrent state updates.\n   */\n  stateMutex: Mutex;\n\n  /**\n   * A mutex to prevent concurrent state decryption.\n   */\n  getStateMutex: Mutex;\n};\n\nexport type SnapError = {\n  message: string;\n  code: number;\n  data?: Json;\n};\n\n// Types that probably should be defined elsewhere in prod\ntype CloseAllConnectionsFunction = (origin: string) => void;\ntype StoredSnaps = Record<SnapId, Snap>;\n\nexport type SnapControllerState = {\n  snaps: StoredSnaps;\n  snapStates: Record<SnapId, string | null>;\n  unencryptedSnapStates: Record<SnapId, string | null>;\n};\n\nexport type PersistedSnapControllerState = SnapControllerState & {\n  snaps: Record<SnapId, PersistedSnap>;\n  snapStates: Record<SnapId, string>;\n};\n\ntype RollbackSnapshot = {\n  statePatches: Patch[];\n  permissions: {\n    revoked?: SubjectPermissions<ValidPermission<string, Caveat<string, any>>>;\n    granted?: RequestedPermissions;\n    requestData?: Record<string, unknown>;\n  };\n  previousInitialConnections?: Record<string, EmptyObject> | null;\n  newInitialConnections?: Record<string, EmptyObject>;\n  newVersion: string;\n};\n\ntype PendingApproval = {\n  id: string;\n  promise: Promise<unknown>;\n};\n\n// Controller Messenger Actions\n\n/**\n * Initialise the SnapController. This should be called after all controllers\n * are created.\n */\nexport type SnapControllerInitAction = {\n  type: `${typeof controllerName}:init`;\n  handler: SnapController['init'];\n};\n\n/**\n * Gets the specified Snap from state.\n */\nexport type GetSnap = {\n  type: `${typeof controllerName}:get`;\n  handler: SnapController['get'];\n};\n\n/**\n * Handles sending an inbound request to a snap and returns its result.\n */\nexport type HandleSnapRequest = {\n  type: `${typeof controllerName}:handleRequest`;\n  handler: SnapController['handleRequest'];\n};\n\n/**\n * Gets the specified Snap's persisted state.\n */\nexport type GetSnapState = {\n  type: `${typeof controllerName}:getSnapState`;\n  handler: SnapController['getSnapState'];\n};\n\n/**\n * Checks if the specified snap exists in state.\n */\nexport type HasSnap = {\n  type: `${typeof controllerName}:has`;\n  handler: SnapController['has'];\n};\n\n/**\n * Updates the specified Snap's persisted state.\n */\nexport type UpdateSnapState = {\n  type: `${typeof controllerName}:updateSnapState`;\n  handler: SnapController['updateSnapState'];\n};\n\n/**\n * Clears the specified Snap's persisted state.\n */\nexport type ClearSnapState = {\n  type: `${typeof controllerName}:clearSnapState`;\n  handler: SnapController['clearSnapState'];\n};\n\n/**\n * Checks all installed snaps against the blocklist.\n */\nexport type UpdateRegistry = {\n  type: `${typeof controllerName}:updateRegistry`;\n  handler: SnapController['updateRegistry'];\n};\n\nexport type EnableSnap = {\n  type: `${typeof controllerName}:enable`;\n  handler: SnapController['enableSnap'];\n};\n\nexport type DisableSnap = {\n  type: `${typeof controllerName}:disable`;\n  handler: SnapController['disableSnap'];\n};\n\nexport type RemoveSnap = {\n  type: `${typeof controllerName}:remove`;\n  handler: SnapController['removeSnap'];\n};\n\nexport type GetPermittedSnaps = {\n  type: `${typeof controllerName}:getPermitted`;\n  handler: SnapController['getPermittedSnaps'];\n};\n\nexport type GetAllSnaps = {\n  type: `${typeof controllerName}:getAll`;\n  handler: SnapController['getAllSnaps'];\n};\n\nexport type GetRunnableSnaps = {\n  type: `${typeof controllerName}:getRunnableSnaps`;\n  handler: SnapController['getRunnableSnaps'];\n};\n\nexport type StopAllSnaps = {\n  type: `${typeof controllerName}:stopAllSnaps`;\n  handler: SnapController['stopAllSnaps'];\n};\n\nexport type IncrementActiveReferences = {\n  type: `${typeof controllerName}:incrementActiveReferences`;\n  handler: SnapController['incrementActiveReferences'];\n};\n\nexport type DecrementActiveReferences = {\n  type: `${typeof controllerName}:decrementActiveReferences`;\n  handler: SnapController['decrementActiveReferences'];\n};\n\nexport type InstallSnaps = {\n  type: `${typeof controllerName}:install`;\n  handler: SnapController['installSnaps'];\n};\n\nexport type DisconnectOrigin = {\n  type: `${typeof controllerName}:disconnectOrigin`;\n  handler: SnapController['removeSnapFromSubject'];\n};\n\nexport type RevokeDynamicPermissions = {\n  type: `${typeof controllerName}:revokeDynamicPermissions`;\n  handler: SnapController['revokeDynamicSnapPermissions'];\n};\n\nexport type GetSnapFile = {\n  type: `${typeof controllerName}:getFile`;\n  handler: SnapController['getSnapFile'];\n};\n\nexport type IsMinimumPlatformVersion = {\n  type: `${typeof controllerName}:isMinimumPlatformVersion`;\n  handler: SnapController['isMinimumPlatformVersion'];\n};\n\nexport type SetClientActive = {\n  type: `${typeof controllerName}:setClientActive`;\n  handler: SnapController['setClientActive'];\n};\n\nexport type SnapControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapControllerState\n>;\n\nexport type SnapControllerActions =\n  | SnapControllerInitAction\n  | ClearSnapState\n  | GetSnap\n  | GetSnapState\n  | HandleSnapRequest\n  | HasSnap\n  | UpdateRegistry\n  | UpdateSnapState\n  | EnableSnap\n  | DisableSnap\n  | RemoveSnap\n  | GetPermittedSnaps\n  | InstallSnaps\n  | GetAllSnaps\n  | GetRunnableSnaps\n  | IncrementActiveReferences\n  | DecrementActiveReferences\n  | DisconnectOrigin\n  | RevokeDynamicPermissions\n  | GetSnapFile\n  | SnapControllerGetStateAction\n  | StopAllSnaps\n  | IsMinimumPlatformVersion\n  | SetClientActive;\n\n// Controller Messenger Events\n\nexport type SnapStateChange = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [SnapControllerState, Patch[]];\n};\n\n/**\n * Emitted when an installed snap has been blocked.\n */\nexport type SnapBlocked = {\n  type: `${typeof controllerName}:snapBlocked`;\n  payload: [snapId: string, blockedSnapInfo?: BlockReason];\n};\n\n/**\n * Emitted when a snap installation or update is started.\n */\nexport type SnapInstallStarted = {\n  type: `${typeof controllerName}:snapInstallStarted`;\n  payload: [snapId: SnapId, origin: string, isUpdate: boolean];\n};\n\n/**\n * Emitted when a snap installation or update failed.\n */\nexport type SnapInstallFailed = {\n  type: `${typeof controllerName}:snapInstallFailed`;\n  payload: [snapId: SnapId, origin: string, isUpdate: boolean, error: string];\n};\n\n/**\n * Emitted when a snap has been started after being added and authorized during\n * installation.\n */\nexport type SnapInstalled = {\n  type: `${typeof controllerName}:snapInstalled`;\n  payload: [snap: TruncatedSnap, origin: string, preinstalled: boolean];\n};\n\n/**\n * Emitted when a snap that has previously been fully installed, is uninstalled.\n */\nexport type SnapUninstalled = {\n  type: `${typeof controllerName}:snapUninstalled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when an installed snap has been unblocked.\n */\nexport type SnapUnblocked = {\n  type: `${typeof controllerName}:snapUnblocked`;\n  payload: [snapId: string];\n};\n\n/**\n * Emitted when a snap is updated.\n */\nexport type SnapUpdated = {\n  type: `${typeof controllerName}:snapUpdated`;\n  payload: [\n    snap: TruncatedSnap,\n    oldVersion: string,\n    origin: string,\n    preinstalled: boolean,\n  ];\n};\n\n/**\n * Emitted when a snap is rolled back.\n */\nexport type SnapRolledback = {\n  type: `${typeof controllerName}:snapRolledback`;\n  payload: [snap: TruncatedSnap, failedVersion: string];\n};\n\n/**\n * Emitted when a Snap is terminated. This is different from the snap being\n * stopped as it can also be triggered when a snap fails initialization.\n */\nexport type SnapTerminated = {\n  type: `${typeof controllerName}:snapTerminated`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when a Snap is enabled by a user.\n * This is not emitted by default when installing a snap.\n */\nexport type SnapEnabled = {\n  type: `${typeof controllerName}:snapEnabled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when a Snap is disabled by a user.\n */\nexport type SnapDisabled = {\n  type: `${typeof controllerName}:snapDisabled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when there is a state change.\n */\nexport type SnapControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  SnapControllerState\n>;\n\ntype KeyringControllerLock = {\n  type: 'KeyringController:lock';\n  payload: [];\n};\n\nexport type SnapControllerEvents =\n  | SnapBlocked\n  | SnapInstalled\n  | SnapUninstalled\n  | SnapInstallStarted\n  | SnapInstallFailed\n  | SnapStateChange\n  | SnapUnblocked\n  | SnapUpdated\n  | SnapRolledback\n  | SnapTerminated\n  | SnapEnabled\n  | SnapDisabled\n  | SnapControllerStateChangeEvent;\n\ntype NetworkControllerGetNetworkClientById = {\n  type: `NetworkController:getNetworkClientById`;\n  handler: (customNetworkClientId: string) => {\n    configuration: {\n      chainId: Hex;\n    };\n  };\n};\n\ntype SelectedNetworkControllerGetNetworkClientIdForDomain = {\n  type: `SelectedNetworkController:getNetworkClientIdForDomain`;\n  handler: (domain: string) => string;\n};\n\nexport type AllowedActions =\n  | GetEndowments\n  | GetPermissions\n  | GetSubjects\n  | GetSubjectMetadata\n  | AddSubjectMetadata\n  | HasPermission\n  | HasPermissions\n  | RevokePermissions\n  | RevokeAllPermissions\n  | RevokePermissionForAllSubjects\n  | GrantPermissions\n  | AddApprovalRequest\n  | HandleRpcRequestAction\n  | ExecuteSnapAction\n  | TerminateSnapAction\n  | UpdateCaveat\n  | UpdateRequestState\n  | GetResult\n  | GetMetadata\n  | Update\n  | ResolveVersion\n  | CreateInterface\n  | GetInterface\n  | NetworkControllerGetNetworkClientById\n  | SelectedNetworkControllerGetNetworkClientIdForDomain;\n\nexport type AllowedEvents =\n  | ExecutionServiceEvents\n  | SnapInstalled\n  | SnapUpdated\n  | KeyringControllerLock;\n\ntype SnapControllerMessenger = Messenger<\n  typeof controllerName,\n  SnapControllerActions | AllowedActions,\n  SnapControllerEvents | AllowedEvents\n>;\n\ntype FeatureFlags = {\n  requireAllowlist?: boolean;\n  allowLocalSnaps?: boolean;\n  disableSnapInstallation?: boolean;\n  rejectInvalidPlatformVersion?: boolean;\n\n  /**\n   * Force any local Snap to be treated as a preinstalled Snap.\n   *\n   * This should only be used for local testing, and should not be enabled in\n   * any production builds (including beta and Flask).\n   */\n  forcePreinstalledSnaps?: boolean;\n\n  /**\n   * Automatically update preinstalled Snaps \"over the air\",\n   * when a new version of the Snap is added to the registry.\n   */\n  autoUpdatePreinstalledSnaps?: boolean;\n};\n\ntype DynamicFeatureFlags = {\n  disableSnaps?: boolean;\n};\n\ntype SnapControllerArgs = {\n  /**\n   * A teardown function that allows the host to clean up its instrumentation\n   * for a running snap.\n   */\n  closeAllConnections?: CloseAllConnectionsFunction;\n\n  /**\n   * A list of permissions that are allowed to be dynamic, meaning they can be revoked from the snap whenever.\n   */\n  dynamicPermissions?: string[];\n\n  /**\n   * The names of endowment permissions whose values are the names of JavaScript\n   * APIs that will be added to the snap execution environment at runtime.\n   */\n  environmentEndowmentPermissions?: string[];\n\n  /**\n   * Excluded permissions with its associated error message used to forbid certain permissions.\n   */\n  excludedPermissions?: Record<string, string>;\n\n  /**\n   * The function that will be used by the controller fo make network requests.\n   * Should be compatible with {@link fetch}.\n   */\n  fetchFunction?: typeof fetch;\n\n  /**\n   * Flags that enable or disable features in the controller.\n   * See {@link FeatureFlags}.\n   */\n  featureFlags: FeatureFlags;\n\n  /**\n   * How frequently to check whether a snap is idle.\n   */\n  idleTimeCheckInterval?: number;\n\n  /**\n   * The maximum amount of time that a snap may be idle.\n   */\n  maxIdleTime?: number;\n\n  /**\n   * The controller messenger.\n   */\n  messenger: SnapControllerMessenger;\n\n  /**\n   * The maximum amount of time a snap may take to process an RPC request,\n   * unless it is permitted to take longer.\n   */\n  maxRequestTime?: number;\n\n  /**\n   * The npm registry URL that will be used to fetch published snaps.\n   */\n  npmRegistryUrl?: string;\n\n  /**\n   * Persisted state that will be used for rehydration.\n   */\n  state?: PersistedSnapControllerState;\n\n  /**\n   * A function that takes Snap Id and converts it into a class that fetches files.\n   *\n   * Used for test overrides.\n   */\n  detectSnapLocation?: typeof detectSnapLocation;\n\n  /**\n   * A list of snaps to be preinstalled into the SnapController state on initialization.\n   */\n  preinstalledSnaps?: PreinstalledSnap[] | null;\n\n  /**\n   * A utility object containing functions required for state encryption.\n   */\n  encryptor: ExportableKeyEncryptor;\n\n  /**\n   * A hook to access the mnemonic seed of the user's primary keyring.\n   *\n   * @returns The mnemonic seed as bytes.\n   */\n  getMnemonicSeed: () => Promise<Uint8Array>;\n\n  /**\n   * A hook to get dynamic feature flags at runtime.\n   *\n   * @returns The feature flags.\n   */\n  getFeatureFlags: () => DynamicFeatureFlags;\n\n  /**\n   * The cryptographic functions to use for the client. This may be an empty\n   * object to fall back to the default cryptographic functions.\n   */\n  clientCryptography?: CryptographicFunctions;\n\n  /**\n   * MetaMetrics event tracking hook.\n   */\n  trackEvent: TrackEventHook;\n};\n\ntype AddSnapArgs = {\n  id: SnapId;\n  origin: string;\n  location: SnapLocation;\n  versionRange: SemVerRange;\n};\n\n// When we set a snap, we need all required properties to be present and\n// validated.\ntype SetSnapArgs = Omit<AddSnapArgs, 'location' | 'versionRange'> & {\n  files: FetchedSnapFiles;\n  isUpdate?: boolean;\n  removable?: boolean;\n  preinstalled?: boolean;\n  hidden?: boolean;\n  hideSnapBranding?: boolean;\n};\n\ntype TrackingEventPayload = {\n  event: string;\n  category: string;\n  properties: Record<string, Json | undefined>;\n};\n\ntype TrackEventHook = (event: TrackingEventPayload) => void;\n\nconst defaultState: SnapControllerState = {\n  snaps: {},\n  snapStates: {},\n  unencryptedSnapStates: {},\n};\n\n/**\n * Truncates the properties of a snap to only ones that are easily serializable.\n *\n * @param snap - The snap to truncate.\n * @returns Object with serializable snap properties.\n */\nfunction truncateSnap(snap: Snap): TruncatedSnap {\n  const truncatedSnap = Object.keys(snap).reduce<Partial<TruncatedSnap>>(\n    (serialized, key) => {\n      if (TRUNCATED_SNAP_PROPERTIES.has(key as any)) {\n        serialized[key as keyof TruncatedSnap] = snap[\n          key as keyof TruncatedSnap\n        ] as any;\n      }\n\n      return serialized;\n    },\n    {},\n  );\n\n  return truncatedSnap as TruncatedSnap;\n}\n\n/*\n * A snap is initialized in three phases:\n * - Add: Loads the snap from a remote source and parses it.\n * - Authorize: Requests the snap's required permissions from the user.\n * - Start: Initializes the snap in its SES realm with the authorized permissions.\n */\n\nexport class SnapController extends BaseController<\n  typeof controllerName,\n  SnapControllerState,\n  SnapControllerMessenger\n> {\n  readonly #closeAllConnections?: CloseAllConnectionsFunction;\n\n  readonly #dynamicPermissions: string[];\n\n  readonly #environmentEndowmentPermissions: string[];\n\n  readonly #excludedPermissions: Record<string, string>;\n\n  readonly #featureFlags: FeatureFlags;\n\n  readonly #fetchFunction: typeof fetch;\n\n  readonly #idleTimeCheckInterval: number;\n\n  readonly #maxIdleTime: number;\n\n  // This property cannot be hash private yet because of tests.\n  // eslint-disable-next-line no-restricted-syntax\n  private readonly maxRequestTime: number;\n\n  readonly #encryptor: ExportableKeyEncryptor;\n\n  readonly #getMnemonicSeed: () => Promise<Uint8Array>;\n\n  readonly #getFeatureFlags: () => DynamicFeatureFlags;\n\n  readonly #clientCryptography: CryptographicFunctions | undefined;\n\n  readonly #detectSnapLocation: typeof detectSnapLocation;\n\n  readonly #snapsRuntimeData: Map<SnapId, SnapRuntimeData>;\n\n  readonly #rollbackSnapshots: Map<string, RollbackSnapshot>;\n\n  #timeoutForLastRequestStatus?: number;\n\n  #statusMachine!: StateMachine.Machine<\n    StatusContext,\n    StatusEvents,\n    StatusStates\n  >;\n\n  readonly #preinstalledSnaps: PreinstalledSnap[] | null;\n\n  readonly #trackEvent: TrackEventHook;\n\n  readonly #trackSnapExport: ReturnType<typeof throttleTracking>;\n\n  constructor({\n    closeAllConnections,\n    messenger,\n    state,\n    dynamicPermissions = ['eth_accounts'],\n    environmentEndowmentPermissions = [],\n    excludedPermissions = {},\n    idleTimeCheckInterval = inMilliseconds(5, Duration.Second),\n    maxIdleTime = inMilliseconds(30, Duration.Second),\n    maxRequestTime = inMilliseconds(60, Duration.Second),\n    fetchFunction = globalThis.fetch.bind(undefined),\n    featureFlags = {},\n    detectSnapLocation: detectSnapLocationFunction = detectSnapLocation,\n    preinstalledSnaps = null,\n    encryptor,\n    getMnemonicSeed,\n    getFeatureFlags = () => ({}),\n    clientCryptography,\n    trackEvent,\n  }: SnapControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        snapStates: {\n          includeInStateLogs: false,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: false,\n        },\n        unencryptedSnapStates: {\n          includeInStateLogs: false,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: false,\n        },\n        snaps: {\n          includeInStateLogs: (snaps) => {\n            // Delete larger snap properties\n            return Object.values(snaps).reduce<Record<SnapId, Partial<Snap>>>(\n              (acc, snap) => {\n                const snapCopy: Partial<Snap> = { ...snap };\n                delete snapCopy.sourceCode;\n                delete snapCopy.auxiliaryFiles;\n                acc[snap.id] = snapCopy;\n                return acc;\n              },\n              {},\n            );\n          },\n          persist: (snaps) => {\n            return (\n              Object.values(snaps)\n                // We should not persist snaps that are in the installing state,\n                // since they haven't completed installation and would be unusable\n                .filter((snap) => snap.status !== SnapStatus.Installing)\n                .map((snap) => {\n                  return {\n                    ...snap,\n                    // At the time state is rehydrated, no snap will be running.\n                    status: SnapStatus.Stopped,\n                  };\n                })\n                .reduce((memo: Record<SnapId, Snap>, snap) => {\n                  memo[snap.id] = snap;\n                  return memo;\n                }, {})\n            );\n          },\n          includeInDebugSnapshot: false,\n          // TODO: Ensure larger snap properties are not sent to the UI\n          // Currently these are stripped out manually in the extension\n          usedInUi: true,\n        },\n      },\n      name: controllerName,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n\n    this.#closeAllConnections = closeAllConnections;\n    this.#dynamicPermissions = dynamicPermissions;\n    this.#environmentEndowmentPermissions = environmentEndowmentPermissions;\n    this.#excludedPermissions = excludedPermissions;\n    this.#featureFlags = featureFlags;\n    this.#fetchFunction = fetchFunction;\n    this.#idleTimeCheckInterval = idleTimeCheckInterval;\n    this.#maxIdleTime = maxIdleTime;\n    this.maxRequestTime = maxRequestTime;\n    this.#detectSnapLocation = detectSnapLocationFunction;\n    this.#encryptor = encryptor;\n    this.#getMnemonicSeed = getMnemonicSeed;\n    this.#getFeatureFlags = getFeatureFlags;\n    this.#clientCryptography = clientCryptography;\n    this.#preinstalledSnaps = preinstalledSnaps;\n    this._onUnhandledSnapError = this._onUnhandledSnapError.bind(this);\n    this._onOutboundRequest = this._onOutboundRequest.bind(this);\n    this._onOutboundResponse = this._onOutboundResponse.bind(this);\n    this.#rollbackSnapshots = new Map();\n    this.#snapsRuntimeData = new Map();\n    this.#trackEvent = trackEvent;\n\n    this.#pollForLastRequestStatus();\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messenger.subscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messenger.subscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messenger.subscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n    this.messenger.subscribe(\n      'SnapController:snapInstalled',\n      ({ id }, origin) => {\n        this.#callLifecycleHook(origin, id, HandlerType.OnInstall).catch(\n          (error) => {\n            logError(\n              `Error when calling \\`onInstall\\` lifecycle hook for snap \"${id}\": ${getErrorMessage(\n                error,\n              )}`,\n            );\n          },\n        );\n      },\n    );\n\n    this.messenger.subscribe(\n      'SnapController:snapUpdated',\n      ({ id }, _oldVersion, origin) => {\n        this.#callLifecycleHook(origin, id, HandlerType.OnUpdate).catch(\n          (error) => {\n            logError(\n              `Error when calling \\`onUpdate\\` lifecycle hook for snap \"${id}\": ${getErrorMessage(\n                error,\n              )}`,\n            );\n          },\n        );\n      },\n    );\n\n    this.messenger.subscribe(\n      'KeyringController:lock',\n      this.#handleLock.bind(this),\n    );\n\n    this.#initializeStateMachine();\n    this.#registerMessageHandlers();\n\n    Object.values(this.state?.snaps ?? {}).forEach((snap) =>\n      this.#setupRuntime(snap.id),\n    );\n\n    if (this.#preinstalledSnaps) {\n      this.#handlePreinstalledSnaps(this.#preinstalledSnaps);\n    }\n\n    this.#trackSnapExport = throttleTracking(\n      (snapId: SnapId, handler: string, success: boolean, origin: string) => {\n        const snapMetadata = this.messenger.call(\n          'SnapsRegistry:getMetadata',\n          snapId,\n        );\n        this.#trackEvent({\n          event: 'Snap Export Used',\n          category: 'Snaps',\n          properties: {\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            snap_id: snapId,\n            export: handler,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            snap_category: snapMetadata?.category,\n            success,\n            origin,\n          },\n        });\n      },\n    );\n  }\n\n  /**\n   * We track status of a Snap using a finite-state-machine.\n   * It keeps track of whether the snap is started / stopped / etc.\n   *\n   * @see {@link SnapController.transition} for interacting with the machine.\n   */\n  // We initialize the machine in the instance because the status is currently tightly coupled\n  // with the SnapController - the guard checks for enabled status inside the SnapController state.\n  // In the future, side-effects could be added to the machine during transitions.\n  #initializeStateMachine() {\n    const disableGuard = ({ snapId }: StatusContext) => {\n      return this.getExpect(snapId).enabled;\n    };\n\n    const statusConfig: StateMachine.Config<\n      StatusContext,\n      StatusEvents,\n      StatusStates\n    > = {\n      initial: SnapStatus.Installing,\n      states: {\n        [SnapStatus.Installing]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n          },\n        },\n        [SnapStatus.Updating]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Stop]: SnapStatus.Stopped,\n          },\n        },\n        [SnapStatus.Running]: {\n          on: {\n            [SnapStatusEvents.Stop]: SnapStatus.Stopped,\n            [SnapStatusEvents.Crash]: SnapStatus.Crashed,\n          },\n        },\n        [SnapStatus.Stopped]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Update]: SnapStatus.Updating,\n          },\n        },\n        [SnapStatus.Crashed]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Update]: SnapStatus.Updating,\n          },\n        },\n      },\n    };\n    this.#statusMachine = createMachine(statusConfig);\n    validateMachine(this.#statusMachine);\n  }\n\n  /**\n   * Constructor helper for registering the controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers(): void {\n    this.messenger.registerActionHandler(`${controllerName}:init`, (...args) =>\n      this.init(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:clearSnapState`,\n      (...args) => this.clearSnapState(...args),\n    );\n\n    this.messenger.registerActionHandler(`${controllerName}:get`, (...args) =>\n      this.get(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:getSnapState`,\n      async (...args) => this.getSnapState(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:handleRequest`,\n      async (...args) => this.handleRequest(...args),\n    );\n\n    this.messenger.registerActionHandler(`${controllerName}:has`, (...args) =>\n      this.has(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:updateRegistry`,\n      async () => this.updateRegistry(),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:updateSnapState`,\n      async (...args) => this.updateSnapState(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:enable`,\n      (...args) => this.enableSnap(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:disable`,\n      async (...args) => this.disableSnap(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:remove`,\n      async (...args) => this.removeSnap(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:getPermitted`,\n      (...args) => this.getPermittedSnaps(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:install`,\n      async (...args) => this.installSnaps(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:getAll`,\n      (...args) => this.getAllSnaps(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:getRunnableSnaps`,\n      (...args) => this.getRunnableSnaps(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:incrementActiveReferences`,\n      (...args) => this.incrementActiveReferences(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:decrementActiveReferences`,\n      (...args) => this.decrementActiveReferences(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:disconnectOrigin`,\n      (...args) => this.removeSnapFromSubject(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:revokeDynamicPermissions`,\n      (...args) => this.revokeDynamicSnapPermissions(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:getFile`,\n      async (...args) => this.getSnapFile(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:stopAllSnaps`,\n      async (...args) => this.stopAllSnaps(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:isMinimumPlatformVersion`,\n      (...args) => this.isMinimumPlatformVersion(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:setClientActive`,\n      (...args) => this.setClientActive(...args),\n    );\n  }\n\n  /**\n   * Initialise the SnapController.\n   *\n   * Currently this method calls the `onStart` lifecycle hook for all\n   * runnable Snaps.\n   */\n  init() {\n    this.#callLifecycleHooks(METAMASK_ORIGIN, HandlerType.OnStart);\n  }\n\n  #handlePreinstalledSnaps(preinstalledSnaps: PreinstalledSnap[]) {\n    for (const {\n      snapId,\n      manifest,\n      files,\n      removable,\n      hidden,\n      hideSnapBranding,\n    } of preinstalledSnaps) {\n      const existingSnap = this.get(snapId);\n      const isAlreadyInstalled = existingSnap !== undefined;\n      const isUpdate =\n        isAlreadyInstalled && gtVersion(manifest.version, existingSnap.version);\n\n      // Disallow downgrades and overwriting non preinstalled snaps\n      if (\n        isAlreadyInstalled &&\n        (!isUpdate || existingSnap.preinstalled !== true)\n      ) {\n        continue;\n      }\n\n      const manifestFile = new VirtualFile<SnapManifest>({\n        path: NpmSnapFileNames.Manifest,\n        value: JSON.stringify(manifest),\n        result: manifest,\n      });\n\n      const virtualFiles = files.map(\n        ({ path, value }) => new VirtualFile({ value, path }),\n      );\n      const { filePath, iconPath } = manifest.source.location.npm;\n      const sourceCode = virtualFiles.find((file) => file.path === filePath);\n      const svgIcon = iconPath\n        ? virtualFiles.find((file) => file.path === iconPath)\n        : undefined;\n\n      assert(sourceCode, 'Source code not provided for preinstalled snap.');\n\n      assert(\n        !iconPath || (iconPath && svgIcon),\n        'Icon not provided for preinstalled snap.',\n      );\n\n      assert(\n        manifest.source.files === undefined,\n        'Auxiliary files are not currently supported for preinstalled snaps.',\n      );\n\n      const localizationFiles =\n        manifest.source.locales?.map((path) =>\n          virtualFiles.find((file) => file.path === path),\n        ) ?? [];\n\n      const validatedLocalizationFiles = getValidatedLocalizationFiles(\n        localizationFiles.filter(Boolean) as VirtualFile[],\n      );\n\n      assert(\n        localizationFiles.length === validatedLocalizationFiles.length,\n        'Missing localization files for preinstalled snap.',\n      );\n\n      const filesObject: FetchedSnapFiles = {\n        manifest: manifestFile,\n        sourceCode,\n        svgIcon,\n        auxiliaryFiles: [],\n        localizationFiles: validatedLocalizationFiles,\n      };\n\n      // Add snap to the SnapController state\n      this.#set({\n        id: snapId,\n        origin: METAMASK_ORIGIN,\n        files: filesObject,\n        removable,\n        hidden,\n        hideSnapBranding,\n        preinstalled: true,\n      });\n\n      // Setup permissions\n      const processedPermissions = processSnapPermissions(\n        manifest.initialPermissions,\n      );\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      const { newPermissions, unusedPermissions } =\n        this.#calculatePermissionsChange(snapId, processedPermissions);\n\n      this.#updatePermissions({ snapId, newPermissions, unusedPermissions });\n\n      if (manifest.initialConnections) {\n        this.#handleInitialConnections(\n          snapId,\n          existingSnap?.initialConnections ?? null,\n          manifest.initialConnections,\n        );\n      }\n\n      // Set status\n      this.update((state) => {\n        state.snaps[snapId].status = SnapStatus.Stopped;\n      });\n\n      this.#setupRuntime(snapId);\n\n      // Emit events\n      if (isUpdate) {\n        this.messenger.publish(\n          'SnapController:snapUpdated',\n          this.getTruncatedExpect(snapId),\n          existingSnap.version,\n          METAMASK_ORIGIN,\n          true,\n        );\n      } else {\n        this.messenger.publish(\n          'SnapController:snapInstalled',\n          this.getTruncatedExpect(snapId),\n          METAMASK_ORIGIN,\n          true,\n        );\n      }\n    }\n  }\n\n  #pollForLastRequestStatus() {\n    this.#timeoutForLastRequestStatus = setTimeout(() => {\n      this.#stopSnapsLastRequestPastMax().catch((error) => {\n        // TODO: Decide how to handle errors.\n        logError(error);\n      });\n\n      this.#pollForLastRequestStatus();\n    }, this.#idleTimeCheckInterval) as unknown as number;\n  }\n\n  /**\n   * Checks all installed snaps against the block list and\n   * blocks/unblocks snaps as appropriate. See {@link SnapController.blockSnap}\n   * for more information.\n   *\n   * Also updates any preinstalled Snaps to the latest allowlisted version.\n   */\n  async updateRegistry(): Promise<void> {\n    this.#assertCanUsePlatform();\n    await this.messenger.call('SnapsRegistry:update');\n\n    const blockedSnaps = await this.messenger.call(\n      'SnapsRegistry:get',\n      Object.values(this.state.snaps).reduce<SnapsRegistryRequest>(\n        (blockListArg, snap) => {\n          blockListArg[snap.id] = {\n            version: snap.version,\n            checksum: snap.manifest.source.shasum,\n          };\n          return blockListArg;\n        },\n        {},\n      ),\n    );\n\n    await Promise.all(\n      Object.entries(blockedSnaps).map(async ([snapId, { status, reason }]) => {\n        if (status === SnapsRegistryStatus.Blocked) {\n          return this.#blockSnap(snapId as SnapId, reason);\n        }\n\n        return this.#unblockSnap(snapId as SnapId);\n      }),\n    );\n\n    if (!this.#featureFlags.autoUpdatePreinstalledSnaps) {\n      return;\n    }\n\n    const preinstalledVersionRange = '*' as SemVerRange;\n\n    await Promise.allSettled(\n      Object.values(this.state.snaps)\n        .filter((snap) => snap.preinstalled)\n        .map(async (snap) => {\n          const resolvedVersion = await this.#resolveAllowlistVersion(\n            snap.id,\n            preinstalledVersionRange,\n          );\n\n          if (\n            resolvedVersion !== preinstalledVersionRange &&\n            gtVersion(resolvedVersion as unknown as SemVerVersion, snap.version)\n          ) {\n            const location = this.#detectSnapLocation(snap.id, {\n              versionRange: resolvedVersion,\n              fetch: this.#fetchFunction,\n              allowLocal: false,\n            });\n\n            await this.#updateSnap({\n              origin: ORIGIN_METAMASK,\n              snapId: snap.id,\n              location,\n              versionRange: resolvedVersion,\n              automaticUpdate: true,\n            });\n          }\n        }),\n    );\n  }\n\n  /**\n   * Blocks an installed snap and prevents it from being started again. Emits\n   * {@link SnapBlocked}. Does nothing if the snap is not installed.\n   *\n   * @param snapId - The snap to block.\n   * @param blockedSnapInfo - Information detailing why the snap is blocked.\n   */\n  async #blockSnap(\n    snapId: SnapId,\n    blockedSnapInfo?: BlockReason,\n  ): Promise<void> {\n    if (!this.has(snapId)) {\n      return;\n    }\n\n    try {\n      this.update((state: any) => {\n        state.snaps[snapId].blocked = true;\n        state.snaps[snapId].blockInformation = blockedSnapInfo;\n      });\n\n      await this.disableSnap(snapId);\n    } catch (error) {\n      logError(\n        `Encountered error when stopping blocked snap \"${snapId}\".`,\n        error,\n      );\n    }\n\n    this.messenger.publish(\n      `${controllerName}:snapBlocked`,\n      snapId,\n      blockedSnapInfo,\n    );\n  }\n\n  /**\n   * Unblocks a snap so that it can be enabled and started again. Emits\n   * {@link SnapUnblocked}. Does nothing if the snap is not installed or already\n   * unblocked.\n   *\n   * @param snapId - The id of the snap to unblock.\n   */\n  #unblockSnap(snapId: SnapId) {\n    if (!this.has(snapId) || !this.state.snaps[snapId].blocked) {\n      return;\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].blocked = false;\n      delete state.snaps[snapId].blockInformation;\n    });\n\n    this.messenger.publish(`${controllerName}:snapUnblocked`, snapId);\n  }\n\n  async #assertIsInstallAllowed(\n    snapId: SnapId,\n    {\n      platformVersion,\n      ...snapInfo\n    }: SnapsRegistryInfo & {\n      permissions: SnapPermissions;\n      platformVersion: string | undefined;\n    },\n  ) {\n    const results = await this.messenger.call('SnapsRegistry:get', {\n      [snapId]: snapInfo,\n    });\n\n    const result = results[snapId];\n    if (result.status === SnapsRegistryStatus.Blocked) {\n      throw new Error(\n        `Cannot install version \"${\n          snapInfo.version\n        }\" of snap \"${snapId}\": The version is blocked. ${\n          result.reason?.explanation ?? ''\n        }`,\n      );\n    }\n\n    const isAllowlistingRequired = Object.keys(snapInfo.permissions).some(\n      (permission) => !ALLOWED_PERMISSIONS.includes(permission),\n    );\n\n    if (\n      this.#featureFlags.requireAllowlist &&\n      isAllowlistingRequired &&\n      result.status !== SnapsRegistryStatus.Verified\n    ) {\n      throw new Error(\n        `Cannot install version \"${snapInfo.version}\" of snap \"${snapId}\": ${\n          result.status === SnapsRegistryStatus.Unavailable\n            ? 'The registry is temporarily unavailable.'\n            : 'The snap is not on the allowlist.'\n        }`,\n      );\n    }\n\n    this.#validatePlatformVersion(snapId, platformVersion);\n  }\n\n  /**\n   * Asserts whether new Snaps are allowed to be installed.\n   */\n  #assertCanInstallSnaps() {\n    assert(\n      this.#featureFlags.disableSnapInstallation !== true,\n      'Installing Snaps is currently disabled in this version of MetaMask.',\n    );\n  }\n\n  /**\n   * Asserts whether the Snaps platform is allowed to run.\n   */\n  #assertCanUsePlatform() {\n    const flags = this.#getFeatureFlags();\n    assert(\n      flags.disableSnaps !== true,\n      'The Snaps platform requires basic functionality to be used. Enable basic functionality in the settings to use the Snaps platform.',\n    );\n  }\n\n  async #stopSnapsLastRequestPastMax() {\n    const entries = [...this.#snapsRuntimeData.entries()];\n    return Promise.all(\n      entries\n        .filter(\n          ([_snapId, runtime]) =>\n            runtime.activeReferences === 0 &&\n            runtime.pendingInboundRequests.length === 0 &&\n            runtime.lastRequest &&\n            this.#maxIdleTime &&\n            timeSince(runtime.lastRequest) > this.#maxIdleTime,\n        )\n        .map(async ([snapId]) => this.stopSnap(snapId, SnapStatusEvents.Stop)),\n    );\n  }\n\n  _onUnhandledSnapError(snapId: string, error: SnapErrorJson) {\n    // Log the error that caused the crash\n    // so it gets raised to the developer for debugging purposes.\n    logError(`Unhandled error from \"${snapId}\":`, error);\n    this.stopSnap(snapId as SnapId, SnapStatusEvents.Crash).catch(\n      (stopSnapError) => {\n        // TODO: Decide how to handle errors.\n        logError(stopSnapError);\n      },\n    );\n  }\n\n  _onOutboundRequest(snapId: string) {\n    const runtime = this.#getRuntimeExpect(snapId as SnapId);\n    // Ideally we would only pause the pending request that is making the outbound request\n    // but right now we don't have a way to know which request initiated the outbound request\n    runtime.pendingInboundRequests\n      .filter((pendingRequest) => pendingRequest.timer.status === 'running')\n      .forEach((pendingRequest) => pendingRequest.timer.pause());\n    runtime.pendingOutboundRequests += 1;\n  }\n\n  _onOutboundResponse(snapId: string) {\n    const runtime = this.#getRuntimeExpect(snapId as SnapId);\n    runtime.pendingOutboundRequests -= 1;\n    if (runtime.pendingOutboundRequests === 0) {\n      runtime.pendingInboundRequests\n        .filter((pendingRequest) => pendingRequest.timer.status === 'paused')\n        .forEach((pendingRequest) => pendingRequest.timer.resume());\n    }\n  }\n\n  /**\n   * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out\n   * the next state. This transition function uses a very minimal subset of XState conventions:\n   * - supports initial state\n   * - .on supports raw event target string\n   * - .on supports {target, cond} object\n   * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event,\n   * context) => boolean`\n   *\n   * @param snapId - The id of the snap to transition.\n   * @param event - The event enum to use to transition.\n   */\n  #transition(snapId: SnapId, event: StatusEvents | StatusEvents['type']) {\n    const { interpreter } = this.#getRuntimeExpect(snapId);\n    interpreter.send(event);\n    this.update((state: any) => {\n      state.snaps[snapId].status = interpreter.state.value;\n    });\n  }\n\n  /**\n   * Starts the given snap. Throws an error if no such snap exists\n   * or if it is already running.\n   *\n   * @param snapId - The id of the Snap to start.\n   */\n  async startSnap(snapId: SnapId): Promise<void> {\n    this.#assertCanUsePlatform();\n    const snap = this.state.snaps[snapId];\n\n    if (!snap.enabled) {\n      throw new Error(`Snap \"${snapId}\" is disabled.`);\n    }\n\n    await this.#startSnap({\n      snapId,\n      sourceCode: snap.sourceCode,\n    });\n  }\n\n  /**\n   * Enables the given snap. A snap can only be started if it is enabled. A snap\n   * can only be enabled if it isn't blocked.\n   *\n   * @param snapId - The id of the Snap to enable.\n   */\n  enableSnap(snapId: SnapId): void {\n    this.getExpect(snapId);\n\n    if (this.state.snaps[snapId].blocked) {\n      throw new Error(`Snap \"${snapId}\" is blocked and cannot be enabled.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = true;\n    });\n\n    this.messenger.publish(\n      'SnapController:snapEnabled',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Disables the given snap. A snap can only be started if it is enabled.\n   *\n   * @param snapId - The id of the Snap to disable.\n   * @returns A promise that resolves once the snap has been disabled.\n   */\n  async disableSnap(snapId: SnapId): Promise<void> {\n    if (!this.has(snapId)) {\n      throw new Error(`Snap \"${snapId}\" not found.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = false;\n    });\n\n    if (this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    this.messenger.publish(\n      'SnapController:snapDisabled',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Stops the given snap, removes all hooks, closes all connections, and\n   * terminates its worker.\n   *\n   * @param snapId - The id of the Snap to stop.\n   * @param statusEvent - The Snap status event that caused the snap to be\n   * stopped.\n   */\n  public async stopSnap(\n    snapId: SnapId,\n    statusEvent:\n      | SnapStatusEvents.Stop\n      | SnapStatusEvents.Crash = SnapStatusEvents.Stop,\n  ): Promise<void> {\n    const runtime = this.#getRuntime(snapId);\n    if (!runtime) {\n      throw new Error(`The snap \"${snapId}\" is not running.`);\n    }\n\n    // If we are already stopping, wait for that to finish.\n    if (runtime.stopPromise) {\n      await runtime.stopPromise;\n      return;\n    }\n\n    // Flag that the Snap is actively stopping, this prevents other calls to stopSnap\n    // while we are handling termination of the Snap\n    const { promise, resolve } = createDeferredPromise();\n    runtime.stopPromise = promise;\n\n    try {\n      if (this.isRunning(snapId)) {\n        this.#closeAllConnections?.(snapId);\n        await this.#terminateSnap(snapId);\n      }\n    } finally {\n      // Reset request tracking\n      runtime.lastRequest = null;\n      runtime.pendingInboundRequests = [];\n      runtime.pendingOutboundRequests = 0;\n      runtime.stopPromise = null;\n      if (this.isRunning(snapId)) {\n        this.#transition(snapId, statusEvent);\n      }\n      resolve();\n    }\n  }\n\n  /**\n   * Stops all running snaps, removes all hooks, closes all connections, and\n   * terminates their workers.\n   *\n   * @param statusEvent - The Snap status event that caused the snap to be\n   * stopped.\n   */\n  public async stopAllSnaps(\n    statusEvent:\n      | SnapStatusEvents.Stop\n      | SnapStatusEvents.Crash = SnapStatusEvents.Stop,\n  ): Promise<void> {\n    const snaps = Object.values(this.state.snaps).filter((snap) =>\n      this.isRunning(snap.id),\n    );\n    const promises = snaps.map(async (snap) =>\n      this.stopSnap(snap.id, statusEvent),\n    );\n    await Promise.allSettled(promises);\n  }\n\n  /**\n   * Terminates the specified snap and emits the `snapTerminated` event.\n   *\n   * @param snapId - The snap to terminate.\n   */\n  async #terminateSnap(snapId: SnapId) {\n    await this.messenger.call('ExecutionService:terminateSnap', snapId);\n\n    // Hack to give up execution for a bit to let gracefully terminating Snaps return.\n    await new Promise((resolve) => setTimeout(resolve, 1));\n\n    const runtime = this.#getRuntimeExpect(snapId);\n    // Unresponsive requests may still be timed, time them out.\n    runtime.pendingInboundRequests\n      .filter((pendingRequest) => pendingRequest.timer.status !== 'finished')\n      .forEach((pendingRequest) => pendingRequest.timer.finish());\n\n    // Hack to give up execution for a bit to let timed out requests return.\n    await new Promise((resolve) => setTimeout(resolve, 1));\n\n    this.messenger.publish(\n      'SnapController:snapTerminated',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Returns whether the given snap is running.\n   * Throws an error if the snap doesn't exist.\n   *\n   * @param snapId - The id of the Snap to check.\n   * @returns `true` if the snap is running, otherwise `false`.\n   */\n  isRunning(snapId: SnapId): boolean {\n    return this.getExpect(snapId).status === 'running';\n  }\n\n  /**\n   * Returns whether the given snap has been added to state.\n   *\n   * @param snapId - The id of the Snap to check for.\n   * @returns `true` if the snap exists in the controller state, otherwise `false`.\n   */\n  has(snapId: SnapId): boolean {\n    return Boolean(this.get(snapId));\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, including all data.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns The entire snap object from the controller state.\n   */\n  get(snapId: string): Snap | undefined {\n    return this.state.snaps[snapId as SnapId];\n  }\n\n  /**\n   * Gets the snap with the given id, throws if doesn't.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @see {@link SnapController.get}\n   * @throws {@link Error}. If the snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns The entire snap object.\n   */\n  getExpect(snapId: SnapId): Snap {\n    const snap = this.get(snapId);\n    assert(snap !== undefined, `Snap \"${snapId}\" not found.`);\n    return snap;\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, excluding any\n   * non-serializable or expensive-to-serialize data.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  // TODO(ritave): this.get returns undefined, this.getTruncated returns null\n  getTruncated(snapId: SnapId): TruncatedSnap | null {\n    const snap = this.get(snapId);\n\n    return snap ? truncateSnap(snap) : null;\n  }\n\n  /**\n   * Gets the snap with the given id, throw if it doesn't exist.\n   *\n   * @throws {@link Error}. If snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  getTruncatedExpect(snapId: SnapId): TruncatedSnap {\n    return truncateSnap(this.getExpect(snapId));\n  }\n\n  /**\n   * Check if a given Snap has a cached encryption key stored in the runtime.\n   *\n   * @param snapId - The Snap ID.\n   * @param runtime - The Snap runtime data.\n   * @returns True if the Snap has a cached encryption key, otherwise false.\n   */\n  #hasCachedEncryptionKey(\n    snapId: SnapId,\n    runtime = this.#getRuntimeExpect(snapId),\n  ): runtime is SnapRuntimeData & {\n    encryptionKey: string;\n    encryptionSalt: string;\n  } {\n    return runtime.encryptionKey !== null && runtime.encryptionSalt !== null;\n  }\n\n  /**\n   * Generate an encryption key to be used for state encryption for a given Snap.\n   *\n   * @param options - An options bag.\n   * @param options.snapId - The Snap ID.\n   * @param options.salt - A salt to be used for the encryption key.\n   * @param options.useCache - Whether to use caching or not.\n   * @param options.keyMetadata - Optional metadata about how to derive the encryption key.\n   * @returns An encryption key.\n   */\n  async #getSnapEncryptionKey({\n    snapId,\n    salt: passedSalt,\n    useCache,\n    keyMetadata,\n  }: {\n    snapId: SnapId;\n    salt?: string;\n    useCache: boolean;\n    keyMetadata?: KeyDerivationOptions;\n  }): Promise<{ key: unknown; salt: string }> {\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (this.#hasCachedEncryptionKey(snapId, runtime) && useCache) {\n      return {\n        key: await this.#encryptor.importKey(runtime.encryptionKey),\n        salt: runtime.encryptionSalt,\n      };\n    }\n\n    const salt = passedSalt ?? this.#encryptor.generateSalt();\n    const seed = await this.#getMnemonicSeed();\n\n    const entropy = await getEncryptionEntropy({\n      snapId,\n      seed,\n      cryptographicFunctions: this.#clientCryptography,\n    });\n\n    const encryptionKey = await this.#encryptor.keyFromPassword(\n      entropy,\n      salt,\n      true,\n      keyMetadata,\n    );\n    const exportedKey = await this.#encryptor.exportKey(encryptionKey);\n\n    // Cache exported encryption key in runtime\n    if (useCache) {\n      runtime.encryptionKey = exportedKey;\n      runtime.encryptionSalt = salt;\n    }\n    return { key: encryptionKey, salt };\n  }\n\n  /**\n   * Decrypt the encrypted state for a given Snap.\n   *\n   * @param snapId - The Snap ID.\n   * @param state - The encrypted state as a string.\n   * @returns A valid JSON object derived from the encrypted state.\n   * @throws If the decryption fails or the decrypted state is not valid JSON.\n   */\n  async #decryptSnapState(snapId: SnapId, state: string) {\n    try {\n      // We assume that the state string here is valid JSON since we control serialization.\n      // This lets us skip JSON validation.\n      const parsed = JSON.parse(state) as EncryptionResult;\n      const { salt, keyMetadata } = parsed;\n\n      // We only cache encryption keys if they are already cached or if the encryption key is using the latest key derivation params.\n      const useCache =\n        this.#hasCachedEncryptionKey(snapId) ||\n        this.#encryptor.isVaultUpdated(state);\n\n      const { key } = await this.#getSnapEncryptionKey({\n        snapId,\n        salt,\n        useCache,\n        // When decrypting state we expect key metadata to be present.\n        // If it isn't present, we assume that the Snap state we are decrypting is old enough to use the legacy encryption params.\n        keyMetadata: keyMetadata ?? LEGACY_ENCRYPTION_KEY_DERIVATION_OPTIONS,\n      });\n      const decryptedState = await this.#encryptor.decryptWithKey(key, parsed);\n\n      // We assume this to be valid JSON, since all RPC requests from a Snap are validated and sanitized.\n      return decryptedState as Record<string, Json>;\n    } catch {\n      throw rpcErrors.internal({\n        message: 'Failed to decrypt snap state, the state must be corrupted.',\n      });\n    }\n  }\n\n  /**\n   * Encrypt a JSON state object for a given Snap.\n   *\n   * Note: This function does not assert the validity of the object,\n   * please ensure only valid JSON is passed to it.\n   *\n   * @param snapId - The Snap ID.\n   * @param state - The state object.\n   * @returns A string containing the encrypted JSON object.\n   */\n  async #encryptSnapState(snapId: SnapId, state: Record<string, Json>) {\n    const { key, salt } = await this.#getSnapEncryptionKey({\n      snapId,\n      useCache: true,\n    });\n    const encryptedState = await this.#encryptor.encryptWithKey(key, state);\n\n    encryptedState.salt = salt;\n    return JSON.stringify(encryptedState);\n  }\n\n  /**\n   * Get the new Snap state to persist based on the given state and encryption\n   * flag.\n   *\n   * - If the state is null, return null.\n   * - If the state should be encrypted, return the encrypted state.\n   * - Otherwise, if the state should not be encrypted, return the JSON-\n   * stringified state.\n   *\n   * @param snapId - The Snap ID.\n   * @param state - The state to persist.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or\n   * not.\n   * @returns The state to persist.\n   */\n  async #getStateToPersist(\n    snapId: SnapId,\n    state: Record<string, Json> | null,\n    encrypted: boolean,\n  ) {\n    if (state === null) {\n      return null;\n    }\n\n    if (encrypted) {\n      return await this.#encryptSnapState(snapId, state);\n    }\n\n    return JSON.stringify(state);\n  }\n\n  /**\n   * Persist the state of a Snap.\n   *\n   * This function is debounced per Snap, meaning that multiple calls to this\n   * function for the same Snap will only result in one state update. It also\n   * uses a mutex to ensure that only one state update per Snap is processed at\n   * a time, avoiding possible race conditions.\n   *\n   * @param snapId - The Snap ID.\n   * @param newSnapState - The new state of the Snap.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or\n   * not.\n   */\n  readonly #persistSnapState = debouncePersistState(\n    (\n      snapId: SnapId,\n      newSnapState: Record<string, Json> | null,\n      encrypted: boolean,\n    ) => {\n      const runtime = this.#getRuntimeExpect(snapId);\n      runtime.stateMutex\n        .runExclusive(async () => {\n          const newState = await this.#getStateToPersist(\n            snapId,\n            newSnapState,\n            encrypted,\n          );\n\n          if (encrypted) {\n            return this.update((state) => {\n              state.snapStates[snapId] = newState;\n            });\n          }\n\n          return this.update((state) => {\n            state.unencryptedSnapStates[snapId] = newState;\n          });\n        })\n        .catch(logError);\n    },\n    STATE_DEBOUNCE_TIMEOUT,\n  );\n\n  /**\n   * Updates the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be updated.\n   * @param newSnapState - The new state of the snap.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   */\n  async updateSnapState(\n    snapId: SnapId,\n    newSnapState: Record<string, Json>,\n    encrypted: boolean,\n  ) {\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (encrypted) {\n      runtime.state = newSnapState;\n    } else {\n      runtime.unencryptedState = newSnapState;\n    }\n\n    this.#persistSnapState(snapId, newSnapState, encrypted);\n  }\n\n  /**\n   * Clears the state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be cleared.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   */\n  clearSnapState(snapId: SnapId, encrypted: boolean) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    if (encrypted) {\n      runtime.state = null;\n    } else {\n      runtime.unencryptedState = null;\n    }\n\n    this.#persistSnapState(snapId, null, encrypted);\n  }\n\n  /**\n   * Gets the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state to get.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   * @returns The requested snap state or null if no state exists.\n   */\n  async getSnapState(snapId: SnapId, encrypted: boolean): Promise<Json> {\n    const runtime = this.#getRuntimeExpect(snapId);\n    return await runtime.getStateMutex.runExclusive(async () => {\n      const cachedState = encrypted ? runtime.state : runtime.unencryptedState;\n\n      if (cachedState !== undefined) {\n        return cachedState;\n      }\n\n      const state = encrypted\n        ? this.state.snapStates[snapId]\n        : this.state.unencryptedSnapStates[snapId];\n\n      if (state === null || state === undefined) {\n        return null;\n      }\n\n      if (!encrypted) {\n        // For performance reasons, we do not validate that the state is JSON,\n        // since we control serialization.\n        const json = JSON.parse(state);\n        runtime.unencryptedState = json;\n\n        return json;\n      }\n\n      const decrypted = await this.#decryptSnapState(snapId, state);\n      // eslint-disable-next-line require-atomic-updates\n      runtime.state = decrypted;\n\n      return decrypted;\n    });\n  }\n\n  /**\n   * Gets a static auxiliary snap file in a chosen file encoding.\n   *\n   * @param snapId - The id of the Snap whose state to get.\n   * @param path - The path to the requested file.\n   * @param encoding - An optional requested file encoding.\n   * @returns The file requested in the chosen file encoding or null if the file is not found.\n   */\n  async getSnapFile(\n    snapId: SnapId,\n    path: string,\n    encoding: AuxiliaryFileEncoding = AuxiliaryFileEncoding.Base64,\n  ): Promise<string | null> {\n    const snap = this.getExpect(snapId);\n    const normalizedPath = normalizeRelative(path);\n    const value = snap.auxiliaryFiles?.find(\n      (file) => file.path === normalizedPath,\n    )?.value;\n\n    if (!value) {\n      return null;\n    }\n\n    const encoded = await encodeAuxiliaryFile(value, encoding);\n\n    assert(\n      encoded.length < MAX_FILE_SIZE,\n      `Failed to encode static file to \"${encoding}\": Static files must be less than 64 MB when encoded.`,\n    );\n\n    return encoded;\n  }\n\n  /**\n   * Determine if a given Snap ID supports a given minimum version of the Snaps platform\n   * by inspecting the platformVersion in the Snap manifest.\n   *\n   * @param snapId - The Snap ID.\n   * @param version - The version.\n   * @returns True if the platform version is equal or greater to the passed version, false otherwise.\n   */\n  isMinimumPlatformVersion(snapId: SnapId, version: SemVerVersion): boolean {\n    const snap = this.getExpect(snapId);\n\n    const { platformVersion } = snap.manifest;\n\n    if (!platformVersion) {\n      return false;\n    }\n\n    return gte(platformVersion, version);\n  }\n\n  /**\n   * Completely clear the controller's state: delete all associated data,\n   * handlers, event listeners, and permissions; tear down all snap providers.\n   */\n  async clearState() {\n    const snapIds = Object.keys(this.state.snaps);\n\n    await this.stopAllSnaps();\n    snapIds.forEach((snapId) => this.#revokeAllSnapPermissions(snapId));\n\n    this.update((state) => {\n      state.snaps = {};\n      state.snapStates = {};\n      state.unencryptedSnapStates = {};\n    });\n\n    this.#snapsRuntimeData.clear();\n    this.#rollbackSnapshots.clear();\n\n    // We want to remove all snaps & permissions, except for preinstalled snaps\n    if (this.#preinstalledSnaps) {\n      this.#handlePreinstalledSnaps(this.#preinstalledSnaps);\n    }\n  }\n\n  /**\n   * Removes the given snap from state, and clears all associated handlers\n   * and listeners.\n   *\n   * @param snapId - The id of the Snap.\n   * @returns A promise that resolves once the snap has been removed.\n   */\n  async removeSnap(snapId: SnapId): Promise<void> {\n    return this.removeSnaps([snapId]);\n  }\n\n  /**\n   * Stops the given snaps, removes them from state, and clears all associated\n   * permissions, handlers, and listeners.\n   *\n   * @param snapIds - The ids of the Snaps.\n   */\n  async removeSnaps(snapIds: SnapId[]): Promise<void> {\n    if (!Array.isArray(snapIds)) {\n      throw new Error('Expected array of snap ids.');\n    }\n\n    snapIds.forEach((snapId) => {\n      const snap = this.getExpect(snapId);\n      assert(snap.removable !== false, `${snapId} is not removable.`);\n    });\n\n    await Promise.all(\n      snapIds.map(async (snapId) => {\n        const snap = this.getExpect(snapId);\n        const truncated = this.getTruncatedExpect(snapId);\n        // Disable the snap and revoke all of its permissions before deleting\n        // it. This ensures that the snap will not be restarted or otherwise\n        // affect the host environment while we are deleting it.\n        await this.disableSnap(snapId);\n        this.#revokeAllSnapPermissions(snapId);\n\n        this.#removeSnapFromSubjects(snapId);\n\n        this.#snapsRuntimeData.delete(snapId);\n\n        this.update((state: any) => {\n          delete state.snaps[snapId];\n          delete state.snapStates[snapId];\n          delete state.unencryptedSnapStates[snapId];\n        });\n\n        // If the snap has been fully installed before, also emit snapUninstalled.\n        if (snap.status !== SnapStatus.Installing) {\n          this.messenger.publish(`SnapController:snapUninstalled`, truncated);\n        }\n      }),\n    );\n  }\n\n  #handleInitialConnections(\n    snapId: SnapId,\n    previousInitialConnections: InitialConnections | null,\n    initialConnections: InitialConnections,\n  ) {\n    if (previousInitialConnections) {\n      const revokedInitialConnections = setDiff(\n        previousInitialConnections,\n        initialConnections,\n      );\n\n      for (const origin of Object.keys(revokedInitialConnections)) {\n        this.removeSnapFromSubject(origin, snapId);\n      }\n    }\n\n    for (const origin of Object.keys(initialConnections)) {\n      this.#addSnapToSubject(origin, snapId);\n    }\n  }\n\n  #addSnapToSubject(origin: string, snapId: SnapId) {\n    const subjectPermissions = this.messenger.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const existingCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds);\n\n    const subjectHasSnap = Boolean(\n      (existingCaveat?.value as Record<string, Json>)?.[snapId],\n    );\n\n    // If the subject is already connected to the snap, this is a no-op.\n    if (subjectHasSnap) {\n      return;\n    }\n\n    // If an existing caveat exists, we add the snap to that.\n    if (existingCaveat) {\n      this.messenger.call(\n        'PermissionController:updateCaveat',\n        origin,\n        WALLET_SNAP_PERMISSION_KEY,\n        SnapCaveatType.SnapIds,\n        { ...(existingCaveat.value as Record<string, Json>), [snapId]: {} },\n      );\n      return;\n    }\n\n    const approvedPermissions = {\n      [WALLET_SNAP_PERMISSION_KEY]: {\n        caveats: [\n          {\n            type: SnapCaveatType.SnapIds,\n            value: {\n              [snapId]: {},\n            },\n          },\n        ],\n      },\n    } as RequestedPermissions;\n\n    this.messenger.call('PermissionController:grantPermissions', {\n      approvedPermissions,\n      subject: { origin },\n    });\n  }\n\n  /**\n   * Removes a snap's permission (caveat) from the specified subject.\n   *\n   * @param origin - The origin from which to remove the snap.\n   * @param snapId - The id of the snap to remove.\n   */\n  removeSnapFromSubject(origin: string, snapId: SnapId) {\n    const subjectPermissions = this.messenger.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const snapIdsCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds) as\n      | Caveat<string, Json>\n      | undefined;\n\n    if (!snapIdsCaveat) {\n      return;\n    }\n\n    const caveatHasSnap = Boolean(\n      (snapIdsCaveat.value as Record<string, Json>)?.[snapId],\n    );\n    if (caveatHasSnap) {\n      const newCaveatValue = {\n        ...(snapIdsCaveat.value as Record<string, Json>),\n      };\n      delete newCaveatValue[snapId];\n      if (Object.keys(newCaveatValue).length > 0) {\n        this.messenger.call(\n          'PermissionController:updateCaveat',\n          origin,\n          WALLET_SNAP_PERMISSION_KEY,\n          SnapCaveatType.SnapIds,\n          newCaveatValue,\n        );\n      } else {\n        this.messenger.call('PermissionController:revokePermissions', {\n          [origin]: [WALLET_SNAP_PERMISSION_KEY],\n        });\n      }\n    }\n  }\n\n  /**\n   * Checks if a list of permissions are dynamic and allowed to be revoked, if they are they will all be revoked.\n   *\n   * @param snapId - The snap ID.\n   * @param permissionNames - The names of the permissions.\n   * @throws If non-dynamic permissions are passed.\n   */\n  revokeDynamicSnapPermissions(\n    snapId: string,\n    permissionNames: NonEmptyArray<string>,\n  ) {\n    assert(\n      permissionNames.every((permissionName) =>\n        this.#dynamicPermissions.includes(permissionName),\n      ),\n      'Non-dynamic permissions cannot be revoked',\n    );\n    this.messenger.call('PermissionController:revokePermissions', {\n      [snapId]: permissionNames,\n    });\n  }\n\n  /**\n   * Removes a snap's permission (caveat) from all subjects.\n   *\n   * @param snapId - The id of the Snap.\n   */\n  #removeSnapFromSubjects(snapId: SnapId) {\n    const subjects = this.messenger.call(\n      'PermissionController:getSubjectNames',\n    );\n    for (const subject of subjects) {\n      this.removeSnapFromSubject(subject, snapId);\n    }\n  }\n\n  /**\n   * Safely revokes all permissions granted to a Snap.\n   *\n   * @param snapId - The snap ID.\n   */\n  #revokeAllSnapPermissions(snapId: string) {\n    if (this.messenger.call('PermissionController:hasPermissions', snapId)) {\n      this.messenger.call('PermissionController:revokeAllPermissions', snapId);\n    }\n  }\n\n  /**\n   * Handles incrementing the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced.\n   */\n  incrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.activeReferences += 1;\n  }\n\n  /**\n   * Handles decrement the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced..\n   */\n  decrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    assert(\n      runtime.activeReferences > 0,\n      'SnapController reference management is in an invalid state.',\n    );\n    runtime.activeReferences -= 1;\n  }\n\n  /**\n   * Gets all snaps in their truncated format.\n   *\n   * @returns All installed snaps in their truncated format.\n   */\n  getAllSnaps(): TruncatedSnap[] {\n    return Object.values(this.state.snaps).map(truncateSnap);\n  }\n\n  /**\n   * Gets all runnable snaps.\n   *\n   * @returns All runnable snaps.\n   */\n  getRunnableSnaps(): TruncatedSnap[] {\n    return getRunnableSnaps(this.getAllSnaps());\n  }\n\n  /**\n   * Gets the serialized permitted snaps of the given origin, if any.\n   *\n   * @param origin - The origin whose permitted snaps to retrieve.\n   * @returns The serialized permitted snaps for the origin.\n   */\n  getPermittedSnaps(origin: string): RequestSnapsResult {\n    const permissions =\n      this.messenger.call('PermissionController:getPermissions', origin) ?? {};\n    const snaps =\n      permissions[WALLET_SNAP_PERMISSION_KEY]?.caveats?.find(\n        (caveat) => caveat.type === SnapCaveatType.SnapIds,\n      )?.value ?? {};\n    return Object.keys(snaps).reduce<RequestSnapsResult>(\n      (permittedSnaps, snapId) => {\n        const snap = this.get(snapId);\n        const truncatedSnap = this.getTruncated(snapId as SnapId);\n\n        if (truncatedSnap && snap?.status !== SnapStatus.Installing) {\n          permittedSnaps[snapId] = truncatedSnap;\n        }\n        return permittedSnaps;\n      },\n      {},\n    );\n  }\n\n  /**\n   * Installs the snaps requested by the given origin, returning the snap\n   * object if the origin is permitted to install it, and an authorization error\n   * otherwise.\n   *\n   * @param origin - The origin that requested to install the snaps.\n   * @param requestedSnaps - The snaps to install.\n   * @returns An object of snap ids and snap objects, or errors if a\n   * snap couldn't be installed.\n   */\n  async installSnaps(\n    origin: string,\n    requestedSnaps: RequestSnapsParams,\n  ): Promise<RequestSnapsResult> {\n    this.#assertCanUsePlatform();\n\n    const result: RequestSnapsResult = {};\n\n    const snapIds = Object.keys(requestedSnaps);\n\n    const pendingUpdates = [];\n    const pendingInstalls = [];\n\n    try {\n      for (const [snapId, { version: rawVersion }] of Object.entries(\n        requestedSnaps,\n      )) {\n        assertIsValidSnapId(snapId);\n\n        const [error, version] = resolveVersionRange(rawVersion);\n\n        if (error) {\n          throw rpcErrors.invalidParams(\n            `The \"version\" field must be a valid SemVer version range if specified. Received: \"${\n              rawVersion as string\n            }\".`,\n          );\n        }\n\n        const location = this.#detectSnapLocation(snapId, {\n          versionRange: version,\n          fetch: this.#fetchFunction,\n          allowLocal: this.#featureFlags.allowLocalSnaps,\n          resolveVersion: async (range) =>\n            this.#featureFlags.requireAllowlist\n              ? await this.#resolveAllowlistVersion(snapId, range)\n              : range,\n        });\n\n        // Existing snaps may need to be updated, unless they should be re-installed (e.g. local snaps)\n        // Everything else is treated as an install\n        const isUpdate = this.has(snapId) && !location.shouldAlwaysReload;\n\n        if (isUpdate && this.#isValidUpdate(snapId, version)) {\n          const existingSnap = this.getExpect(snapId);\n          pendingUpdates.push({ snapId, oldVersion: existingSnap.version });\n          let rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n          if (rollbackSnapshot === undefined) {\n            rollbackSnapshot = this.#createRollbackSnapshot(snapId);\n            rollbackSnapshot.newVersion = version;\n          } else {\n            throw new Error('This snap is already being updated.');\n          }\n        } else if (!isUpdate) {\n          pendingInstalls.push(snapId);\n        }\n\n        result[snapId] = await this.#processRequestedSnap(\n          origin,\n          snapId,\n          location,\n          version,\n        );\n      }\n\n      // Once we finish all installs / updates, emit events.\n      pendingInstalls.forEach((snapId) =>\n        this.messenger.publish(\n          `SnapController:snapInstalled`,\n          this.getTruncatedExpect(snapId),\n          origin,\n          false,\n        ),\n      );\n\n      pendingUpdates.forEach(({ snapId, oldVersion }) =>\n        this.messenger.publish(\n          `SnapController:snapUpdated`,\n          this.getTruncatedExpect(snapId),\n          oldVersion,\n          origin,\n          false,\n        ),\n      );\n\n      snapIds.forEach((snapId) => this.#rollbackSnapshots.delete(snapId));\n    } catch (error) {\n      const installed = pendingInstalls.filter((snapId) => this.has(snapId));\n      await this.removeSnaps(installed);\n      const snapshottedSnaps = [...this.#rollbackSnapshots.keys()];\n      const snapsToRollback = pendingUpdates\n        .map(({ snapId }) => snapId)\n        .filter((snapId) => snapshottedSnaps.includes(snapId));\n      await this.#rollbackSnaps(snapsToRollback);\n\n      throw error;\n    }\n\n    return result;\n  }\n\n  /**\n   * Adds, authorizes, and runs the given snap with a snap provider.\n   * Results from this method should be efficiently serializable.\n   *\n   * @param origin - The origin requesting the snap.\n   * @param snapId - The id of the snap.\n   * @param location - The location implementation of the snap.\n   * @param versionRange - The semver range of the snap to install.\n   * @returns The resulting snap object, or an error if something went wrong.\n   */\n  async #processRequestedSnap(\n    origin: string,\n    snapId: SnapId,\n    location: SnapLocation,\n    versionRange: SemVerRange,\n  ): Promise<TruncatedSnap> {\n    const existingSnap = this.getTruncated(snapId);\n\n    // For devX we always re-install local snaps.\n    if (existingSnap && !location.shouldAlwaysReload) {\n      if (satisfiesVersionRange(existingSnap.version, versionRange)) {\n        return existingSnap;\n      }\n\n      return await this.#updateSnap({\n        origin,\n        snapId,\n        location,\n        versionRange,\n      });\n    }\n\n    this.#assertCanInstallSnaps();\n\n    let pendingApproval = this.#createApproval({\n      origin,\n      snapId,\n      type: SNAP_APPROVAL_INSTALL,\n    });\n\n    this.messenger.publish(\n      'SnapController:snapInstallStarted',\n      snapId,\n      origin,\n      false,\n    );\n\n    // Existing snaps must be stopped before overwriting\n    if (existingSnap && this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    // Existing snaps that should be re-installed should not maintain their existing permissions\n    if (existingSnap && location.shouldAlwaysReload) {\n      this.#revokeAllSnapPermissions(snapId);\n    }\n\n    try {\n      const { sourceCode } = await this.#add({\n        origin,\n        id: snapId,\n        location,\n        versionRange,\n      });\n\n      await this.#authorize(snapId, pendingApproval);\n\n      pendingApproval = this.#createApproval({\n        origin,\n        snapId,\n        type: SNAP_APPROVAL_RESULT,\n      });\n\n      await this.#startSnap({\n        snapId,\n        sourceCode,\n      });\n\n      const truncated = this.getTruncatedExpect(snapId);\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        type: SNAP_APPROVAL_INSTALL,\n      });\n\n      return truncated;\n    } catch (error) {\n      logError(`Error when adding ${snapId}.`, error);\n\n      const errorString =\n        error instanceof Error ? error.message : error.toString();\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        type: SNAP_APPROVAL_INSTALL,\n        error: errorString,\n      });\n\n      this.messenger.publish(\n        'SnapController:snapInstallFailed',\n        snapId,\n        origin,\n        false,\n        errorString,\n      );\n\n      throw error;\n    }\n  }\n\n  #createApproval({\n    origin,\n    snapId,\n    type,\n  }: {\n    origin: string;\n    snapId: SnapId;\n    type: string;\n  }): PendingApproval {\n    const id = nanoid();\n    const promise = this.messenger.call(\n      'ApprovalController:addRequest',\n      {\n        origin,\n        id,\n        type,\n        requestData: {\n          // Mirror previous installation metadata\n          metadata: { id, origin: snapId, dappOrigin: origin },\n          snapId,\n        },\n        requestState: {\n          loading: true,\n        },\n      },\n      true,\n    );\n\n    return { id, promise };\n  }\n\n  #updateApproval(id: string, requestState: Record<string, Json>) {\n    try {\n      this.messenger.call('ApprovalController:updateRequestState', {\n        id,\n        requestState,\n      });\n    } catch {\n      // Do nothing\n    }\n  }\n\n  /**\n   * Updates an installed snap. The flow is similar to\n   * {@link SnapController.installSnaps}. The user will be asked if they want\n   * to update, then approve any permission changes, and finally the snap will\n   * be restarted.\n   *\n   * The update will fail if the user rejects any prompt or if the new version\n   * of the snap is blocked.\n   *\n   * If the original version of the snap was blocked and the update succeeded,\n   * the snap will be unblocked and enabled before it is restarted.\n   *\n   * @param options - An options bag.\n   * @param options.origin - The origin requesting the snap update.\n   * @param options.snapId - The id of the Snap to be updated.\n   * @param options.location - The location implementation of the snap.\n   * @param options.versionRange - A semver version range in which the maximum version will be chosen.\n   * @param options.automaticUpdate - An optional boolean flag to indicate whether this update should be done\n   * automatically.\n   * @returns The snap metadata if updated, `null` otherwise.\n   */\n  async #updateSnap({\n    origin,\n    snapId,\n    location,\n    versionRange,\n    automaticUpdate = false,\n  }: {\n    origin: string;\n    snapId: SnapId;\n    location: SnapLocation;\n    versionRange: SemVerRange;\n    automaticUpdate?: boolean;\n  }): Promise<TruncatedSnap> {\n    this.#assertCanInstallSnaps();\n    this.#assertCanUsePlatform();\n\n    const snap = this.getExpect(snapId);\n\n    const { preinstalled, removable, hidden, hideSnapBranding } = snap;\n\n    if (preinstalled && !automaticUpdate) {\n      throw new Error('Preinstalled Snaps cannot be manually updated.');\n    }\n\n    let pendingApproval = automaticUpdate\n      ? null\n      : this.#createApproval({\n          origin,\n          snapId,\n          type: SNAP_APPROVAL_UPDATE,\n        });\n\n    try {\n      this.messenger.publish(\n        'SnapController:snapInstallStarted',\n        snapId,\n        origin,\n        true,\n      );\n\n      const oldManifest = snap.manifest;\n\n      const newSnap = await fetchSnap(snapId, location);\n      const { sourceCode: sourceCodeFile, manifest: manifestFile } = newSnap;\n\n      const manifest = manifestFile.result;\n\n      const newVersion = manifest.version;\n      if (!gtVersion(newVersion, snap.version)) {\n        throw rpcErrors.invalidParams(\n          `Snap \"${snapId}@${snap.version}\" is already installed. Couldn't update to a version inside requested \"${versionRange}\" range.`,\n        );\n      }\n\n      if (!satisfiesVersionRange(newVersion, versionRange)) {\n        throw new Error(\n          `Version mismatch. Manifest for \"${snapId}\" specifies version \"${newVersion}\" which doesn't satisfy requested version range \"${versionRange}\".`,\n        );\n      }\n\n      await this.#assertIsInstallAllowed(snapId, {\n        version: newVersion,\n        checksum: manifest.source.shasum,\n        permissions: manifest.initialPermissions,\n        platformVersion: manifest.platformVersion,\n      });\n\n      const processedPermissions = processSnapPermissions(\n        manifest.initialPermissions,\n      );\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      const { newPermissions, unusedPermissions, approvedPermissions } =\n        this.#calculatePermissionsChange(snapId, processedPermissions);\n\n      const { newConnections, unusedConnections, approvedConnections } =\n        this.#calculateConnectionsChange(\n          snapId,\n          oldManifest.initialConnections ?? {},\n          manifest.initialConnections ?? {},\n        );\n\n      let approvedNewPermissions;\n      let requestData;\n\n      if (pendingApproval) {\n        this.#updateApproval(pendingApproval.id, {\n          permissions: newPermissions,\n          newVersion: manifest.version,\n          newPermissions,\n          approvedPermissions,\n          unusedPermissions,\n          newConnections,\n          unusedConnections,\n          approvedConnections,\n          loading: false,\n        });\n\n        const { permissions, ...rest } =\n          (await pendingApproval.promise) as PermissionsRequest;\n\n        approvedNewPermissions = permissions;\n        requestData = rest;\n\n        pendingApproval = this.#createApproval({\n          origin,\n          snapId,\n          type: SNAP_APPROVAL_RESULT,\n        });\n      } else {\n        assert(automaticUpdate);\n        approvedNewPermissions = newPermissions;\n      }\n\n      if (this.isRunning(snapId)) {\n        await this.stopSnap(snapId, SnapStatusEvents.Stop);\n      }\n\n      this.#transition(snapId, SnapStatusEvents.Update);\n\n      this.#set({\n        origin,\n        id: snapId,\n        files: newSnap,\n        removable,\n        preinstalled,\n        hidden,\n        hideSnapBranding,\n        isUpdate: true,\n      });\n\n      this.#updatePermissions({\n        snapId,\n        unusedPermissions,\n        newPermissions: approvedNewPermissions,\n        requestData,\n      });\n\n      const previousInitialConnections = oldManifest.initialConnections ?? null;\n      const newInitialConnections = manifest.initialConnections ?? {};\n      this.#handleInitialConnections(\n        snapId,\n        previousInitialConnections,\n        newInitialConnections,\n      );\n\n      const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n      if (rollbackSnapshot !== undefined) {\n        rollbackSnapshot.permissions.revoked = unusedPermissions;\n        rollbackSnapshot.permissions.granted = approvedNewPermissions;\n        rollbackSnapshot.permissions.requestData = requestData;\n        rollbackSnapshot.previousInitialConnections =\n          previousInitialConnections;\n        rollbackSnapshot.newInitialConnections = newInitialConnections;\n      }\n\n      const sourceCode = sourceCodeFile.toString();\n\n      assert(\n        typeof sourceCode === 'string' && sourceCode.length > 0,\n        `Invalid source code for snap \"${snapId}\".`,\n      );\n\n      try {\n        await this.#startSnap({ snapId, sourceCode });\n      } catch {\n        throw new Error(`Snap ${snapId} crashed with updated source code.`);\n      }\n\n      const truncatedSnap = this.getTruncatedExpect(snapId);\n\n      if (pendingApproval) {\n        this.#updateApproval(pendingApproval.id, {\n          loading: false,\n          type: SNAP_APPROVAL_UPDATE,\n        });\n      }\n\n      return truncatedSnap;\n    } catch (error) {\n      logError(`Error when updating ${snapId},`, error);\n\n      const errorString =\n        error instanceof Error ? error.message : error.toString();\n\n      if (pendingApproval) {\n        this.#updateApproval(pendingApproval.id, {\n          loading: false,\n          error: errorString,\n          type: SNAP_APPROVAL_UPDATE,\n        });\n      }\n\n      this.messenger.publish(\n        'SnapController:snapInstallFailed',\n        snapId,\n        origin,\n        true,\n        errorString,\n      );\n\n      throw error;\n    }\n  }\n\n  async #resolveAllowlistVersion(\n    snapId: SnapId,\n    versionRange: SemVerRange,\n  ): Promise<SemVerRange> {\n    return await this.messenger.call(\n      'SnapsRegistry:resolveVersion',\n      snapId,\n      versionRange,\n    );\n  }\n\n  /**\n   * Returns a promise representing the complete installation of the requested snap.\n   * If the snap is already being installed, the previously pending promise will be returned.\n   *\n   * @param args - Object containing the snap id and either the URL of the snap's manifest,\n   * or the snap's manifest and source code. The object may also optionally contain a target\n   * version.\n   * @returns The resulting snap object.\n   */\n  async #add(args: AddSnapArgs): Promise<PersistedSnap> {\n    const { id: snapId, location, versionRange } = args;\n\n    this.#setupRuntime(snapId);\n    const runtime = this.#getRuntimeExpect(snapId);\n    if (!runtime.installPromise) {\n      log(`Adding snap: ${snapId}`);\n\n      // If fetching and setting the snap succeeds, this property will be set\n      // to null in the authorize() method.\n      runtime.installPromise = (async () => {\n        const fetchedSnap = await fetchSnap(snapId, location);\n        const manifest = fetchedSnap.manifest.result;\n        if (!satisfiesVersionRange(manifest.version, versionRange)) {\n          throw new Error(\n            `Version mismatch. Manifest for \"${snapId}\" specifies version \"${manifest.version}\" which doesn't satisfy requested version range \"${versionRange}\".`,\n          );\n        }\n\n        await this.#assertIsInstallAllowed(snapId, {\n          version: manifest.version,\n          checksum: manifest.source.shasum,\n          permissions: manifest.initialPermissions,\n          platformVersion: manifest.platformVersion,\n        });\n\n        const preinstalledArgs =\n          this.#featureFlags.forcePreinstalledSnaps && isLocalSnapId(snapId)\n            ? {\n                preinstalled: true,\n                hideSnapBranding: true,\n                hidden: false,\n              }\n            : {};\n\n        return this.#set({\n          ...args,\n          files: fetchedSnap,\n          id: snapId,\n          ...preinstalledArgs,\n        });\n      })();\n    }\n\n    try {\n      return await runtime.installPromise;\n    } catch (error) {\n      // Reset promise so users can retry installation in case the problem is\n      // temporary.\n      runtime.installPromise = null;\n      throw error;\n    }\n  }\n\n  async #startSnap(snapData: { snapId: SnapId; sourceCode: string }) {\n    const { snapId } = snapData;\n    if (this.isRunning(snapId)) {\n      throw new Error(`Snap \"${snapId}\" is already started.`);\n    }\n\n    try {\n      const runtime = this.#getRuntimeExpect(snapId);\n      const result = await this.messenger.call('ExecutionService:executeSnap', {\n        ...snapData,\n        endowments: await this.#getEndowments(snapId),\n      });\n\n      this.#transition(snapId, SnapStatusEvents.Start);\n      // We treat the initialization of the snap as the first request, for idle timing purposes.\n      runtime.lastRequest = Date.now();\n      return result;\n    } catch (error) {\n      await this.#terminateSnap(snapId);\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the names of all endowments that will be added to the Snap's\n   * Compartment when it executes. These should be the names of global\n   * JavaScript APIs accessible in the root realm of the execution environment.\n   *\n   * Throws an error if the endowment getter for a permission returns a truthy\n   * value that is not an array of strings.\n   *\n   * @param snapId - The id of the snap whose SES endowments to get.\n   * @returns An array of the names of the endowments.\n   */\n  async #getEndowments(snapId: string): Promise<string[]> {\n    let allEndowments: string[] = [];\n\n    for (const permissionName of this.#environmentEndowmentPermissions) {\n      if (\n        this.messenger.call(\n          'PermissionController:hasPermission',\n          snapId,\n          permissionName,\n        )\n      ) {\n        const endowments = await this.messenger.call(\n          'PermissionController:getEndowments',\n          snapId,\n          permissionName,\n        );\n\n        if (endowments) {\n          // We don't have any guarantees about the type of the endowments\n          // value, so we have to guard at runtime.\n          if (\n            !Array.isArray(endowments) ||\n            endowments.some((value) => typeof value !== 'string')\n          ) {\n            throw new Error('Expected an array of string endowment names.');\n          }\n\n          allEndowments = allEndowments.concat(endowments as string[]);\n        }\n      }\n    }\n\n    const dedupedEndowments = [\n      ...new Set([...DEFAULT_ENDOWMENTS, ...allEndowments]),\n    ];\n\n    if (\n      dedupedEndowments.length <\n      DEFAULT_ENDOWMENTS.length + allEndowments.length\n    ) {\n      logError(\n        `Duplicate endowments found for ${snapId}. Default endowments should not be requested.`,\n        allEndowments,\n      );\n    }\n    return dedupedEndowments;\n  }\n\n  /**\n   * Sets a snap in state. Called when a snap is installed or updated. Performs\n   * various validation checks on the received arguments, and will throw if\n   * validation fails.\n   *\n   * The snap will be enabled and unblocked by the time this method returns,\n   * regardless of its previous state.\n   *\n   * See {@link SnapController.add} and {@link SnapController.updateSnap} for\n   * usage.\n   *\n   * @param args - The add snap args.\n   * @returns The resulting snap object.\n   */\n  #set(args: SetSnapArgs): PersistedSnap {\n    const {\n      id: snapId,\n      origin,\n      files,\n      isUpdate = false,\n      removable,\n      preinstalled,\n      hidden,\n      hideSnapBranding,\n    } = args;\n\n    const {\n      manifest,\n      sourceCode: sourceCodeFile,\n      svgIcon,\n      auxiliaryFiles: rawAuxiliaryFiles,\n      localizationFiles,\n    } = files;\n\n    assertIsSnapManifest(manifest.result);\n    const { version } = manifest.result;\n\n    const sourceCode = sourceCodeFile.toString();\n\n    assert(\n      typeof sourceCode === 'string' && sourceCode.length > 0,\n      `Invalid source code for snap \"${snapId}\".`,\n    );\n\n    const auxiliaryFiles = rawAuxiliaryFiles.map((file) => {\n      assert(typeof file.data.base64 === 'string');\n      return {\n        path: file.path,\n        value: file.data.base64,\n      };\n    });\n\n    const snapsState = this.state.snaps;\n\n    const existingSnap = snapsState[snapId];\n\n    const previousVersionHistory = existingSnap?.versionHistory ?? [];\n    const versionHistory = [\n      ...previousVersionHistory,\n      {\n        version,\n        date: Date.now(),\n        origin,\n      },\n    ];\n\n    const localizedFiles = localizationFiles.map((file) => file.result);\n\n    const snap: Snap = {\n      // Restore relevant snap state if it exists\n      ...existingSnap,\n\n      // Note that the snap will be unblocked and enabled, regardless of its\n      // previous state.\n      blocked: false,\n      enabled: true,\n\n      removable,\n      preinstalled,\n      hidden,\n      hideSnapBranding,\n\n      id: snapId,\n      initialConnections: manifest.result.initialConnections,\n      initialPermissions: manifest.result.initialPermissions,\n      manifest: manifest.result,\n      status: this.#statusMachine.config.initial as StatusStates['value'],\n      sourceCode,\n      version,\n      versionHistory,\n      auxiliaryFiles,\n      localizationFiles: localizedFiles,\n    };\n\n    // If the snap was blocked, it isn't any longer\n    delete snap.blockInformation;\n\n    // store the snap back in state\n    const { inversePatches } = this.update((state: any) => {\n      state.snaps[snapId] = snap;\n    });\n\n    // checking for isUpdate here as this function is also used in\n    // the install flow, we do not care to create snapshots for installs\n    if (isUpdate) {\n      const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n      if (rollbackSnapshot !== undefined) {\n        rollbackSnapshot.statePatches = inversePatches;\n      }\n    }\n\n    // In case the Snap uses a localized manifest, we need to get the\n    // proposed name from the localized manifest.\n    const { proposedName } = getLocalizedSnapManifest(\n      manifest.result,\n      'en',\n      localizedFiles,\n    );\n\n    this.messenger.call('SubjectMetadataController:addSubjectMetadata', {\n      subjectType: SubjectType.Snap,\n      name: proposedName,\n      origin: snap.id,\n      version,\n      svgIcon: svgIcon?.toString() ?? null,\n    });\n\n    return { ...snap, sourceCode };\n  }\n\n  #validateSnapPermissions(\n    processedPermissions: Record<string, Pick<PermissionConstraint, 'caveats'>>,\n  ) {\n    const permissionKeys = Object.keys(processedPermissions);\n    const handlerPermissions = Array.from(\n      new Set(Object.values(handlerEndowments)),\n    );\n\n    assert(\n      permissionKeys.some((key) => handlerPermissions.includes(key)),\n      `A snap must request at least one of the following permissions: ${handlerPermissions\n        .filter((handler) => handler !== null)\n        .join(', ')}.`,\n    );\n\n    const excludedPermissionErrors = permissionKeys.reduce<string[]>(\n      (errors, permission) => {\n        if (hasProperty(this.#excludedPermissions, permission)) {\n          errors.push(this.#excludedPermissions[permission]);\n        }\n\n        return errors;\n      },\n      [],\n    );\n\n    assert(\n      excludedPermissionErrors.length === 0,\n      `One or more permissions are not allowed:\\n${excludedPermissionErrors.join(\n        '\\n',\n      )}`,\n    );\n  }\n\n  /**\n   * Validate that the platform version specified in the manifest (if any) is\n   * compatible with the current platform version.\n   *\n   * @param snapId - The ID of the Snap.\n   * @param platformVersion - The platform version to validate against.\n   * @throws If the platform version is greater than the current platform\n   * version.\n   */\n  #validatePlatformVersion(\n    snapId: SnapId,\n    platformVersion: string | undefined,\n  ) {\n    if (platformVersion === undefined) {\n      return;\n    }\n\n    if (gt(platformVersion, getPlatformVersion())) {\n      const message = `The Snap \"${snapId}\" requires platform version \"${platformVersion}\" which is greater than the current platform version \"${getPlatformVersion()}\".`;\n\n      if (this.#featureFlags.rejectInvalidPlatformVersion) {\n        throw new Error(message);\n      }\n\n      logWarning(message);\n    }\n  }\n\n  /**\n   * Initiates a request for the given snap's initial permissions.\n   * Must be called in order. See processRequestedSnap.\n   *\n   * @param snapId - The id of the Snap.\n   * @param pendingApproval - Pending approval to update.\n   * @returns The snap's approvedPermissions.\n   */\n  async #authorize(\n    snapId: SnapId,\n    pendingApproval: PendingApproval,\n  ): Promise<void> {\n    log(`Authorizing snap: ${snapId}`);\n    const snapsState = this.state.snaps;\n    const snap = snapsState[snapId];\n    const { initialPermissions, initialConnections } = snap;\n\n    try {\n      const processedPermissions = processSnapPermissions(initialPermissions);\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        connections: initialConnections ?? {},\n        permissions: processedPermissions,\n      });\n\n      const { permissions: approvedPermissions, ...requestData } =\n        (await pendingApproval.promise) as PermissionsRequest;\n\n      this.#updatePermissions({\n        snapId,\n        newPermissions: approvedPermissions,\n        requestData,\n      });\n\n      if (snap.manifest.initialConnections) {\n        this.#handleInitialConnections(\n          snapId,\n          null,\n          snap.manifest.initialConnections,\n        );\n      }\n    } finally {\n      const runtime = this.#getRuntimeExpect(snapId);\n      runtime.installPromise = null;\n    }\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this.#timeoutForLastRequestStatus) {\n      clearTimeout(this.#timeoutForLastRequestStatus);\n    }\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messenger.unsubscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messenger.unsubscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messenger.unsubscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n\n    this.messenger.clearEventSubscriptions('SnapController:snapInstalled');\n\n    this.messenger.clearEventSubscriptions('SnapController:snapUpdated');\n    /* eslint-enable @typescript-eslint/unbound-method */\n  }\n\n  /**\n   * Passes a JSON-RPC request object to the RPC handler function of a snap.\n   *\n   * @param options - A bag of options.\n   * @param options.snapId - The ID of the recipient snap.\n   * @param options.origin - The origin of the RPC request.\n   * @param options.handler - The handler to trigger on the snap for the request.\n   * @param options.request - The JSON-RPC request object.\n   * @returns The result of the JSON-RPC request.\n   */\n  async handleRequest({\n    snapId,\n    origin,\n    handler: handlerType,\n    request: rawRequest,\n  }: SnapRpcHookArgs & { snapId: SnapId }): Promise<unknown> {\n    this.#assertCanUsePlatform();\n\n    const snap = this.get(snapId);\n\n    assert(\n      snap,\n      `The Snap \"${snapId}\" is not installed. Please install it before invoking it.`,\n    );\n\n    assert(\n      origin === METAMASK_ORIGIN || isValidUrl(origin),\n      \"'origin' must be a valid URL or 'metamask'.\",\n    );\n\n    const request = {\n      jsonrpc: '2.0',\n      id: nanoid(),\n      ...rawRequest,\n    };\n\n    assertIsJsonRpcRequest(request);\n\n    const permissionName = handlerEndowments[handlerType];\n\n    assert(\n      typeof permissionName === 'string' || permissionName === null,\n      \"'permissionName' must be either a string or null.\",\n    );\n\n    const permissions = this.messenger.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n\n    // If permissionName is null, the handler does not require a permission.\n    if (\n      permissionName !== null &&\n      (!permissions || !hasProperty(permissions, permissionName))\n    ) {\n      throw new Error(\n        `Snap \"${snapId}\" is not permitted to use \"${permissionName}\".`,\n      );\n    }\n\n    const handlerPermissions = permissionName\n      ? (permissions as SubjectPermissions<PermissionConstraint>)[\n          permissionName\n        ]\n      : undefined;\n\n    if (\n      permissionName === SnapEndowments.Rpc ||\n      permissionName === SnapEndowments.Keyring\n    ) {\n      assert(handlerPermissions);\n\n      const subject = this.messenger.call(\n        'SubjectMetadataController:getSubjectMetadata',\n        origin,\n      );\n\n      const origins =\n        permissionName === SnapEndowments.Rpc\n          ? getRpcCaveatOrigins(handlerPermissions)\n          : getKeyringCaveatOrigins(handlerPermissions);\n      assert(origins);\n\n      if (\n        !isOriginAllowed(\n          origins,\n          subject?.subjectType ?? SubjectType.Website,\n          origin,\n        )\n      ) {\n        throw new Error(\n          `Snap \"${snapId}\" is not permitted to handle requests from \"${origin}\".`,\n        );\n      }\n    }\n\n    if (\n      origin !== METAMASK_ORIGIN &&\n      CLIENT_ONLY_HANDLERS.includes(handlerType)\n    ) {\n      throw new Error(`\"${handlerType}\" can only be invoked by MetaMask.`);\n    }\n\n    if (!snap.enabled) {\n      throw new Error(`Snap \"${snapId}\" is disabled.`);\n    }\n\n    if (snap.status === SnapStatus.Installing) {\n      throw new Error(\n        `Snap \"${snapId}\" is currently being installed. Please try again later.`,\n      );\n    }\n\n    const timeout = this.#getExecutionTimeout(handlerPermissions);\n\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (runtime.stopPromise) {\n      await runtime.stopPromise;\n    }\n\n    if (!this.isRunning(snapId)) {\n      if (!runtime.startPromise) {\n        runtime.startPromise = this.startSnap(snapId);\n      }\n\n      try {\n        await runtime.startPromise;\n      } finally {\n        runtime.startPromise = null;\n      }\n    }\n\n    const transformedRequest = this.#transformSnapRpcRequest(\n      snapId,\n      handlerType,\n      request,\n    );\n\n    const timer = new Timer(timeout);\n    this.#recordSnapRpcRequestStart(snapId, transformedRequest.id, timer);\n\n    const handleRpcRequestPromise = this.messenger.call(\n      'ExecutionService:handleRpcRequest',\n      snapId,\n      { origin, handler: handlerType, request: transformedRequest },\n    );\n\n    // This will either get the result or reject due to the timeout.\n    try {\n      const result = await withTimeout(handleRpcRequestPromise, timer);\n\n      if (result === hasTimedOut) {\n        const stopping =\n          runtime.stopPromise !== null || !this.isRunning(snapId);\n        throw new Error(\n          stopping\n            ? `${snapId} was stopped and the request was cancelled. This is likely because the Snap crashed.`\n            : `${snapId} failed to respond to the request in time.`,\n        );\n      }\n\n      await this.#assertSnapRpcResponse(snapId, handlerType, result);\n\n      const transformedResult = await this.#transformSnapRpcResponse(\n        snapId,\n        handlerType,\n        transformedRequest,\n        result,\n      );\n\n      this.#recordSnapRpcRequestFinish(\n        snapId,\n        transformedRequest.id,\n        handlerType,\n        origin,\n        true,\n      );\n\n      return transformedResult;\n    } catch (error) {\n      // We flag the RPC request as finished early since termination may affect pending requests\n      this.#recordSnapRpcRequestFinish(\n        snapId,\n        transformedRequest.id,\n        handlerType,\n        origin,\n        false,\n      );\n\n      const [jsonRpcError, handled] = unwrapError(error);\n\n      const stopping = runtime.stopPromise !== null || !this.isRunning(snapId);\n\n      if (!handled) {\n        if (!stopping) {\n          logError(\n            `\"${snapId}\" crashed due to an unhandled error:`,\n            jsonRpcError,\n          );\n        }\n        await this.stopSnap(snapId, SnapStatusEvents.Crash);\n      }\n\n      throw jsonRpcError;\n    }\n  }\n\n  /**\n   * Set the active state of the client. This will trigger the `onActive` or\n   * `onInactive` lifecycle hooks for all Snaps.\n   *\n   * @param active - A boolean indicating whether the client is active or not.\n   */\n  setClientActive(active: boolean) {\n    if (active) {\n      this.#callLifecycleHooks(METAMASK_ORIGIN, HandlerType.OnActive);\n    } else {\n      this.#callLifecycleHooks(METAMASK_ORIGIN, HandlerType.OnInactive);\n    }\n  }\n\n  /**\n   * Determine the execution timeout for a given handler permission.\n   *\n   * If no permission is specified or the permission itself has no execution timeout defined\n   * the constructor argument `maxRequestTime` will be used.\n   *\n   * @param permission - An optional permission constraint for the handler being called.\n   * @returns The execution timeout for the given handler.\n   */\n  #getExecutionTimeout(permission?: PermissionConstraint): number {\n    return getMaxRequestTimeCaveat(permission) ?? this.maxRequestTime;\n  }\n\n  /**\n   * Create a dynamic interface in the SnapInterfaceController.\n   *\n   * @param snapId - The snap ID.\n   * @param content - The initial interface content.\n   * @param contentType - The type of content.\n   * @returns An identifier that can be used to identify the interface.\n   */\n  async #createInterface(\n    snapId: SnapId,\n    content: ComponentOrElement,\n    contentType?: ContentType,\n  ): Promise<string> {\n    return this.messenger.call(\n      'SnapInterfaceController:createInterface',\n      snapId,\n      content,\n      undefined,\n      contentType,\n    );\n  }\n\n  #assertInterfaceExists(snapId: SnapId, id: string) {\n    // This will throw if the interface isn't accessible, but we assert nevertheless.\n    assert(\n      this.messenger.call('SnapInterfaceController:getInterface', snapId, id),\n    );\n  }\n\n  /**\n   * Transform a RPC response if necessary.\n   *\n   * @param snapId - The snap ID of the snap that produced the result.\n   * @param handlerType - The handler type that produced the result.\n   * @param request - The request that returned the result.\n   * @param result - The response.\n   * @returns The transformed result if applicable, otherwise the original result.\n   */\n  async #transformSnapRpcResponse(\n    snapId: SnapId,\n    handlerType: HandlerType,\n    request: Record<string, unknown>,\n    result: unknown,\n  ) {\n    switch (handlerType) {\n      case HandlerType.OnTransaction:\n      case HandlerType.OnSignature:\n      case HandlerType.OnHomePage:\n      case HandlerType.OnSettingsPage: {\n        // Since this type has been asserted earlier we can cast\n        const castResult = result as Record<string, Json> | null;\n\n        // If a handler returns static content, we turn it into a dynamic UI\n        if (castResult && hasProperty(castResult, 'content')) {\n          const { content, ...rest } = castResult;\n          const id = await this.#createInterface(\n            snapId,\n            content as ComponentOrElement,\n          );\n\n          return { ...rest, id };\n        }\n        return result;\n      }\n      case HandlerType.OnAssetsLookup:\n        // We can cast since the request and result have already been validated.\n        return this.#transformOnAssetsLookupResult(\n          snapId,\n          request as { params: OnAssetsLookupArguments },\n          result as OnAssetsLookupResponse,\n        );\n\n      case HandlerType.OnAssetsConversion:\n        // We can cast since the request and result have already been validated.\n        return this.#transformOnAssetsConversionResult(\n          request as {\n            params: OnAssetsConversionArguments;\n          },\n          result as OnAssetsConversionResponse,\n        );\n\n      case HandlerType.OnAssetsMarketData:\n        // We can cast since the request and result have already been validated.\n        return this.#transformOnAssetsMarketDataResult(\n          request as { params: OnAssetsMarketDataArguments },\n          result as OnAssetsMarketDataResponse,\n        );\n\n      default:\n        return result;\n    }\n  }\n\n  /**\n   * Transform an RPC response coming from the `onAssetsLookup` handler.\n   *\n   * This filters out responses that are out of scope for the Snap based on\n   * its permissions and the incoming request.\n   *\n   * @param snapId - The snap ID of the snap that produced the result.\n   * @param request - The request that returned the result.\n   * @param request.params - The parameters for the request.\n   * @param result - The result.\n   * @param result.assets - The assets returned by the Snap.\n   * @returns The transformed result.\n   */\n  #transformOnAssetsLookupResult(\n    snapId: SnapId,\n    { params: requestedParams }: { params: OnAssetsLookupArguments },\n    { assets }: OnAssetsLookupResponse,\n  ) {\n    const permissions = this.messenger.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n    // We know the permissions are guaranteed to be set here.\n    assert(permissions);\n\n    const permission = permissions[SnapEndowments.Assets];\n    const scopes = getChainIdsCaveat(permission);\n    assert(scopes);\n\n    const { assets: requestedAssets } = requestedParams;\n\n    const filteredAssets = Object.keys(assets).reduce<\n      Record<CaipAssetType, AssetMetadata | null>\n    >((accumulator, assetType) => {\n      const castAssetType = assetType as CaipAssetTypeOrId;\n      const isValid =\n        scopes.some((scope) => castAssetType.startsWith(scope)) &&\n        requestedAssets.includes(castAssetType);\n      // Filter out unrequested assets and assets for scopes the Snap hasn't registered for.\n      if (isValid) {\n        accumulator[castAssetType] = assets[castAssetType];\n      }\n      return accumulator;\n    }, {});\n    return { assets: filteredAssets };\n  }\n\n  /**\n   * Transform an RPC response coming from the `onAssetsConversion` handler.\n   *\n   * This filters out responses that are out of scope for the Snap based on\n   * the incoming request.\n   *\n   * @param request - The request that returned the result.\n   * @param request.params - The parameters for the request.\n   * @param result - The result.\n   * @param result.conversionRates - The conversion rates returned by the Snap.\n   * @returns The transformed result.\n   */\n  #transformOnAssetsConversionResult(\n    { params: requestedParams }: { params: OnAssetsConversionArguments },\n    { conversionRates }: OnAssetsConversionResponse,\n  ) {\n    const { conversions: requestedConversions } = requestedParams;\n\n    const filteredConversionRates = requestedConversions.reduce<\n      Record<CaipAssetType, Record<CaipAssetType, AssetConversion>>\n    >((accumulator, conversion) => {\n      const rate = conversionRates[conversion.from]?.[conversion.to];\n      // Only include rates that were actually requested.\n      if (rate) {\n        accumulator[conversion.from] ??= {};\n        accumulator[conversion.from][conversion.to] = rate;\n      }\n      return accumulator;\n    }, {});\n    return { conversionRates: filteredConversionRates };\n  }\n\n  /**\n   * Transforms an RPC response coming from the `onAssetsMarketData` handler.\n   *\n   * This filters out responses that are out of scope for the Snap based on\n   * the incoming request.\n   *\n   * @param request - The request that returned the result.\n   * @param request.params - The parameters for the request.\n   * @param result - The result.\n   * @param result.marketData - The market data returned by the Snap.\n   * @returns The transformed result.\n   */\n  #transformOnAssetsMarketDataResult(\n    { params: requestedParams }: { params: OnAssetsMarketDataArguments },\n    { marketData }: OnAssetsMarketDataResponse,\n  ) {\n    const { assets: requestedAssets } = requestedParams;\n\n    const filteredMarketData = requestedAssets.reduce<\n      Record<CaipAssetTypeOrId, Record<CaipAssetType, AssetMarketData | null>>\n    >((accumulator, assets) => {\n      const result = marketData[assets.asset]?.[assets.unit];\n      // Only include rates that were actually requested.\n      if (result) {\n        accumulator[assets.asset] ??= {};\n        accumulator[assets.asset][assets.unit] = result;\n      }\n      return accumulator;\n    }, {});\n    return { marketData: filteredMarketData };\n  }\n\n  /**\n   * Transforms a JSON-RPC request before sending it to the Snap, if required for a given handler.\n   *\n   * @param snapId - The Snap ID.\n   * @param handlerType - The handler being called.\n   * @param request - The JSON-RPC request.\n   * @returns The potentially transformed JSON-RPC request.\n   */\n  #transformSnapRpcRequest(\n    snapId: SnapId,\n    handlerType: HandlerType,\n    request: JsonRpcRequest,\n  ) {\n    switch (handlerType) {\n      // For onUserInput we inject context, so the client doesn't have to worry about keeping it in sync.\n      case HandlerType.OnUserInput: {\n        assert(request.params && hasProperty(request.params, 'id'));\n\n        const interfaceId = request.params.id as string;\n        const { context } = this.messenger.call(\n          'SnapInterfaceController:getInterface',\n          snapId,\n          interfaceId,\n        );\n\n        return {\n          ...request,\n          params: { ...request.params, context },\n        };\n      }\n\n      default:\n        return request;\n    }\n  }\n\n  /**\n   * Assert that the returned result of a Snap RPC call is the expected shape.\n   *\n   * @param snapId - The snap ID.\n   * @param handlerType - The handler type of the RPC Request.\n   * @param result - The result of the RPC request.\n   */\n  async #assertSnapRpcResponse(\n    snapId: SnapId,\n    handlerType: HandlerType,\n    result: unknown,\n  ) {\n    switch (handlerType) {\n      case HandlerType.OnTransaction: {\n        assertStruct(result, OnTransactionResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnSignature: {\n        assertStruct(result, OnSignatureResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnHomePage: {\n        assertStruct(result, OnHomePageResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnSettingsPage: {\n        assertStruct(result, OnSettingsPageResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnNameLookup:\n        assertStruct(result, OnNameLookupResponseStruct);\n        break;\n      case HandlerType.OnAssetsLookup:\n        assertStruct(result, OnAssetsLookupResponseStruct);\n        break;\n      case HandlerType.OnAssetsConversion:\n        assertStruct(result, OnAssetsConversionResponseStruct);\n        break;\n      case HandlerType.OnAssetHistoricalPrice:\n        assertStruct(result, OnAssetHistoricalPriceResponseStruct);\n        break;\n      case HandlerType.OnAssetsMarketData:\n        assertStruct(result, OnAssetsMarketDataResponseStruct);\n        break;\n      default:\n        break;\n    }\n  }\n\n  #recordSnapRpcRequestStart(snapId: SnapId, requestId: unknown, timer: Timer) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests.push({ requestId, timer });\n    runtime.lastRequest = null;\n  }\n\n  #recordSnapRpcRequestFinish(\n    snapId: SnapId,\n    requestId: unknown,\n    handlerType: HandlerType,\n    origin: string,\n    success: boolean,\n  ) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests = runtime.pendingInboundRequests.filter(\n      (request) => request.requestId !== requestId,\n    );\n\n    if (runtime.pendingInboundRequests.length === 0) {\n      runtime.lastRequest = Date.now();\n    }\n\n    const snap = this.get(snapId);\n\n    if (isTrackableHandler(handlerType) && !snap?.preinstalled) {\n      try {\n        this.#trackSnapExport(snapId, handlerType, success, origin);\n      } catch (error) {\n        logError(\n          `Error when calling MetaMetrics hook for snap \"${snap?.id}\": ${getErrorMessage(\n            error,\n          )}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Retrieves the rollback snapshot of a snap.\n   *\n   * @param snapId - The snap id.\n   * @returns A `RollbackSnapshot` or `undefined` if one doesn't exist.\n   */\n  #getRollbackSnapshot(snapId: SnapId): RollbackSnapshot | undefined {\n    return this.#rollbackSnapshots.get(snapId);\n  }\n\n  /**\n   * Creates a `RollbackSnapshot` that is used to help ensure\n   * atomicity in multiple snap updates.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If the snap exists before creation or if creation fails.\n   * @returns A `RollbackSnapshot`.\n   */\n  #createRollbackSnapshot(snapId: SnapId): RollbackSnapshot {\n    assert(\n      this.#rollbackSnapshots.get(snapId) === undefined,\n      `Snap \"${snapId}\" rollback snapshot already exists.`,\n    );\n\n    this.#rollbackSnapshots.set(snapId, {\n      statePatches: [],\n      permissions: {},\n      newVersion: '',\n    });\n\n    const newRollbackSnapshot = this.#rollbackSnapshots.get(snapId);\n\n    assert(\n      newRollbackSnapshot !== undefined,\n      `Snapshot creation failed for ${snapId}.`,\n    );\n    return newRollbackSnapshot;\n  }\n\n  /**\n   * Rolls back a snap to its previous state, permissions\n   * and source code based on the `RollbackSnapshot` that\n   * is captured during the update process. After rolling back,\n   * the function also emits an event indicating that the\n   * snap has been rolled back and it clears the snapshot\n   * for that snap.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If a snapshot does not exist.\n   */\n  async #rollbackSnap(snapId: SnapId) {\n    const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n    if (!rollbackSnapshot) {\n      throw new Error('A snapshot does not exist for this snap.');\n    }\n\n    await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    // Always set to stopped even if it wasn't running initially\n    if (this.get(snapId)?.status !== SnapStatus.Stopped) {\n      this.#transition(snapId, SnapStatusEvents.Stop);\n    }\n\n    const {\n      statePatches,\n      permissions,\n      previousInitialConnections,\n      newInitialConnections,\n    } = rollbackSnapshot;\n\n    if (statePatches?.length) {\n      this.applyPatches(statePatches);\n    }\n\n    // Reset snap status, as we may have been in another state when we stored state patches\n    // But now we are 100% in a stopped state\n    if (this.get(snapId)?.status !== SnapStatus.Stopped) {\n      this.update((state) => {\n        state.snaps[snapId].status = SnapStatus.Stopped;\n      });\n    }\n\n    this.#updatePermissions({\n      snapId,\n      unusedPermissions: permissions.granted,\n      newPermissions: permissions.revoked,\n      requestData: permissions.requestData,\n    });\n\n    // Calling this in reverse order to undo the changes\n    this.#handleInitialConnections(\n      snapId,\n      newInitialConnections ?? null,\n      previousInitialConnections ?? {},\n    );\n\n    const truncatedSnap = this.getTruncatedExpect(snapId);\n\n    this.messenger.publish(\n      'SnapController:snapRolledback',\n      truncatedSnap,\n      rollbackSnapshot.newVersion,\n    );\n\n    this.#rollbackSnapshots.delete(snapId);\n  }\n\n  /**\n   * Iterates through an array of snap ids\n   * and calls `rollbackSnap` on them.\n   *\n   * @param snapIds - An array of snap ids.\n   */\n  async #rollbackSnaps(snapIds: SnapId[]) {\n    for (const snapId of snapIds) {\n      await this.#rollbackSnap(snapId);\n    }\n  }\n\n  #getRuntime(snapId: SnapId): SnapRuntimeData | undefined {\n    return this.#snapsRuntimeData.get(snapId);\n  }\n\n  #getRuntimeExpect(snapId: SnapId): SnapRuntimeData {\n    const runtime = this.#getRuntime(snapId);\n    assert(runtime !== undefined, `Snap \"${snapId}\" runtime data not found`);\n    return runtime;\n  }\n\n  #setupRuntime(snapId: SnapId) {\n    if (this.#snapsRuntimeData.has(snapId)) {\n      return;\n    }\n\n    const snap = this.get(snapId);\n    const interpreter = interpret(this.#statusMachine);\n    interpreter.start({\n      context: { snapId },\n      value:\n        snap?.status ??\n        (this.#statusMachine.config.initial as StatusStates['value']),\n    });\n\n    forceStrict(interpreter);\n\n    this.#snapsRuntimeData.set(snapId, {\n      lastRequest: null,\n      startPromise: null,\n      stopPromise: null,\n      installPromise: null,\n      encryptionKey: null,\n      encryptionSalt: null,\n      activeReferences: 0,\n      pendingInboundRequests: [],\n      pendingOutboundRequests: 0,\n      interpreter,\n      stateMutex: new Mutex(),\n      getStateMutex: new Mutex(),\n    });\n  }\n\n  #calculatePermissionsChange(\n    snapId: SnapId,\n    desiredPermissionsSet: Record<\n      string,\n      Pick<PermissionConstraint, 'caveats'>\n    >,\n  ): {\n    newPermissions: Record<string, Pick<PermissionConstraint, 'caveats'>>;\n    unusedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n    approvedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n  } {\n    const oldPermissions =\n      this.messenger.call('PermissionController:getPermissions', snapId) ?? {};\n\n    const newPermissions = permissionsDiff(\n      desiredPermissionsSet,\n      oldPermissions,\n    );\n    // TODO(ritave): The assumption that these are unused only holds so long as we do not\n    //               permit dynamic permission requests.\n    const unusedPermissions = permissionsDiff(\n      oldPermissions,\n      desiredPermissionsSet,\n    );\n\n    // It's a Set Intersection of oldPermissions and desiredPermissionsSet\n    // oldPermissions ∖ (oldPermissions ∖ desiredPermissionsSet) ⟺ oldPermissions ∩ desiredPermissionsSet\n    const approvedPermissions = permissionsDiff(\n      oldPermissions,\n      unusedPermissions,\n    );\n\n    return { newPermissions, unusedPermissions, approvedPermissions };\n  }\n\n  #isSubjectConnectedToSnap(snapId: SnapId, origin: string) {\n    const subjectPermissions = this.messenger.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const existingCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds);\n\n    return Boolean((existingCaveat?.value as Record<string, Json>)?.[snapId]);\n  }\n\n  #calculateConnectionsChange(\n    snapId: SnapId,\n    oldConnectionsSet: Record<string, Json>,\n    desiredConnectionsSet: Record<string, Json>,\n  ): {\n    newConnections: Record<string, Json>;\n    unusedConnections: Record<string, Json>;\n    approvedConnections: Record<string, Json>;\n  } {\n    // Filter out any origins that have been revoked since last install/update.\n    // That way they will be represented as new.\n    const filteredOldConnections = Object.keys(oldConnectionsSet)\n      .filter((origin) => this.#isSubjectConnectedToSnap(snapId, origin))\n      .reduce<Record<string, Json>>((accumulator, origin) => {\n        accumulator[origin] = oldConnectionsSet[origin];\n        return accumulator;\n      }, {});\n\n    const newConnections = setDiff(\n      desiredConnectionsSet,\n      filteredOldConnections,\n    );\n\n    const unusedConnections = setDiff(\n      filteredOldConnections,\n      desiredConnectionsSet,\n    );\n\n    // It's a Set Intersection of oldConnections and desiredConnectionsSet\n    // oldConnections ∖ (oldConnections ∖ desiredConnectionsSet) ⟺ oldConnections ∩ desiredConnectionsSet\n    const approvedConnections = setDiff(\n      filteredOldConnections,\n      unusedConnections,\n    );\n\n    return { newConnections, unusedConnections, approvedConnections };\n  }\n\n  /**\n   * Get the permissions to grant to a Snap following an install, update or\n   * rollback.\n   *\n   * @param snapId - The snap ID.\n   * @param newPermissions - The new permissions to be granted.\n   * @returns The permissions to grant to the Snap.\n   */\n  #getPermissionsToGrant(snapId: SnapId, newPermissions: RequestedPermissions) {\n    if (Object.keys(newPermissions).includes(SnapEndowments.EthereumProvider)) {\n      // This will return the globally selected network if the Snap doesn't have\n      // one set.\n      const networkClientId = this.messenger.call(\n        'SelectedNetworkController:getNetworkClientIdForDomain',\n        snapId,\n      );\n\n      const { configuration } = this.messenger.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n\n      const chainId = hexToNumber(configuration.chainId);\n\n      // This needs to be assigned to have proper type inference.\n      const modifiedPermissions: RequestedPermissions = {\n        ...newPermissions,\n        'endowment:caip25': {\n          caveats: [\n            {\n              type: 'authorizedScopes',\n              value: {\n                requiredScopes: {},\n                optionalScopes: {\n                  [`eip155:${chainId}`]: {\n                    accounts: [],\n                  },\n                },\n                sessionProperties: {},\n                isMultichainOrigin: false,\n              },\n            },\n          ],\n        },\n      };\n\n      return modifiedPermissions;\n    }\n\n    return newPermissions;\n  }\n\n  /**\n   * Update the permissions for a snap following an install, update or rollback.\n   *\n   * Grants newly requested permissions and revokes unused/revoked permissions.\n   *\n   * @param args - An options bag.\n   * @param args.snapId - The snap ID.\n   * @param args.newPermissions - New permissions to be granted.\n   * @param args.unusedPermissions - Unused permissions to be revoked.\n   * @param args.requestData - Optional request data from an approval.\n   */\n  #updatePermissions({\n    snapId,\n    unusedPermissions = {},\n    newPermissions = {},\n    requestData,\n  }: {\n    snapId: SnapId;\n    newPermissions?:\n      | RequestedPermissions\n      | Record<string, Pick<PermissionConstraint, 'caveats'>>;\n    unusedPermissions?:\n      | RequestedPermissions\n      | SubjectPermissions<ValidPermission<string, Caveat<string, any>>>;\n    requestData?: Record<string, unknown>;\n  }) {\n    const unusedPermissionsKeys = Object.keys(unusedPermissions);\n    if (isNonEmptyArray(unusedPermissionsKeys)) {\n      this.messenger.call('PermissionController:revokePermissions', {\n        [snapId]: unusedPermissionsKeys,\n      });\n    }\n\n    if (isNonEmptyArray(Object.keys(newPermissions))) {\n      const approvedPermissions = this.#getPermissionsToGrant(\n        snapId,\n        newPermissions,\n      );\n\n      this.messenger.call('PermissionController:grantPermissions', {\n        approvedPermissions,\n        subject: { origin: snapId },\n        requestData,\n      });\n    }\n  }\n\n  /**\n   * Checks if a snap will pass version validation checks\n   * with the new version range that is requested. The first\n   * check that is done is to check if the existing snap version\n   * falls inside the requested range. If it does, we want to return\n   * false because we do not care to create a rollback snapshot in\n   * that scenario. The second check is to ensure that the current\n   * snap version is not greater than all possible versions in\n   * the requested version range. If it is, then we also want\n   * to return false in that scenario.\n   *\n   * @param snapId - The snap id.\n   * @param newVersionRange - The new version range being requested.\n   * @returns `true` if validation checks pass and `false` if they do not.\n   */\n  #isValidUpdate(snapId: SnapId, newVersionRange: SemVerRange): boolean {\n    const existingSnap = this.getExpect(snapId);\n\n    if (satisfiesVersionRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    if (gtRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Call a lifecycle hook for all runnable Snaps.\n   *\n   * @param origin - The origin of the request.\n   * @param handler - The lifecycle hook to call. This should be one of the\n   * supported lifecycle hooks.\n   */\n  #callLifecycleHooks(origin: string, handler: HandlerType) {\n    const snaps = this.getRunnableSnaps();\n    for (const { id } of snaps) {\n      const hasLifecycleHooksEndowment = this.messenger.call(\n        'PermissionController:hasPermission',\n        id,\n        SnapEndowments.LifecycleHooks,\n      );\n\n      if (!hasLifecycleHooksEndowment) {\n        continue;\n      }\n\n      this.#callLifecycleHook(origin, id, handler).catch((error) => {\n        logError(\n          `Error calling lifecycle hook \"${handler}\" for Snap \"${id}\": ${getErrorMessage(\n            error,\n          )}`,\n        );\n      });\n    }\n  }\n\n  /**\n   * Call a lifecycle hook on a snap, if the snap has the\n   * `endowment:lifecycle-hooks` permission. If the snap does not have the\n   * permission, nothing happens.\n   *\n   * @param origin - The origin.\n   * @param snapId - The snap ID.\n   * @param handler - The lifecycle hook to call. This should be one of the\n   * supported lifecycle hooks.\n   * @private\n   */\n  async #callLifecycleHook(\n    origin: string,\n    snapId: SnapId,\n    handler: HandlerType,\n  ) {\n    const permissionName = handlerEndowments[handler];\n\n    assert(permissionName, 'Lifecycle hook must have an endowment.');\n\n    const hasPermission = this.messenger.call(\n      'PermissionController:hasPermission',\n      snapId,\n      permissionName,\n    );\n\n    if (!hasPermission) {\n      return;\n    }\n\n    await this.handleRequest({\n      snapId,\n      handler,\n      origin,\n      request: {\n        jsonrpc: '2.0',\n        method: handler,\n      },\n    });\n  }\n\n  /**\n   * Handle the `KeyringController:lock` event.\n   *\n   * Currently this clears the cached encrypted state (if any) for all Snaps.\n   */\n  #handleLock() {\n    for (const runtime of this.#snapsRuntimeData.values()) {\n      runtime.encryptionKey = null;\n      runtime.encryptionSalt = null;\n      runtime.state = undefined;\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/snaps/SnapController.d.cts b/dist/snaps/SnapController.d.cts
index 7e005e39995e851201d06a58435912c0a331a8a9..494545824d33b1c619b404120b6af777c32d710a 100644
--- a/dist/snaps/SnapController.d.cts
+++ b/dist/snaps/SnapController.d.cts
@@ -1,7 +1,8 @@
 import { type AddApprovalRequest, type UpdateRequestState } from "@metamask/approval-controller";
-import type { RestrictedMessenger, ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
-import { BaseController } from "@metamask/base-controller";
+import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller/next";
+import { BaseController } from "@metamask/base-controller/next";
 import type { CryptographicFunctions } from "@metamask/key-tree";
+import type { Messenger } from "@metamask/messenger";
 import type { GetEndowments, GetPermissions, GetSubjectMetadata, AddSubjectMetadata, GetSubjects, GrantPermissions, HasPermission, HasPermissions, RevokeAllPermissions, RevokePermissionForAllSubjects, RevokePermissions, UpdateCaveat } from "@metamask/permission-controller";
 import type { BlockReason } from "@metamask/snaps-registry";
 import type { RequestSnapsParams, RequestSnapsResult, SnapId } from "@metamask/snaps-sdk";
@@ -352,7 +353,7 @@ type SelectedNetworkControllerGetNetworkClientIdForDomain = {
 };
 export type AllowedActions = GetEndowments | GetPermissions | GetSubjects | GetSubjectMetadata | AddSubjectMetadata | HasPermission | HasPermissions | RevokePermissions | RevokeAllPermissions | RevokePermissionForAllSubjects | GrantPermissions | AddApprovalRequest | HandleRpcRequestAction | ExecuteSnapAction | TerminateSnapAction | UpdateCaveat | UpdateRequestState | GetResult | GetMetadata | Update | ResolveVersion | CreateInterface | GetInterface | NetworkControllerGetNetworkClientById | SelectedNetworkControllerGetNetworkClientIdForDomain;
 export type AllowedEvents = ExecutionServiceEvents | SnapInstalled | SnapUpdated | KeyringControllerLock;
-type SnapControllerMessenger = RestrictedMessenger<typeof controllerName, SnapControllerActions | AllowedActions, SnapControllerEvents | AllowedEvents, AllowedActions['type'], AllowedEvents['type']>;
+type SnapControllerMessenger = Messenger<typeof controllerName, SnapControllerActions | AllowedActions, SnapControllerEvents | AllowedEvents>;
 type FeatureFlags = {
     requireAllowlist?: boolean;
     allowLocalSnaps?: boolean;
diff --git a/dist/snaps/SnapController.d.cts.map b/dist/snaps/SnapController.d.cts.map
index c77f5ae60976d84a7e167b0c984926543546664b..59b7c47ffb043d05785fd48c170630471876a742 100644
--- a/dist/snaps/SnapController.d.cts.map
+++ b/dist/snaps/SnapController.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"SnapController.d.cts","sourceRoot":"","sources":["../../src/snaps/SnapController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"SnapController.d.cts","sourceRoot":"","sources":["../../src/snaps/SnapController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/snaps/SnapController.d.mts b/dist/snaps/SnapController.d.mts
index cf79200db33f766716d5767e4b4b19528a5a3424..36586eb017385297ce627f7f8c6d8f951bd5efde 100644
--- a/dist/snaps/SnapController.d.mts
+++ b/dist/snaps/SnapController.d.mts
@@ -1,7 +1,8 @@
 import { type AddApprovalRequest, type UpdateRequestState } from "@metamask/approval-controller";
-import type { RestrictedMessenger, ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller";
-import { BaseController } from "@metamask/base-controller";
+import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller/next";
+import { BaseController } from "@metamask/base-controller/next";
 import type { CryptographicFunctions } from "@metamask/key-tree";
+import type { Messenger } from "@metamask/messenger";
 import type { GetEndowments, GetPermissions, GetSubjectMetadata, AddSubjectMetadata, GetSubjects, GrantPermissions, HasPermission, HasPermissions, RevokeAllPermissions, RevokePermissionForAllSubjects, RevokePermissions, UpdateCaveat } from "@metamask/permission-controller";
 import type { BlockReason } from "@metamask/snaps-registry";
 import type { RequestSnapsParams, RequestSnapsResult, SnapId } from "@metamask/snaps-sdk";
@@ -352,7 +353,7 @@ type SelectedNetworkControllerGetNetworkClientIdForDomain = {
 };
 export type AllowedActions = GetEndowments | GetPermissions | GetSubjects | GetSubjectMetadata | AddSubjectMetadata | HasPermission | HasPermissions | RevokePermissions | RevokeAllPermissions | RevokePermissionForAllSubjects | GrantPermissions | AddApprovalRequest | HandleRpcRequestAction | ExecuteSnapAction | TerminateSnapAction | UpdateCaveat | UpdateRequestState | GetResult | GetMetadata | Update | ResolveVersion | CreateInterface | GetInterface | NetworkControllerGetNetworkClientById | SelectedNetworkControllerGetNetworkClientIdForDomain;
 export type AllowedEvents = ExecutionServiceEvents | SnapInstalled | SnapUpdated | KeyringControllerLock;
-type SnapControllerMessenger = RestrictedMessenger<typeof controllerName, SnapControllerActions | AllowedActions, SnapControllerEvents | AllowedEvents, AllowedActions['type'], AllowedEvents['type']>;
+type SnapControllerMessenger = Messenger<typeof controllerName, SnapControllerActions | AllowedActions, SnapControllerEvents | AllowedEvents>;
 type FeatureFlags = {
     requireAllowlist?: boolean;
     allowLocalSnaps?: boolean;
diff --git a/dist/snaps/SnapController.d.mts.map b/dist/snaps/SnapController.d.mts.map
index c272a2d865539f88286c3c9ebbe1210d8e5dcc33..7261049262e3b00da2ee53b44dd808d5adf2ff4d 100644
--- a/dist/snaps/SnapController.d.mts.map
+++ b/dist/snaps/SnapController.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"SnapController.d.mts","sourceRoot":"","sources":["../../src/snaps/SnapController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"SnapController.d.mts","sourceRoot":"","sources":["../../src/snaps/SnapController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/snaps/SnapController.mjs b/dist/snaps/SnapController.mjs
index cc009509da1b4e9e1ac6e168201fa752cba004c7..51161a0f1e346cbe9e7b724f38db5f5ac2f4e117 100644
--- a/dist/snaps/SnapController.mjs
+++ b/dist/snaps/SnapController.mjs
@@ -1,5 +1,5 @@
 import { ORIGIN_METAMASK } from "@metamask/approval-controller";
-import { BaseController } from "@metamask/base-controller";
+import { BaseController } from "@metamask/base-controller/next";
 import { SubjectType } from "@metamask/permission-controller";
 import { rpcErrors } from "@metamask/rpc-errors";
 import { WALLET_SNAP_PERMISSION_KEY, getMaxRequestTimeCaveat, handlerEndowments, SnapEndowments, getKeyringCaveatOrigins, getRpcCaveatOrigins, processSnapPermissions, getEncryptionEntropy, getChainIdsCaveat } from "@metamask/snaps-rpc-methods";
@@ -87,13 +87,13 @@ export class SnapController extends BaseController {
                 snapStates: {
                     includeInStateLogs: false,
                     persist: true,
-                    anonymous: false,
+                    includeInDebugSnapshot: false,
                     usedInUi: false,
                 },
                 unencryptedSnapStates: {
                     includeInStateLogs: false,
                     persist: true,
-                    anonymous: false,
+                    includeInDebugSnapshot: false,
                     usedInUi: false,
                 },
                 snaps: {
@@ -124,7 +124,7 @@ export class SnapController extends BaseController {
                             return memo;
                         }, {}));
                     },
-                    anonymous: false,
+                    includeInDebugSnapshot: false,
                     // TODO: Ensure larger snap properties are not sent to the UI
                     // Currently these are stripped out manually in the extension
                     usedInUi: true,
@@ -159,21 +159,21 @@ export class SnapController extends BaseController {
         this.#trackEvent = trackEvent;
         this.#pollForLastRequestStatus();
         /* eslint-disable @typescript-eslint/unbound-method */
-        this.messagingSystem.subscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
-        this.messagingSystem.subscribe('ExecutionService:outboundRequest', this._onOutboundRequest);
-        this.messagingSystem.subscribe('ExecutionService:outboundResponse', this._onOutboundResponse);
+        this.messenger.subscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
+        this.messenger.subscribe('ExecutionService:outboundRequest', this._onOutboundRequest);
+        this.messenger.subscribe('ExecutionService:outboundResponse', this._onOutboundResponse);
         /* eslint-enable @typescript-eslint/unbound-method */
-        this.messagingSystem.subscribe('SnapController:snapInstalled', ({ id }, origin) => {
+        this.messenger.subscribe('SnapController:snapInstalled', ({ id }, origin) => {
             this.#callLifecycleHook(origin, id, HandlerType.OnInstall).catch((error) => {
                 logError(`Error when calling \`onInstall\` lifecycle hook for snap "${id}": ${getErrorMessage(error)}`);
             });
         });
-        this.messagingSystem.subscribe('SnapController:snapUpdated', ({ id }, _oldVersion, origin) => {
+        this.messenger.subscribe('SnapController:snapUpdated', ({ id }, _oldVersion, origin) => {
             this.#callLifecycleHook(origin, id, HandlerType.OnUpdate).catch((error) => {
                 logError(`Error when calling \`onUpdate\` lifecycle hook for snap "${id}": ${getErrorMessage(error)}`);
             });
         });
-        this.messagingSystem.subscribe('KeyringController:lock', this.#handleLock.bind(this));
+        this.messenger.subscribe('KeyringController:lock', this.#handleLock.bind(this));
         this.#initializeStateMachine();
         this.#registerMessageHandlers();
         Object.values(this.state?.snaps ?? {}).forEach((snap) => this.#setupRuntime(snap.id));
@@ -181,7 +181,7 @@ export class SnapController extends BaseController {
             this.#handlePreinstalledSnaps(this.#preinstalledSnaps);
         }
         this.#trackSnapExport = throttleTracking((snapId, handler, success, origin) => {
-            const snapMetadata = this.messagingSystem.call('SnapsRegistry:getMetadata', snapId);
+            const snapMetadata = this.messenger.call('SnapsRegistry:getMetadata', snapId);
             this.#trackEvent({
                 event: 'Snap Export Used',
                 category: 'Snaps',
@@ -264,29 +264,29 @@ export class SnapController extends BaseController {
      * actions.
      */
     #registerMessageHandlers() {
-        this.messagingSystem.registerActionHandler(`${controllerName}:init`, (...args) => this.init(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:clearSnapState`, (...args) => this.clearSnapState(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:get`, (...args) => this.get(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:getSnapState`, async (...args) => this.getSnapState(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:handleRequest`, async (...args) => this.handleRequest(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:has`, (...args) => this.has(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:updateRegistry`, async () => this.updateRegistry());
-        this.messagingSystem.registerActionHandler(`${controllerName}:updateSnapState`, async (...args) => this.updateSnapState(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:enable`, (...args) => this.enableSnap(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:disable`, async (...args) => this.disableSnap(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:remove`, async (...args) => this.removeSnap(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:getPermitted`, (...args) => this.getPermittedSnaps(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:install`, async (...args) => this.installSnaps(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:getAll`, (...args) => this.getAllSnaps(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:getRunnableSnaps`, (...args) => this.getRunnableSnaps(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:incrementActiveReferences`, (...args) => this.incrementActiveReferences(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:decrementActiveReferences`, (...args) => this.decrementActiveReferences(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:disconnectOrigin`, (...args) => this.removeSnapFromSubject(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:revokeDynamicPermissions`, (...args) => this.revokeDynamicSnapPermissions(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:getFile`, async (...args) => this.getSnapFile(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:stopAllSnaps`, async (...args) => this.stopAllSnaps(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:isMinimumPlatformVersion`, (...args) => this.isMinimumPlatformVersion(...args));
-        this.messagingSystem.registerActionHandler(`${controllerName}:setClientActive`, (...args) => this.setClientActive(...args));
+        this.messenger.registerActionHandler(`${controllerName}:init`, (...args) => this.init(...args));
+        this.messenger.registerActionHandler(`${controllerName}:clearSnapState`, (...args) => this.clearSnapState(...args));
+        this.messenger.registerActionHandler(`${controllerName}:get`, (...args) => this.get(...args));
+        this.messenger.registerActionHandler(`${controllerName}:getSnapState`, async (...args) => this.getSnapState(...args));
+        this.messenger.registerActionHandler(`${controllerName}:handleRequest`, async (...args) => this.handleRequest(...args));
+        this.messenger.registerActionHandler(`${controllerName}:has`, (...args) => this.has(...args));
+        this.messenger.registerActionHandler(`${controllerName}:updateRegistry`, async () => this.updateRegistry());
+        this.messenger.registerActionHandler(`${controllerName}:updateSnapState`, async (...args) => this.updateSnapState(...args));
+        this.messenger.registerActionHandler(`${controllerName}:enable`, (...args) => this.enableSnap(...args));
+        this.messenger.registerActionHandler(`${controllerName}:disable`, async (...args) => this.disableSnap(...args));
+        this.messenger.registerActionHandler(`${controllerName}:remove`, async (...args) => this.removeSnap(...args));
+        this.messenger.registerActionHandler(`${controllerName}:getPermitted`, (...args) => this.getPermittedSnaps(...args));
+        this.messenger.registerActionHandler(`${controllerName}:install`, async (...args) => this.installSnaps(...args));
+        this.messenger.registerActionHandler(`${controllerName}:getAll`, (...args) => this.getAllSnaps(...args));
+        this.messenger.registerActionHandler(`${controllerName}:getRunnableSnaps`, (...args) => this.getRunnableSnaps(...args));
+        this.messenger.registerActionHandler(`${controllerName}:incrementActiveReferences`, (...args) => this.incrementActiveReferences(...args));
+        this.messenger.registerActionHandler(`${controllerName}:decrementActiveReferences`, (...args) => this.decrementActiveReferences(...args));
+        this.messenger.registerActionHandler(`${controllerName}:disconnectOrigin`, (...args) => this.removeSnapFromSubject(...args));
+        this.messenger.registerActionHandler(`${controllerName}:revokeDynamicPermissions`, (...args) => this.revokeDynamicSnapPermissions(...args));
+        this.messenger.registerActionHandler(`${controllerName}:getFile`, async (...args) => this.getSnapFile(...args));
+        this.messenger.registerActionHandler(`${controllerName}:stopAllSnaps`, async (...args) => this.stopAllSnaps(...args));
+        this.messenger.registerActionHandler(`${controllerName}:isMinimumPlatformVersion`, (...args) => this.isMinimumPlatformVersion(...args));
+        this.messenger.registerActionHandler(`${controllerName}:setClientActive`, (...args) => this.setClientActive(...args));
     }
     /**
      * Initialise the SnapController.
@@ -356,10 +356,10 @@ export class SnapController extends BaseController {
             this.#setupRuntime(snapId);
             // Emit events
             if (isUpdate) {
-                this.messagingSystem.publish('SnapController:snapUpdated', this.getTruncatedExpect(snapId), existingSnap.version, METAMASK_ORIGIN, true);
+                this.messenger.publish('SnapController:snapUpdated', this.getTruncatedExpect(snapId), existingSnap.version, METAMASK_ORIGIN, true);
             }
             else {
-                this.messagingSystem.publish('SnapController:snapInstalled', this.getTruncatedExpect(snapId), METAMASK_ORIGIN, true);
+                this.messenger.publish('SnapController:snapInstalled', this.getTruncatedExpect(snapId), METAMASK_ORIGIN, true);
             }
         }
     }
@@ -381,8 +381,8 @@ export class SnapController extends BaseController {
      */
     async updateRegistry() {
         this.#assertCanUsePlatform();
-        await this.messagingSystem.call('SnapsRegistry:update');
-        const blockedSnaps = await this.messagingSystem.call('SnapsRegistry:get', Object.values(this.state.snaps).reduce((blockListArg, snap) => {
+        await this.messenger.call('SnapsRegistry:update');
+        const blockedSnaps = await this.messenger.call('SnapsRegistry:get', Object.values(this.state.snaps).reduce((blockListArg, snap) => {
             blockListArg[snap.id] = {
                 version: snap.version,
                 checksum: snap.manifest.source.shasum,
@@ -441,7 +441,7 @@ export class SnapController extends BaseController {
         catch (error) {
             logError(`Encountered error when stopping blocked snap "${snapId}".`, error);
         }
-        this.messagingSystem.publish(`${controllerName}:snapBlocked`, snapId, blockedSnapInfo);
+        this.messenger.publish(`${controllerName}:snapBlocked`, snapId, blockedSnapInfo);
     }
     /**
      * Unblocks a snap so that it can be enabled and started again. Emits
@@ -458,10 +458,10 @@ export class SnapController extends BaseController {
             state.snaps[snapId].blocked = false;
             delete state.snaps[snapId].blockInformation;
         });
-        this.messagingSystem.publish(`${controllerName}:snapUnblocked`, snapId);
+        this.messenger.publish(`${controllerName}:snapUnblocked`, snapId);
     }
     async #assertIsInstallAllowed(snapId, { platformVersion, ...snapInfo }) {
-        const results = await this.messagingSystem.call('SnapsRegistry:get', {
+        const results = await this.messenger.call('SnapsRegistry:get', {
             [snapId]: snapInfo,
         });
         const result = results[snapId];
@@ -578,7 +578,7 @@ export class SnapController extends BaseController {
         this.update((state) => {
             state.snaps[snapId].enabled = true;
         });
-        this.messagingSystem.publish('SnapController:snapEnabled', this.getTruncatedExpect(snapId));
+        this.messenger.publish('SnapController:snapEnabled', this.getTruncatedExpect(snapId));
     }
     /**
      * Disables the given snap. A snap can only be started if it is enabled.
@@ -596,7 +596,7 @@ export class SnapController extends BaseController {
         if (this.isRunning(snapId)) {
             await this.stopSnap(snapId, SnapStatusEvents.Stop);
         }
-        this.messagingSystem.publish('SnapController:snapDisabled', this.getTruncatedExpect(snapId));
+        this.messenger.publish('SnapController:snapDisabled', this.getTruncatedExpect(snapId));
     }
     /**
      * Stops the given snap, removes all hooks, closes all connections, and
@@ -656,7 +656,7 @@ export class SnapController extends BaseController {
      * @param snapId - The snap to terminate.
      */
     async #terminateSnap(snapId) {
-        await this.messagingSystem.call('ExecutionService:terminateSnap', snapId);
+        await this.messenger.call('ExecutionService:terminateSnap', snapId);
         // Hack to give up execution for a bit to let gracefully terminating Snaps return.
         await new Promise((resolve) => setTimeout(resolve, 1));
         const runtime = this.#getRuntimeExpect(snapId);
@@ -666,7 +666,7 @@ export class SnapController extends BaseController {
             .forEach((pendingRequest) => pendingRequest.timer.finish());
         // Hack to give up execution for a bit to let timed out requests return.
         await new Promise((resolve) => setTimeout(resolve, 1));
-        this.messagingSystem.publish('SnapController:snapTerminated', this.getTruncatedExpect(snapId));
+        this.messenger.publish('SnapController:snapTerminated', this.getTruncatedExpect(snapId));
     }
     /**
      * Returns whether the given snap is running.
@@ -1051,7 +1051,7 @@ export class SnapController extends BaseController {
             });
             // If the snap has been fully installed before, also emit snapUninstalled.
             if (snap.status !== SnapStatus.Installing) {
-                this.messagingSystem.publish(`SnapController:snapUninstalled`, truncated);
+                this.messenger.publish(`SnapController:snapUninstalled`, truncated);
             }
         }));
     }
@@ -1067,7 +1067,7 @@ export class SnapController extends BaseController {
         }
     }
     #addSnapToSubject(origin, snapId) {
-        const subjectPermissions = this.messagingSystem.call('PermissionController:getPermissions', origin);
+        const subjectPermissions = this.messenger.call('PermissionController:getPermissions', origin);
         const existingCaveat = subjectPermissions?.[WALLET_SNAP_PERMISSION_KEY]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds);
         const subjectHasSnap = Boolean(existingCaveat?.value?.[snapId]);
         // If the subject is already connected to the snap, this is a no-op.
@@ -1076,7 +1076,7 @@ export class SnapController extends BaseController {
         }
         // If an existing caveat exists, we add the snap to that.
         if (existingCaveat) {
-            this.messagingSystem.call('PermissionController:updateCaveat', origin, WALLET_SNAP_PERMISSION_KEY, SnapCaveatType.SnapIds, { ...existingCaveat.value, [snapId]: {} });
+            this.messenger.call('PermissionController:updateCaveat', origin, WALLET_SNAP_PERMISSION_KEY, SnapCaveatType.SnapIds, { ...existingCaveat.value, [snapId]: {} });
             return;
         }
         const approvedPermissions = {
@@ -1091,7 +1091,7 @@ export class SnapController extends BaseController {
                 ],
             },
         };
-        this.messagingSystem.call('PermissionController:grantPermissions', {
+        this.messenger.call('PermissionController:grantPermissions', {
             approvedPermissions,
             subject: { origin },
         });
@@ -1103,7 +1103,7 @@ export class SnapController extends BaseController {
      * @param snapId - The id of the snap to remove.
      */
     removeSnapFromSubject(origin, snapId) {
-        const subjectPermissions = this.messagingSystem.call('PermissionController:getPermissions', origin);
+        const subjectPermissions = this.messenger.call('PermissionController:getPermissions', origin);
         const snapIdsCaveat = subjectPermissions?.[WALLET_SNAP_PERMISSION_KEY]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds);
         if (!snapIdsCaveat) {
             return;
@@ -1115,10 +1115,10 @@ export class SnapController extends BaseController {
             };
             delete newCaveatValue[snapId];
             if (Object.keys(newCaveatValue).length > 0) {
-                this.messagingSystem.call('PermissionController:updateCaveat', origin, WALLET_SNAP_PERMISSION_KEY, SnapCaveatType.SnapIds, newCaveatValue);
+                this.messenger.call('PermissionController:updateCaveat', origin, WALLET_SNAP_PERMISSION_KEY, SnapCaveatType.SnapIds, newCaveatValue);
             }
             else {
-                this.messagingSystem.call('PermissionController:revokePermissions', {
+                this.messenger.call('PermissionController:revokePermissions', {
                     [origin]: [WALLET_SNAP_PERMISSION_KEY],
                 });
             }
@@ -1133,7 +1133,7 @@ export class SnapController extends BaseController {
      */
     revokeDynamicSnapPermissions(snapId, permissionNames) {
         assert(permissionNames.every((permissionName) => this.#dynamicPermissions.includes(permissionName)), 'Non-dynamic permissions cannot be revoked');
-        this.messagingSystem.call('PermissionController:revokePermissions', {
+        this.messenger.call('PermissionController:revokePermissions', {
             [snapId]: permissionNames,
         });
     }
@@ -1143,7 +1143,7 @@ export class SnapController extends BaseController {
      * @param snapId - The id of the Snap.
      */
     #removeSnapFromSubjects(snapId) {
-        const subjects = this.messagingSystem.call('PermissionController:getSubjectNames');
+        const subjects = this.messenger.call('PermissionController:getSubjectNames');
         for (const subject of subjects) {
             this.removeSnapFromSubject(subject, snapId);
         }
@@ -1154,8 +1154,8 @@ export class SnapController extends BaseController {
      * @param snapId - The snap ID.
      */
     #revokeAllSnapPermissions(snapId) {
-        if (this.messagingSystem.call('PermissionController:hasPermissions', snapId)) {
-            this.messagingSystem.call('PermissionController:revokeAllPermissions', snapId);
+        if (this.messenger.call('PermissionController:hasPermissions', snapId)) {
+            this.messenger.call('PermissionController:revokeAllPermissions', snapId);
         }
     }
     /**
@@ -1200,7 +1200,7 @@ export class SnapController extends BaseController {
      * @returns The serialized permitted snaps for the origin.
      */
     getPermittedSnaps(origin) {
-        const permissions = this.messagingSystem.call('PermissionController:getPermissions', origin) ?? {};
+        const permissions = this.messenger.call('PermissionController:getPermissions', origin) ?? {};
         const snaps = permissions[WALLET_SNAP_PERMISSION_KEY]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds)?.value ?? {};
         return Object.keys(snaps).reduce((permittedSnaps, snapId) => {
             const snap = this.get(snapId);
@@ -1263,8 +1263,8 @@ export class SnapController extends BaseController {
                 result[snapId] = await this.#processRequestedSnap(origin, snapId, location, version);
             }
             // Once we finish all installs / updates, emit events.
-            pendingInstalls.forEach((snapId) => this.messagingSystem.publish(`SnapController:snapInstalled`, this.getTruncatedExpect(snapId), origin, false));
-            pendingUpdates.forEach(({ snapId, oldVersion }) => this.messagingSystem.publish(`SnapController:snapUpdated`, this.getTruncatedExpect(snapId), oldVersion, origin, false));
+            pendingInstalls.forEach((snapId) => this.messenger.publish(`SnapController:snapInstalled`, this.getTruncatedExpect(snapId), origin, false));
+            pendingUpdates.forEach(({ snapId, oldVersion }) => this.messenger.publish(`SnapController:snapUpdated`, this.getTruncatedExpect(snapId), oldVersion, origin, false));
             snapIds.forEach((snapId) => this.#rollbackSnapshots.delete(snapId));
         }
         catch (error) {
@@ -1309,7 +1309,7 @@ export class SnapController extends BaseController {
             snapId,
             type: SNAP_APPROVAL_INSTALL,
         });
-        this.messagingSystem.publish('SnapController:snapInstallStarted', snapId, origin, false);
+        this.messenger.publish('SnapController:snapInstallStarted', snapId, origin, false);
         // Existing snaps must be stopped before overwriting
         if (existingSnap && this.isRunning(snapId)) {
             await this.stopSnap(snapId, SnapStatusEvents.Stop);
@@ -1350,13 +1350,13 @@ export class SnapController extends BaseController {
                 type: SNAP_APPROVAL_INSTALL,
                 error: errorString,
             });
-            this.messagingSystem.publish('SnapController:snapInstallFailed', snapId, origin, false, errorString);
+            this.messenger.publish('SnapController:snapInstallFailed', snapId, origin, false, errorString);
             throw error;
         }
     }
     #createApproval({ origin, snapId, type, }) {
         const id = nanoid();
-        const promise = this.messagingSystem.call('ApprovalController:addRequest', {
+        const promise = this.messenger.call('ApprovalController:addRequest', {
             origin,
             id,
             type,
@@ -1373,7 +1373,7 @@ export class SnapController extends BaseController {
     }
     #updateApproval(id, requestState) {
         try {
-            this.messagingSystem.call('ApprovalController:updateRequestState', {
+            this.messenger.call('ApprovalController:updateRequestState', {
                 id,
                 requestState,
             });
@@ -1419,7 +1419,7 @@ export class SnapController extends BaseController {
                 type: SNAP_APPROVAL_UPDATE,
             });
         try {
-            this.messagingSystem.publish('SnapController:snapInstallStarted', snapId, origin, true);
+            this.messenger.publish('SnapController:snapInstallStarted', snapId, origin, true);
             const oldManifest = snap.manifest;
             const newSnap = await fetchSnap(snapId, location);
             const { sourceCode: sourceCodeFile, manifest: manifestFile } = newSnap;
@@ -1527,12 +1527,12 @@ export class SnapController extends BaseController {
                     type: SNAP_APPROVAL_UPDATE,
                 });
             }
-            this.messagingSystem.publish('SnapController:snapInstallFailed', snapId, origin, true, errorString);
+            this.messenger.publish('SnapController:snapInstallFailed', snapId, origin, true, errorString);
             throw error;
         }
     }
     async #resolveAllowlistVersion(snapId, versionRange) {
-        return await this.messagingSystem.call('SnapsRegistry:resolveVersion', snapId, versionRange);
+        return await this.messenger.call('SnapsRegistry:resolveVersion', snapId, versionRange);
     }
     /**
      * Returns a promise representing the complete installation of the requested snap.
@@ -1595,7 +1595,7 @@ export class SnapController extends BaseController {
         }
         try {
             const runtime = this.#getRuntimeExpect(snapId);
-            const result = await this.messagingSystem.call('ExecutionService:executeSnap', {
+            const result = await this.messenger.call('ExecutionService:executeSnap', {
                 ...snapData,
                 endowments: await this.#getEndowments(snapId),
             });
@@ -1623,8 +1623,8 @@ export class SnapController extends BaseController {
     async #getEndowments(snapId) {
         let allEndowments = [];
         for (const permissionName of this.#environmentEndowmentPermissions) {
-            if (this.messagingSystem.call('PermissionController:hasPermission', snapId, permissionName)) {
-                const endowments = await this.messagingSystem.call('PermissionController:getEndowments', snapId, permissionName);
+            if (this.messenger.call('PermissionController:hasPermission', snapId, permissionName)) {
+                const endowments = await this.messenger.call('PermissionController:getEndowments', snapId, permissionName);
                 if (endowments) {
                     // We don't have any guarantees about the type of the endowments
                     // value, so we have to guard at runtime.
@@ -1724,7 +1724,7 @@ export class SnapController extends BaseController {
         // In case the Snap uses a localized manifest, we need to get the
         // proposed name from the localized manifest.
         const { proposedName } = getLocalizedSnapManifest(manifest.result, 'en', localizedFiles);
-        this.messagingSystem.call('SubjectMetadataController:addSubjectMetadata', {
+        this.messenger.call('SubjectMetadataController:addSubjectMetadata', {
             subjectType: SubjectType.Snap,
             name: proposedName,
             origin: snap.id,
@@ -1810,11 +1810,11 @@ export class SnapController extends BaseController {
             clearTimeout(this.#timeoutForLastRequestStatus);
         }
         /* eslint-disable @typescript-eslint/unbound-method */
-        this.messagingSystem.unsubscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
-        this.messagingSystem.unsubscribe('ExecutionService:outboundRequest', this._onOutboundRequest);
-        this.messagingSystem.unsubscribe('ExecutionService:outboundResponse', this._onOutboundResponse);
-        this.messagingSystem.clearEventSubscriptions('SnapController:snapInstalled');
-        this.messagingSystem.clearEventSubscriptions('SnapController:snapUpdated');
+        this.messenger.unsubscribe('ExecutionService:unhandledError', this._onUnhandledSnapError);
+        this.messenger.unsubscribe('ExecutionService:outboundRequest', this._onOutboundRequest);
+        this.messenger.unsubscribe('ExecutionService:outboundResponse', this._onOutboundResponse);
+        this.messenger.clearEventSubscriptions('SnapController:snapInstalled');
+        this.messenger.clearEventSubscriptions('SnapController:snapUpdated');
         /* eslint-enable @typescript-eslint/unbound-method */
     }
     /**
@@ -1840,7 +1840,7 @@ export class SnapController extends BaseController {
         assertIsJsonRpcRequest(request);
         const permissionName = handlerEndowments[handlerType];
         assert(typeof permissionName === 'string' || permissionName === null, "'permissionName' must be either a string or null.");
-        const permissions = this.messagingSystem.call('PermissionController:getPermissions', snapId);
+        const permissions = this.messenger.call('PermissionController:getPermissions', snapId);
         // If permissionName is null, the handler does not require a permission.
         if (permissionName !== null &&
             (!permissions || !hasProperty(permissions, permissionName))) {
@@ -1852,7 +1852,7 @@ export class SnapController extends BaseController {
         if (permissionName === SnapEndowments.Rpc ||
             permissionName === SnapEndowments.Keyring) {
             assert(handlerPermissions);
-            const subject = this.messagingSystem.call('SubjectMetadataController:getSubjectMetadata', origin);
+            const subject = this.messenger.call('SubjectMetadataController:getSubjectMetadata', origin);
             const origins = permissionName === SnapEndowments.Rpc
                 ? getRpcCaveatOrigins(handlerPermissions)
                 : getKeyringCaveatOrigins(handlerPermissions);
@@ -1890,7 +1890,7 @@ export class SnapController extends BaseController {
         const transformedRequest = this.#transformSnapRpcRequest(snapId, handlerType, request);
         const timer = new Timer(timeout);
         this.#recordSnapRpcRequestStart(snapId, transformedRequest.id, timer);
-        const handleRpcRequestPromise = this.messagingSystem.call('ExecutionService:handleRpcRequest', snapId, { origin, handler: handlerType, request: transformedRequest });
+        const handleRpcRequestPromise = this.messenger.call('ExecutionService:handleRpcRequest', snapId, { origin, handler: handlerType, request: transformedRequest });
         // This will either get the result or reject due to the timeout.
         try {
             const result = await withTimeout(handleRpcRequestPromise, timer);
@@ -1954,11 +1954,11 @@ export class SnapController extends BaseController {
      * @returns An identifier that can be used to identify the interface.
      */
     async #createInterface(snapId, content, contentType) {
-        return this.messagingSystem.call('SnapInterfaceController:createInterface', snapId, content, undefined, contentType);
+        return this.messenger.call('SnapInterfaceController:createInterface', snapId, content, undefined, contentType);
     }
     #assertInterfaceExists(snapId, id) {
         // This will throw if the interface isn't accessible, but we assert nevertheless.
-        assert(this.messagingSystem.call('SnapInterfaceController:getInterface', snapId, id));
+        assert(this.messenger.call('SnapInterfaceController:getInterface', snapId, id));
     }
     /**
      * Transform a RPC response if necessary.
@@ -2012,7 +2012,7 @@ export class SnapController extends BaseController {
      * @returns The transformed result.
      */
     #transformOnAssetsLookupResult(snapId, { params: requestedParams }, { assets }) {
-        const permissions = this.messagingSystem.call('PermissionController:getPermissions', snapId);
+        const permissions = this.messenger.call('PermissionController:getPermissions', snapId);
         // We know the permissions are guaranteed to be set here.
         assert(permissions);
         const permission = permissions[SnapEndowments.Assets];
@@ -2095,7 +2095,7 @@ export class SnapController extends BaseController {
             case HandlerType.OnUserInput: {
                 assert(request.params && hasProperty(request.params, 'id'));
                 const interfaceId = request.params.id;
-                const { context } = this.messagingSystem.call('SnapInterfaceController:getInterface', snapId, interfaceId);
+                const { context } = this.messenger.call('SnapInterfaceController:getInterface', snapId, interfaceId);
                 return {
                     ...request,
                     params: { ...request.params, context },
@@ -2251,7 +2251,7 @@ export class SnapController extends BaseController {
         // Calling this in reverse order to undo the changes
         this.#handleInitialConnections(snapId, newInitialConnections ?? null, previousInitialConnections ?? {});
         const truncatedSnap = this.getTruncatedExpect(snapId);
-        this.messagingSystem.publish('SnapController:snapRolledback', truncatedSnap, rollbackSnapshot.newVersion);
+        this.messenger.publish('SnapController:snapRolledback', truncatedSnap, rollbackSnapshot.newVersion);
         this.#rollbackSnapshots.delete(snapId);
     }
     /**
@@ -2301,7 +2301,7 @@ export class SnapController extends BaseController {
         });
     }
     #calculatePermissionsChange(snapId, desiredPermissionsSet) {
-        const oldPermissions = this.messagingSystem.call('PermissionController:getPermissions', snapId) ?? {};
+        const oldPermissions = this.messenger.call('PermissionController:getPermissions', snapId) ?? {};
         const newPermissions = permissionsDiff(desiredPermissionsSet, oldPermissions);
         // TODO(ritave): The assumption that these are unused only holds so long as we do not
         //               permit dynamic permission requests.
@@ -2312,7 +2312,7 @@ export class SnapController extends BaseController {
         return { newPermissions, unusedPermissions, approvedPermissions };
     }
     #isSubjectConnectedToSnap(snapId, origin) {
-        const subjectPermissions = this.messagingSystem.call('PermissionController:getPermissions', origin);
+        const subjectPermissions = this.messenger.call('PermissionController:getPermissions', origin);
         const existingCaveat = subjectPermissions?.[WALLET_SNAP_PERMISSION_KEY]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds);
         return Boolean(existingCaveat?.value?.[snapId]);
     }
@@ -2344,8 +2344,8 @@ export class SnapController extends BaseController {
         if (Object.keys(newPermissions).includes(SnapEndowments.EthereumProvider)) {
             // This will return the globally selected network if the Snap doesn't have
             // one set.
-            const networkClientId = this.messagingSystem.call('SelectedNetworkController:getNetworkClientIdForDomain', snapId);
-            const { configuration } = this.messagingSystem.call('NetworkController:getNetworkClientById', networkClientId);
+            const networkClientId = this.messenger.call('SelectedNetworkController:getNetworkClientIdForDomain', snapId);
+            const { configuration } = this.messenger.call('NetworkController:getNetworkClientById', networkClientId);
             const chainId = hexToNumber(configuration.chainId);
             // This needs to be assigned to have proper type inference.
             const modifiedPermissions = {
@@ -2386,13 +2386,13 @@ export class SnapController extends BaseController {
     #updatePermissions({ snapId, unusedPermissions = {}, newPermissions = {}, requestData, }) {
         const unusedPermissionsKeys = Object.keys(unusedPermissions);
         if (isNonEmptyArray(unusedPermissionsKeys)) {
-            this.messagingSystem.call('PermissionController:revokePermissions', {
+            this.messenger.call('PermissionController:revokePermissions', {
                 [snapId]: unusedPermissionsKeys,
             });
         }
         if (isNonEmptyArray(Object.keys(newPermissions))) {
             const approvedPermissions = this.#getPermissionsToGrant(snapId, newPermissions);
-            this.messagingSystem.call('PermissionController:grantPermissions', {
+            this.messenger.call('PermissionController:grantPermissions', {
                 approvedPermissions,
                 subject: { origin: snapId },
                 requestData,
@@ -2434,7 +2434,7 @@ export class SnapController extends BaseController {
     #callLifecycleHooks(origin, handler) {
         const snaps = this.getRunnableSnaps();
         for (const { id } of snaps) {
-            const hasLifecycleHooksEndowment = this.messagingSystem.call('PermissionController:hasPermission', id, SnapEndowments.LifecycleHooks);
+            const hasLifecycleHooksEndowment = this.messenger.call('PermissionController:hasPermission', id, SnapEndowments.LifecycleHooks);
             if (!hasLifecycleHooksEndowment) {
                 continue;
             }
@@ -2457,7 +2457,7 @@ export class SnapController extends BaseController {
     async #callLifecycleHook(origin, snapId, handler) {
         const permissionName = handlerEndowments[handler];
         assert(permissionName, 'Lifecycle hook must have an endowment.');
-        const hasPermission = this.messagingSystem.call('PermissionController:hasPermission', snapId, permissionName);
+        const hasPermission = this.messenger.call('PermissionController:hasPermission', snapId, permissionName);
         if (!hasPermission) {
             return;
         }
diff --git a/dist/snaps/SnapController.mjs.map b/dist/snaps/SnapController.mjs.map
index c8a54e3056100c0320c9714609cea875c9377bf2..ace168886ccab8052a54ddcbfbd626210eaa32ff 100644
--- a/dist/snaps/SnapController.mjs.map
+++ b/dist/snaps/SnapController.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"SnapController.mjs","sourceRoot":"","sources":["../../src/snaps/SnapController.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ORIGIN_METAMASK,\n  type AddApprovalRequest,\n  type UpdateRequestState,\n} from '@metamask/approval-controller';\nimport type {\n  RestrictedMessenger,\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { CryptographicFunctions } from '@metamask/key-tree';\nimport type {\n  Caveat,\n  GetEndowments,\n  GetPermissions,\n  GetSubjectMetadata,\n  AddSubjectMetadata,\n  GetSubjects,\n  GrantPermissions,\n  HasPermission,\n  HasPermissions,\n  PermissionConstraint,\n  PermissionsRequest,\n  RequestedPermissions,\n  RevokeAllPermissions,\n  RevokePermissionForAllSubjects,\n  RevokePermissions,\n  SubjectPermissions,\n  UpdateCaveat,\n  ValidPermission,\n} from '@metamask/permission-controller';\nimport { SubjectType } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { BlockReason } from '@metamask/snaps-registry';\nimport {\n  WALLET_SNAP_PERMISSION_KEY,\n  getMaxRequestTimeCaveat,\n  handlerEndowments,\n  SnapEndowments,\n  getKeyringCaveatOrigins,\n  getRpcCaveatOrigins,\n  processSnapPermissions,\n  getEncryptionEntropy,\n  getChainIdsCaveat,\n} from '@metamask/snaps-rpc-methods';\nimport type {\n  RequestSnapsParams,\n  RequestSnapsResult,\n  SnapId,\n  ComponentOrElement,\n  ContentType,\n  OnAssetsLookupResponse,\n  OnAssetsConversionResponse,\n  OnAssetsConversionArguments,\n  AssetConversion,\n  OnAssetsLookupArguments,\n  OnAssetsMarketDataArguments,\n  OnAssetsMarketDataResponse,\n  AssetMarketData,\n  AssetMetadata,\n  EmptyObject,\n} from '@metamask/snaps-sdk';\nimport {\n  AuxiliaryFileEncoding,\n  getErrorMessage,\n  OnAssetsLookupResponseStruct,\n} from '@metamask/snaps-sdk';\nimport type {\n  FetchedSnapFiles,\n  InitialConnections,\n  PersistedSnap,\n  Snap,\n  SnapManifest,\n  SnapPermissions,\n  SnapRpcHookArgs,\n  StatusContext,\n  StatusEvents,\n  StatusStates,\n  TruncatedSnap,\n  TruncatedSnapFields,\n} from '@metamask/snaps-utils';\nimport {\n  logWarning,\n  getPlatformVersion,\n  assertIsSnapManifest,\n  assertIsValidSnapId,\n  DEFAULT_ENDOWMENTS,\n  encodeAuxiliaryFile,\n  HandlerType,\n  isOriginAllowed,\n  logError,\n  normalizeRelative,\n  OnTransactionResponseStruct,\n  OnSignatureResponseStruct,\n  resolveVersionRange,\n  SnapCaveatType,\n  SnapStatus,\n  SnapStatusEvents,\n  unwrapError,\n  OnHomePageResponseStruct,\n  getValidatedLocalizationFiles,\n  VirtualFile,\n  NpmSnapFileNames,\n  OnNameLookupResponseStruct,\n  getLocalizedSnapManifest,\n  MAX_FILE_SIZE,\n  OnSettingsPageResponseStruct,\n  isValidUrl,\n  OnAssetHistoricalPriceResponseStruct,\n  OnAssetsConversionResponseStruct,\n  OnAssetsMarketDataResponseStruct,\n} from '@metamask/snaps-utils';\nimport type {\n  Json,\n  NonEmptyArray,\n  SemVerRange,\n  CaipAssetType,\n  JsonRpcRequest,\n  Hex,\n  SemVerVersion,\n  CaipAssetTypeOrId,\n} from '@metamask/utils';\nimport {\n  hexToNumber,\n  assert,\n  assertIsJsonRpcRequest,\n  assertStruct,\n  Duration,\n  gtRange,\n  gtVersion,\n  hasProperty,\n  inMilliseconds,\n  isNonEmptyArray,\n  satisfiesVersionRange,\n  timeSince,\n  createDeferredPromise,\n} from '@metamask/utils';\nimport type { StateMachine } from '@xstate/fsm';\nimport { createMachine, interpret } from '@xstate/fsm';\nimport { Mutex } from 'async-mutex';\nimport type { Patch } from 'immer';\nimport { nanoid } from 'nanoid';\nimport { gt, gte } from 'semver';\n\nimport {\n  ALLOWED_PERMISSIONS,\n  CLIENT_ONLY_HANDLERS,\n  LEGACY_ENCRYPTION_KEY_DERIVATION_OPTIONS,\n  METAMASK_ORIGIN,\n  STATE_DEBOUNCE_TIMEOUT,\n} from './constants';\nimport type { SnapLocation } from './location';\nimport { detectSnapLocation } from './location';\nimport type {\n  GetMetadata,\n  GetResult,\n  ResolveVersion,\n  SnapsRegistryInfo,\n  SnapsRegistryRequest,\n  Update,\n} from './registry';\nimport { SnapsRegistryStatus } from './registry';\nimport { getRunnableSnaps } from './selectors';\nimport { Timer } from './Timer';\nimport { forceStrict, validateMachine } from '../fsm';\nimport type { CreateInterface, GetInterface } from '../interface';\nimport { log } from '../logging';\nimport type {\n  ExecuteSnapAction,\n  ExecutionServiceEvents,\n  HandleRpcRequestAction,\n  SnapErrorJson,\n  TerminateSnapAction,\n} from '../services';\nimport type {\n  EncryptionResult,\n  ExportableKeyEncryptor,\n  KeyDerivationOptions,\n} from '../types';\nimport {\n  debouncePersistState,\n  fetchSnap,\n  hasTimedOut,\n  permissionsDiff,\n  setDiff,\n  throttleTracking,\n  withTimeout,\n  isTrackableHandler,\n  isLocalSnapId,\n} from '../utils';\n\nexport const controllerName = 'SnapController';\n\n// TODO: Figure out how to name these\nexport const SNAP_APPROVAL_INSTALL = 'wallet_installSnap';\nexport const SNAP_APPROVAL_UPDATE = 'wallet_updateSnap';\nexport const SNAP_APPROVAL_RESULT = 'wallet_installSnapResult';\n\nconst TRUNCATED_SNAP_PROPERTIES = new Set<TruncatedSnapFields>([\n  'initialPermissions',\n  'id',\n  'version',\n  'enabled',\n  'blocked',\n]);\n\nexport type PendingRequest = {\n  requestId: unknown;\n  timer: Timer;\n};\n\nexport type PreinstalledSnapFile = {\n  path: string;\n  value: string | Uint8Array;\n};\n\nexport type PreinstalledSnap = {\n  snapId: SnapId;\n  manifest: SnapManifest;\n  files: PreinstalledSnapFile[];\n  removable?: boolean;\n  hidden?: boolean;\n  hideSnapBranding?: boolean;\n};\n\n/**\n * A wrapper type for any data stored during runtime of Snaps.\n * It is not persisted in state as it contains non-serializable data and is only relevant for the\n * current session.\n */\nexport type SnapRuntimeData = {\n  /**\n   * A promise that resolves when the Snap has finished installing\n   */\n  installPromise: null | Promise<PersistedSnap>;\n\n  /**\n   * A promise that resolves when the Snap has finished booting\n   */\n  startPromise: null | Promise<void>;\n\n  /**\n   * A promise that resolves when the Snap has finished stopping\n   */\n  stopPromise: null | Promise<void>;\n\n  /**\n   * A Unix timestamp for the last time the Snap received an RPC request\n   */\n  lastRequest: null | number;\n\n  /**\n   * The current number of active references where this Snap is being used\n   */\n  activeReferences: number;\n\n  /**\n   * The current pending inbound requests, meaning requests that are processed by snaps.\n   */\n  pendingInboundRequests: PendingRequest[];\n\n  /**\n   * The current pending outbound requests, meaning requests made from snaps towards the MetaMask\n   * extension.\n   */\n  pendingOutboundRequests: number;\n\n  /**\n   * The finite state machine interpreter for possible states that the Snap can be in such as\n   * stopped, running, blocked\n   *\n   * @see {@link SnapController:constructor}\n   */\n  interpreter: StateMachine.Service<StatusContext, StatusEvents, StatusStates>;\n\n  /**\n   * Cached encryption key used for state encryption.\n   */\n  encryptionKey: string | null;\n\n  /**\n   * Cached encryption salt used for state encryption.\n   */\n  encryptionSalt: string | null;\n\n  /**\n   * Cached encrypted state of the Snap.\n   */\n  state?: Record<string, Json> | null;\n\n  /**\n   * Cached unencrypted state of the Snap.\n   */\n  unencryptedState?: Record<string, Json> | null;\n\n  /**\n   * A mutex to prevent concurrent state updates.\n   */\n  stateMutex: Mutex;\n\n  /**\n   * A mutex to prevent concurrent state decryption.\n   */\n  getStateMutex: Mutex;\n};\n\nexport type SnapError = {\n  message: string;\n  code: number;\n  data?: Json;\n};\n\n// Types that probably should be defined elsewhere in prod\ntype CloseAllConnectionsFunction = (origin: string) => void;\ntype StoredSnaps = Record<SnapId, Snap>;\n\nexport type SnapControllerState = {\n  snaps: StoredSnaps;\n  snapStates: Record<SnapId, string | null>;\n  unencryptedSnapStates: Record<SnapId, string | null>;\n};\n\nexport type PersistedSnapControllerState = SnapControllerState & {\n  snaps: Record<SnapId, PersistedSnap>;\n  snapStates: Record<SnapId, string>;\n};\n\ntype RollbackSnapshot = {\n  statePatches: Patch[];\n  permissions: {\n    revoked?: SubjectPermissions<ValidPermission<string, Caveat<string, any>>>;\n    granted?: RequestedPermissions;\n    requestData?: Record<string, unknown>;\n  };\n  previousInitialConnections?: Record<string, EmptyObject> | null;\n  newInitialConnections?: Record<string, EmptyObject>;\n  newVersion: string;\n};\n\ntype PendingApproval = {\n  id: string;\n  promise: Promise<unknown>;\n};\n\n// Controller Messenger Actions\n\n/**\n * Initialise the SnapController. This should be called after all controllers\n * are created.\n */\nexport type SnapControllerInitAction = {\n  type: `${typeof controllerName}:init`;\n  handler: SnapController['init'];\n};\n\n/**\n * Gets the specified Snap from state.\n */\nexport type GetSnap = {\n  type: `${typeof controllerName}:get`;\n  handler: SnapController['get'];\n};\n\n/**\n * Handles sending an inbound request to a snap and returns its result.\n */\nexport type HandleSnapRequest = {\n  type: `${typeof controllerName}:handleRequest`;\n  handler: SnapController['handleRequest'];\n};\n\n/**\n * Gets the specified Snap's persisted state.\n */\nexport type GetSnapState = {\n  type: `${typeof controllerName}:getSnapState`;\n  handler: SnapController['getSnapState'];\n};\n\n/**\n * Checks if the specified snap exists in state.\n */\nexport type HasSnap = {\n  type: `${typeof controllerName}:has`;\n  handler: SnapController['has'];\n};\n\n/**\n * Updates the specified Snap's persisted state.\n */\nexport type UpdateSnapState = {\n  type: `${typeof controllerName}:updateSnapState`;\n  handler: SnapController['updateSnapState'];\n};\n\n/**\n * Clears the specified Snap's persisted state.\n */\nexport type ClearSnapState = {\n  type: `${typeof controllerName}:clearSnapState`;\n  handler: SnapController['clearSnapState'];\n};\n\n/**\n * Checks all installed snaps against the blocklist.\n */\nexport type UpdateRegistry = {\n  type: `${typeof controllerName}:updateRegistry`;\n  handler: SnapController['updateRegistry'];\n};\n\nexport type EnableSnap = {\n  type: `${typeof controllerName}:enable`;\n  handler: SnapController['enableSnap'];\n};\n\nexport type DisableSnap = {\n  type: `${typeof controllerName}:disable`;\n  handler: SnapController['disableSnap'];\n};\n\nexport type RemoveSnap = {\n  type: `${typeof controllerName}:remove`;\n  handler: SnapController['removeSnap'];\n};\n\nexport type GetPermittedSnaps = {\n  type: `${typeof controllerName}:getPermitted`;\n  handler: SnapController['getPermittedSnaps'];\n};\n\nexport type GetAllSnaps = {\n  type: `${typeof controllerName}:getAll`;\n  handler: SnapController['getAllSnaps'];\n};\n\nexport type GetRunnableSnaps = {\n  type: `${typeof controllerName}:getRunnableSnaps`;\n  handler: SnapController['getRunnableSnaps'];\n};\n\nexport type StopAllSnaps = {\n  type: `${typeof controllerName}:stopAllSnaps`;\n  handler: SnapController['stopAllSnaps'];\n};\n\nexport type IncrementActiveReferences = {\n  type: `${typeof controllerName}:incrementActiveReferences`;\n  handler: SnapController['incrementActiveReferences'];\n};\n\nexport type DecrementActiveReferences = {\n  type: `${typeof controllerName}:decrementActiveReferences`;\n  handler: SnapController['decrementActiveReferences'];\n};\n\nexport type InstallSnaps = {\n  type: `${typeof controllerName}:install`;\n  handler: SnapController['installSnaps'];\n};\n\nexport type DisconnectOrigin = {\n  type: `${typeof controllerName}:disconnectOrigin`;\n  handler: SnapController['removeSnapFromSubject'];\n};\n\nexport type RevokeDynamicPermissions = {\n  type: `${typeof controllerName}:revokeDynamicPermissions`;\n  handler: SnapController['revokeDynamicSnapPermissions'];\n};\n\nexport type GetSnapFile = {\n  type: `${typeof controllerName}:getFile`;\n  handler: SnapController['getSnapFile'];\n};\n\nexport type IsMinimumPlatformVersion = {\n  type: `${typeof controllerName}:isMinimumPlatformVersion`;\n  handler: SnapController['isMinimumPlatformVersion'];\n};\n\nexport type SetClientActive = {\n  type: `${typeof controllerName}:setClientActive`;\n  handler: SnapController['setClientActive'];\n};\n\nexport type SnapControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapControllerState\n>;\n\nexport type SnapControllerActions =\n  | SnapControllerInitAction\n  | ClearSnapState\n  | GetSnap\n  | GetSnapState\n  | HandleSnapRequest\n  | HasSnap\n  | UpdateRegistry\n  | UpdateSnapState\n  | EnableSnap\n  | DisableSnap\n  | RemoveSnap\n  | GetPermittedSnaps\n  | InstallSnaps\n  | GetAllSnaps\n  | GetRunnableSnaps\n  | IncrementActiveReferences\n  | DecrementActiveReferences\n  | DisconnectOrigin\n  | RevokeDynamicPermissions\n  | GetSnapFile\n  | SnapControllerGetStateAction\n  | StopAllSnaps\n  | IsMinimumPlatformVersion\n  | SetClientActive;\n\n// Controller Messenger Events\n\nexport type SnapStateChange = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [SnapControllerState, Patch[]];\n};\n\n/**\n * Emitted when an installed snap has been blocked.\n */\nexport type SnapBlocked = {\n  type: `${typeof controllerName}:snapBlocked`;\n  payload: [snapId: string, blockedSnapInfo?: BlockReason];\n};\n\n/**\n * Emitted when a snap installation or update is started.\n */\nexport type SnapInstallStarted = {\n  type: `${typeof controllerName}:snapInstallStarted`;\n  payload: [snapId: SnapId, origin: string, isUpdate: boolean];\n};\n\n/**\n * Emitted when a snap installation or update failed.\n */\nexport type SnapInstallFailed = {\n  type: `${typeof controllerName}:snapInstallFailed`;\n  payload: [snapId: SnapId, origin: string, isUpdate: boolean, error: string];\n};\n\n/**\n * Emitted when a snap has been started after being added and authorized during\n * installation.\n */\nexport type SnapInstalled = {\n  type: `${typeof controllerName}:snapInstalled`;\n  payload: [snap: TruncatedSnap, origin: string, preinstalled: boolean];\n};\n\n/**\n * Emitted when a snap that has previously been fully installed, is uninstalled.\n */\nexport type SnapUninstalled = {\n  type: `${typeof controllerName}:snapUninstalled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when an installed snap has been unblocked.\n */\nexport type SnapUnblocked = {\n  type: `${typeof controllerName}:snapUnblocked`;\n  payload: [snapId: string];\n};\n\n/**\n * Emitted when a snap is updated.\n */\nexport type SnapUpdated = {\n  type: `${typeof controllerName}:snapUpdated`;\n  payload: [\n    snap: TruncatedSnap,\n    oldVersion: string,\n    origin: string,\n    preinstalled: boolean,\n  ];\n};\n\n/**\n * Emitted when a snap is rolled back.\n */\nexport type SnapRolledback = {\n  type: `${typeof controllerName}:snapRolledback`;\n  payload: [snap: TruncatedSnap, failedVersion: string];\n};\n\n/**\n * Emitted when a Snap is terminated. This is different from the snap being\n * stopped as it can also be triggered when a snap fails initialization.\n */\nexport type SnapTerminated = {\n  type: `${typeof controllerName}:snapTerminated`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when a Snap is enabled by a user.\n * This is not emitted by default when installing a snap.\n */\nexport type SnapEnabled = {\n  type: `${typeof controllerName}:snapEnabled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when a Snap is disabled by a user.\n */\nexport type SnapDisabled = {\n  type: `${typeof controllerName}:snapDisabled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when there is a state change.\n */\nexport type SnapControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  SnapControllerState\n>;\n\ntype KeyringControllerLock = {\n  type: 'KeyringController:lock';\n  payload: [];\n};\n\nexport type SnapControllerEvents =\n  | SnapBlocked\n  | SnapInstalled\n  | SnapUninstalled\n  | SnapInstallStarted\n  | SnapInstallFailed\n  | SnapStateChange\n  | SnapUnblocked\n  | SnapUpdated\n  | SnapRolledback\n  | SnapTerminated\n  | SnapEnabled\n  | SnapDisabled\n  | SnapControllerStateChangeEvent;\n\ntype NetworkControllerGetNetworkClientById = {\n  type: `NetworkController:getNetworkClientById`;\n  handler: (customNetworkClientId: string) => {\n    configuration: {\n      chainId: Hex;\n    };\n  };\n};\n\ntype SelectedNetworkControllerGetNetworkClientIdForDomain = {\n  type: `SelectedNetworkController:getNetworkClientIdForDomain`;\n  handler: (domain: string) => string;\n};\n\nexport type AllowedActions =\n  | GetEndowments\n  | GetPermissions\n  | GetSubjects\n  | GetSubjectMetadata\n  | AddSubjectMetadata\n  | HasPermission\n  | HasPermissions\n  | RevokePermissions\n  | RevokeAllPermissions\n  | RevokePermissionForAllSubjects\n  | GrantPermissions\n  | AddApprovalRequest\n  | HandleRpcRequestAction\n  | ExecuteSnapAction\n  | TerminateSnapAction\n  | UpdateCaveat\n  | UpdateRequestState\n  | GetResult\n  | GetMetadata\n  | Update\n  | ResolveVersion\n  | CreateInterface\n  | GetInterface\n  | NetworkControllerGetNetworkClientById\n  | SelectedNetworkControllerGetNetworkClientIdForDomain;\n\nexport type AllowedEvents =\n  | ExecutionServiceEvents\n  | SnapInstalled\n  | SnapUpdated\n  | KeyringControllerLock;\n\ntype SnapControllerMessenger = RestrictedMessenger<\n  typeof controllerName,\n  SnapControllerActions | AllowedActions,\n  SnapControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\ntype FeatureFlags = {\n  requireAllowlist?: boolean;\n  allowLocalSnaps?: boolean;\n  disableSnapInstallation?: boolean;\n  rejectInvalidPlatformVersion?: boolean;\n\n  /**\n   * Force any local Snap to be treated as a preinstalled Snap.\n   *\n   * This should only be used for local testing, and should not be enabled in\n   * any production builds (including beta and Flask).\n   */\n  forcePreinstalledSnaps?: boolean;\n\n  /**\n   * Automatically update preinstalled Snaps \"over the air\",\n   * when a new version of the Snap is added to the registry.\n   */\n  autoUpdatePreinstalledSnaps?: boolean;\n};\n\ntype DynamicFeatureFlags = {\n  disableSnaps?: boolean;\n};\n\ntype SnapControllerArgs = {\n  /**\n   * A teardown function that allows the host to clean up its instrumentation\n   * for a running snap.\n   */\n  closeAllConnections?: CloseAllConnectionsFunction;\n\n  /**\n   * A list of permissions that are allowed to be dynamic, meaning they can be revoked from the snap whenever.\n   */\n  dynamicPermissions?: string[];\n\n  /**\n   * The names of endowment permissions whose values are the names of JavaScript\n   * APIs that will be added to the snap execution environment at runtime.\n   */\n  environmentEndowmentPermissions?: string[];\n\n  /**\n   * Excluded permissions with its associated error message used to forbid certain permissions.\n   */\n  excludedPermissions?: Record<string, string>;\n\n  /**\n   * The function that will be used by the controller fo make network requests.\n   * Should be compatible with {@link fetch}.\n   */\n  fetchFunction?: typeof fetch;\n\n  /**\n   * Flags that enable or disable features in the controller.\n   * See {@link FeatureFlags}.\n   */\n  featureFlags: FeatureFlags;\n\n  /**\n   * How frequently to check whether a snap is idle.\n   */\n  idleTimeCheckInterval?: number;\n\n  /**\n   * The maximum amount of time that a snap may be idle.\n   */\n  maxIdleTime?: number;\n\n  /**\n   * The controller messenger.\n   */\n  messenger: SnapControllerMessenger;\n\n  /**\n   * The maximum amount of time a snap may take to process an RPC request,\n   * unless it is permitted to take longer.\n   */\n  maxRequestTime?: number;\n\n  /**\n   * The npm registry URL that will be used to fetch published snaps.\n   */\n  npmRegistryUrl?: string;\n\n  /**\n   * Persisted state that will be used for rehydration.\n   */\n  state?: PersistedSnapControllerState;\n\n  /**\n   * A function that takes Snap Id and converts it into a class that fetches files.\n   *\n   * Used for test overrides.\n   */\n  detectSnapLocation?: typeof detectSnapLocation;\n\n  /**\n   * A list of snaps to be preinstalled into the SnapController state on initialization.\n   */\n  preinstalledSnaps?: PreinstalledSnap[] | null;\n\n  /**\n   * A utility object containing functions required for state encryption.\n   */\n  encryptor: ExportableKeyEncryptor;\n\n  /**\n   * A hook to access the mnemonic seed of the user's primary keyring.\n   *\n   * @returns The mnemonic seed as bytes.\n   */\n  getMnemonicSeed: () => Promise<Uint8Array>;\n\n  /**\n   * A hook to get dynamic feature flags at runtime.\n   *\n   * @returns The feature flags.\n   */\n  getFeatureFlags: () => DynamicFeatureFlags;\n\n  /**\n   * The cryptographic functions to use for the client. This may be an empty\n   * object to fall back to the default cryptographic functions.\n   */\n  clientCryptography?: CryptographicFunctions;\n\n  /**\n   * MetaMetrics event tracking hook.\n   */\n  trackEvent: TrackEventHook;\n};\n\ntype AddSnapArgs = {\n  id: SnapId;\n  origin: string;\n  location: SnapLocation;\n  versionRange: SemVerRange;\n};\n\n// When we set a snap, we need all required properties to be present and\n// validated.\ntype SetSnapArgs = Omit<AddSnapArgs, 'location' | 'versionRange'> & {\n  files: FetchedSnapFiles;\n  isUpdate?: boolean;\n  removable?: boolean;\n  preinstalled?: boolean;\n  hidden?: boolean;\n  hideSnapBranding?: boolean;\n};\n\ntype TrackingEventPayload = {\n  event: string;\n  category: string;\n  properties: Record<string, Json | undefined>;\n};\n\ntype TrackEventHook = (event: TrackingEventPayload) => void;\n\nconst defaultState: SnapControllerState = {\n  snaps: {},\n  snapStates: {},\n  unencryptedSnapStates: {},\n};\n\n/**\n * Truncates the properties of a snap to only ones that are easily serializable.\n *\n * @param snap - The snap to truncate.\n * @returns Object with serializable snap properties.\n */\nfunction truncateSnap(snap: Snap): TruncatedSnap {\n  const truncatedSnap = Object.keys(snap).reduce<Partial<TruncatedSnap>>(\n    (serialized, key) => {\n      if (TRUNCATED_SNAP_PROPERTIES.has(key as any)) {\n        serialized[key as keyof TruncatedSnap] = snap[\n          key as keyof TruncatedSnap\n        ] as any;\n      }\n\n      return serialized;\n    },\n    {},\n  );\n\n  return truncatedSnap as TruncatedSnap;\n}\n\n/*\n * A snap is initialized in three phases:\n * - Add: Loads the snap from a remote source and parses it.\n * - Authorize: Requests the snap's required permissions from the user.\n * - Start: Initializes the snap in its SES realm with the authorized permissions.\n */\n\nexport class SnapController extends BaseController<\n  typeof controllerName,\n  SnapControllerState,\n  SnapControllerMessenger\n> {\n  readonly #closeAllConnections?: CloseAllConnectionsFunction;\n\n  readonly #dynamicPermissions: string[];\n\n  readonly #environmentEndowmentPermissions: string[];\n\n  readonly #excludedPermissions: Record<string, string>;\n\n  readonly #featureFlags: FeatureFlags;\n\n  readonly #fetchFunction: typeof fetch;\n\n  readonly #idleTimeCheckInterval: number;\n\n  readonly #maxIdleTime: number;\n\n  // This property cannot be hash private yet because of tests.\n  // eslint-disable-next-line no-restricted-syntax\n  private readonly maxRequestTime: number;\n\n  readonly #encryptor: ExportableKeyEncryptor;\n\n  readonly #getMnemonicSeed: () => Promise<Uint8Array>;\n\n  readonly #getFeatureFlags: () => DynamicFeatureFlags;\n\n  readonly #clientCryptography: CryptographicFunctions | undefined;\n\n  readonly #detectSnapLocation: typeof detectSnapLocation;\n\n  readonly #snapsRuntimeData: Map<SnapId, SnapRuntimeData>;\n\n  readonly #rollbackSnapshots: Map<string, RollbackSnapshot>;\n\n  #timeoutForLastRequestStatus?: number;\n\n  #statusMachine!: StateMachine.Machine<\n    StatusContext,\n    StatusEvents,\n    StatusStates\n  >;\n\n  readonly #preinstalledSnaps: PreinstalledSnap[] | null;\n\n  readonly #trackEvent: TrackEventHook;\n\n  readonly #trackSnapExport: ReturnType<typeof throttleTracking>;\n\n  constructor({\n    closeAllConnections,\n    messenger,\n    state,\n    dynamicPermissions = ['eth_accounts'],\n    environmentEndowmentPermissions = [],\n    excludedPermissions = {},\n    idleTimeCheckInterval = inMilliseconds(5, Duration.Second),\n    maxIdleTime = inMilliseconds(30, Duration.Second),\n    maxRequestTime = inMilliseconds(60, Duration.Second),\n    fetchFunction = globalThis.fetch.bind(undefined),\n    featureFlags = {},\n    detectSnapLocation: detectSnapLocationFunction = detectSnapLocation,\n    preinstalledSnaps = null,\n    encryptor,\n    getMnemonicSeed,\n    getFeatureFlags = () => ({}),\n    clientCryptography,\n    trackEvent,\n  }: SnapControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        snapStates: {\n          includeInStateLogs: false,\n          persist: true,\n          anonymous: false,\n          usedInUi: false,\n        },\n        unencryptedSnapStates: {\n          includeInStateLogs: false,\n          persist: true,\n          anonymous: false,\n          usedInUi: false,\n        },\n        snaps: {\n          includeInStateLogs: (snaps) => {\n            // Delete larger snap properties\n            return Object.values(snaps).reduce<Record<SnapId, Partial<Snap>>>(\n              (acc, snap) => {\n                const snapCopy: Partial<Snap> = { ...snap };\n                delete snapCopy.sourceCode;\n                delete snapCopy.auxiliaryFiles;\n                acc[snap.id] = snapCopy;\n                return acc;\n              },\n              {},\n            );\n          },\n          persist: (snaps) => {\n            return (\n              Object.values(snaps)\n                // We should not persist snaps that are in the installing state,\n                // since they haven't completed installation and would be unusable\n                .filter((snap) => snap.status !== SnapStatus.Installing)\n                .map((snap) => {\n                  return {\n                    ...snap,\n                    // At the time state is rehydrated, no snap will be running.\n                    status: SnapStatus.Stopped,\n                  };\n                })\n                .reduce((memo: Record<SnapId, Snap>, snap) => {\n                  memo[snap.id] = snap;\n                  return memo;\n                }, {})\n            );\n          },\n          anonymous: false,\n          // TODO: Ensure larger snap properties are not sent to the UI\n          // Currently these are stripped out manually in the extension\n          usedInUi: true,\n        },\n      },\n      name: controllerName,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n\n    this.#closeAllConnections = closeAllConnections;\n    this.#dynamicPermissions = dynamicPermissions;\n    this.#environmentEndowmentPermissions = environmentEndowmentPermissions;\n    this.#excludedPermissions = excludedPermissions;\n    this.#featureFlags = featureFlags;\n    this.#fetchFunction = fetchFunction;\n    this.#idleTimeCheckInterval = idleTimeCheckInterval;\n    this.#maxIdleTime = maxIdleTime;\n    this.maxRequestTime = maxRequestTime;\n    this.#detectSnapLocation = detectSnapLocationFunction;\n    this.#encryptor = encryptor;\n    this.#getMnemonicSeed = getMnemonicSeed;\n    this.#getFeatureFlags = getFeatureFlags;\n    this.#clientCryptography = clientCryptography;\n    this.#preinstalledSnaps = preinstalledSnaps;\n    this._onUnhandledSnapError = this._onUnhandledSnapError.bind(this);\n    this._onOutboundRequest = this._onOutboundRequest.bind(this);\n    this._onOutboundResponse = this._onOutboundResponse.bind(this);\n    this.#rollbackSnapshots = new Map();\n    this.#snapsRuntimeData = new Map();\n    this.#trackEvent = trackEvent;\n\n    this.#pollForLastRequestStatus();\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.subscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messagingSystem.subscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messagingSystem.subscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapInstalled',\n      ({ id }, origin) => {\n        this.#callLifecycleHook(origin, id, HandlerType.OnInstall).catch(\n          (error) => {\n            logError(\n              `Error when calling \\`onInstall\\` lifecycle hook for snap \"${id}\": ${getErrorMessage(\n                error,\n              )}`,\n            );\n          },\n        );\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapUpdated',\n      ({ id }, _oldVersion, origin) => {\n        this.#callLifecycleHook(origin, id, HandlerType.OnUpdate).catch(\n          (error) => {\n            logError(\n              `Error when calling \\`onUpdate\\` lifecycle hook for snap \"${id}\": ${getErrorMessage(\n                error,\n              )}`,\n            );\n          },\n        );\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'KeyringController:lock',\n      this.#handleLock.bind(this),\n    );\n\n    this.#initializeStateMachine();\n    this.#registerMessageHandlers();\n\n    Object.values(this.state?.snaps ?? {}).forEach((snap) =>\n      this.#setupRuntime(snap.id),\n    );\n\n    if (this.#preinstalledSnaps) {\n      this.#handlePreinstalledSnaps(this.#preinstalledSnaps);\n    }\n\n    this.#trackSnapExport = throttleTracking(\n      (snapId: SnapId, handler: string, success: boolean, origin: string) => {\n        const snapMetadata = this.messagingSystem.call(\n          'SnapsRegistry:getMetadata',\n          snapId,\n        );\n        this.#trackEvent({\n          event: 'Snap Export Used',\n          category: 'Snaps',\n          properties: {\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            snap_id: snapId,\n            export: handler,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            snap_category: snapMetadata?.category,\n            success,\n            origin,\n          },\n        });\n      },\n    );\n  }\n\n  /**\n   * We track status of a Snap using a finite-state-machine.\n   * It keeps track of whether the snap is started / stopped / etc.\n   *\n   * @see {@link SnapController.transition} for interacting with the machine.\n   */\n  // We initialize the machine in the instance because the status is currently tightly coupled\n  // with the SnapController - the guard checks for enabled status inside the SnapController state.\n  // In the future, side-effects could be added to the machine during transitions.\n  #initializeStateMachine() {\n    const disableGuard = ({ snapId }: StatusContext) => {\n      return this.getExpect(snapId).enabled;\n    };\n\n    const statusConfig: StateMachine.Config<\n      StatusContext,\n      StatusEvents,\n      StatusStates\n    > = {\n      initial: SnapStatus.Installing,\n      states: {\n        [SnapStatus.Installing]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n          },\n        },\n        [SnapStatus.Updating]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Stop]: SnapStatus.Stopped,\n          },\n        },\n        [SnapStatus.Running]: {\n          on: {\n            [SnapStatusEvents.Stop]: SnapStatus.Stopped,\n            [SnapStatusEvents.Crash]: SnapStatus.Crashed,\n          },\n        },\n        [SnapStatus.Stopped]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Update]: SnapStatus.Updating,\n          },\n        },\n        [SnapStatus.Crashed]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Update]: SnapStatus.Updating,\n          },\n        },\n      },\n    };\n    this.#statusMachine = createMachine(statusConfig);\n    validateMachine(this.#statusMachine);\n  }\n\n  /**\n   * Constructor helper for registering the controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers(): void {\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:init`,\n      (...args) => this.init(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:clearSnapState`,\n      (...args) => this.clearSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:get`,\n      (...args) => this.get(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getSnapState`,\n      async (...args) => this.getSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:handleRequest`,\n      async (...args) => this.handleRequest(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:has`,\n      (...args) => this.has(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateRegistry`,\n      async () => this.updateRegistry(),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateSnapState`,\n      async (...args) => this.updateSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:enable`,\n      (...args) => this.enableSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:disable`,\n      async (...args) => this.disableSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:remove`,\n      async (...args) => this.removeSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getPermitted`,\n      (...args) => this.getPermittedSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:install`,\n      async (...args) => this.installSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getAll`,\n      (...args) => this.getAllSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getRunnableSnaps`,\n      (...args) => this.getRunnableSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:incrementActiveReferences`,\n      (...args) => this.incrementActiveReferences(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:decrementActiveReferences`,\n      (...args) => this.decrementActiveReferences(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:disconnectOrigin`,\n      (...args) => this.removeSnapFromSubject(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:revokeDynamicPermissions`,\n      (...args) => this.revokeDynamicSnapPermissions(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getFile`,\n      async (...args) => this.getSnapFile(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:stopAllSnaps`,\n      async (...args) => this.stopAllSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:isMinimumPlatformVersion`,\n      (...args) => this.isMinimumPlatformVersion(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:setClientActive`,\n      (...args) => this.setClientActive(...args),\n    );\n  }\n\n  /**\n   * Initialise the SnapController.\n   *\n   * Currently this method calls the `onStart` lifecycle hook for all\n   * runnable Snaps.\n   */\n  init() {\n    this.#callLifecycleHooks(METAMASK_ORIGIN, HandlerType.OnStart);\n  }\n\n  #handlePreinstalledSnaps(preinstalledSnaps: PreinstalledSnap[]) {\n    for (const {\n      snapId,\n      manifest,\n      files,\n      removable,\n      hidden,\n      hideSnapBranding,\n    } of preinstalledSnaps) {\n      const existingSnap = this.get(snapId);\n      const isAlreadyInstalled = existingSnap !== undefined;\n      const isUpdate =\n        isAlreadyInstalled && gtVersion(manifest.version, existingSnap.version);\n\n      // Disallow downgrades and overwriting non preinstalled snaps\n      if (\n        isAlreadyInstalled &&\n        (!isUpdate || existingSnap.preinstalled !== true)\n      ) {\n        continue;\n      }\n\n      const manifestFile = new VirtualFile<SnapManifest>({\n        path: NpmSnapFileNames.Manifest,\n        value: JSON.stringify(manifest),\n        result: manifest,\n      });\n\n      const virtualFiles = files.map(\n        ({ path, value }) => new VirtualFile({ value, path }),\n      );\n      const { filePath, iconPath } = manifest.source.location.npm;\n      const sourceCode = virtualFiles.find((file) => file.path === filePath);\n      const svgIcon = iconPath\n        ? virtualFiles.find((file) => file.path === iconPath)\n        : undefined;\n\n      assert(sourceCode, 'Source code not provided for preinstalled snap.');\n\n      assert(\n        !iconPath || (iconPath && svgIcon),\n        'Icon not provided for preinstalled snap.',\n      );\n\n      assert(\n        manifest.source.files === undefined,\n        'Auxiliary files are not currently supported for preinstalled snaps.',\n      );\n\n      const localizationFiles =\n        manifest.source.locales?.map((path) =>\n          virtualFiles.find((file) => file.path === path),\n        ) ?? [];\n\n      const validatedLocalizationFiles = getValidatedLocalizationFiles(\n        localizationFiles.filter(Boolean) as VirtualFile[],\n      );\n\n      assert(\n        localizationFiles.length === validatedLocalizationFiles.length,\n        'Missing localization files for preinstalled snap.',\n      );\n\n      const filesObject: FetchedSnapFiles = {\n        manifest: manifestFile,\n        sourceCode,\n        svgIcon,\n        auxiliaryFiles: [],\n        localizationFiles: validatedLocalizationFiles,\n      };\n\n      // Add snap to the SnapController state\n      this.#set({\n        id: snapId,\n        origin: METAMASK_ORIGIN,\n        files: filesObject,\n        removable,\n        hidden,\n        hideSnapBranding,\n        preinstalled: true,\n      });\n\n      // Setup permissions\n      const processedPermissions = processSnapPermissions(\n        manifest.initialPermissions,\n      );\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      const { newPermissions, unusedPermissions } =\n        this.#calculatePermissionsChange(snapId, processedPermissions);\n\n      this.#updatePermissions({ snapId, newPermissions, unusedPermissions });\n\n      if (manifest.initialConnections) {\n        this.#handleInitialConnections(\n          snapId,\n          existingSnap?.initialConnections ?? null,\n          manifest.initialConnections,\n        );\n      }\n\n      // Set status\n      this.update((state) => {\n        state.snaps[snapId].status = SnapStatus.Stopped;\n      });\n\n      this.#setupRuntime(snapId);\n\n      // Emit events\n      if (isUpdate) {\n        this.messagingSystem.publish(\n          'SnapController:snapUpdated',\n          this.getTruncatedExpect(snapId),\n          existingSnap.version,\n          METAMASK_ORIGIN,\n          true,\n        );\n      } else {\n        this.messagingSystem.publish(\n          'SnapController:snapInstalled',\n          this.getTruncatedExpect(snapId),\n          METAMASK_ORIGIN,\n          true,\n        );\n      }\n    }\n  }\n\n  #pollForLastRequestStatus() {\n    this.#timeoutForLastRequestStatus = setTimeout(() => {\n      this.#stopSnapsLastRequestPastMax().catch((error) => {\n        // TODO: Decide how to handle errors.\n        logError(error);\n      });\n\n      this.#pollForLastRequestStatus();\n    }, this.#idleTimeCheckInterval) as unknown as number;\n  }\n\n  /**\n   * Checks all installed snaps against the block list and\n   * blocks/unblocks snaps as appropriate. See {@link SnapController.blockSnap}\n   * for more information.\n   *\n   * Also updates any preinstalled Snaps to the latest allowlisted version.\n   */\n  async updateRegistry(): Promise<void> {\n    this.#assertCanUsePlatform();\n    await this.messagingSystem.call('SnapsRegistry:update');\n\n    const blockedSnaps = await this.messagingSystem.call(\n      'SnapsRegistry:get',\n      Object.values(this.state.snaps).reduce<SnapsRegistryRequest>(\n        (blockListArg, snap) => {\n          blockListArg[snap.id] = {\n            version: snap.version,\n            checksum: snap.manifest.source.shasum,\n          };\n          return blockListArg;\n        },\n        {},\n      ),\n    );\n\n    await Promise.all(\n      Object.entries(blockedSnaps).map(async ([snapId, { status, reason }]) => {\n        if (status === SnapsRegistryStatus.Blocked) {\n          return this.#blockSnap(snapId as SnapId, reason);\n        }\n\n        return this.#unblockSnap(snapId as SnapId);\n      }),\n    );\n\n    if (!this.#featureFlags.autoUpdatePreinstalledSnaps) {\n      return;\n    }\n\n    const preinstalledVersionRange = '*' as SemVerRange;\n\n    await Promise.allSettled(\n      Object.values(this.state.snaps)\n        .filter((snap) => snap.preinstalled)\n        .map(async (snap) => {\n          const resolvedVersion = await this.#resolveAllowlistVersion(\n            snap.id,\n            preinstalledVersionRange,\n          );\n\n          if (\n            resolvedVersion !== preinstalledVersionRange &&\n            gtVersion(resolvedVersion as unknown as SemVerVersion, snap.version)\n          ) {\n            const location = this.#detectSnapLocation(snap.id, {\n              versionRange: resolvedVersion,\n              fetch: this.#fetchFunction,\n              allowLocal: false,\n            });\n\n            await this.#updateSnap({\n              origin: ORIGIN_METAMASK,\n              snapId: snap.id,\n              location,\n              versionRange: resolvedVersion,\n              automaticUpdate: true,\n            });\n          }\n        }),\n    );\n  }\n\n  /**\n   * Blocks an installed snap and prevents it from being started again. Emits\n   * {@link SnapBlocked}. Does nothing if the snap is not installed.\n   *\n   * @param snapId - The snap to block.\n   * @param blockedSnapInfo - Information detailing why the snap is blocked.\n   */\n  async #blockSnap(\n    snapId: SnapId,\n    blockedSnapInfo?: BlockReason,\n  ): Promise<void> {\n    if (!this.has(snapId)) {\n      return;\n    }\n\n    try {\n      this.update((state: any) => {\n        state.snaps[snapId].blocked = true;\n        state.snaps[snapId].blockInformation = blockedSnapInfo;\n      });\n\n      await this.disableSnap(snapId);\n    } catch (error) {\n      logError(\n        `Encountered error when stopping blocked snap \"${snapId}\".`,\n        error,\n      );\n    }\n\n    this.messagingSystem.publish(\n      `${controllerName}:snapBlocked`,\n      snapId,\n      blockedSnapInfo,\n    );\n  }\n\n  /**\n   * Unblocks a snap so that it can be enabled and started again. Emits\n   * {@link SnapUnblocked}. Does nothing if the snap is not installed or already\n   * unblocked.\n   *\n   * @param snapId - The id of the snap to unblock.\n   */\n  #unblockSnap(snapId: SnapId) {\n    if (!this.has(snapId) || !this.state.snaps[snapId].blocked) {\n      return;\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].blocked = false;\n      delete state.snaps[snapId].blockInformation;\n    });\n\n    this.messagingSystem.publish(`${controllerName}:snapUnblocked`, snapId);\n  }\n\n  async #assertIsInstallAllowed(\n    snapId: SnapId,\n    {\n      platformVersion,\n      ...snapInfo\n    }: SnapsRegistryInfo & {\n      permissions: SnapPermissions;\n      platformVersion: string | undefined;\n    },\n  ) {\n    const results = await this.messagingSystem.call('SnapsRegistry:get', {\n      [snapId]: snapInfo,\n    });\n\n    const result = results[snapId];\n    if (result.status === SnapsRegistryStatus.Blocked) {\n      throw new Error(\n        `Cannot install version \"${\n          snapInfo.version\n        }\" of snap \"${snapId}\": The version is blocked. ${\n          result.reason?.explanation ?? ''\n        }`,\n      );\n    }\n\n    const isAllowlistingRequired = Object.keys(snapInfo.permissions).some(\n      (permission) => !ALLOWED_PERMISSIONS.includes(permission),\n    );\n\n    if (\n      this.#featureFlags.requireAllowlist &&\n      isAllowlistingRequired &&\n      result.status !== SnapsRegistryStatus.Verified\n    ) {\n      throw new Error(\n        `Cannot install version \"${snapInfo.version}\" of snap \"${snapId}\": ${\n          result.status === SnapsRegistryStatus.Unavailable\n            ? 'The registry is temporarily unavailable.'\n            : 'The snap is not on the allowlist.'\n        }`,\n      );\n    }\n\n    this.#validatePlatformVersion(snapId, platformVersion);\n  }\n\n  /**\n   * Asserts whether new Snaps are allowed to be installed.\n   */\n  #assertCanInstallSnaps() {\n    assert(\n      this.#featureFlags.disableSnapInstallation !== true,\n      'Installing Snaps is currently disabled in this version of MetaMask.',\n    );\n  }\n\n  /**\n   * Asserts whether the Snaps platform is allowed to run.\n   */\n  #assertCanUsePlatform() {\n    const flags = this.#getFeatureFlags();\n    assert(\n      flags.disableSnaps !== true,\n      'The Snaps platform requires basic functionality to be used. Enable basic functionality in the settings to use the Snaps platform.',\n    );\n  }\n\n  async #stopSnapsLastRequestPastMax() {\n    const entries = [...this.#snapsRuntimeData.entries()];\n    return Promise.all(\n      entries\n        .filter(\n          ([_snapId, runtime]) =>\n            runtime.activeReferences === 0 &&\n            runtime.pendingInboundRequests.length === 0 &&\n            runtime.lastRequest &&\n            this.#maxIdleTime &&\n            timeSince(runtime.lastRequest) > this.#maxIdleTime,\n        )\n        .map(async ([snapId]) => this.stopSnap(snapId, SnapStatusEvents.Stop)),\n    );\n  }\n\n  _onUnhandledSnapError(snapId: string, error: SnapErrorJson) {\n    // Log the error that caused the crash\n    // so it gets raised to the developer for debugging purposes.\n    logError(`Unhandled error from \"${snapId}\":`, error);\n    this.stopSnap(snapId as SnapId, SnapStatusEvents.Crash).catch(\n      (stopSnapError) => {\n        // TODO: Decide how to handle errors.\n        logError(stopSnapError);\n      },\n    );\n  }\n\n  _onOutboundRequest(snapId: string) {\n    const runtime = this.#getRuntimeExpect(snapId as SnapId);\n    // Ideally we would only pause the pending request that is making the outbound request\n    // but right now we don't have a way to know which request initiated the outbound request\n    runtime.pendingInboundRequests\n      .filter((pendingRequest) => pendingRequest.timer.status === 'running')\n      .forEach((pendingRequest) => pendingRequest.timer.pause());\n    runtime.pendingOutboundRequests += 1;\n  }\n\n  _onOutboundResponse(snapId: string) {\n    const runtime = this.#getRuntimeExpect(snapId as SnapId);\n    runtime.pendingOutboundRequests -= 1;\n    if (runtime.pendingOutboundRequests === 0) {\n      runtime.pendingInboundRequests\n        .filter((pendingRequest) => pendingRequest.timer.status === 'paused')\n        .forEach((pendingRequest) => pendingRequest.timer.resume());\n    }\n  }\n\n  /**\n   * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out\n   * the next state. This transition function uses a very minimal subset of XState conventions:\n   * - supports initial state\n   * - .on supports raw event target string\n   * - .on supports {target, cond} object\n   * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event,\n   * context) => boolean`\n   *\n   * @param snapId - The id of the snap to transition.\n   * @param event - The event enum to use to transition.\n   */\n  #transition(snapId: SnapId, event: StatusEvents | StatusEvents['type']) {\n    const { interpreter } = this.#getRuntimeExpect(snapId);\n    interpreter.send(event);\n    this.update((state: any) => {\n      state.snaps[snapId].status = interpreter.state.value;\n    });\n  }\n\n  /**\n   * Starts the given snap. Throws an error if no such snap exists\n   * or if it is already running.\n   *\n   * @param snapId - The id of the Snap to start.\n   */\n  async startSnap(snapId: SnapId): Promise<void> {\n    this.#assertCanUsePlatform();\n    const snap = this.state.snaps[snapId];\n\n    if (!snap.enabled) {\n      throw new Error(`Snap \"${snapId}\" is disabled.`);\n    }\n\n    await this.#startSnap({\n      snapId,\n      sourceCode: snap.sourceCode,\n    });\n  }\n\n  /**\n   * Enables the given snap. A snap can only be started if it is enabled. A snap\n   * can only be enabled if it isn't blocked.\n   *\n   * @param snapId - The id of the Snap to enable.\n   */\n  enableSnap(snapId: SnapId): void {\n    this.getExpect(snapId);\n\n    if (this.state.snaps[snapId].blocked) {\n      throw new Error(`Snap \"${snapId}\" is blocked and cannot be enabled.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = true;\n    });\n\n    this.messagingSystem.publish(\n      'SnapController:snapEnabled',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Disables the given snap. A snap can only be started if it is enabled.\n   *\n   * @param snapId - The id of the Snap to disable.\n   * @returns A promise that resolves once the snap has been disabled.\n   */\n  async disableSnap(snapId: SnapId): Promise<void> {\n    if (!this.has(snapId)) {\n      throw new Error(`Snap \"${snapId}\" not found.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = false;\n    });\n\n    if (this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    this.messagingSystem.publish(\n      'SnapController:snapDisabled',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Stops the given snap, removes all hooks, closes all connections, and\n   * terminates its worker.\n   *\n   * @param snapId - The id of the Snap to stop.\n   * @param statusEvent - The Snap status event that caused the snap to be\n   * stopped.\n   */\n  public async stopSnap(\n    snapId: SnapId,\n    statusEvent:\n      | SnapStatusEvents.Stop\n      | SnapStatusEvents.Crash = SnapStatusEvents.Stop,\n  ): Promise<void> {\n    const runtime = this.#getRuntime(snapId);\n    if (!runtime) {\n      throw new Error(`The snap \"${snapId}\" is not running.`);\n    }\n\n    // If we are already stopping, wait for that to finish.\n    if (runtime.stopPromise) {\n      await runtime.stopPromise;\n      return;\n    }\n\n    // Flag that the Snap is actively stopping, this prevents other calls to stopSnap\n    // while we are handling termination of the Snap\n    const { promise, resolve } = createDeferredPromise();\n    runtime.stopPromise = promise;\n\n    try {\n      if (this.isRunning(snapId)) {\n        this.#closeAllConnections?.(snapId);\n        await this.#terminateSnap(snapId);\n      }\n    } finally {\n      // Reset request tracking\n      runtime.lastRequest = null;\n      runtime.pendingInboundRequests = [];\n      runtime.pendingOutboundRequests = 0;\n      runtime.stopPromise = null;\n      if (this.isRunning(snapId)) {\n        this.#transition(snapId, statusEvent);\n      }\n      resolve();\n    }\n  }\n\n  /**\n   * Stops all running snaps, removes all hooks, closes all connections, and\n   * terminates their workers.\n   *\n   * @param statusEvent - The Snap status event that caused the snap to be\n   * stopped.\n   */\n  public async stopAllSnaps(\n    statusEvent:\n      | SnapStatusEvents.Stop\n      | SnapStatusEvents.Crash = SnapStatusEvents.Stop,\n  ): Promise<void> {\n    const snaps = Object.values(this.state.snaps).filter((snap) =>\n      this.isRunning(snap.id),\n    );\n    const promises = snaps.map(async (snap) =>\n      this.stopSnap(snap.id, statusEvent),\n    );\n    await Promise.allSettled(promises);\n  }\n\n  /**\n   * Terminates the specified snap and emits the `snapTerminated` event.\n   *\n   * @param snapId - The snap to terminate.\n   */\n  async #terminateSnap(snapId: SnapId) {\n    await this.messagingSystem.call('ExecutionService:terminateSnap', snapId);\n\n    // Hack to give up execution for a bit to let gracefully terminating Snaps return.\n    await new Promise((resolve) => setTimeout(resolve, 1));\n\n    const runtime = this.#getRuntimeExpect(snapId);\n    // Unresponsive requests may still be timed, time them out.\n    runtime.pendingInboundRequests\n      .filter((pendingRequest) => pendingRequest.timer.status !== 'finished')\n      .forEach((pendingRequest) => pendingRequest.timer.finish());\n\n    // Hack to give up execution for a bit to let timed out requests return.\n    await new Promise((resolve) => setTimeout(resolve, 1));\n\n    this.messagingSystem.publish(\n      'SnapController:snapTerminated',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Returns whether the given snap is running.\n   * Throws an error if the snap doesn't exist.\n   *\n   * @param snapId - The id of the Snap to check.\n   * @returns `true` if the snap is running, otherwise `false`.\n   */\n  isRunning(snapId: SnapId): boolean {\n    return this.getExpect(snapId).status === 'running';\n  }\n\n  /**\n   * Returns whether the given snap has been added to state.\n   *\n   * @param snapId - The id of the Snap to check for.\n   * @returns `true` if the snap exists in the controller state, otherwise `false`.\n   */\n  has(snapId: SnapId): boolean {\n    return Boolean(this.get(snapId));\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, including all data.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns The entire snap object from the controller state.\n   */\n  get(snapId: string): Snap | undefined {\n    return this.state.snaps[snapId as SnapId];\n  }\n\n  /**\n   * Gets the snap with the given id, throws if doesn't.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @see {@link SnapController.get}\n   * @throws {@link Error}. If the snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns The entire snap object.\n   */\n  getExpect(snapId: SnapId): Snap {\n    const snap = this.get(snapId);\n    assert(snap !== undefined, `Snap \"${snapId}\" not found.`);\n    return snap;\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, excluding any\n   * non-serializable or expensive-to-serialize data.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  // TODO(ritave): this.get returns undefined, this.getTruncated returns null\n  getTruncated(snapId: SnapId): TruncatedSnap | null {\n    const snap = this.get(snapId);\n\n    return snap ? truncateSnap(snap) : null;\n  }\n\n  /**\n   * Gets the snap with the given id, throw if it doesn't exist.\n   *\n   * @throws {@link Error}. If snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  getTruncatedExpect(snapId: SnapId): TruncatedSnap {\n    return truncateSnap(this.getExpect(snapId));\n  }\n\n  /**\n   * Check if a given Snap has a cached encryption key stored in the runtime.\n   *\n   * @param snapId - The Snap ID.\n   * @param runtime - The Snap runtime data.\n   * @returns True if the Snap has a cached encryption key, otherwise false.\n   */\n  #hasCachedEncryptionKey(\n    snapId: SnapId,\n    runtime = this.#getRuntimeExpect(snapId),\n  ): runtime is SnapRuntimeData & {\n    encryptionKey: string;\n    encryptionSalt: string;\n  } {\n    return runtime.encryptionKey !== null && runtime.encryptionSalt !== null;\n  }\n\n  /**\n   * Generate an encryption key to be used for state encryption for a given Snap.\n   *\n   * @param options - An options bag.\n   * @param options.snapId - The Snap ID.\n   * @param options.salt - A salt to be used for the encryption key.\n   * @param options.useCache - Whether to use caching or not.\n   * @param options.keyMetadata - Optional metadata about how to derive the encryption key.\n   * @returns An encryption key.\n   */\n  async #getSnapEncryptionKey({\n    snapId,\n    salt: passedSalt,\n    useCache,\n    keyMetadata,\n  }: {\n    snapId: SnapId;\n    salt?: string;\n    useCache: boolean;\n    keyMetadata?: KeyDerivationOptions;\n  }): Promise<{ key: unknown; salt: string }> {\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (this.#hasCachedEncryptionKey(snapId, runtime) && useCache) {\n      return {\n        key: await this.#encryptor.importKey(runtime.encryptionKey),\n        salt: runtime.encryptionSalt,\n      };\n    }\n\n    const salt = passedSalt ?? this.#encryptor.generateSalt();\n    const seed = await this.#getMnemonicSeed();\n\n    const entropy = await getEncryptionEntropy({\n      snapId,\n      seed,\n      cryptographicFunctions: this.#clientCryptography,\n    });\n\n    const encryptionKey = await this.#encryptor.keyFromPassword(\n      entropy,\n      salt,\n      true,\n      keyMetadata,\n    );\n    const exportedKey = await this.#encryptor.exportKey(encryptionKey);\n\n    // Cache exported encryption key in runtime\n    if (useCache) {\n      runtime.encryptionKey = exportedKey;\n      runtime.encryptionSalt = salt;\n    }\n    return { key: encryptionKey, salt };\n  }\n\n  /**\n   * Decrypt the encrypted state for a given Snap.\n   *\n   * @param snapId - The Snap ID.\n   * @param state - The encrypted state as a string.\n   * @returns A valid JSON object derived from the encrypted state.\n   * @throws If the decryption fails or the decrypted state is not valid JSON.\n   */\n  async #decryptSnapState(snapId: SnapId, state: string) {\n    try {\n      // We assume that the state string here is valid JSON since we control serialization.\n      // This lets us skip JSON validation.\n      const parsed = JSON.parse(state) as EncryptionResult;\n      const { salt, keyMetadata } = parsed;\n\n      // We only cache encryption keys if they are already cached or if the encryption key is using the latest key derivation params.\n      const useCache =\n        this.#hasCachedEncryptionKey(snapId) ||\n        this.#encryptor.isVaultUpdated(state);\n\n      const { key } = await this.#getSnapEncryptionKey({\n        snapId,\n        salt,\n        useCache,\n        // When decrypting state we expect key metadata to be present.\n        // If it isn't present, we assume that the Snap state we are decrypting is old enough to use the legacy encryption params.\n        keyMetadata: keyMetadata ?? LEGACY_ENCRYPTION_KEY_DERIVATION_OPTIONS,\n      });\n      const decryptedState = await this.#encryptor.decryptWithKey(key, parsed);\n\n      // We assume this to be valid JSON, since all RPC requests from a Snap are validated and sanitized.\n      return decryptedState as Record<string, Json>;\n    } catch {\n      throw rpcErrors.internal({\n        message: 'Failed to decrypt snap state, the state must be corrupted.',\n      });\n    }\n  }\n\n  /**\n   * Encrypt a JSON state object for a given Snap.\n   *\n   * Note: This function does not assert the validity of the object,\n   * please ensure only valid JSON is passed to it.\n   *\n   * @param snapId - The Snap ID.\n   * @param state - The state object.\n   * @returns A string containing the encrypted JSON object.\n   */\n  async #encryptSnapState(snapId: SnapId, state: Record<string, Json>) {\n    const { key, salt } = await this.#getSnapEncryptionKey({\n      snapId,\n      useCache: true,\n    });\n    const encryptedState = await this.#encryptor.encryptWithKey(key, state);\n\n    encryptedState.salt = salt;\n    return JSON.stringify(encryptedState);\n  }\n\n  /**\n   * Get the new Snap state to persist based on the given state and encryption\n   * flag.\n   *\n   * - If the state is null, return null.\n   * - If the state should be encrypted, return the encrypted state.\n   * - Otherwise, if the state should not be encrypted, return the JSON-\n   * stringified state.\n   *\n   * @param snapId - The Snap ID.\n   * @param state - The state to persist.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or\n   * not.\n   * @returns The state to persist.\n   */\n  async #getStateToPersist(\n    snapId: SnapId,\n    state: Record<string, Json> | null,\n    encrypted: boolean,\n  ) {\n    if (state === null) {\n      return null;\n    }\n\n    if (encrypted) {\n      return await this.#encryptSnapState(snapId, state);\n    }\n\n    return JSON.stringify(state);\n  }\n\n  /**\n   * Persist the state of a Snap.\n   *\n   * This function is debounced per Snap, meaning that multiple calls to this\n   * function for the same Snap will only result in one state update. It also\n   * uses a mutex to ensure that only one state update per Snap is processed at\n   * a time, avoiding possible race conditions.\n   *\n   * @param snapId - The Snap ID.\n   * @param newSnapState - The new state of the Snap.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or\n   * not.\n   */\n  readonly #persistSnapState = debouncePersistState(\n    (\n      snapId: SnapId,\n      newSnapState: Record<string, Json> | null,\n      encrypted: boolean,\n    ) => {\n      const runtime = this.#getRuntimeExpect(snapId);\n      runtime.stateMutex\n        .runExclusive(async () => {\n          const newState = await this.#getStateToPersist(\n            snapId,\n            newSnapState,\n            encrypted,\n          );\n\n          if (encrypted) {\n            return this.update((state) => {\n              state.snapStates[snapId] = newState;\n            });\n          }\n\n          return this.update((state) => {\n            state.unencryptedSnapStates[snapId] = newState;\n          });\n        })\n        .catch(logError);\n    },\n    STATE_DEBOUNCE_TIMEOUT,\n  );\n\n  /**\n   * Updates the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be updated.\n   * @param newSnapState - The new state of the snap.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   */\n  async updateSnapState(\n    snapId: SnapId,\n    newSnapState: Record<string, Json>,\n    encrypted: boolean,\n  ) {\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (encrypted) {\n      runtime.state = newSnapState;\n    } else {\n      runtime.unencryptedState = newSnapState;\n    }\n\n    this.#persistSnapState(snapId, newSnapState, encrypted);\n  }\n\n  /**\n   * Clears the state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be cleared.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   */\n  clearSnapState(snapId: SnapId, encrypted: boolean) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    if (encrypted) {\n      runtime.state = null;\n    } else {\n      runtime.unencryptedState = null;\n    }\n\n    this.#persistSnapState(snapId, null, encrypted);\n  }\n\n  /**\n   * Gets the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state to get.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   * @returns The requested snap state or null if no state exists.\n   */\n  async getSnapState(snapId: SnapId, encrypted: boolean): Promise<Json> {\n    const runtime = this.#getRuntimeExpect(snapId);\n    return await runtime.getStateMutex.runExclusive(async () => {\n      const cachedState = encrypted ? runtime.state : runtime.unencryptedState;\n\n      if (cachedState !== undefined) {\n        return cachedState;\n      }\n\n      const state = encrypted\n        ? this.state.snapStates[snapId]\n        : this.state.unencryptedSnapStates[snapId];\n\n      if (state === null || state === undefined) {\n        return null;\n      }\n\n      if (!encrypted) {\n        // For performance reasons, we do not validate that the state is JSON,\n        // since we control serialization.\n        const json = JSON.parse(state);\n        runtime.unencryptedState = json;\n\n        return json;\n      }\n\n      const decrypted = await this.#decryptSnapState(snapId, state);\n      // eslint-disable-next-line require-atomic-updates\n      runtime.state = decrypted;\n\n      return decrypted;\n    });\n  }\n\n  /**\n   * Gets a static auxiliary snap file in a chosen file encoding.\n   *\n   * @param snapId - The id of the Snap whose state to get.\n   * @param path - The path to the requested file.\n   * @param encoding - An optional requested file encoding.\n   * @returns The file requested in the chosen file encoding or null if the file is not found.\n   */\n  async getSnapFile(\n    snapId: SnapId,\n    path: string,\n    encoding: AuxiliaryFileEncoding = AuxiliaryFileEncoding.Base64,\n  ): Promise<string | null> {\n    const snap = this.getExpect(snapId);\n    const normalizedPath = normalizeRelative(path);\n    const value = snap.auxiliaryFiles?.find(\n      (file) => file.path === normalizedPath,\n    )?.value;\n\n    if (!value) {\n      return null;\n    }\n\n    const encoded = await encodeAuxiliaryFile(value, encoding);\n\n    assert(\n      encoded.length < MAX_FILE_SIZE,\n      `Failed to encode static file to \"${encoding}\": Static files must be less than 64 MB when encoded.`,\n    );\n\n    return encoded;\n  }\n\n  /**\n   * Determine if a given Snap ID supports a given minimum version of the Snaps platform\n   * by inspecting the platformVersion in the Snap manifest.\n   *\n   * @param snapId - The Snap ID.\n   * @param version - The version.\n   * @returns True if the platform version is equal or greater to the passed version, false otherwise.\n   */\n  isMinimumPlatformVersion(snapId: SnapId, version: SemVerVersion): boolean {\n    const snap = this.getExpect(snapId);\n\n    const { platformVersion } = snap.manifest;\n\n    if (!platformVersion) {\n      return false;\n    }\n\n    return gte(platformVersion, version);\n  }\n\n  /**\n   * Completely clear the controller's state: delete all associated data,\n   * handlers, event listeners, and permissions; tear down all snap providers.\n   */\n  async clearState() {\n    const snapIds = Object.keys(this.state.snaps);\n\n    await this.stopAllSnaps();\n    snapIds.forEach((snapId) => this.#revokeAllSnapPermissions(snapId));\n\n    this.update((state) => {\n      state.snaps = {};\n      state.snapStates = {};\n      state.unencryptedSnapStates = {};\n    });\n\n    this.#snapsRuntimeData.clear();\n    this.#rollbackSnapshots.clear();\n\n    // We want to remove all snaps & permissions, except for preinstalled snaps\n    if (this.#preinstalledSnaps) {\n      this.#handlePreinstalledSnaps(this.#preinstalledSnaps);\n    }\n  }\n\n  /**\n   * Removes the given snap from state, and clears all associated handlers\n   * and listeners.\n   *\n   * @param snapId - The id of the Snap.\n   * @returns A promise that resolves once the snap has been removed.\n   */\n  async removeSnap(snapId: SnapId): Promise<void> {\n    return this.removeSnaps([snapId]);\n  }\n\n  /**\n   * Stops the given snaps, removes them from state, and clears all associated\n   * permissions, handlers, and listeners.\n   *\n   * @param snapIds - The ids of the Snaps.\n   */\n  async removeSnaps(snapIds: SnapId[]): Promise<void> {\n    if (!Array.isArray(snapIds)) {\n      throw new Error('Expected array of snap ids.');\n    }\n\n    snapIds.forEach((snapId) => {\n      const snap = this.getExpect(snapId);\n      assert(snap.removable !== false, `${snapId} is not removable.`);\n    });\n\n    await Promise.all(\n      snapIds.map(async (snapId) => {\n        const snap = this.getExpect(snapId);\n        const truncated = this.getTruncatedExpect(snapId);\n        // Disable the snap and revoke all of its permissions before deleting\n        // it. This ensures that the snap will not be restarted or otherwise\n        // affect the host environment while we are deleting it.\n        await this.disableSnap(snapId);\n        this.#revokeAllSnapPermissions(snapId);\n\n        this.#removeSnapFromSubjects(snapId);\n\n        this.#snapsRuntimeData.delete(snapId);\n\n        this.update((state: any) => {\n          delete state.snaps[snapId];\n          delete state.snapStates[snapId];\n          delete state.unencryptedSnapStates[snapId];\n        });\n\n        // If the snap has been fully installed before, also emit snapUninstalled.\n        if (snap.status !== SnapStatus.Installing) {\n          this.messagingSystem.publish(\n            `SnapController:snapUninstalled`,\n            truncated,\n          );\n        }\n      }),\n    );\n  }\n\n  #handleInitialConnections(\n    snapId: SnapId,\n    previousInitialConnections: InitialConnections | null,\n    initialConnections: InitialConnections,\n  ) {\n    if (previousInitialConnections) {\n      const revokedInitialConnections = setDiff(\n        previousInitialConnections,\n        initialConnections,\n      );\n\n      for (const origin of Object.keys(revokedInitialConnections)) {\n        this.removeSnapFromSubject(origin, snapId);\n      }\n    }\n\n    for (const origin of Object.keys(initialConnections)) {\n      this.#addSnapToSubject(origin, snapId);\n    }\n  }\n\n  #addSnapToSubject(origin: string, snapId: SnapId) {\n    const subjectPermissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const existingCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds);\n\n    const subjectHasSnap = Boolean(\n      (existingCaveat?.value as Record<string, Json>)?.[snapId],\n    );\n\n    // If the subject is already connected to the snap, this is a no-op.\n    if (subjectHasSnap) {\n      return;\n    }\n\n    // If an existing caveat exists, we add the snap to that.\n    if (existingCaveat) {\n      this.messagingSystem.call(\n        'PermissionController:updateCaveat',\n        origin,\n        WALLET_SNAP_PERMISSION_KEY,\n        SnapCaveatType.SnapIds,\n        { ...(existingCaveat.value as Record<string, Json>), [snapId]: {} },\n      );\n      return;\n    }\n\n    const approvedPermissions = {\n      [WALLET_SNAP_PERMISSION_KEY]: {\n        caveats: [\n          {\n            type: SnapCaveatType.SnapIds,\n            value: {\n              [snapId]: {},\n            },\n          },\n        ],\n      },\n    } as RequestedPermissions;\n\n    this.messagingSystem.call('PermissionController:grantPermissions', {\n      approvedPermissions,\n      subject: { origin },\n    });\n  }\n\n  /**\n   * Removes a snap's permission (caveat) from the specified subject.\n   *\n   * @param origin - The origin from which to remove the snap.\n   * @param snapId - The id of the snap to remove.\n   */\n  removeSnapFromSubject(origin: string, snapId: SnapId) {\n    const subjectPermissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const snapIdsCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds) as\n      | Caveat<string, Json>\n      | undefined;\n\n    if (!snapIdsCaveat) {\n      return;\n    }\n\n    const caveatHasSnap = Boolean(\n      (snapIdsCaveat.value as Record<string, Json>)?.[snapId],\n    );\n    if (caveatHasSnap) {\n      const newCaveatValue = {\n        ...(snapIdsCaveat.value as Record<string, Json>),\n      };\n      delete newCaveatValue[snapId];\n      if (Object.keys(newCaveatValue).length > 0) {\n        this.messagingSystem.call(\n          'PermissionController:updateCaveat',\n          origin,\n          WALLET_SNAP_PERMISSION_KEY,\n          SnapCaveatType.SnapIds,\n          newCaveatValue,\n        );\n      } else {\n        this.messagingSystem.call('PermissionController:revokePermissions', {\n          [origin]: [WALLET_SNAP_PERMISSION_KEY],\n        });\n      }\n    }\n  }\n\n  /**\n   * Checks if a list of permissions are dynamic and allowed to be revoked, if they are they will all be revoked.\n   *\n   * @param snapId - The snap ID.\n   * @param permissionNames - The names of the permissions.\n   * @throws If non-dynamic permissions are passed.\n   */\n  revokeDynamicSnapPermissions(\n    snapId: string,\n    permissionNames: NonEmptyArray<string>,\n  ) {\n    assert(\n      permissionNames.every((permissionName) =>\n        this.#dynamicPermissions.includes(permissionName),\n      ),\n      'Non-dynamic permissions cannot be revoked',\n    );\n    this.messagingSystem.call('PermissionController:revokePermissions', {\n      [snapId]: permissionNames,\n    });\n  }\n\n  /**\n   * Removes a snap's permission (caveat) from all subjects.\n   *\n   * @param snapId - The id of the Snap.\n   */\n  #removeSnapFromSubjects(snapId: SnapId) {\n    const subjects = this.messagingSystem.call(\n      'PermissionController:getSubjectNames',\n    );\n    for (const subject of subjects) {\n      this.removeSnapFromSubject(subject, snapId);\n    }\n  }\n\n  /**\n   * Safely revokes all permissions granted to a Snap.\n   *\n   * @param snapId - The snap ID.\n   */\n  #revokeAllSnapPermissions(snapId: string) {\n    if (\n      this.messagingSystem.call('PermissionController:hasPermissions', snapId)\n    ) {\n      this.messagingSystem.call(\n        'PermissionController:revokeAllPermissions',\n        snapId,\n      );\n    }\n  }\n\n  /**\n   * Handles incrementing the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced.\n   */\n  incrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.activeReferences += 1;\n  }\n\n  /**\n   * Handles decrement the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced..\n   */\n  decrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    assert(\n      runtime.activeReferences > 0,\n      'SnapController reference management is in an invalid state.',\n    );\n    runtime.activeReferences -= 1;\n  }\n\n  /**\n   * Gets all snaps in their truncated format.\n   *\n   * @returns All installed snaps in their truncated format.\n   */\n  getAllSnaps(): TruncatedSnap[] {\n    return Object.values(this.state.snaps).map(truncateSnap);\n  }\n\n  /**\n   * Gets all runnable snaps.\n   *\n   * @returns All runnable snaps.\n   */\n  getRunnableSnaps(): TruncatedSnap[] {\n    return getRunnableSnaps(this.getAllSnaps());\n  }\n\n  /**\n   * Gets the serialized permitted snaps of the given origin, if any.\n   *\n   * @param origin - The origin whose permitted snaps to retrieve.\n   * @returns The serialized permitted snaps for the origin.\n   */\n  getPermittedSnaps(origin: string): RequestSnapsResult {\n    const permissions =\n      this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        origin,\n      ) ?? {};\n    const snaps =\n      permissions[WALLET_SNAP_PERMISSION_KEY]?.caveats?.find(\n        (caveat) => caveat.type === SnapCaveatType.SnapIds,\n      )?.value ?? {};\n    return Object.keys(snaps).reduce<RequestSnapsResult>(\n      (permittedSnaps, snapId) => {\n        const snap = this.get(snapId);\n        const truncatedSnap = this.getTruncated(snapId as SnapId);\n\n        if (truncatedSnap && snap?.status !== SnapStatus.Installing) {\n          permittedSnaps[snapId] = truncatedSnap;\n        }\n        return permittedSnaps;\n      },\n      {},\n    );\n  }\n\n  /**\n   * Installs the snaps requested by the given origin, returning the snap\n   * object if the origin is permitted to install it, and an authorization error\n   * otherwise.\n   *\n   * @param origin - The origin that requested to install the snaps.\n   * @param requestedSnaps - The snaps to install.\n   * @returns An object of snap ids and snap objects, or errors if a\n   * snap couldn't be installed.\n   */\n  async installSnaps(\n    origin: string,\n    requestedSnaps: RequestSnapsParams,\n  ): Promise<RequestSnapsResult> {\n    this.#assertCanUsePlatform();\n\n    const result: RequestSnapsResult = {};\n\n    const snapIds = Object.keys(requestedSnaps);\n\n    const pendingUpdates = [];\n    const pendingInstalls = [];\n\n    try {\n      for (const [snapId, { version: rawVersion }] of Object.entries(\n        requestedSnaps,\n      )) {\n        assertIsValidSnapId(snapId);\n\n        const [error, version] = resolveVersionRange(rawVersion);\n\n        if (error) {\n          throw rpcErrors.invalidParams(\n            `The \"version\" field must be a valid SemVer version range if specified. Received: \"${\n              rawVersion as string\n            }\".`,\n          );\n        }\n\n        const location = this.#detectSnapLocation(snapId, {\n          versionRange: version,\n          fetch: this.#fetchFunction,\n          allowLocal: this.#featureFlags.allowLocalSnaps,\n          resolveVersion: async (range) =>\n            this.#featureFlags.requireAllowlist\n              ? await this.#resolveAllowlistVersion(snapId, range)\n              : range,\n        });\n\n        // Existing snaps may need to be updated, unless they should be re-installed (e.g. local snaps)\n        // Everything else is treated as an install\n        const isUpdate = this.has(snapId) && !location.shouldAlwaysReload;\n\n        if (isUpdate && this.#isValidUpdate(snapId, version)) {\n          const existingSnap = this.getExpect(snapId);\n          pendingUpdates.push({ snapId, oldVersion: existingSnap.version });\n          let rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n          if (rollbackSnapshot === undefined) {\n            rollbackSnapshot = this.#createRollbackSnapshot(snapId);\n            rollbackSnapshot.newVersion = version;\n          } else {\n            throw new Error('This snap is already being updated.');\n          }\n        } else if (!isUpdate) {\n          pendingInstalls.push(snapId);\n        }\n\n        result[snapId] = await this.#processRequestedSnap(\n          origin,\n          snapId,\n          location,\n          version,\n        );\n      }\n\n      // Once we finish all installs / updates, emit events.\n      pendingInstalls.forEach((snapId) =>\n        this.messagingSystem.publish(\n          `SnapController:snapInstalled`,\n          this.getTruncatedExpect(snapId),\n          origin,\n          false,\n        ),\n      );\n\n      pendingUpdates.forEach(({ snapId, oldVersion }) =>\n        this.messagingSystem.publish(\n          `SnapController:snapUpdated`,\n          this.getTruncatedExpect(snapId),\n          oldVersion,\n          origin,\n          false,\n        ),\n      );\n\n      snapIds.forEach((snapId) => this.#rollbackSnapshots.delete(snapId));\n    } catch (error) {\n      const installed = pendingInstalls.filter((snapId) => this.has(snapId));\n      await this.removeSnaps(installed);\n      const snapshottedSnaps = [...this.#rollbackSnapshots.keys()];\n      const snapsToRollback = pendingUpdates\n        .map(({ snapId }) => snapId)\n        .filter((snapId) => snapshottedSnaps.includes(snapId));\n      await this.#rollbackSnaps(snapsToRollback);\n\n      throw error;\n    }\n\n    return result;\n  }\n\n  /**\n   * Adds, authorizes, and runs the given snap with a snap provider.\n   * Results from this method should be efficiently serializable.\n   *\n   * @param origin - The origin requesting the snap.\n   * @param snapId - The id of the snap.\n   * @param location - The location implementation of the snap.\n   * @param versionRange - The semver range of the snap to install.\n   * @returns The resulting snap object, or an error if something went wrong.\n   */\n  async #processRequestedSnap(\n    origin: string,\n    snapId: SnapId,\n    location: SnapLocation,\n    versionRange: SemVerRange,\n  ): Promise<TruncatedSnap> {\n    const existingSnap = this.getTruncated(snapId);\n\n    // For devX we always re-install local snaps.\n    if (existingSnap && !location.shouldAlwaysReload) {\n      if (satisfiesVersionRange(existingSnap.version, versionRange)) {\n        return existingSnap;\n      }\n\n      return await this.#updateSnap({\n        origin,\n        snapId,\n        location,\n        versionRange,\n      });\n    }\n\n    this.#assertCanInstallSnaps();\n\n    let pendingApproval = this.#createApproval({\n      origin,\n      snapId,\n      type: SNAP_APPROVAL_INSTALL,\n    });\n\n    this.messagingSystem.publish(\n      'SnapController:snapInstallStarted',\n      snapId,\n      origin,\n      false,\n    );\n\n    // Existing snaps must be stopped before overwriting\n    if (existingSnap && this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    // Existing snaps that should be re-installed should not maintain their existing permissions\n    if (existingSnap && location.shouldAlwaysReload) {\n      this.#revokeAllSnapPermissions(snapId);\n    }\n\n    try {\n      const { sourceCode } = await this.#add({\n        origin,\n        id: snapId,\n        location,\n        versionRange,\n      });\n\n      await this.#authorize(snapId, pendingApproval);\n\n      pendingApproval = this.#createApproval({\n        origin,\n        snapId,\n        type: SNAP_APPROVAL_RESULT,\n      });\n\n      await this.#startSnap({\n        snapId,\n        sourceCode,\n      });\n\n      const truncated = this.getTruncatedExpect(snapId);\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        type: SNAP_APPROVAL_INSTALL,\n      });\n\n      return truncated;\n    } catch (error) {\n      logError(`Error when adding ${snapId}.`, error);\n\n      const errorString =\n        error instanceof Error ? error.message : error.toString();\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        type: SNAP_APPROVAL_INSTALL,\n        error: errorString,\n      });\n\n      this.messagingSystem.publish(\n        'SnapController:snapInstallFailed',\n        snapId,\n        origin,\n        false,\n        errorString,\n      );\n\n      throw error;\n    }\n  }\n\n  #createApproval({\n    origin,\n    snapId,\n    type,\n  }: {\n    origin: string;\n    snapId: SnapId;\n    type: string;\n  }): PendingApproval {\n    const id = nanoid();\n    const promise = this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        origin,\n        id,\n        type,\n        requestData: {\n          // Mirror previous installation metadata\n          metadata: { id, origin: snapId, dappOrigin: origin },\n          snapId,\n        },\n        requestState: {\n          loading: true,\n        },\n      },\n      true,\n    );\n\n    return { id, promise };\n  }\n\n  #updateApproval(id: string, requestState: Record<string, Json>) {\n    try {\n      this.messagingSystem.call('ApprovalController:updateRequestState', {\n        id,\n        requestState,\n      });\n    } catch {\n      // Do nothing\n    }\n  }\n\n  /**\n   * Updates an installed snap. The flow is similar to\n   * {@link SnapController.installSnaps}. The user will be asked if they want\n   * to update, then approve any permission changes, and finally the snap will\n   * be restarted.\n   *\n   * The update will fail if the user rejects any prompt or if the new version\n   * of the snap is blocked.\n   *\n   * If the original version of the snap was blocked and the update succeeded,\n   * the snap will be unblocked and enabled before it is restarted.\n   *\n   * @param options - An options bag.\n   * @param options.origin - The origin requesting the snap update.\n   * @param options.snapId - The id of the Snap to be updated.\n   * @param options.location - The location implementation of the snap.\n   * @param options.versionRange - A semver version range in which the maximum version will be chosen.\n   * @param options.automaticUpdate - An optional boolean flag to indicate whether this update should be done\n   * automatically.\n   * @returns The snap metadata if updated, `null` otherwise.\n   */\n  async #updateSnap({\n    origin,\n    snapId,\n    location,\n    versionRange,\n    automaticUpdate = false,\n  }: {\n    origin: string;\n    snapId: SnapId;\n    location: SnapLocation;\n    versionRange: SemVerRange;\n    automaticUpdate?: boolean;\n  }): Promise<TruncatedSnap> {\n    this.#assertCanInstallSnaps();\n    this.#assertCanUsePlatform();\n\n    const snap = this.getExpect(snapId);\n\n    const { preinstalled, removable, hidden, hideSnapBranding } = snap;\n\n    if (preinstalled && !automaticUpdate) {\n      throw new Error('Preinstalled Snaps cannot be manually updated.');\n    }\n\n    let pendingApproval = automaticUpdate\n      ? null\n      : this.#createApproval({\n          origin,\n          snapId,\n          type: SNAP_APPROVAL_UPDATE,\n        });\n\n    try {\n      this.messagingSystem.publish(\n        'SnapController:snapInstallStarted',\n        snapId,\n        origin,\n        true,\n      );\n\n      const oldManifest = snap.manifest;\n\n      const newSnap = await fetchSnap(snapId, location);\n      const { sourceCode: sourceCodeFile, manifest: manifestFile } = newSnap;\n\n      const manifest = manifestFile.result;\n\n      const newVersion = manifest.version;\n      if (!gtVersion(newVersion, snap.version)) {\n        throw rpcErrors.invalidParams(\n          `Snap \"${snapId}@${snap.version}\" is already installed. Couldn't update to a version inside requested \"${versionRange}\" range.`,\n        );\n      }\n\n      if (!satisfiesVersionRange(newVersion, versionRange)) {\n        throw new Error(\n          `Version mismatch. Manifest for \"${snapId}\" specifies version \"${newVersion}\" which doesn't satisfy requested version range \"${versionRange}\".`,\n        );\n      }\n\n      await this.#assertIsInstallAllowed(snapId, {\n        version: newVersion,\n        checksum: manifest.source.shasum,\n        permissions: manifest.initialPermissions,\n        platformVersion: manifest.platformVersion,\n      });\n\n      const processedPermissions = processSnapPermissions(\n        manifest.initialPermissions,\n      );\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      const { newPermissions, unusedPermissions, approvedPermissions } =\n        this.#calculatePermissionsChange(snapId, processedPermissions);\n\n      const { newConnections, unusedConnections, approvedConnections } =\n        this.#calculateConnectionsChange(\n          snapId,\n          oldManifest.initialConnections ?? {},\n          manifest.initialConnections ?? {},\n        );\n\n      let approvedNewPermissions;\n      let requestData;\n\n      if (pendingApproval) {\n        this.#updateApproval(pendingApproval.id, {\n          permissions: newPermissions,\n          newVersion: manifest.version,\n          newPermissions,\n          approvedPermissions,\n          unusedPermissions,\n          newConnections,\n          unusedConnections,\n          approvedConnections,\n          loading: false,\n        });\n\n        const { permissions, ...rest } =\n          (await pendingApproval.promise) as PermissionsRequest;\n\n        approvedNewPermissions = permissions;\n        requestData = rest;\n\n        pendingApproval = this.#createApproval({\n          origin,\n          snapId,\n          type: SNAP_APPROVAL_RESULT,\n        });\n      } else {\n        assert(automaticUpdate);\n        approvedNewPermissions = newPermissions;\n      }\n\n      if (this.isRunning(snapId)) {\n        await this.stopSnap(snapId, SnapStatusEvents.Stop);\n      }\n\n      this.#transition(snapId, SnapStatusEvents.Update);\n\n      this.#set({\n        origin,\n        id: snapId,\n        files: newSnap,\n        removable,\n        preinstalled,\n        hidden,\n        hideSnapBranding,\n        isUpdate: true,\n      });\n\n      this.#updatePermissions({\n        snapId,\n        unusedPermissions,\n        newPermissions: approvedNewPermissions,\n        requestData,\n      });\n\n      const previousInitialConnections = oldManifest.initialConnections ?? null;\n      const newInitialConnections = manifest.initialConnections ?? {};\n      this.#handleInitialConnections(\n        snapId,\n        previousInitialConnections,\n        newInitialConnections,\n      );\n\n      const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n      if (rollbackSnapshot !== undefined) {\n        rollbackSnapshot.permissions.revoked = unusedPermissions;\n        rollbackSnapshot.permissions.granted = approvedNewPermissions;\n        rollbackSnapshot.permissions.requestData = requestData;\n        rollbackSnapshot.previousInitialConnections =\n          previousInitialConnections;\n        rollbackSnapshot.newInitialConnections = newInitialConnections;\n      }\n\n      const sourceCode = sourceCodeFile.toString();\n\n      assert(\n        typeof sourceCode === 'string' && sourceCode.length > 0,\n        `Invalid source code for snap \"${snapId}\".`,\n      );\n\n      try {\n        await this.#startSnap({ snapId, sourceCode });\n      } catch {\n        throw new Error(`Snap ${snapId} crashed with updated source code.`);\n      }\n\n      const truncatedSnap = this.getTruncatedExpect(snapId);\n\n      if (pendingApproval) {\n        this.#updateApproval(pendingApproval.id, {\n          loading: false,\n          type: SNAP_APPROVAL_UPDATE,\n        });\n      }\n\n      return truncatedSnap;\n    } catch (error) {\n      logError(`Error when updating ${snapId},`, error);\n\n      const errorString =\n        error instanceof Error ? error.message : error.toString();\n\n      if (pendingApproval) {\n        this.#updateApproval(pendingApproval.id, {\n          loading: false,\n          error: errorString,\n          type: SNAP_APPROVAL_UPDATE,\n        });\n      }\n\n      this.messagingSystem.publish(\n        'SnapController:snapInstallFailed',\n        snapId,\n        origin,\n        true,\n        errorString,\n      );\n\n      throw error;\n    }\n  }\n\n  async #resolveAllowlistVersion(\n    snapId: SnapId,\n    versionRange: SemVerRange,\n  ): Promise<SemVerRange> {\n    return await this.messagingSystem.call(\n      'SnapsRegistry:resolveVersion',\n      snapId,\n      versionRange,\n    );\n  }\n\n  /**\n   * Returns a promise representing the complete installation of the requested snap.\n   * If the snap is already being installed, the previously pending promise will be returned.\n   *\n   * @param args - Object containing the snap id and either the URL of the snap's manifest,\n   * or the snap's manifest and source code. The object may also optionally contain a target\n   * version.\n   * @returns The resulting snap object.\n   */\n  async #add(args: AddSnapArgs): Promise<PersistedSnap> {\n    const { id: snapId, location, versionRange } = args;\n\n    this.#setupRuntime(snapId);\n    const runtime = this.#getRuntimeExpect(snapId);\n    if (!runtime.installPromise) {\n      log(`Adding snap: ${snapId}`);\n\n      // If fetching and setting the snap succeeds, this property will be set\n      // to null in the authorize() method.\n      runtime.installPromise = (async () => {\n        const fetchedSnap = await fetchSnap(snapId, location);\n        const manifest = fetchedSnap.manifest.result;\n        if (!satisfiesVersionRange(manifest.version, versionRange)) {\n          throw new Error(\n            `Version mismatch. Manifest for \"${snapId}\" specifies version \"${manifest.version}\" which doesn't satisfy requested version range \"${versionRange}\".`,\n          );\n        }\n\n        await this.#assertIsInstallAllowed(snapId, {\n          version: manifest.version,\n          checksum: manifest.source.shasum,\n          permissions: manifest.initialPermissions,\n          platformVersion: manifest.platformVersion,\n        });\n\n        const preinstalledArgs =\n          this.#featureFlags.forcePreinstalledSnaps && isLocalSnapId(snapId)\n            ? {\n                preinstalled: true,\n                hideSnapBranding: true,\n                hidden: false,\n              }\n            : {};\n\n        return this.#set({\n          ...args,\n          files: fetchedSnap,\n          id: snapId,\n          ...preinstalledArgs,\n        });\n      })();\n    }\n\n    try {\n      return await runtime.installPromise;\n    } catch (error) {\n      // Reset promise so users can retry installation in case the problem is\n      // temporary.\n      runtime.installPromise = null;\n      throw error;\n    }\n  }\n\n  async #startSnap(snapData: { snapId: SnapId; sourceCode: string }) {\n    const { snapId } = snapData;\n    if (this.isRunning(snapId)) {\n      throw new Error(`Snap \"${snapId}\" is already started.`);\n    }\n\n    try {\n      const runtime = this.#getRuntimeExpect(snapId);\n      const result = await this.messagingSystem.call(\n        'ExecutionService:executeSnap',\n        {\n          ...snapData,\n          endowments: await this.#getEndowments(snapId),\n        },\n      );\n\n      this.#transition(snapId, SnapStatusEvents.Start);\n      // We treat the initialization of the snap as the first request, for idle timing purposes.\n      runtime.lastRequest = Date.now();\n      return result;\n    } catch (error) {\n      await this.#terminateSnap(snapId);\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the names of all endowments that will be added to the Snap's\n   * Compartment when it executes. These should be the names of global\n   * JavaScript APIs accessible in the root realm of the execution environment.\n   *\n   * Throws an error if the endowment getter for a permission returns a truthy\n   * value that is not an array of strings.\n   *\n   * @param snapId - The id of the snap whose SES endowments to get.\n   * @returns An array of the names of the endowments.\n   */\n  async #getEndowments(snapId: string): Promise<string[]> {\n    let allEndowments: string[] = [];\n\n    for (const permissionName of this.#environmentEndowmentPermissions) {\n      if (\n        this.messagingSystem.call(\n          'PermissionController:hasPermission',\n          snapId,\n          permissionName,\n        )\n      ) {\n        const endowments = await this.messagingSystem.call(\n          'PermissionController:getEndowments',\n          snapId,\n          permissionName,\n        );\n\n        if (endowments) {\n          // We don't have any guarantees about the type of the endowments\n          // value, so we have to guard at runtime.\n          if (\n            !Array.isArray(endowments) ||\n            endowments.some((value) => typeof value !== 'string')\n          ) {\n            throw new Error('Expected an array of string endowment names.');\n          }\n\n          allEndowments = allEndowments.concat(endowments as string[]);\n        }\n      }\n    }\n\n    const dedupedEndowments = [\n      ...new Set([...DEFAULT_ENDOWMENTS, ...allEndowments]),\n    ];\n\n    if (\n      dedupedEndowments.length <\n      DEFAULT_ENDOWMENTS.length + allEndowments.length\n    ) {\n      logError(\n        `Duplicate endowments found for ${snapId}. Default endowments should not be requested.`,\n        allEndowments,\n      );\n    }\n    return dedupedEndowments;\n  }\n\n  /**\n   * Sets a snap in state. Called when a snap is installed or updated. Performs\n   * various validation checks on the received arguments, and will throw if\n   * validation fails.\n   *\n   * The snap will be enabled and unblocked by the time this method returns,\n   * regardless of its previous state.\n   *\n   * See {@link SnapController.add} and {@link SnapController.updateSnap} for\n   * usage.\n   *\n   * @param args - The add snap args.\n   * @returns The resulting snap object.\n   */\n  #set(args: SetSnapArgs): PersistedSnap {\n    const {\n      id: snapId,\n      origin,\n      files,\n      isUpdate = false,\n      removable,\n      preinstalled,\n      hidden,\n      hideSnapBranding,\n    } = args;\n\n    const {\n      manifest,\n      sourceCode: sourceCodeFile,\n      svgIcon,\n      auxiliaryFiles: rawAuxiliaryFiles,\n      localizationFiles,\n    } = files;\n\n    assertIsSnapManifest(manifest.result);\n    const { version } = manifest.result;\n\n    const sourceCode = sourceCodeFile.toString();\n\n    assert(\n      typeof sourceCode === 'string' && sourceCode.length > 0,\n      `Invalid source code for snap \"${snapId}\".`,\n    );\n\n    const auxiliaryFiles = rawAuxiliaryFiles.map((file) => {\n      assert(typeof file.data.base64 === 'string');\n      return {\n        path: file.path,\n        value: file.data.base64,\n      };\n    });\n\n    const snapsState = this.state.snaps;\n\n    const existingSnap = snapsState[snapId];\n\n    const previousVersionHistory = existingSnap?.versionHistory ?? [];\n    const versionHistory = [\n      ...previousVersionHistory,\n      {\n        version,\n        date: Date.now(),\n        origin,\n      },\n    ];\n\n    const localizedFiles = localizationFiles.map((file) => file.result);\n\n    const snap: Snap = {\n      // Restore relevant snap state if it exists\n      ...existingSnap,\n\n      // Note that the snap will be unblocked and enabled, regardless of its\n      // previous state.\n      blocked: false,\n      enabled: true,\n\n      removable,\n      preinstalled,\n      hidden,\n      hideSnapBranding,\n\n      id: snapId,\n      initialConnections: manifest.result.initialConnections,\n      initialPermissions: manifest.result.initialPermissions,\n      manifest: manifest.result,\n      status: this.#statusMachine.config.initial as StatusStates['value'],\n      sourceCode,\n      version,\n      versionHistory,\n      auxiliaryFiles,\n      localizationFiles: localizedFiles,\n    };\n\n    // If the snap was blocked, it isn't any longer\n    delete snap.blockInformation;\n\n    // store the snap back in state\n    const { inversePatches } = this.update((state: any) => {\n      state.snaps[snapId] = snap;\n    });\n\n    // checking for isUpdate here as this function is also used in\n    // the install flow, we do not care to create snapshots for installs\n    if (isUpdate) {\n      const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n      if (rollbackSnapshot !== undefined) {\n        rollbackSnapshot.statePatches = inversePatches;\n      }\n    }\n\n    // In case the Snap uses a localized manifest, we need to get the\n    // proposed name from the localized manifest.\n    const { proposedName } = getLocalizedSnapManifest(\n      manifest.result,\n      'en',\n      localizedFiles,\n    );\n\n    this.messagingSystem.call('SubjectMetadataController:addSubjectMetadata', {\n      subjectType: SubjectType.Snap,\n      name: proposedName,\n      origin: snap.id,\n      version,\n      svgIcon: svgIcon?.toString() ?? null,\n    });\n\n    return { ...snap, sourceCode };\n  }\n\n  #validateSnapPermissions(\n    processedPermissions: Record<string, Pick<PermissionConstraint, 'caveats'>>,\n  ) {\n    const permissionKeys = Object.keys(processedPermissions);\n    const handlerPermissions = Array.from(\n      new Set(Object.values(handlerEndowments)),\n    );\n\n    assert(\n      permissionKeys.some((key) => handlerPermissions.includes(key)),\n      `A snap must request at least one of the following permissions: ${handlerPermissions\n        .filter((handler) => handler !== null)\n        .join(', ')}.`,\n    );\n\n    const excludedPermissionErrors = permissionKeys.reduce<string[]>(\n      (errors, permission) => {\n        if (hasProperty(this.#excludedPermissions, permission)) {\n          errors.push(this.#excludedPermissions[permission]);\n        }\n\n        return errors;\n      },\n      [],\n    );\n\n    assert(\n      excludedPermissionErrors.length === 0,\n      `One or more permissions are not allowed:\\n${excludedPermissionErrors.join(\n        '\\n',\n      )}`,\n    );\n  }\n\n  /**\n   * Validate that the platform version specified in the manifest (if any) is\n   * compatible with the current platform version.\n   *\n   * @param snapId - The ID of the Snap.\n   * @param platformVersion - The platform version to validate against.\n   * @throws If the platform version is greater than the current platform\n   * version.\n   */\n  #validatePlatformVersion(\n    snapId: SnapId,\n    platformVersion: string | undefined,\n  ) {\n    if (platformVersion === undefined) {\n      return;\n    }\n\n    if (gt(platformVersion, getPlatformVersion())) {\n      const message = `The Snap \"${snapId}\" requires platform version \"${platformVersion}\" which is greater than the current platform version \"${getPlatformVersion()}\".`;\n\n      if (this.#featureFlags.rejectInvalidPlatformVersion) {\n        throw new Error(message);\n      }\n\n      logWarning(message);\n    }\n  }\n\n  /**\n   * Initiates a request for the given snap's initial permissions.\n   * Must be called in order. See processRequestedSnap.\n   *\n   * @param snapId - The id of the Snap.\n   * @param pendingApproval - Pending approval to update.\n   * @returns The snap's approvedPermissions.\n   */\n  async #authorize(\n    snapId: SnapId,\n    pendingApproval: PendingApproval,\n  ): Promise<void> {\n    log(`Authorizing snap: ${snapId}`);\n    const snapsState = this.state.snaps;\n    const snap = snapsState[snapId];\n    const { initialPermissions, initialConnections } = snap;\n\n    try {\n      const processedPermissions = processSnapPermissions(initialPermissions);\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        connections: initialConnections ?? {},\n        permissions: processedPermissions,\n      });\n\n      const { permissions: approvedPermissions, ...requestData } =\n        (await pendingApproval.promise) as PermissionsRequest;\n\n      this.#updatePermissions({\n        snapId,\n        newPermissions: approvedPermissions,\n        requestData,\n      });\n\n      if (snap.manifest.initialConnections) {\n        this.#handleInitialConnections(\n          snapId,\n          null,\n          snap.manifest.initialConnections,\n        );\n      }\n    } finally {\n      const runtime = this.#getRuntimeExpect(snapId);\n      runtime.installPromise = null;\n    }\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this.#timeoutForLastRequestStatus) {\n      clearTimeout(this.#timeoutForLastRequestStatus);\n    }\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n\n    this.messagingSystem.clearEventSubscriptions(\n      'SnapController:snapInstalled',\n    );\n\n    this.messagingSystem.clearEventSubscriptions('SnapController:snapUpdated');\n    /* eslint-enable @typescript-eslint/unbound-method */\n  }\n\n  /**\n   * Passes a JSON-RPC request object to the RPC handler function of a snap.\n   *\n   * @param options - A bag of options.\n   * @param options.snapId - The ID of the recipient snap.\n   * @param options.origin - The origin of the RPC request.\n   * @param options.handler - The handler to trigger on the snap for the request.\n   * @param options.request - The JSON-RPC request object.\n   * @returns The result of the JSON-RPC request.\n   */\n  async handleRequest({\n    snapId,\n    origin,\n    handler: handlerType,\n    request: rawRequest,\n  }: SnapRpcHookArgs & { snapId: SnapId }): Promise<unknown> {\n    this.#assertCanUsePlatform();\n\n    const snap = this.get(snapId);\n\n    assert(\n      snap,\n      `The Snap \"${snapId}\" is not installed. Please install it before invoking it.`,\n    );\n\n    assert(\n      origin === METAMASK_ORIGIN || isValidUrl(origin),\n      \"'origin' must be a valid URL or 'metamask'.\",\n    );\n\n    const request = {\n      jsonrpc: '2.0',\n      id: nanoid(),\n      ...rawRequest,\n    };\n\n    assertIsJsonRpcRequest(request);\n\n    const permissionName = handlerEndowments[handlerType];\n\n    assert(\n      typeof permissionName === 'string' || permissionName === null,\n      \"'permissionName' must be either a string or null.\",\n    );\n\n    const permissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n\n    // If permissionName is null, the handler does not require a permission.\n    if (\n      permissionName !== null &&\n      (!permissions || !hasProperty(permissions, permissionName))\n    ) {\n      throw new Error(\n        `Snap \"${snapId}\" is not permitted to use \"${permissionName}\".`,\n      );\n    }\n\n    const handlerPermissions = permissionName\n      ? (permissions as SubjectPermissions<PermissionConstraint>)[\n          permissionName\n        ]\n      : undefined;\n\n    if (\n      permissionName === SnapEndowments.Rpc ||\n      permissionName === SnapEndowments.Keyring\n    ) {\n      assert(handlerPermissions);\n\n      const subject = this.messagingSystem.call(\n        'SubjectMetadataController:getSubjectMetadata',\n        origin,\n      );\n\n      const origins =\n        permissionName === SnapEndowments.Rpc\n          ? getRpcCaveatOrigins(handlerPermissions)\n          : getKeyringCaveatOrigins(handlerPermissions);\n      assert(origins);\n\n      if (\n        !isOriginAllowed(\n          origins,\n          subject?.subjectType ?? SubjectType.Website,\n          origin,\n        )\n      ) {\n        throw new Error(\n          `Snap \"${snapId}\" is not permitted to handle requests from \"${origin}\".`,\n        );\n      }\n    }\n\n    if (\n      origin !== METAMASK_ORIGIN &&\n      CLIENT_ONLY_HANDLERS.includes(handlerType)\n    ) {\n      throw new Error(`\"${handlerType}\" can only be invoked by MetaMask.`);\n    }\n\n    if (!snap.enabled) {\n      throw new Error(`Snap \"${snapId}\" is disabled.`);\n    }\n\n    if (snap.status === SnapStatus.Installing) {\n      throw new Error(\n        `Snap \"${snapId}\" is currently being installed. Please try again later.`,\n      );\n    }\n\n    const timeout = this.#getExecutionTimeout(handlerPermissions);\n\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (runtime.stopPromise) {\n      await runtime.stopPromise;\n    }\n\n    if (!this.isRunning(snapId)) {\n      if (!runtime.startPromise) {\n        runtime.startPromise = this.startSnap(snapId);\n      }\n\n      try {\n        await runtime.startPromise;\n      } finally {\n        runtime.startPromise = null;\n      }\n    }\n\n    const transformedRequest = this.#transformSnapRpcRequest(\n      snapId,\n      handlerType,\n      request,\n    );\n\n    const timer = new Timer(timeout);\n    this.#recordSnapRpcRequestStart(snapId, transformedRequest.id, timer);\n\n    const handleRpcRequestPromise = this.messagingSystem.call(\n      'ExecutionService:handleRpcRequest',\n      snapId,\n      { origin, handler: handlerType, request: transformedRequest },\n    );\n\n    // This will either get the result or reject due to the timeout.\n    try {\n      const result = await withTimeout(handleRpcRequestPromise, timer);\n\n      if (result === hasTimedOut) {\n        const stopping =\n          runtime.stopPromise !== null || !this.isRunning(snapId);\n        throw new Error(\n          stopping\n            ? `${snapId} was stopped and the request was cancelled. This is likely because the Snap crashed.`\n            : `${snapId} failed to respond to the request in time.`,\n        );\n      }\n\n      await this.#assertSnapRpcResponse(snapId, handlerType, result);\n\n      const transformedResult = await this.#transformSnapRpcResponse(\n        snapId,\n        handlerType,\n        transformedRequest,\n        result,\n      );\n\n      this.#recordSnapRpcRequestFinish(\n        snapId,\n        transformedRequest.id,\n        handlerType,\n        origin,\n        true,\n      );\n\n      return transformedResult;\n    } catch (error) {\n      // We flag the RPC request as finished early since termination may affect pending requests\n      this.#recordSnapRpcRequestFinish(\n        snapId,\n        transformedRequest.id,\n        handlerType,\n        origin,\n        false,\n      );\n\n      const [jsonRpcError, handled] = unwrapError(error);\n\n      const stopping = runtime.stopPromise !== null || !this.isRunning(snapId);\n\n      if (!handled) {\n        if (!stopping) {\n          logError(\n            `\"${snapId}\" crashed due to an unhandled error:`,\n            jsonRpcError,\n          );\n        }\n        await this.stopSnap(snapId, SnapStatusEvents.Crash);\n      }\n\n      throw jsonRpcError;\n    }\n  }\n\n  /**\n   * Set the active state of the client. This will trigger the `onActive` or\n   * `onInactive` lifecycle hooks for all Snaps.\n   *\n   * @param active - A boolean indicating whether the client is active or not.\n   */\n  setClientActive(active: boolean) {\n    if (active) {\n      this.#callLifecycleHooks(METAMASK_ORIGIN, HandlerType.OnActive);\n    } else {\n      this.#callLifecycleHooks(METAMASK_ORIGIN, HandlerType.OnInactive);\n    }\n  }\n\n  /**\n   * Determine the execution timeout for a given handler permission.\n   *\n   * If no permission is specified or the permission itself has no execution timeout defined\n   * the constructor argument `maxRequestTime` will be used.\n   *\n   * @param permission - An optional permission constraint for the handler being called.\n   * @returns The execution timeout for the given handler.\n   */\n  #getExecutionTimeout(permission?: PermissionConstraint): number {\n    return getMaxRequestTimeCaveat(permission) ?? this.maxRequestTime;\n  }\n\n  /**\n   * Create a dynamic interface in the SnapInterfaceController.\n   *\n   * @param snapId - The snap ID.\n   * @param content - The initial interface content.\n   * @param contentType - The type of content.\n   * @returns An identifier that can be used to identify the interface.\n   */\n  async #createInterface(\n    snapId: SnapId,\n    content: ComponentOrElement,\n    contentType?: ContentType,\n  ): Promise<string> {\n    return this.messagingSystem.call(\n      'SnapInterfaceController:createInterface',\n      snapId,\n      content,\n      undefined,\n      contentType,\n    );\n  }\n\n  #assertInterfaceExists(snapId: SnapId, id: string) {\n    // This will throw if the interface isn't accessible, but we assert nevertheless.\n    assert(\n      this.messagingSystem.call(\n        'SnapInterfaceController:getInterface',\n        snapId,\n        id,\n      ),\n    );\n  }\n\n  /**\n   * Transform a RPC response if necessary.\n   *\n   * @param snapId - The snap ID of the snap that produced the result.\n   * @param handlerType - The handler type that produced the result.\n   * @param request - The request that returned the result.\n   * @param result - The response.\n   * @returns The transformed result if applicable, otherwise the original result.\n   */\n  async #transformSnapRpcResponse(\n    snapId: SnapId,\n    handlerType: HandlerType,\n    request: Record<string, unknown>,\n    result: unknown,\n  ) {\n    switch (handlerType) {\n      case HandlerType.OnTransaction:\n      case HandlerType.OnSignature:\n      case HandlerType.OnHomePage:\n      case HandlerType.OnSettingsPage: {\n        // Since this type has been asserted earlier we can cast\n        const castResult = result as Record<string, Json> | null;\n\n        // If a handler returns static content, we turn it into a dynamic UI\n        if (castResult && hasProperty(castResult, 'content')) {\n          const { content, ...rest } = castResult;\n          const id = await this.#createInterface(\n            snapId,\n            content as ComponentOrElement,\n          );\n\n          return { ...rest, id };\n        }\n        return result;\n      }\n      case HandlerType.OnAssetsLookup:\n        // We can cast since the request and result have already been validated.\n        return this.#transformOnAssetsLookupResult(\n          snapId,\n          request as { params: OnAssetsLookupArguments },\n          result as OnAssetsLookupResponse,\n        );\n\n      case HandlerType.OnAssetsConversion:\n        // We can cast since the request and result have already been validated.\n        return this.#transformOnAssetsConversionResult(\n          request as {\n            params: OnAssetsConversionArguments;\n          },\n          result as OnAssetsConversionResponse,\n        );\n\n      case HandlerType.OnAssetsMarketData:\n        // We can cast since the request and result have already been validated.\n        return this.#transformOnAssetsMarketDataResult(\n          request as { params: OnAssetsMarketDataArguments },\n          result as OnAssetsMarketDataResponse,\n        );\n\n      default:\n        return result;\n    }\n  }\n\n  /**\n   * Transform an RPC response coming from the `onAssetsLookup` handler.\n   *\n   * This filters out responses that are out of scope for the Snap based on\n   * its permissions and the incoming request.\n   *\n   * @param snapId - The snap ID of the snap that produced the result.\n   * @param request - The request that returned the result.\n   * @param request.params - The parameters for the request.\n   * @param result - The result.\n   * @param result.assets - The assets returned by the Snap.\n   * @returns The transformed result.\n   */\n  #transformOnAssetsLookupResult(\n    snapId: SnapId,\n    { params: requestedParams }: { params: OnAssetsLookupArguments },\n    { assets }: OnAssetsLookupResponse,\n  ) {\n    const permissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n    // We know the permissions are guaranteed to be set here.\n    assert(permissions);\n\n    const permission = permissions[SnapEndowments.Assets];\n    const scopes = getChainIdsCaveat(permission);\n    assert(scopes);\n\n    const { assets: requestedAssets } = requestedParams;\n\n    const filteredAssets = Object.keys(assets).reduce<\n      Record<CaipAssetType, AssetMetadata | null>\n    >((accumulator, assetType) => {\n      const castAssetType = assetType as CaipAssetTypeOrId;\n      const isValid =\n        scopes.some((scope) => castAssetType.startsWith(scope)) &&\n        requestedAssets.includes(castAssetType);\n      // Filter out unrequested assets and assets for scopes the Snap hasn't registered for.\n      if (isValid) {\n        accumulator[castAssetType] = assets[castAssetType];\n      }\n      return accumulator;\n    }, {});\n    return { assets: filteredAssets };\n  }\n\n  /**\n   * Transform an RPC response coming from the `onAssetsConversion` handler.\n   *\n   * This filters out responses that are out of scope for the Snap based on\n   * the incoming request.\n   *\n   * @param request - The request that returned the result.\n   * @param request.params - The parameters for the request.\n   * @param result - The result.\n   * @param result.conversionRates - The conversion rates returned by the Snap.\n   * @returns The transformed result.\n   */\n  #transformOnAssetsConversionResult(\n    { params: requestedParams }: { params: OnAssetsConversionArguments },\n    { conversionRates }: OnAssetsConversionResponse,\n  ) {\n    const { conversions: requestedConversions } = requestedParams;\n\n    const filteredConversionRates = requestedConversions.reduce<\n      Record<CaipAssetType, Record<CaipAssetType, AssetConversion>>\n    >((accumulator, conversion) => {\n      const rate = conversionRates[conversion.from]?.[conversion.to];\n      // Only include rates that were actually requested.\n      if (rate) {\n        accumulator[conversion.from] ??= {};\n        accumulator[conversion.from][conversion.to] = rate;\n      }\n      return accumulator;\n    }, {});\n    return { conversionRates: filteredConversionRates };\n  }\n\n  /**\n   * Transforms an RPC response coming from the `onAssetsMarketData` handler.\n   *\n   * This filters out responses that are out of scope for the Snap based on\n   * the incoming request.\n   *\n   * @param request - The request that returned the result.\n   * @param request.params - The parameters for the request.\n   * @param result - The result.\n   * @param result.marketData - The market data returned by the Snap.\n   * @returns The transformed result.\n   */\n  #transformOnAssetsMarketDataResult(\n    { params: requestedParams }: { params: OnAssetsMarketDataArguments },\n    { marketData }: OnAssetsMarketDataResponse,\n  ) {\n    const { assets: requestedAssets } = requestedParams;\n\n    const filteredMarketData = requestedAssets.reduce<\n      Record<CaipAssetTypeOrId, Record<CaipAssetType, AssetMarketData | null>>\n    >((accumulator, assets) => {\n      const result = marketData[assets.asset]?.[assets.unit];\n      // Only include rates that were actually requested.\n      if (result) {\n        accumulator[assets.asset] ??= {};\n        accumulator[assets.asset][assets.unit] = result;\n      }\n      return accumulator;\n    }, {});\n    return { marketData: filteredMarketData };\n  }\n\n  /**\n   * Transforms a JSON-RPC request before sending it to the Snap, if required for a given handler.\n   *\n   * @param snapId - The Snap ID.\n   * @param handlerType - The handler being called.\n   * @param request - The JSON-RPC request.\n   * @returns The potentially transformed JSON-RPC request.\n   */\n  #transformSnapRpcRequest(\n    snapId: SnapId,\n    handlerType: HandlerType,\n    request: JsonRpcRequest,\n  ) {\n    switch (handlerType) {\n      // For onUserInput we inject context, so the client doesn't have to worry about keeping it in sync.\n      case HandlerType.OnUserInput: {\n        assert(request.params && hasProperty(request.params, 'id'));\n\n        const interfaceId = request.params.id as string;\n        const { context } = this.messagingSystem.call(\n          'SnapInterfaceController:getInterface',\n          snapId,\n          interfaceId,\n        );\n\n        return {\n          ...request,\n          params: { ...request.params, context },\n        };\n      }\n\n      default:\n        return request;\n    }\n  }\n\n  /**\n   * Assert that the returned result of a Snap RPC call is the expected shape.\n   *\n   * @param snapId - The snap ID.\n   * @param handlerType - The handler type of the RPC Request.\n   * @param result - The result of the RPC request.\n   */\n  async #assertSnapRpcResponse(\n    snapId: SnapId,\n    handlerType: HandlerType,\n    result: unknown,\n  ) {\n    switch (handlerType) {\n      case HandlerType.OnTransaction: {\n        assertStruct(result, OnTransactionResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnSignature: {\n        assertStruct(result, OnSignatureResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnHomePage: {\n        assertStruct(result, OnHomePageResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnSettingsPage: {\n        assertStruct(result, OnSettingsPageResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnNameLookup:\n        assertStruct(result, OnNameLookupResponseStruct);\n        break;\n      case HandlerType.OnAssetsLookup:\n        assertStruct(result, OnAssetsLookupResponseStruct);\n        break;\n      case HandlerType.OnAssetsConversion:\n        assertStruct(result, OnAssetsConversionResponseStruct);\n        break;\n      case HandlerType.OnAssetHistoricalPrice:\n        assertStruct(result, OnAssetHistoricalPriceResponseStruct);\n        break;\n      case HandlerType.OnAssetsMarketData:\n        assertStruct(result, OnAssetsMarketDataResponseStruct);\n        break;\n      default:\n        break;\n    }\n  }\n\n  #recordSnapRpcRequestStart(snapId: SnapId, requestId: unknown, timer: Timer) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests.push({ requestId, timer });\n    runtime.lastRequest = null;\n  }\n\n  #recordSnapRpcRequestFinish(\n    snapId: SnapId,\n    requestId: unknown,\n    handlerType: HandlerType,\n    origin: string,\n    success: boolean,\n  ) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests = runtime.pendingInboundRequests.filter(\n      (request) => request.requestId !== requestId,\n    );\n\n    if (runtime.pendingInboundRequests.length === 0) {\n      runtime.lastRequest = Date.now();\n    }\n\n    const snap = this.get(snapId);\n\n    if (isTrackableHandler(handlerType) && !snap?.preinstalled) {\n      try {\n        this.#trackSnapExport(snapId, handlerType, success, origin);\n      } catch (error) {\n        logError(\n          `Error when calling MetaMetrics hook for snap \"${snap?.id}\": ${getErrorMessage(\n            error,\n          )}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Retrieves the rollback snapshot of a snap.\n   *\n   * @param snapId - The snap id.\n   * @returns A `RollbackSnapshot` or `undefined` if one doesn't exist.\n   */\n  #getRollbackSnapshot(snapId: SnapId): RollbackSnapshot | undefined {\n    return this.#rollbackSnapshots.get(snapId);\n  }\n\n  /**\n   * Creates a `RollbackSnapshot` that is used to help ensure\n   * atomicity in multiple snap updates.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If the snap exists before creation or if creation fails.\n   * @returns A `RollbackSnapshot`.\n   */\n  #createRollbackSnapshot(snapId: SnapId): RollbackSnapshot {\n    assert(\n      this.#rollbackSnapshots.get(snapId) === undefined,\n      `Snap \"${snapId}\" rollback snapshot already exists.`,\n    );\n\n    this.#rollbackSnapshots.set(snapId, {\n      statePatches: [],\n      permissions: {},\n      newVersion: '',\n    });\n\n    const newRollbackSnapshot = this.#rollbackSnapshots.get(snapId);\n\n    assert(\n      newRollbackSnapshot !== undefined,\n      `Snapshot creation failed for ${snapId}.`,\n    );\n    return newRollbackSnapshot;\n  }\n\n  /**\n   * Rolls back a snap to its previous state, permissions\n   * and source code based on the `RollbackSnapshot` that\n   * is captured during the update process. After rolling back,\n   * the function also emits an event indicating that the\n   * snap has been rolled back and it clears the snapshot\n   * for that snap.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If a snapshot does not exist.\n   */\n  async #rollbackSnap(snapId: SnapId) {\n    const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n    if (!rollbackSnapshot) {\n      throw new Error('A snapshot does not exist for this snap.');\n    }\n\n    await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    // Always set to stopped even if it wasn't running initially\n    if (this.get(snapId)?.status !== SnapStatus.Stopped) {\n      this.#transition(snapId, SnapStatusEvents.Stop);\n    }\n\n    const {\n      statePatches,\n      permissions,\n      previousInitialConnections,\n      newInitialConnections,\n    } = rollbackSnapshot;\n\n    if (statePatches?.length) {\n      this.applyPatches(statePatches);\n    }\n\n    // Reset snap status, as we may have been in another state when we stored state patches\n    // But now we are 100% in a stopped state\n    if (this.get(snapId)?.status !== SnapStatus.Stopped) {\n      this.update((state) => {\n        state.snaps[snapId].status = SnapStatus.Stopped;\n      });\n    }\n\n    this.#updatePermissions({\n      snapId,\n      unusedPermissions: permissions.granted,\n      newPermissions: permissions.revoked,\n      requestData: permissions.requestData,\n    });\n\n    // Calling this in reverse order to undo the changes\n    this.#handleInitialConnections(\n      snapId,\n      newInitialConnections ?? null,\n      previousInitialConnections ?? {},\n    );\n\n    const truncatedSnap = this.getTruncatedExpect(snapId);\n\n    this.messagingSystem.publish(\n      'SnapController:snapRolledback',\n      truncatedSnap,\n      rollbackSnapshot.newVersion,\n    );\n\n    this.#rollbackSnapshots.delete(snapId);\n  }\n\n  /**\n   * Iterates through an array of snap ids\n   * and calls `rollbackSnap` on them.\n   *\n   * @param snapIds - An array of snap ids.\n   */\n  async #rollbackSnaps(snapIds: SnapId[]) {\n    for (const snapId of snapIds) {\n      await this.#rollbackSnap(snapId);\n    }\n  }\n\n  #getRuntime(snapId: SnapId): SnapRuntimeData | undefined {\n    return this.#snapsRuntimeData.get(snapId);\n  }\n\n  #getRuntimeExpect(snapId: SnapId): SnapRuntimeData {\n    const runtime = this.#getRuntime(snapId);\n    assert(runtime !== undefined, `Snap \"${snapId}\" runtime data not found`);\n    return runtime;\n  }\n\n  #setupRuntime(snapId: SnapId) {\n    if (this.#snapsRuntimeData.has(snapId)) {\n      return;\n    }\n\n    const snap = this.get(snapId);\n    const interpreter = interpret(this.#statusMachine);\n    interpreter.start({\n      context: { snapId },\n      value:\n        snap?.status ??\n        (this.#statusMachine.config.initial as StatusStates['value']),\n    });\n\n    forceStrict(interpreter);\n\n    this.#snapsRuntimeData.set(snapId, {\n      lastRequest: null,\n      startPromise: null,\n      stopPromise: null,\n      installPromise: null,\n      encryptionKey: null,\n      encryptionSalt: null,\n      activeReferences: 0,\n      pendingInboundRequests: [],\n      pendingOutboundRequests: 0,\n      interpreter,\n      stateMutex: new Mutex(),\n      getStateMutex: new Mutex(),\n    });\n  }\n\n  #calculatePermissionsChange(\n    snapId: SnapId,\n    desiredPermissionsSet: Record<\n      string,\n      Pick<PermissionConstraint, 'caveats'>\n    >,\n  ): {\n    newPermissions: Record<string, Pick<PermissionConstraint, 'caveats'>>;\n    unusedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n    approvedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n  } {\n    const oldPermissions =\n      this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        snapId,\n      ) ?? {};\n\n    const newPermissions = permissionsDiff(\n      desiredPermissionsSet,\n      oldPermissions,\n    );\n    // TODO(ritave): The assumption that these are unused only holds so long as we do not\n    //               permit dynamic permission requests.\n    const unusedPermissions = permissionsDiff(\n      oldPermissions,\n      desiredPermissionsSet,\n    );\n\n    // It's a Set Intersection of oldPermissions and desiredPermissionsSet\n    // oldPermissions ∖ (oldPermissions ∖ desiredPermissionsSet) ⟺ oldPermissions ∩ desiredPermissionsSet\n    const approvedPermissions = permissionsDiff(\n      oldPermissions,\n      unusedPermissions,\n    );\n\n    return { newPermissions, unusedPermissions, approvedPermissions };\n  }\n\n  #isSubjectConnectedToSnap(snapId: SnapId, origin: string) {\n    const subjectPermissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const existingCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds);\n\n    return Boolean((existingCaveat?.value as Record<string, Json>)?.[snapId]);\n  }\n\n  #calculateConnectionsChange(\n    snapId: SnapId,\n    oldConnectionsSet: Record<string, Json>,\n    desiredConnectionsSet: Record<string, Json>,\n  ): {\n    newConnections: Record<string, Json>;\n    unusedConnections: Record<string, Json>;\n    approvedConnections: Record<string, Json>;\n  } {\n    // Filter out any origins that have been revoked since last install/update.\n    // That way they will be represented as new.\n    const filteredOldConnections = Object.keys(oldConnectionsSet)\n      .filter((origin) => this.#isSubjectConnectedToSnap(snapId, origin))\n      .reduce<Record<string, Json>>((accumulator, origin) => {\n        accumulator[origin] = oldConnectionsSet[origin];\n        return accumulator;\n      }, {});\n\n    const newConnections = setDiff(\n      desiredConnectionsSet,\n      filteredOldConnections,\n    );\n\n    const unusedConnections = setDiff(\n      filteredOldConnections,\n      desiredConnectionsSet,\n    );\n\n    // It's a Set Intersection of oldConnections and desiredConnectionsSet\n    // oldConnections ∖ (oldConnections ∖ desiredConnectionsSet) ⟺ oldConnections ∩ desiredConnectionsSet\n    const approvedConnections = setDiff(\n      filteredOldConnections,\n      unusedConnections,\n    );\n\n    return { newConnections, unusedConnections, approvedConnections };\n  }\n\n  /**\n   * Get the permissions to grant to a Snap following an install, update or\n   * rollback.\n   *\n   * @param snapId - The snap ID.\n   * @param newPermissions - The new permissions to be granted.\n   * @returns The permissions to grant to the Snap.\n   */\n  #getPermissionsToGrant(snapId: SnapId, newPermissions: RequestedPermissions) {\n    if (Object.keys(newPermissions).includes(SnapEndowments.EthereumProvider)) {\n      // This will return the globally selected network if the Snap doesn't have\n      // one set.\n      const networkClientId = this.messagingSystem.call(\n        'SelectedNetworkController:getNetworkClientIdForDomain',\n        snapId,\n      );\n\n      const { configuration } = this.messagingSystem.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n\n      const chainId = hexToNumber(configuration.chainId);\n\n      // This needs to be assigned to have proper type inference.\n      const modifiedPermissions: RequestedPermissions = {\n        ...newPermissions,\n        'endowment:caip25': {\n          caveats: [\n            {\n              type: 'authorizedScopes',\n              value: {\n                requiredScopes: {},\n                optionalScopes: {\n                  [`eip155:${chainId}`]: {\n                    accounts: [],\n                  },\n                },\n                sessionProperties: {},\n                isMultichainOrigin: false,\n              },\n            },\n          ],\n        },\n      };\n\n      return modifiedPermissions;\n    }\n\n    return newPermissions;\n  }\n\n  /**\n   * Update the permissions for a snap following an install, update or rollback.\n   *\n   * Grants newly requested permissions and revokes unused/revoked permissions.\n   *\n   * @param args - An options bag.\n   * @param args.snapId - The snap ID.\n   * @param args.newPermissions - New permissions to be granted.\n   * @param args.unusedPermissions - Unused permissions to be revoked.\n   * @param args.requestData - Optional request data from an approval.\n   */\n  #updatePermissions({\n    snapId,\n    unusedPermissions = {},\n    newPermissions = {},\n    requestData,\n  }: {\n    snapId: SnapId;\n    newPermissions?:\n      | RequestedPermissions\n      | Record<string, Pick<PermissionConstraint, 'caveats'>>;\n    unusedPermissions?:\n      | RequestedPermissions\n      | SubjectPermissions<ValidPermission<string, Caveat<string, any>>>;\n    requestData?: Record<string, unknown>;\n  }) {\n    const unusedPermissionsKeys = Object.keys(unusedPermissions);\n    if (isNonEmptyArray(unusedPermissionsKeys)) {\n      this.messagingSystem.call('PermissionController:revokePermissions', {\n        [snapId]: unusedPermissionsKeys,\n      });\n    }\n\n    if (isNonEmptyArray(Object.keys(newPermissions))) {\n      const approvedPermissions = this.#getPermissionsToGrant(\n        snapId,\n        newPermissions,\n      );\n\n      this.messagingSystem.call('PermissionController:grantPermissions', {\n        approvedPermissions,\n        subject: { origin: snapId },\n        requestData,\n      });\n    }\n  }\n\n  /**\n   * Checks if a snap will pass version validation checks\n   * with the new version range that is requested. The first\n   * check that is done is to check if the existing snap version\n   * falls inside the requested range. If it does, we want to return\n   * false because we do not care to create a rollback snapshot in\n   * that scenario. The second check is to ensure that the current\n   * snap version is not greater than all possible versions in\n   * the requested version range. If it is, then we also want\n   * to return false in that scenario.\n   *\n   * @param snapId - The snap id.\n   * @param newVersionRange - The new version range being requested.\n   * @returns `true` if validation checks pass and `false` if they do not.\n   */\n  #isValidUpdate(snapId: SnapId, newVersionRange: SemVerRange): boolean {\n    const existingSnap = this.getExpect(snapId);\n\n    if (satisfiesVersionRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    if (gtRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Call a lifecycle hook for all runnable Snaps.\n   *\n   * @param origin - The origin of the request.\n   * @param handler - The lifecycle hook to call. This should be one of the\n   * supported lifecycle hooks.\n   */\n  #callLifecycleHooks(origin: string, handler: HandlerType) {\n    const snaps = this.getRunnableSnaps();\n    for (const { id } of snaps) {\n      const hasLifecycleHooksEndowment = this.messagingSystem.call(\n        'PermissionController:hasPermission',\n        id,\n        SnapEndowments.LifecycleHooks,\n      );\n\n      if (!hasLifecycleHooksEndowment) {\n        continue;\n      }\n\n      this.#callLifecycleHook(origin, id, handler).catch((error) => {\n        logError(\n          `Error calling lifecycle hook \"${handler}\" for Snap \"${id}\": ${getErrorMessage(\n            error,\n          )}`,\n        );\n      });\n    }\n  }\n\n  /**\n   * Call a lifecycle hook on a snap, if the snap has the\n   * `endowment:lifecycle-hooks` permission. If the snap does not have the\n   * permission, nothing happens.\n   *\n   * @param origin - The origin.\n   * @param snapId - The snap ID.\n   * @param handler - The lifecycle hook to call. This should be one of the\n   * supported lifecycle hooks.\n   * @private\n   */\n  async #callLifecycleHook(\n    origin: string,\n    snapId: SnapId,\n    handler: HandlerType,\n  ) {\n    const permissionName = handlerEndowments[handler];\n\n    assert(permissionName, 'Lifecycle hook must have an endowment.');\n\n    const hasPermission = this.messagingSystem.call(\n      'PermissionController:hasPermission',\n      snapId,\n      permissionName,\n    );\n\n    if (!hasPermission) {\n      return;\n    }\n\n    await this.handleRequest({\n      snapId,\n      handler,\n      origin,\n      request: {\n        jsonrpc: '2.0',\n        method: handler,\n      },\n    });\n  }\n\n  /**\n   * Handle the `KeyringController:lock` event.\n   *\n   * Currently this clears the cached encrypted state (if any) for all Snaps.\n   */\n  #handleLock() {\n    for (const runtime of this.#snapsRuntimeData.values()) {\n      runtime.encryptionKey = null;\n      runtime.encryptionSalt = null;\n      runtime.state = undefined;\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SnapController.mjs","sourceRoot":"","sources":["../../src/snaps/SnapController.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ORIGIN_METAMASK,\n  type AddApprovalRequest,\n  type UpdateRequestState,\n} from '@metamask/approval-controller';\nimport type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller/next';\nimport { BaseController } from '@metamask/base-controller/next';\nimport type { CryptographicFunctions } from '@metamask/key-tree';\nimport type { Messenger } from '@metamask/messenger';\nimport type {\n  Caveat,\n  GetEndowments,\n  GetPermissions,\n  GetSubjectMetadata,\n  AddSubjectMetadata,\n  GetSubjects,\n  GrantPermissions,\n  HasPermission,\n  HasPermissions,\n  PermissionConstraint,\n  PermissionsRequest,\n  RequestedPermissions,\n  RevokeAllPermissions,\n  RevokePermissionForAllSubjects,\n  RevokePermissions,\n  SubjectPermissions,\n  UpdateCaveat,\n  ValidPermission,\n} from '@metamask/permission-controller';\nimport { SubjectType } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { BlockReason } from '@metamask/snaps-registry';\nimport {\n  WALLET_SNAP_PERMISSION_KEY,\n  getMaxRequestTimeCaveat,\n  handlerEndowments,\n  SnapEndowments,\n  getKeyringCaveatOrigins,\n  getRpcCaveatOrigins,\n  processSnapPermissions,\n  getEncryptionEntropy,\n  getChainIdsCaveat,\n} from '@metamask/snaps-rpc-methods';\nimport type {\n  RequestSnapsParams,\n  RequestSnapsResult,\n  SnapId,\n  ComponentOrElement,\n  ContentType,\n  OnAssetsLookupResponse,\n  OnAssetsConversionResponse,\n  OnAssetsConversionArguments,\n  AssetConversion,\n  OnAssetsLookupArguments,\n  OnAssetsMarketDataArguments,\n  OnAssetsMarketDataResponse,\n  AssetMarketData,\n  AssetMetadata,\n  EmptyObject,\n} from '@metamask/snaps-sdk';\nimport {\n  AuxiliaryFileEncoding,\n  getErrorMessage,\n  OnAssetsLookupResponseStruct,\n} from '@metamask/snaps-sdk';\nimport type {\n  FetchedSnapFiles,\n  InitialConnections,\n  PersistedSnap,\n  Snap,\n  SnapManifest,\n  SnapPermissions,\n  SnapRpcHookArgs,\n  StatusContext,\n  StatusEvents,\n  StatusStates,\n  TruncatedSnap,\n  TruncatedSnapFields,\n} from '@metamask/snaps-utils';\nimport {\n  logWarning,\n  getPlatformVersion,\n  assertIsSnapManifest,\n  assertIsValidSnapId,\n  DEFAULT_ENDOWMENTS,\n  encodeAuxiliaryFile,\n  HandlerType,\n  isOriginAllowed,\n  logError,\n  normalizeRelative,\n  OnTransactionResponseStruct,\n  OnSignatureResponseStruct,\n  resolveVersionRange,\n  SnapCaveatType,\n  SnapStatus,\n  SnapStatusEvents,\n  unwrapError,\n  OnHomePageResponseStruct,\n  getValidatedLocalizationFiles,\n  VirtualFile,\n  NpmSnapFileNames,\n  OnNameLookupResponseStruct,\n  getLocalizedSnapManifest,\n  MAX_FILE_SIZE,\n  OnSettingsPageResponseStruct,\n  isValidUrl,\n  OnAssetHistoricalPriceResponseStruct,\n  OnAssetsConversionResponseStruct,\n  OnAssetsMarketDataResponseStruct,\n} from '@metamask/snaps-utils';\nimport type {\n  Json,\n  NonEmptyArray,\n  SemVerRange,\n  CaipAssetType,\n  JsonRpcRequest,\n  Hex,\n  SemVerVersion,\n  CaipAssetTypeOrId,\n} from '@metamask/utils';\nimport {\n  hexToNumber,\n  assert,\n  assertIsJsonRpcRequest,\n  assertStruct,\n  Duration,\n  gtRange,\n  gtVersion,\n  hasProperty,\n  inMilliseconds,\n  isNonEmptyArray,\n  satisfiesVersionRange,\n  timeSince,\n  createDeferredPromise,\n} from '@metamask/utils';\nimport type { StateMachine } from '@xstate/fsm';\nimport { createMachine, interpret } from '@xstate/fsm';\nimport { Mutex } from 'async-mutex';\nimport type { Patch } from 'immer';\nimport { nanoid } from 'nanoid';\nimport { gt, gte } from 'semver';\n\nimport {\n  ALLOWED_PERMISSIONS,\n  CLIENT_ONLY_HANDLERS,\n  LEGACY_ENCRYPTION_KEY_DERIVATION_OPTIONS,\n  METAMASK_ORIGIN,\n  STATE_DEBOUNCE_TIMEOUT,\n} from './constants';\nimport type { SnapLocation } from './location';\nimport { detectSnapLocation } from './location';\nimport type {\n  GetMetadata,\n  GetResult,\n  ResolveVersion,\n  SnapsRegistryInfo,\n  SnapsRegistryRequest,\n  Update,\n} from './registry';\nimport { SnapsRegistryStatus } from './registry';\nimport { getRunnableSnaps } from './selectors';\nimport { Timer } from './Timer';\nimport { forceStrict, validateMachine } from '../fsm';\nimport type { CreateInterface, GetInterface } from '../interface';\nimport { log } from '../logging';\nimport type {\n  ExecuteSnapAction,\n  ExecutionServiceEvents,\n  HandleRpcRequestAction,\n  SnapErrorJson,\n  TerminateSnapAction,\n} from '../services';\nimport type {\n  EncryptionResult,\n  ExportableKeyEncryptor,\n  KeyDerivationOptions,\n} from '../types';\nimport {\n  debouncePersistState,\n  fetchSnap,\n  hasTimedOut,\n  permissionsDiff,\n  setDiff,\n  throttleTracking,\n  withTimeout,\n  isTrackableHandler,\n  isLocalSnapId,\n} from '../utils';\n\nexport const controllerName = 'SnapController';\n\n// TODO: Figure out how to name these\nexport const SNAP_APPROVAL_INSTALL = 'wallet_installSnap';\nexport const SNAP_APPROVAL_UPDATE = 'wallet_updateSnap';\nexport const SNAP_APPROVAL_RESULT = 'wallet_installSnapResult';\n\nconst TRUNCATED_SNAP_PROPERTIES = new Set<TruncatedSnapFields>([\n  'initialPermissions',\n  'id',\n  'version',\n  'enabled',\n  'blocked',\n]);\n\nexport type PendingRequest = {\n  requestId: unknown;\n  timer: Timer;\n};\n\nexport type PreinstalledSnapFile = {\n  path: string;\n  value: string | Uint8Array;\n};\n\nexport type PreinstalledSnap = {\n  snapId: SnapId;\n  manifest: SnapManifest;\n  files: PreinstalledSnapFile[];\n  removable?: boolean;\n  hidden?: boolean;\n  hideSnapBranding?: boolean;\n};\n\n/**\n * A wrapper type for any data stored during runtime of Snaps.\n * It is not persisted in state as it contains non-serializable data and is only relevant for the\n * current session.\n */\nexport type SnapRuntimeData = {\n  /**\n   * A promise that resolves when the Snap has finished installing\n   */\n  installPromise: null | Promise<PersistedSnap>;\n\n  /**\n   * A promise that resolves when the Snap has finished booting\n   */\n  startPromise: null | Promise<void>;\n\n  /**\n   * A promise that resolves when the Snap has finished stopping\n   */\n  stopPromise: null | Promise<void>;\n\n  /**\n   * A Unix timestamp for the last time the Snap received an RPC request\n   */\n  lastRequest: null | number;\n\n  /**\n   * The current number of active references where this Snap is being used\n   */\n  activeReferences: number;\n\n  /**\n   * The current pending inbound requests, meaning requests that are processed by snaps.\n   */\n  pendingInboundRequests: PendingRequest[];\n\n  /**\n   * The current pending outbound requests, meaning requests made from snaps towards the MetaMask\n   * extension.\n   */\n  pendingOutboundRequests: number;\n\n  /**\n   * The finite state machine interpreter for possible states that the Snap can be in such as\n   * stopped, running, blocked\n   *\n   * @see {@link SnapController:constructor}\n   */\n  interpreter: StateMachine.Service<StatusContext, StatusEvents, StatusStates>;\n\n  /**\n   * Cached encryption key used for state encryption.\n   */\n  encryptionKey: string | null;\n\n  /**\n   * Cached encryption salt used for state encryption.\n   */\n  encryptionSalt: string | null;\n\n  /**\n   * Cached encrypted state of the Snap.\n   */\n  state?: Record<string, Json> | null;\n\n  /**\n   * Cached unencrypted state of the Snap.\n   */\n  unencryptedState?: Record<string, Json> | null;\n\n  /**\n   * A mutex to prevent concurrent state updates.\n   */\n  stateMutex: Mutex;\n\n  /**\n   * A mutex to prevent concurrent state decryption.\n   */\n  getStateMutex: Mutex;\n};\n\nexport type SnapError = {\n  message: string;\n  code: number;\n  data?: Json;\n};\n\n// Types that probably should be defined elsewhere in prod\ntype CloseAllConnectionsFunction = (origin: string) => void;\ntype StoredSnaps = Record<SnapId, Snap>;\n\nexport type SnapControllerState = {\n  snaps: StoredSnaps;\n  snapStates: Record<SnapId, string | null>;\n  unencryptedSnapStates: Record<SnapId, string | null>;\n};\n\nexport type PersistedSnapControllerState = SnapControllerState & {\n  snaps: Record<SnapId, PersistedSnap>;\n  snapStates: Record<SnapId, string>;\n};\n\ntype RollbackSnapshot = {\n  statePatches: Patch[];\n  permissions: {\n    revoked?: SubjectPermissions<ValidPermission<string, Caveat<string, any>>>;\n    granted?: RequestedPermissions;\n    requestData?: Record<string, unknown>;\n  };\n  previousInitialConnections?: Record<string, EmptyObject> | null;\n  newInitialConnections?: Record<string, EmptyObject>;\n  newVersion: string;\n};\n\ntype PendingApproval = {\n  id: string;\n  promise: Promise<unknown>;\n};\n\n// Controller Messenger Actions\n\n/**\n * Initialise the SnapController. This should be called after all controllers\n * are created.\n */\nexport type SnapControllerInitAction = {\n  type: `${typeof controllerName}:init`;\n  handler: SnapController['init'];\n};\n\n/**\n * Gets the specified Snap from state.\n */\nexport type GetSnap = {\n  type: `${typeof controllerName}:get`;\n  handler: SnapController['get'];\n};\n\n/**\n * Handles sending an inbound request to a snap and returns its result.\n */\nexport type HandleSnapRequest = {\n  type: `${typeof controllerName}:handleRequest`;\n  handler: SnapController['handleRequest'];\n};\n\n/**\n * Gets the specified Snap's persisted state.\n */\nexport type GetSnapState = {\n  type: `${typeof controllerName}:getSnapState`;\n  handler: SnapController['getSnapState'];\n};\n\n/**\n * Checks if the specified snap exists in state.\n */\nexport type HasSnap = {\n  type: `${typeof controllerName}:has`;\n  handler: SnapController['has'];\n};\n\n/**\n * Updates the specified Snap's persisted state.\n */\nexport type UpdateSnapState = {\n  type: `${typeof controllerName}:updateSnapState`;\n  handler: SnapController['updateSnapState'];\n};\n\n/**\n * Clears the specified Snap's persisted state.\n */\nexport type ClearSnapState = {\n  type: `${typeof controllerName}:clearSnapState`;\n  handler: SnapController['clearSnapState'];\n};\n\n/**\n * Checks all installed snaps against the blocklist.\n */\nexport type UpdateRegistry = {\n  type: `${typeof controllerName}:updateRegistry`;\n  handler: SnapController['updateRegistry'];\n};\n\nexport type EnableSnap = {\n  type: `${typeof controllerName}:enable`;\n  handler: SnapController['enableSnap'];\n};\n\nexport type DisableSnap = {\n  type: `${typeof controllerName}:disable`;\n  handler: SnapController['disableSnap'];\n};\n\nexport type RemoveSnap = {\n  type: `${typeof controllerName}:remove`;\n  handler: SnapController['removeSnap'];\n};\n\nexport type GetPermittedSnaps = {\n  type: `${typeof controllerName}:getPermitted`;\n  handler: SnapController['getPermittedSnaps'];\n};\n\nexport type GetAllSnaps = {\n  type: `${typeof controllerName}:getAll`;\n  handler: SnapController['getAllSnaps'];\n};\n\nexport type GetRunnableSnaps = {\n  type: `${typeof controllerName}:getRunnableSnaps`;\n  handler: SnapController['getRunnableSnaps'];\n};\n\nexport type StopAllSnaps = {\n  type: `${typeof controllerName}:stopAllSnaps`;\n  handler: SnapController['stopAllSnaps'];\n};\n\nexport type IncrementActiveReferences = {\n  type: `${typeof controllerName}:incrementActiveReferences`;\n  handler: SnapController['incrementActiveReferences'];\n};\n\nexport type DecrementActiveReferences = {\n  type: `${typeof controllerName}:decrementActiveReferences`;\n  handler: SnapController['decrementActiveReferences'];\n};\n\nexport type InstallSnaps = {\n  type: `${typeof controllerName}:install`;\n  handler: SnapController['installSnaps'];\n};\n\nexport type DisconnectOrigin = {\n  type: `${typeof controllerName}:disconnectOrigin`;\n  handler: SnapController['removeSnapFromSubject'];\n};\n\nexport type RevokeDynamicPermissions = {\n  type: `${typeof controllerName}:revokeDynamicPermissions`;\n  handler: SnapController['revokeDynamicSnapPermissions'];\n};\n\nexport type GetSnapFile = {\n  type: `${typeof controllerName}:getFile`;\n  handler: SnapController['getSnapFile'];\n};\n\nexport type IsMinimumPlatformVersion = {\n  type: `${typeof controllerName}:isMinimumPlatformVersion`;\n  handler: SnapController['isMinimumPlatformVersion'];\n};\n\nexport type SetClientActive = {\n  type: `${typeof controllerName}:setClientActive`;\n  handler: SnapController['setClientActive'];\n};\n\nexport type SnapControllerGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapControllerState\n>;\n\nexport type SnapControllerActions =\n  | SnapControllerInitAction\n  | ClearSnapState\n  | GetSnap\n  | GetSnapState\n  | HandleSnapRequest\n  | HasSnap\n  | UpdateRegistry\n  | UpdateSnapState\n  | EnableSnap\n  | DisableSnap\n  | RemoveSnap\n  | GetPermittedSnaps\n  | InstallSnaps\n  | GetAllSnaps\n  | GetRunnableSnaps\n  | IncrementActiveReferences\n  | DecrementActiveReferences\n  | DisconnectOrigin\n  | RevokeDynamicPermissions\n  | GetSnapFile\n  | SnapControllerGetStateAction\n  | StopAllSnaps\n  | IsMinimumPlatformVersion\n  | SetClientActive;\n\n// Controller Messenger Events\n\nexport type SnapStateChange = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [SnapControllerState, Patch[]];\n};\n\n/**\n * Emitted when an installed snap has been blocked.\n */\nexport type SnapBlocked = {\n  type: `${typeof controllerName}:snapBlocked`;\n  payload: [snapId: string, blockedSnapInfo?: BlockReason];\n};\n\n/**\n * Emitted when a snap installation or update is started.\n */\nexport type SnapInstallStarted = {\n  type: `${typeof controllerName}:snapInstallStarted`;\n  payload: [snapId: SnapId, origin: string, isUpdate: boolean];\n};\n\n/**\n * Emitted when a snap installation or update failed.\n */\nexport type SnapInstallFailed = {\n  type: `${typeof controllerName}:snapInstallFailed`;\n  payload: [snapId: SnapId, origin: string, isUpdate: boolean, error: string];\n};\n\n/**\n * Emitted when a snap has been started after being added and authorized during\n * installation.\n */\nexport type SnapInstalled = {\n  type: `${typeof controllerName}:snapInstalled`;\n  payload: [snap: TruncatedSnap, origin: string, preinstalled: boolean];\n};\n\n/**\n * Emitted when a snap that has previously been fully installed, is uninstalled.\n */\nexport type SnapUninstalled = {\n  type: `${typeof controllerName}:snapUninstalled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when an installed snap has been unblocked.\n */\nexport type SnapUnblocked = {\n  type: `${typeof controllerName}:snapUnblocked`;\n  payload: [snapId: string];\n};\n\n/**\n * Emitted when a snap is updated.\n */\nexport type SnapUpdated = {\n  type: `${typeof controllerName}:snapUpdated`;\n  payload: [\n    snap: TruncatedSnap,\n    oldVersion: string,\n    origin: string,\n    preinstalled: boolean,\n  ];\n};\n\n/**\n * Emitted when a snap is rolled back.\n */\nexport type SnapRolledback = {\n  type: `${typeof controllerName}:snapRolledback`;\n  payload: [snap: TruncatedSnap, failedVersion: string];\n};\n\n/**\n * Emitted when a Snap is terminated. This is different from the snap being\n * stopped as it can also be triggered when a snap fails initialization.\n */\nexport type SnapTerminated = {\n  type: `${typeof controllerName}:snapTerminated`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when a Snap is enabled by a user.\n * This is not emitted by default when installing a snap.\n */\nexport type SnapEnabled = {\n  type: `${typeof controllerName}:snapEnabled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when a Snap is disabled by a user.\n */\nexport type SnapDisabled = {\n  type: `${typeof controllerName}:snapDisabled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when there is a state change.\n */\nexport type SnapControllerStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  SnapControllerState\n>;\n\ntype KeyringControllerLock = {\n  type: 'KeyringController:lock';\n  payload: [];\n};\n\nexport type SnapControllerEvents =\n  | SnapBlocked\n  | SnapInstalled\n  | SnapUninstalled\n  | SnapInstallStarted\n  | SnapInstallFailed\n  | SnapStateChange\n  | SnapUnblocked\n  | SnapUpdated\n  | SnapRolledback\n  | SnapTerminated\n  | SnapEnabled\n  | SnapDisabled\n  | SnapControllerStateChangeEvent;\n\ntype NetworkControllerGetNetworkClientById = {\n  type: `NetworkController:getNetworkClientById`;\n  handler: (customNetworkClientId: string) => {\n    configuration: {\n      chainId: Hex;\n    };\n  };\n};\n\ntype SelectedNetworkControllerGetNetworkClientIdForDomain = {\n  type: `SelectedNetworkController:getNetworkClientIdForDomain`;\n  handler: (domain: string) => string;\n};\n\nexport type AllowedActions =\n  | GetEndowments\n  | GetPermissions\n  | GetSubjects\n  | GetSubjectMetadata\n  | AddSubjectMetadata\n  | HasPermission\n  | HasPermissions\n  | RevokePermissions\n  | RevokeAllPermissions\n  | RevokePermissionForAllSubjects\n  | GrantPermissions\n  | AddApprovalRequest\n  | HandleRpcRequestAction\n  | ExecuteSnapAction\n  | TerminateSnapAction\n  | UpdateCaveat\n  | UpdateRequestState\n  | GetResult\n  | GetMetadata\n  | Update\n  | ResolveVersion\n  | CreateInterface\n  | GetInterface\n  | NetworkControllerGetNetworkClientById\n  | SelectedNetworkControllerGetNetworkClientIdForDomain;\n\nexport type AllowedEvents =\n  | ExecutionServiceEvents\n  | SnapInstalled\n  | SnapUpdated\n  | KeyringControllerLock;\n\ntype SnapControllerMessenger = Messenger<\n  typeof controllerName,\n  SnapControllerActions | AllowedActions,\n  SnapControllerEvents | AllowedEvents\n>;\n\ntype FeatureFlags = {\n  requireAllowlist?: boolean;\n  allowLocalSnaps?: boolean;\n  disableSnapInstallation?: boolean;\n  rejectInvalidPlatformVersion?: boolean;\n\n  /**\n   * Force any local Snap to be treated as a preinstalled Snap.\n   *\n   * This should only be used for local testing, and should not be enabled in\n   * any production builds (including beta and Flask).\n   */\n  forcePreinstalledSnaps?: boolean;\n\n  /**\n   * Automatically update preinstalled Snaps \"over the air\",\n   * when a new version of the Snap is added to the registry.\n   */\n  autoUpdatePreinstalledSnaps?: boolean;\n};\n\ntype DynamicFeatureFlags = {\n  disableSnaps?: boolean;\n};\n\ntype SnapControllerArgs = {\n  /**\n   * A teardown function that allows the host to clean up its instrumentation\n   * for a running snap.\n   */\n  closeAllConnections?: CloseAllConnectionsFunction;\n\n  /**\n   * A list of permissions that are allowed to be dynamic, meaning they can be revoked from the snap whenever.\n   */\n  dynamicPermissions?: string[];\n\n  /**\n   * The names of endowment permissions whose values are the names of JavaScript\n   * APIs that will be added to the snap execution environment at runtime.\n   */\n  environmentEndowmentPermissions?: string[];\n\n  /**\n   * Excluded permissions with its associated error message used to forbid certain permissions.\n   */\n  excludedPermissions?: Record<string, string>;\n\n  /**\n   * The function that will be used by the controller fo make network requests.\n   * Should be compatible with {@link fetch}.\n   */\n  fetchFunction?: typeof fetch;\n\n  /**\n   * Flags that enable or disable features in the controller.\n   * See {@link FeatureFlags}.\n   */\n  featureFlags: FeatureFlags;\n\n  /**\n   * How frequently to check whether a snap is idle.\n   */\n  idleTimeCheckInterval?: number;\n\n  /**\n   * The maximum amount of time that a snap may be idle.\n   */\n  maxIdleTime?: number;\n\n  /**\n   * The controller messenger.\n   */\n  messenger: SnapControllerMessenger;\n\n  /**\n   * The maximum amount of time a snap may take to process an RPC request,\n   * unless it is permitted to take longer.\n   */\n  maxRequestTime?: number;\n\n  /**\n   * The npm registry URL that will be used to fetch published snaps.\n   */\n  npmRegistryUrl?: string;\n\n  /**\n   * Persisted state that will be used for rehydration.\n   */\n  state?: PersistedSnapControllerState;\n\n  /**\n   * A function that takes Snap Id and converts it into a class that fetches files.\n   *\n   * Used for test overrides.\n   */\n  detectSnapLocation?: typeof detectSnapLocation;\n\n  /**\n   * A list of snaps to be preinstalled into the SnapController state on initialization.\n   */\n  preinstalledSnaps?: PreinstalledSnap[] | null;\n\n  /**\n   * A utility object containing functions required for state encryption.\n   */\n  encryptor: ExportableKeyEncryptor;\n\n  /**\n   * A hook to access the mnemonic seed of the user's primary keyring.\n   *\n   * @returns The mnemonic seed as bytes.\n   */\n  getMnemonicSeed: () => Promise<Uint8Array>;\n\n  /**\n   * A hook to get dynamic feature flags at runtime.\n   *\n   * @returns The feature flags.\n   */\n  getFeatureFlags: () => DynamicFeatureFlags;\n\n  /**\n   * The cryptographic functions to use for the client. This may be an empty\n   * object to fall back to the default cryptographic functions.\n   */\n  clientCryptography?: CryptographicFunctions;\n\n  /**\n   * MetaMetrics event tracking hook.\n   */\n  trackEvent: TrackEventHook;\n};\n\ntype AddSnapArgs = {\n  id: SnapId;\n  origin: string;\n  location: SnapLocation;\n  versionRange: SemVerRange;\n};\n\n// When we set a snap, we need all required properties to be present and\n// validated.\ntype SetSnapArgs = Omit<AddSnapArgs, 'location' | 'versionRange'> & {\n  files: FetchedSnapFiles;\n  isUpdate?: boolean;\n  removable?: boolean;\n  preinstalled?: boolean;\n  hidden?: boolean;\n  hideSnapBranding?: boolean;\n};\n\ntype TrackingEventPayload = {\n  event: string;\n  category: string;\n  properties: Record<string, Json | undefined>;\n};\n\ntype TrackEventHook = (event: TrackingEventPayload) => void;\n\nconst defaultState: SnapControllerState = {\n  snaps: {},\n  snapStates: {},\n  unencryptedSnapStates: {},\n};\n\n/**\n * Truncates the properties of a snap to only ones that are easily serializable.\n *\n * @param snap - The snap to truncate.\n * @returns Object with serializable snap properties.\n */\nfunction truncateSnap(snap: Snap): TruncatedSnap {\n  const truncatedSnap = Object.keys(snap).reduce<Partial<TruncatedSnap>>(\n    (serialized, key) => {\n      if (TRUNCATED_SNAP_PROPERTIES.has(key as any)) {\n        serialized[key as keyof TruncatedSnap] = snap[\n          key as keyof TruncatedSnap\n        ] as any;\n      }\n\n      return serialized;\n    },\n    {},\n  );\n\n  return truncatedSnap as TruncatedSnap;\n}\n\n/*\n * A snap is initialized in three phases:\n * - Add: Loads the snap from a remote source and parses it.\n * - Authorize: Requests the snap's required permissions from the user.\n * - Start: Initializes the snap in its SES realm with the authorized permissions.\n */\n\nexport class SnapController extends BaseController<\n  typeof controllerName,\n  SnapControllerState,\n  SnapControllerMessenger\n> {\n  readonly #closeAllConnections?: CloseAllConnectionsFunction;\n\n  readonly #dynamicPermissions: string[];\n\n  readonly #environmentEndowmentPermissions: string[];\n\n  readonly #excludedPermissions: Record<string, string>;\n\n  readonly #featureFlags: FeatureFlags;\n\n  readonly #fetchFunction: typeof fetch;\n\n  readonly #idleTimeCheckInterval: number;\n\n  readonly #maxIdleTime: number;\n\n  // This property cannot be hash private yet because of tests.\n  // eslint-disable-next-line no-restricted-syntax\n  private readonly maxRequestTime: number;\n\n  readonly #encryptor: ExportableKeyEncryptor;\n\n  readonly #getMnemonicSeed: () => Promise<Uint8Array>;\n\n  readonly #getFeatureFlags: () => DynamicFeatureFlags;\n\n  readonly #clientCryptography: CryptographicFunctions | undefined;\n\n  readonly #detectSnapLocation: typeof detectSnapLocation;\n\n  readonly #snapsRuntimeData: Map<SnapId, SnapRuntimeData>;\n\n  readonly #rollbackSnapshots: Map<string, RollbackSnapshot>;\n\n  #timeoutForLastRequestStatus?: number;\n\n  #statusMachine!: StateMachine.Machine<\n    StatusContext,\n    StatusEvents,\n    StatusStates\n  >;\n\n  readonly #preinstalledSnaps: PreinstalledSnap[] | null;\n\n  readonly #trackEvent: TrackEventHook;\n\n  readonly #trackSnapExport: ReturnType<typeof throttleTracking>;\n\n  constructor({\n    closeAllConnections,\n    messenger,\n    state,\n    dynamicPermissions = ['eth_accounts'],\n    environmentEndowmentPermissions = [],\n    excludedPermissions = {},\n    idleTimeCheckInterval = inMilliseconds(5, Duration.Second),\n    maxIdleTime = inMilliseconds(30, Duration.Second),\n    maxRequestTime = inMilliseconds(60, Duration.Second),\n    fetchFunction = globalThis.fetch.bind(undefined),\n    featureFlags = {},\n    detectSnapLocation: detectSnapLocationFunction = detectSnapLocation,\n    preinstalledSnaps = null,\n    encryptor,\n    getMnemonicSeed,\n    getFeatureFlags = () => ({}),\n    clientCryptography,\n    trackEvent,\n  }: SnapControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        snapStates: {\n          includeInStateLogs: false,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: false,\n        },\n        unencryptedSnapStates: {\n          includeInStateLogs: false,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: false,\n        },\n        snaps: {\n          includeInStateLogs: (snaps) => {\n            // Delete larger snap properties\n            return Object.values(snaps).reduce<Record<SnapId, Partial<Snap>>>(\n              (acc, snap) => {\n                const snapCopy: Partial<Snap> = { ...snap };\n                delete snapCopy.sourceCode;\n                delete snapCopy.auxiliaryFiles;\n                acc[snap.id] = snapCopy;\n                return acc;\n              },\n              {},\n            );\n          },\n          persist: (snaps) => {\n            return (\n              Object.values(snaps)\n                // We should not persist snaps that are in the installing state,\n                // since they haven't completed installation and would be unusable\n                .filter((snap) => snap.status !== SnapStatus.Installing)\n                .map((snap) => {\n                  return {\n                    ...snap,\n                    // At the time state is rehydrated, no snap will be running.\n                    status: SnapStatus.Stopped,\n                  };\n                })\n                .reduce((memo: Record<SnapId, Snap>, snap) => {\n                  memo[snap.id] = snap;\n                  return memo;\n                }, {})\n            );\n          },\n          includeInDebugSnapshot: false,\n          // TODO: Ensure larger snap properties are not sent to the UI\n          // Currently these are stripped out manually in the extension\n          usedInUi: true,\n        },\n      },\n      name: controllerName,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n\n    this.#closeAllConnections = closeAllConnections;\n    this.#dynamicPermissions = dynamicPermissions;\n    this.#environmentEndowmentPermissions = environmentEndowmentPermissions;\n    this.#excludedPermissions = excludedPermissions;\n    this.#featureFlags = featureFlags;\n    this.#fetchFunction = fetchFunction;\n    this.#idleTimeCheckInterval = idleTimeCheckInterval;\n    this.#maxIdleTime = maxIdleTime;\n    this.maxRequestTime = maxRequestTime;\n    this.#detectSnapLocation = detectSnapLocationFunction;\n    this.#encryptor = encryptor;\n    this.#getMnemonicSeed = getMnemonicSeed;\n    this.#getFeatureFlags = getFeatureFlags;\n    this.#clientCryptography = clientCryptography;\n    this.#preinstalledSnaps = preinstalledSnaps;\n    this._onUnhandledSnapError = this._onUnhandledSnapError.bind(this);\n    this._onOutboundRequest = this._onOutboundRequest.bind(this);\n    this._onOutboundResponse = this._onOutboundResponse.bind(this);\n    this.#rollbackSnapshots = new Map();\n    this.#snapsRuntimeData = new Map();\n    this.#trackEvent = trackEvent;\n\n    this.#pollForLastRequestStatus();\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messenger.subscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messenger.subscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messenger.subscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n    this.messenger.subscribe(\n      'SnapController:snapInstalled',\n      ({ id }, origin) => {\n        this.#callLifecycleHook(origin, id, HandlerType.OnInstall).catch(\n          (error) => {\n            logError(\n              `Error when calling \\`onInstall\\` lifecycle hook for snap \"${id}\": ${getErrorMessage(\n                error,\n              )}`,\n            );\n          },\n        );\n      },\n    );\n\n    this.messenger.subscribe(\n      'SnapController:snapUpdated',\n      ({ id }, _oldVersion, origin) => {\n        this.#callLifecycleHook(origin, id, HandlerType.OnUpdate).catch(\n          (error) => {\n            logError(\n              `Error when calling \\`onUpdate\\` lifecycle hook for snap \"${id}\": ${getErrorMessage(\n                error,\n              )}`,\n            );\n          },\n        );\n      },\n    );\n\n    this.messenger.subscribe(\n      'KeyringController:lock',\n      this.#handleLock.bind(this),\n    );\n\n    this.#initializeStateMachine();\n    this.#registerMessageHandlers();\n\n    Object.values(this.state?.snaps ?? {}).forEach((snap) =>\n      this.#setupRuntime(snap.id),\n    );\n\n    if (this.#preinstalledSnaps) {\n      this.#handlePreinstalledSnaps(this.#preinstalledSnaps);\n    }\n\n    this.#trackSnapExport = throttleTracking(\n      (snapId: SnapId, handler: string, success: boolean, origin: string) => {\n        const snapMetadata = this.messenger.call(\n          'SnapsRegistry:getMetadata',\n          snapId,\n        );\n        this.#trackEvent({\n          event: 'Snap Export Used',\n          category: 'Snaps',\n          properties: {\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            snap_id: snapId,\n            export: handler,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            snap_category: snapMetadata?.category,\n            success,\n            origin,\n          },\n        });\n      },\n    );\n  }\n\n  /**\n   * We track status of a Snap using a finite-state-machine.\n   * It keeps track of whether the snap is started / stopped / etc.\n   *\n   * @see {@link SnapController.transition} for interacting with the machine.\n   */\n  // We initialize the machine in the instance because the status is currently tightly coupled\n  // with the SnapController - the guard checks for enabled status inside the SnapController state.\n  // In the future, side-effects could be added to the machine during transitions.\n  #initializeStateMachine() {\n    const disableGuard = ({ snapId }: StatusContext) => {\n      return this.getExpect(snapId).enabled;\n    };\n\n    const statusConfig: StateMachine.Config<\n      StatusContext,\n      StatusEvents,\n      StatusStates\n    > = {\n      initial: SnapStatus.Installing,\n      states: {\n        [SnapStatus.Installing]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n          },\n        },\n        [SnapStatus.Updating]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Stop]: SnapStatus.Stopped,\n          },\n        },\n        [SnapStatus.Running]: {\n          on: {\n            [SnapStatusEvents.Stop]: SnapStatus.Stopped,\n            [SnapStatusEvents.Crash]: SnapStatus.Crashed,\n          },\n        },\n        [SnapStatus.Stopped]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Update]: SnapStatus.Updating,\n          },\n        },\n        [SnapStatus.Crashed]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Update]: SnapStatus.Updating,\n          },\n        },\n      },\n    };\n    this.#statusMachine = createMachine(statusConfig);\n    validateMachine(this.#statusMachine);\n  }\n\n  /**\n   * Constructor helper for registering the controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers(): void {\n    this.messenger.registerActionHandler(`${controllerName}:init`, (...args) =>\n      this.init(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:clearSnapState`,\n      (...args) => this.clearSnapState(...args),\n    );\n\n    this.messenger.registerActionHandler(`${controllerName}:get`, (...args) =>\n      this.get(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:getSnapState`,\n      async (...args) => this.getSnapState(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:handleRequest`,\n      async (...args) => this.handleRequest(...args),\n    );\n\n    this.messenger.registerActionHandler(`${controllerName}:has`, (...args) =>\n      this.has(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:updateRegistry`,\n      async () => this.updateRegistry(),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:updateSnapState`,\n      async (...args) => this.updateSnapState(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:enable`,\n      (...args) => this.enableSnap(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:disable`,\n      async (...args) => this.disableSnap(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:remove`,\n      async (...args) => this.removeSnap(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:getPermitted`,\n      (...args) => this.getPermittedSnaps(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:install`,\n      async (...args) => this.installSnaps(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:getAll`,\n      (...args) => this.getAllSnaps(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:getRunnableSnaps`,\n      (...args) => this.getRunnableSnaps(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:incrementActiveReferences`,\n      (...args) => this.incrementActiveReferences(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:decrementActiveReferences`,\n      (...args) => this.decrementActiveReferences(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:disconnectOrigin`,\n      (...args) => this.removeSnapFromSubject(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:revokeDynamicPermissions`,\n      (...args) => this.revokeDynamicSnapPermissions(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:getFile`,\n      async (...args) => this.getSnapFile(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:stopAllSnaps`,\n      async (...args) => this.stopAllSnaps(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:isMinimumPlatformVersion`,\n      (...args) => this.isMinimumPlatformVersion(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      `${controllerName}:setClientActive`,\n      (...args) => this.setClientActive(...args),\n    );\n  }\n\n  /**\n   * Initialise the SnapController.\n   *\n   * Currently this method calls the `onStart` lifecycle hook for all\n   * runnable Snaps.\n   */\n  init() {\n    this.#callLifecycleHooks(METAMASK_ORIGIN, HandlerType.OnStart);\n  }\n\n  #handlePreinstalledSnaps(preinstalledSnaps: PreinstalledSnap[]) {\n    for (const {\n      snapId,\n      manifest,\n      files,\n      removable,\n      hidden,\n      hideSnapBranding,\n    } of preinstalledSnaps) {\n      const existingSnap = this.get(snapId);\n      const isAlreadyInstalled = existingSnap !== undefined;\n      const isUpdate =\n        isAlreadyInstalled && gtVersion(manifest.version, existingSnap.version);\n\n      // Disallow downgrades and overwriting non preinstalled snaps\n      if (\n        isAlreadyInstalled &&\n        (!isUpdate || existingSnap.preinstalled !== true)\n      ) {\n        continue;\n      }\n\n      const manifestFile = new VirtualFile<SnapManifest>({\n        path: NpmSnapFileNames.Manifest,\n        value: JSON.stringify(manifest),\n        result: manifest,\n      });\n\n      const virtualFiles = files.map(\n        ({ path, value }) => new VirtualFile({ value, path }),\n      );\n      const { filePath, iconPath } = manifest.source.location.npm;\n      const sourceCode = virtualFiles.find((file) => file.path === filePath);\n      const svgIcon = iconPath\n        ? virtualFiles.find((file) => file.path === iconPath)\n        : undefined;\n\n      assert(sourceCode, 'Source code not provided for preinstalled snap.');\n\n      assert(\n        !iconPath || (iconPath && svgIcon),\n        'Icon not provided for preinstalled snap.',\n      );\n\n      assert(\n        manifest.source.files === undefined,\n        'Auxiliary files are not currently supported for preinstalled snaps.',\n      );\n\n      const localizationFiles =\n        manifest.source.locales?.map((path) =>\n          virtualFiles.find((file) => file.path === path),\n        ) ?? [];\n\n      const validatedLocalizationFiles = getValidatedLocalizationFiles(\n        localizationFiles.filter(Boolean) as VirtualFile[],\n      );\n\n      assert(\n        localizationFiles.length === validatedLocalizationFiles.length,\n        'Missing localization files for preinstalled snap.',\n      );\n\n      const filesObject: FetchedSnapFiles = {\n        manifest: manifestFile,\n        sourceCode,\n        svgIcon,\n        auxiliaryFiles: [],\n        localizationFiles: validatedLocalizationFiles,\n      };\n\n      // Add snap to the SnapController state\n      this.#set({\n        id: snapId,\n        origin: METAMASK_ORIGIN,\n        files: filesObject,\n        removable,\n        hidden,\n        hideSnapBranding,\n        preinstalled: true,\n      });\n\n      // Setup permissions\n      const processedPermissions = processSnapPermissions(\n        manifest.initialPermissions,\n      );\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      const { newPermissions, unusedPermissions } =\n        this.#calculatePermissionsChange(snapId, processedPermissions);\n\n      this.#updatePermissions({ snapId, newPermissions, unusedPermissions });\n\n      if (manifest.initialConnections) {\n        this.#handleInitialConnections(\n          snapId,\n          existingSnap?.initialConnections ?? null,\n          manifest.initialConnections,\n        );\n      }\n\n      // Set status\n      this.update((state) => {\n        state.snaps[snapId].status = SnapStatus.Stopped;\n      });\n\n      this.#setupRuntime(snapId);\n\n      // Emit events\n      if (isUpdate) {\n        this.messenger.publish(\n          'SnapController:snapUpdated',\n          this.getTruncatedExpect(snapId),\n          existingSnap.version,\n          METAMASK_ORIGIN,\n          true,\n        );\n      } else {\n        this.messenger.publish(\n          'SnapController:snapInstalled',\n          this.getTruncatedExpect(snapId),\n          METAMASK_ORIGIN,\n          true,\n        );\n      }\n    }\n  }\n\n  #pollForLastRequestStatus() {\n    this.#timeoutForLastRequestStatus = setTimeout(() => {\n      this.#stopSnapsLastRequestPastMax().catch((error) => {\n        // TODO: Decide how to handle errors.\n        logError(error);\n      });\n\n      this.#pollForLastRequestStatus();\n    }, this.#idleTimeCheckInterval) as unknown as number;\n  }\n\n  /**\n   * Checks all installed snaps against the block list and\n   * blocks/unblocks snaps as appropriate. See {@link SnapController.blockSnap}\n   * for more information.\n   *\n   * Also updates any preinstalled Snaps to the latest allowlisted version.\n   */\n  async updateRegistry(): Promise<void> {\n    this.#assertCanUsePlatform();\n    await this.messenger.call('SnapsRegistry:update');\n\n    const blockedSnaps = await this.messenger.call(\n      'SnapsRegistry:get',\n      Object.values(this.state.snaps).reduce<SnapsRegistryRequest>(\n        (blockListArg, snap) => {\n          blockListArg[snap.id] = {\n            version: snap.version,\n            checksum: snap.manifest.source.shasum,\n          };\n          return blockListArg;\n        },\n        {},\n      ),\n    );\n\n    await Promise.all(\n      Object.entries(blockedSnaps).map(async ([snapId, { status, reason }]) => {\n        if (status === SnapsRegistryStatus.Blocked) {\n          return this.#blockSnap(snapId as SnapId, reason);\n        }\n\n        return this.#unblockSnap(snapId as SnapId);\n      }),\n    );\n\n    if (!this.#featureFlags.autoUpdatePreinstalledSnaps) {\n      return;\n    }\n\n    const preinstalledVersionRange = '*' as SemVerRange;\n\n    await Promise.allSettled(\n      Object.values(this.state.snaps)\n        .filter((snap) => snap.preinstalled)\n        .map(async (snap) => {\n          const resolvedVersion = await this.#resolveAllowlistVersion(\n            snap.id,\n            preinstalledVersionRange,\n          );\n\n          if (\n            resolvedVersion !== preinstalledVersionRange &&\n            gtVersion(resolvedVersion as unknown as SemVerVersion, snap.version)\n          ) {\n            const location = this.#detectSnapLocation(snap.id, {\n              versionRange: resolvedVersion,\n              fetch: this.#fetchFunction,\n              allowLocal: false,\n            });\n\n            await this.#updateSnap({\n              origin: ORIGIN_METAMASK,\n              snapId: snap.id,\n              location,\n              versionRange: resolvedVersion,\n              automaticUpdate: true,\n            });\n          }\n        }),\n    );\n  }\n\n  /**\n   * Blocks an installed snap and prevents it from being started again. Emits\n   * {@link SnapBlocked}. Does nothing if the snap is not installed.\n   *\n   * @param snapId - The snap to block.\n   * @param blockedSnapInfo - Information detailing why the snap is blocked.\n   */\n  async #blockSnap(\n    snapId: SnapId,\n    blockedSnapInfo?: BlockReason,\n  ): Promise<void> {\n    if (!this.has(snapId)) {\n      return;\n    }\n\n    try {\n      this.update((state: any) => {\n        state.snaps[snapId].blocked = true;\n        state.snaps[snapId].blockInformation = blockedSnapInfo;\n      });\n\n      await this.disableSnap(snapId);\n    } catch (error) {\n      logError(\n        `Encountered error when stopping blocked snap \"${snapId}\".`,\n        error,\n      );\n    }\n\n    this.messenger.publish(\n      `${controllerName}:snapBlocked`,\n      snapId,\n      blockedSnapInfo,\n    );\n  }\n\n  /**\n   * Unblocks a snap so that it can be enabled and started again. Emits\n   * {@link SnapUnblocked}. Does nothing if the snap is not installed or already\n   * unblocked.\n   *\n   * @param snapId - The id of the snap to unblock.\n   */\n  #unblockSnap(snapId: SnapId) {\n    if (!this.has(snapId) || !this.state.snaps[snapId].blocked) {\n      return;\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].blocked = false;\n      delete state.snaps[snapId].blockInformation;\n    });\n\n    this.messenger.publish(`${controllerName}:snapUnblocked`, snapId);\n  }\n\n  async #assertIsInstallAllowed(\n    snapId: SnapId,\n    {\n      platformVersion,\n      ...snapInfo\n    }: SnapsRegistryInfo & {\n      permissions: SnapPermissions;\n      platformVersion: string | undefined;\n    },\n  ) {\n    const results = await this.messenger.call('SnapsRegistry:get', {\n      [snapId]: snapInfo,\n    });\n\n    const result = results[snapId];\n    if (result.status === SnapsRegistryStatus.Blocked) {\n      throw new Error(\n        `Cannot install version \"${\n          snapInfo.version\n        }\" of snap \"${snapId}\": The version is blocked. ${\n          result.reason?.explanation ?? ''\n        }`,\n      );\n    }\n\n    const isAllowlistingRequired = Object.keys(snapInfo.permissions).some(\n      (permission) => !ALLOWED_PERMISSIONS.includes(permission),\n    );\n\n    if (\n      this.#featureFlags.requireAllowlist &&\n      isAllowlistingRequired &&\n      result.status !== SnapsRegistryStatus.Verified\n    ) {\n      throw new Error(\n        `Cannot install version \"${snapInfo.version}\" of snap \"${snapId}\": ${\n          result.status === SnapsRegistryStatus.Unavailable\n            ? 'The registry is temporarily unavailable.'\n            : 'The snap is not on the allowlist.'\n        }`,\n      );\n    }\n\n    this.#validatePlatformVersion(snapId, platformVersion);\n  }\n\n  /**\n   * Asserts whether new Snaps are allowed to be installed.\n   */\n  #assertCanInstallSnaps() {\n    assert(\n      this.#featureFlags.disableSnapInstallation !== true,\n      'Installing Snaps is currently disabled in this version of MetaMask.',\n    );\n  }\n\n  /**\n   * Asserts whether the Snaps platform is allowed to run.\n   */\n  #assertCanUsePlatform() {\n    const flags = this.#getFeatureFlags();\n    assert(\n      flags.disableSnaps !== true,\n      'The Snaps platform requires basic functionality to be used. Enable basic functionality in the settings to use the Snaps platform.',\n    );\n  }\n\n  async #stopSnapsLastRequestPastMax() {\n    const entries = [...this.#snapsRuntimeData.entries()];\n    return Promise.all(\n      entries\n        .filter(\n          ([_snapId, runtime]) =>\n            runtime.activeReferences === 0 &&\n            runtime.pendingInboundRequests.length === 0 &&\n            runtime.lastRequest &&\n            this.#maxIdleTime &&\n            timeSince(runtime.lastRequest) > this.#maxIdleTime,\n        )\n        .map(async ([snapId]) => this.stopSnap(snapId, SnapStatusEvents.Stop)),\n    );\n  }\n\n  _onUnhandledSnapError(snapId: string, error: SnapErrorJson) {\n    // Log the error that caused the crash\n    // so it gets raised to the developer for debugging purposes.\n    logError(`Unhandled error from \"${snapId}\":`, error);\n    this.stopSnap(snapId as SnapId, SnapStatusEvents.Crash).catch(\n      (stopSnapError) => {\n        // TODO: Decide how to handle errors.\n        logError(stopSnapError);\n      },\n    );\n  }\n\n  _onOutboundRequest(snapId: string) {\n    const runtime = this.#getRuntimeExpect(snapId as SnapId);\n    // Ideally we would only pause the pending request that is making the outbound request\n    // but right now we don't have a way to know which request initiated the outbound request\n    runtime.pendingInboundRequests\n      .filter((pendingRequest) => pendingRequest.timer.status === 'running')\n      .forEach((pendingRequest) => pendingRequest.timer.pause());\n    runtime.pendingOutboundRequests += 1;\n  }\n\n  _onOutboundResponse(snapId: string) {\n    const runtime = this.#getRuntimeExpect(snapId as SnapId);\n    runtime.pendingOutboundRequests -= 1;\n    if (runtime.pendingOutboundRequests === 0) {\n      runtime.pendingInboundRequests\n        .filter((pendingRequest) => pendingRequest.timer.status === 'paused')\n        .forEach((pendingRequest) => pendingRequest.timer.resume());\n    }\n  }\n\n  /**\n   * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out\n   * the next state. This transition function uses a very minimal subset of XState conventions:\n   * - supports initial state\n   * - .on supports raw event target string\n   * - .on supports {target, cond} object\n   * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event,\n   * context) => boolean`\n   *\n   * @param snapId - The id of the snap to transition.\n   * @param event - The event enum to use to transition.\n   */\n  #transition(snapId: SnapId, event: StatusEvents | StatusEvents['type']) {\n    const { interpreter } = this.#getRuntimeExpect(snapId);\n    interpreter.send(event);\n    this.update((state: any) => {\n      state.snaps[snapId].status = interpreter.state.value;\n    });\n  }\n\n  /**\n   * Starts the given snap. Throws an error if no such snap exists\n   * or if it is already running.\n   *\n   * @param snapId - The id of the Snap to start.\n   */\n  async startSnap(snapId: SnapId): Promise<void> {\n    this.#assertCanUsePlatform();\n    const snap = this.state.snaps[snapId];\n\n    if (!snap.enabled) {\n      throw new Error(`Snap \"${snapId}\" is disabled.`);\n    }\n\n    await this.#startSnap({\n      snapId,\n      sourceCode: snap.sourceCode,\n    });\n  }\n\n  /**\n   * Enables the given snap. A snap can only be started if it is enabled. A snap\n   * can only be enabled if it isn't blocked.\n   *\n   * @param snapId - The id of the Snap to enable.\n   */\n  enableSnap(snapId: SnapId): void {\n    this.getExpect(snapId);\n\n    if (this.state.snaps[snapId].blocked) {\n      throw new Error(`Snap \"${snapId}\" is blocked and cannot be enabled.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = true;\n    });\n\n    this.messenger.publish(\n      'SnapController:snapEnabled',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Disables the given snap. A snap can only be started if it is enabled.\n   *\n   * @param snapId - The id of the Snap to disable.\n   * @returns A promise that resolves once the snap has been disabled.\n   */\n  async disableSnap(snapId: SnapId): Promise<void> {\n    if (!this.has(snapId)) {\n      throw new Error(`Snap \"${snapId}\" not found.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = false;\n    });\n\n    if (this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    this.messenger.publish(\n      'SnapController:snapDisabled',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Stops the given snap, removes all hooks, closes all connections, and\n   * terminates its worker.\n   *\n   * @param snapId - The id of the Snap to stop.\n   * @param statusEvent - The Snap status event that caused the snap to be\n   * stopped.\n   */\n  public async stopSnap(\n    snapId: SnapId,\n    statusEvent:\n      | SnapStatusEvents.Stop\n      | SnapStatusEvents.Crash = SnapStatusEvents.Stop,\n  ): Promise<void> {\n    const runtime = this.#getRuntime(snapId);\n    if (!runtime) {\n      throw new Error(`The snap \"${snapId}\" is not running.`);\n    }\n\n    // If we are already stopping, wait for that to finish.\n    if (runtime.stopPromise) {\n      await runtime.stopPromise;\n      return;\n    }\n\n    // Flag that the Snap is actively stopping, this prevents other calls to stopSnap\n    // while we are handling termination of the Snap\n    const { promise, resolve } = createDeferredPromise();\n    runtime.stopPromise = promise;\n\n    try {\n      if (this.isRunning(snapId)) {\n        this.#closeAllConnections?.(snapId);\n        await this.#terminateSnap(snapId);\n      }\n    } finally {\n      // Reset request tracking\n      runtime.lastRequest = null;\n      runtime.pendingInboundRequests = [];\n      runtime.pendingOutboundRequests = 0;\n      runtime.stopPromise = null;\n      if (this.isRunning(snapId)) {\n        this.#transition(snapId, statusEvent);\n      }\n      resolve();\n    }\n  }\n\n  /**\n   * Stops all running snaps, removes all hooks, closes all connections, and\n   * terminates their workers.\n   *\n   * @param statusEvent - The Snap status event that caused the snap to be\n   * stopped.\n   */\n  public async stopAllSnaps(\n    statusEvent:\n      | SnapStatusEvents.Stop\n      | SnapStatusEvents.Crash = SnapStatusEvents.Stop,\n  ): Promise<void> {\n    const snaps = Object.values(this.state.snaps).filter((snap) =>\n      this.isRunning(snap.id),\n    );\n    const promises = snaps.map(async (snap) =>\n      this.stopSnap(snap.id, statusEvent),\n    );\n    await Promise.allSettled(promises);\n  }\n\n  /**\n   * Terminates the specified snap and emits the `snapTerminated` event.\n   *\n   * @param snapId - The snap to terminate.\n   */\n  async #terminateSnap(snapId: SnapId) {\n    await this.messenger.call('ExecutionService:terminateSnap', snapId);\n\n    // Hack to give up execution for a bit to let gracefully terminating Snaps return.\n    await new Promise((resolve) => setTimeout(resolve, 1));\n\n    const runtime = this.#getRuntimeExpect(snapId);\n    // Unresponsive requests may still be timed, time them out.\n    runtime.pendingInboundRequests\n      .filter((pendingRequest) => pendingRequest.timer.status !== 'finished')\n      .forEach((pendingRequest) => pendingRequest.timer.finish());\n\n    // Hack to give up execution for a bit to let timed out requests return.\n    await new Promise((resolve) => setTimeout(resolve, 1));\n\n    this.messenger.publish(\n      'SnapController:snapTerminated',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Returns whether the given snap is running.\n   * Throws an error if the snap doesn't exist.\n   *\n   * @param snapId - The id of the Snap to check.\n   * @returns `true` if the snap is running, otherwise `false`.\n   */\n  isRunning(snapId: SnapId): boolean {\n    return this.getExpect(snapId).status === 'running';\n  }\n\n  /**\n   * Returns whether the given snap has been added to state.\n   *\n   * @param snapId - The id of the Snap to check for.\n   * @returns `true` if the snap exists in the controller state, otherwise `false`.\n   */\n  has(snapId: SnapId): boolean {\n    return Boolean(this.get(snapId));\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, including all data.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns The entire snap object from the controller state.\n   */\n  get(snapId: string): Snap | undefined {\n    return this.state.snaps[snapId as SnapId];\n  }\n\n  /**\n   * Gets the snap with the given id, throws if doesn't.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @see {@link SnapController.get}\n   * @throws {@link Error}. If the snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns The entire snap object.\n   */\n  getExpect(snapId: SnapId): Snap {\n    const snap = this.get(snapId);\n    assert(snap !== undefined, `Snap \"${snapId}\" not found.`);\n    return snap;\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, excluding any\n   * non-serializable or expensive-to-serialize data.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  // TODO(ritave): this.get returns undefined, this.getTruncated returns null\n  getTruncated(snapId: SnapId): TruncatedSnap | null {\n    const snap = this.get(snapId);\n\n    return snap ? truncateSnap(snap) : null;\n  }\n\n  /**\n   * Gets the snap with the given id, throw if it doesn't exist.\n   *\n   * @throws {@link Error}. If snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  getTruncatedExpect(snapId: SnapId): TruncatedSnap {\n    return truncateSnap(this.getExpect(snapId));\n  }\n\n  /**\n   * Check if a given Snap has a cached encryption key stored in the runtime.\n   *\n   * @param snapId - The Snap ID.\n   * @param runtime - The Snap runtime data.\n   * @returns True if the Snap has a cached encryption key, otherwise false.\n   */\n  #hasCachedEncryptionKey(\n    snapId: SnapId,\n    runtime = this.#getRuntimeExpect(snapId),\n  ): runtime is SnapRuntimeData & {\n    encryptionKey: string;\n    encryptionSalt: string;\n  } {\n    return runtime.encryptionKey !== null && runtime.encryptionSalt !== null;\n  }\n\n  /**\n   * Generate an encryption key to be used for state encryption for a given Snap.\n   *\n   * @param options - An options bag.\n   * @param options.snapId - The Snap ID.\n   * @param options.salt - A salt to be used for the encryption key.\n   * @param options.useCache - Whether to use caching or not.\n   * @param options.keyMetadata - Optional metadata about how to derive the encryption key.\n   * @returns An encryption key.\n   */\n  async #getSnapEncryptionKey({\n    snapId,\n    salt: passedSalt,\n    useCache,\n    keyMetadata,\n  }: {\n    snapId: SnapId;\n    salt?: string;\n    useCache: boolean;\n    keyMetadata?: KeyDerivationOptions;\n  }): Promise<{ key: unknown; salt: string }> {\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (this.#hasCachedEncryptionKey(snapId, runtime) && useCache) {\n      return {\n        key: await this.#encryptor.importKey(runtime.encryptionKey),\n        salt: runtime.encryptionSalt,\n      };\n    }\n\n    const salt = passedSalt ?? this.#encryptor.generateSalt();\n    const seed = await this.#getMnemonicSeed();\n\n    const entropy = await getEncryptionEntropy({\n      snapId,\n      seed,\n      cryptographicFunctions: this.#clientCryptography,\n    });\n\n    const encryptionKey = await this.#encryptor.keyFromPassword(\n      entropy,\n      salt,\n      true,\n      keyMetadata,\n    );\n    const exportedKey = await this.#encryptor.exportKey(encryptionKey);\n\n    // Cache exported encryption key in runtime\n    if (useCache) {\n      runtime.encryptionKey = exportedKey;\n      runtime.encryptionSalt = salt;\n    }\n    return { key: encryptionKey, salt };\n  }\n\n  /**\n   * Decrypt the encrypted state for a given Snap.\n   *\n   * @param snapId - The Snap ID.\n   * @param state - The encrypted state as a string.\n   * @returns A valid JSON object derived from the encrypted state.\n   * @throws If the decryption fails or the decrypted state is not valid JSON.\n   */\n  async #decryptSnapState(snapId: SnapId, state: string) {\n    try {\n      // We assume that the state string here is valid JSON since we control serialization.\n      // This lets us skip JSON validation.\n      const parsed = JSON.parse(state) as EncryptionResult;\n      const { salt, keyMetadata } = parsed;\n\n      // We only cache encryption keys if they are already cached or if the encryption key is using the latest key derivation params.\n      const useCache =\n        this.#hasCachedEncryptionKey(snapId) ||\n        this.#encryptor.isVaultUpdated(state);\n\n      const { key } = await this.#getSnapEncryptionKey({\n        snapId,\n        salt,\n        useCache,\n        // When decrypting state we expect key metadata to be present.\n        // If it isn't present, we assume that the Snap state we are decrypting is old enough to use the legacy encryption params.\n        keyMetadata: keyMetadata ?? LEGACY_ENCRYPTION_KEY_DERIVATION_OPTIONS,\n      });\n      const decryptedState = await this.#encryptor.decryptWithKey(key, parsed);\n\n      // We assume this to be valid JSON, since all RPC requests from a Snap are validated and sanitized.\n      return decryptedState as Record<string, Json>;\n    } catch {\n      throw rpcErrors.internal({\n        message: 'Failed to decrypt snap state, the state must be corrupted.',\n      });\n    }\n  }\n\n  /**\n   * Encrypt a JSON state object for a given Snap.\n   *\n   * Note: This function does not assert the validity of the object,\n   * please ensure only valid JSON is passed to it.\n   *\n   * @param snapId - The Snap ID.\n   * @param state - The state object.\n   * @returns A string containing the encrypted JSON object.\n   */\n  async #encryptSnapState(snapId: SnapId, state: Record<string, Json>) {\n    const { key, salt } = await this.#getSnapEncryptionKey({\n      snapId,\n      useCache: true,\n    });\n    const encryptedState = await this.#encryptor.encryptWithKey(key, state);\n\n    encryptedState.salt = salt;\n    return JSON.stringify(encryptedState);\n  }\n\n  /**\n   * Get the new Snap state to persist based on the given state and encryption\n   * flag.\n   *\n   * - If the state is null, return null.\n   * - If the state should be encrypted, return the encrypted state.\n   * - Otherwise, if the state should not be encrypted, return the JSON-\n   * stringified state.\n   *\n   * @param snapId - The Snap ID.\n   * @param state - The state to persist.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or\n   * not.\n   * @returns The state to persist.\n   */\n  async #getStateToPersist(\n    snapId: SnapId,\n    state: Record<string, Json> | null,\n    encrypted: boolean,\n  ) {\n    if (state === null) {\n      return null;\n    }\n\n    if (encrypted) {\n      return await this.#encryptSnapState(snapId, state);\n    }\n\n    return JSON.stringify(state);\n  }\n\n  /**\n   * Persist the state of a Snap.\n   *\n   * This function is debounced per Snap, meaning that multiple calls to this\n   * function for the same Snap will only result in one state update. It also\n   * uses a mutex to ensure that only one state update per Snap is processed at\n   * a time, avoiding possible race conditions.\n   *\n   * @param snapId - The Snap ID.\n   * @param newSnapState - The new state of the Snap.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or\n   * not.\n   */\n  readonly #persistSnapState = debouncePersistState(\n    (\n      snapId: SnapId,\n      newSnapState: Record<string, Json> | null,\n      encrypted: boolean,\n    ) => {\n      const runtime = this.#getRuntimeExpect(snapId);\n      runtime.stateMutex\n        .runExclusive(async () => {\n          const newState = await this.#getStateToPersist(\n            snapId,\n            newSnapState,\n            encrypted,\n          );\n\n          if (encrypted) {\n            return this.update((state) => {\n              state.snapStates[snapId] = newState;\n            });\n          }\n\n          return this.update((state) => {\n            state.unencryptedSnapStates[snapId] = newState;\n          });\n        })\n        .catch(logError);\n    },\n    STATE_DEBOUNCE_TIMEOUT,\n  );\n\n  /**\n   * Updates the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be updated.\n   * @param newSnapState - The new state of the snap.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   */\n  async updateSnapState(\n    snapId: SnapId,\n    newSnapState: Record<string, Json>,\n    encrypted: boolean,\n  ) {\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (encrypted) {\n      runtime.state = newSnapState;\n    } else {\n      runtime.unencryptedState = newSnapState;\n    }\n\n    this.#persistSnapState(snapId, newSnapState, encrypted);\n  }\n\n  /**\n   * Clears the state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be cleared.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   */\n  clearSnapState(snapId: SnapId, encrypted: boolean) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    if (encrypted) {\n      runtime.state = null;\n    } else {\n      runtime.unencryptedState = null;\n    }\n\n    this.#persistSnapState(snapId, null, encrypted);\n  }\n\n  /**\n   * Gets the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state to get.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   * @returns The requested snap state or null if no state exists.\n   */\n  async getSnapState(snapId: SnapId, encrypted: boolean): Promise<Json> {\n    const runtime = this.#getRuntimeExpect(snapId);\n    return await runtime.getStateMutex.runExclusive(async () => {\n      const cachedState = encrypted ? runtime.state : runtime.unencryptedState;\n\n      if (cachedState !== undefined) {\n        return cachedState;\n      }\n\n      const state = encrypted\n        ? this.state.snapStates[snapId]\n        : this.state.unencryptedSnapStates[snapId];\n\n      if (state === null || state === undefined) {\n        return null;\n      }\n\n      if (!encrypted) {\n        // For performance reasons, we do not validate that the state is JSON,\n        // since we control serialization.\n        const json = JSON.parse(state);\n        runtime.unencryptedState = json;\n\n        return json;\n      }\n\n      const decrypted = await this.#decryptSnapState(snapId, state);\n      // eslint-disable-next-line require-atomic-updates\n      runtime.state = decrypted;\n\n      return decrypted;\n    });\n  }\n\n  /**\n   * Gets a static auxiliary snap file in a chosen file encoding.\n   *\n   * @param snapId - The id of the Snap whose state to get.\n   * @param path - The path to the requested file.\n   * @param encoding - An optional requested file encoding.\n   * @returns The file requested in the chosen file encoding or null if the file is not found.\n   */\n  async getSnapFile(\n    snapId: SnapId,\n    path: string,\n    encoding: AuxiliaryFileEncoding = AuxiliaryFileEncoding.Base64,\n  ): Promise<string | null> {\n    const snap = this.getExpect(snapId);\n    const normalizedPath = normalizeRelative(path);\n    const value = snap.auxiliaryFiles?.find(\n      (file) => file.path === normalizedPath,\n    )?.value;\n\n    if (!value) {\n      return null;\n    }\n\n    const encoded = await encodeAuxiliaryFile(value, encoding);\n\n    assert(\n      encoded.length < MAX_FILE_SIZE,\n      `Failed to encode static file to \"${encoding}\": Static files must be less than 64 MB when encoded.`,\n    );\n\n    return encoded;\n  }\n\n  /**\n   * Determine if a given Snap ID supports a given minimum version of the Snaps platform\n   * by inspecting the platformVersion in the Snap manifest.\n   *\n   * @param snapId - The Snap ID.\n   * @param version - The version.\n   * @returns True if the platform version is equal or greater to the passed version, false otherwise.\n   */\n  isMinimumPlatformVersion(snapId: SnapId, version: SemVerVersion): boolean {\n    const snap = this.getExpect(snapId);\n\n    const { platformVersion } = snap.manifest;\n\n    if (!platformVersion) {\n      return false;\n    }\n\n    return gte(platformVersion, version);\n  }\n\n  /**\n   * Completely clear the controller's state: delete all associated data,\n   * handlers, event listeners, and permissions; tear down all snap providers.\n   */\n  async clearState() {\n    const snapIds = Object.keys(this.state.snaps);\n\n    await this.stopAllSnaps();\n    snapIds.forEach((snapId) => this.#revokeAllSnapPermissions(snapId));\n\n    this.update((state) => {\n      state.snaps = {};\n      state.snapStates = {};\n      state.unencryptedSnapStates = {};\n    });\n\n    this.#snapsRuntimeData.clear();\n    this.#rollbackSnapshots.clear();\n\n    // We want to remove all snaps & permissions, except for preinstalled snaps\n    if (this.#preinstalledSnaps) {\n      this.#handlePreinstalledSnaps(this.#preinstalledSnaps);\n    }\n  }\n\n  /**\n   * Removes the given snap from state, and clears all associated handlers\n   * and listeners.\n   *\n   * @param snapId - The id of the Snap.\n   * @returns A promise that resolves once the snap has been removed.\n   */\n  async removeSnap(snapId: SnapId): Promise<void> {\n    return this.removeSnaps([snapId]);\n  }\n\n  /**\n   * Stops the given snaps, removes them from state, and clears all associated\n   * permissions, handlers, and listeners.\n   *\n   * @param snapIds - The ids of the Snaps.\n   */\n  async removeSnaps(snapIds: SnapId[]): Promise<void> {\n    if (!Array.isArray(snapIds)) {\n      throw new Error('Expected array of snap ids.');\n    }\n\n    snapIds.forEach((snapId) => {\n      const snap = this.getExpect(snapId);\n      assert(snap.removable !== false, `${snapId} is not removable.`);\n    });\n\n    await Promise.all(\n      snapIds.map(async (snapId) => {\n        const snap = this.getExpect(snapId);\n        const truncated = this.getTruncatedExpect(snapId);\n        // Disable the snap and revoke all of its permissions before deleting\n        // it. This ensures that the snap will not be restarted or otherwise\n        // affect the host environment while we are deleting it.\n        await this.disableSnap(snapId);\n        this.#revokeAllSnapPermissions(snapId);\n\n        this.#removeSnapFromSubjects(snapId);\n\n        this.#snapsRuntimeData.delete(snapId);\n\n        this.update((state: any) => {\n          delete state.snaps[snapId];\n          delete state.snapStates[snapId];\n          delete state.unencryptedSnapStates[snapId];\n        });\n\n        // If the snap has been fully installed before, also emit snapUninstalled.\n        if (snap.status !== SnapStatus.Installing) {\n          this.messenger.publish(`SnapController:snapUninstalled`, truncated);\n        }\n      }),\n    );\n  }\n\n  #handleInitialConnections(\n    snapId: SnapId,\n    previousInitialConnections: InitialConnections | null,\n    initialConnections: InitialConnections,\n  ) {\n    if (previousInitialConnections) {\n      const revokedInitialConnections = setDiff(\n        previousInitialConnections,\n        initialConnections,\n      );\n\n      for (const origin of Object.keys(revokedInitialConnections)) {\n        this.removeSnapFromSubject(origin, snapId);\n      }\n    }\n\n    for (const origin of Object.keys(initialConnections)) {\n      this.#addSnapToSubject(origin, snapId);\n    }\n  }\n\n  #addSnapToSubject(origin: string, snapId: SnapId) {\n    const subjectPermissions = this.messenger.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const existingCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds);\n\n    const subjectHasSnap = Boolean(\n      (existingCaveat?.value as Record<string, Json>)?.[snapId],\n    );\n\n    // If the subject is already connected to the snap, this is a no-op.\n    if (subjectHasSnap) {\n      return;\n    }\n\n    // If an existing caveat exists, we add the snap to that.\n    if (existingCaveat) {\n      this.messenger.call(\n        'PermissionController:updateCaveat',\n        origin,\n        WALLET_SNAP_PERMISSION_KEY,\n        SnapCaveatType.SnapIds,\n        { ...(existingCaveat.value as Record<string, Json>), [snapId]: {} },\n      );\n      return;\n    }\n\n    const approvedPermissions = {\n      [WALLET_SNAP_PERMISSION_KEY]: {\n        caveats: [\n          {\n            type: SnapCaveatType.SnapIds,\n            value: {\n              [snapId]: {},\n            },\n          },\n        ],\n      },\n    } as RequestedPermissions;\n\n    this.messenger.call('PermissionController:grantPermissions', {\n      approvedPermissions,\n      subject: { origin },\n    });\n  }\n\n  /**\n   * Removes a snap's permission (caveat) from the specified subject.\n   *\n   * @param origin - The origin from which to remove the snap.\n   * @param snapId - The id of the snap to remove.\n   */\n  removeSnapFromSubject(origin: string, snapId: SnapId) {\n    const subjectPermissions = this.messenger.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const snapIdsCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds) as\n      | Caveat<string, Json>\n      | undefined;\n\n    if (!snapIdsCaveat) {\n      return;\n    }\n\n    const caveatHasSnap = Boolean(\n      (snapIdsCaveat.value as Record<string, Json>)?.[snapId],\n    );\n    if (caveatHasSnap) {\n      const newCaveatValue = {\n        ...(snapIdsCaveat.value as Record<string, Json>),\n      };\n      delete newCaveatValue[snapId];\n      if (Object.keys(newCaveatValue).length > 0) {\n        this.messenger.call(\n          'PermissionController:updateCaveat',\n          origin,\n          WALLET_SNAP_PERMISSION_KEY,\n          SnapCaveatType.SnapIds,\n          newCaveatValue,\n        );\n      } else {\n        this.messenger.call('PermissionController:revokePermissions', {\n          [origin]: [WALLET_SNAP_PERMISSION_KEY],\n        });\n      }\n    }\n  }\n\n  /**\n   * Checks if a list of permissions are dynamic and allowed to be revoked, if they are they will all be revoked.\n   *\n   * @param snapId - The snap ID.\n   * @param permissionNames - The names of the permissions.\n   * @throws If non-dynamic permissions are passed.\n   */\n  revokeDynamicSnapPermissions(\n    snapId: string,\n    permissionNames: NonEmptyArray<string>,\n  ) {\n    assert(\n      permissionNames.every((permissionName) =>\n        this.#dynamicPermissions.includes(permissionName),\n      ),\n      'Non-dynamic permissions cannot be revoked',\n    );\n    this.messenger.call('PermissionController:revokePermissions', {\n      [snapId]: permissionNames,\n    });\n  }\n\n  /**\n   * Removes a snap's permission (caveat) from all subjects.\n   *\n   * @param snapId - The id of the Snap.\n   */\n  #removeSnapFromSubjects(snapId: SnapId) {\n    const subjects = this.messenger.call(\n      'PermissionController:getSubjectNames',\n    );\n    for (const subject of subjects) {\n      this.removeSnapFromSubject(subject, snapId);\n    }\n  }\n\n  /**\n   * Safely revokes all permissions granted to a Snap.\n   *\n   * @param snapId - The snap ID.\n   */\n  #revokeAllSnapPermissions(snapId: string) {\n    if (this.messenger.call('PermissionController:hasPermissions', snapId)) {\n      this.messenger.call('PermissionController:revokeAllPermissions', snapId);\n    }\n  }\n\n  /**\n   * Handles incrementing the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced.\n   */\n  incrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.activeReferences += 1;\n  }\n\n  /**\n   * Handles decrement the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced..\n   */\n  decrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    assert(\n      runtime.activeReferences > 0,\n      'SnapController reference management is in an invalid state.',\n    );\n    runtime.activeReferences -= 1;\n  }\n\n  /**\n   * Gets all snaps in their truncated format.\n   *\n   * @returns All installed snaps in their truncated format.\n   */\n  getAllSnaps(): TruncatedSnap[] {\n    return Object.values(this.state.snaps).map(truncateSnap);\n  }\n\n  /**\n   * Gets all runnable snaps.\n   *\n   * @returns All runnable snaps.\n   */\n  getRunnableSnaps(): TruncatedSnap[] {\n    return getRunnableSnaps(this.getAllSnaps());\n  }\n\n  /**\n   * Gets the serialized permitted snaps of the given origin, if any.\n   *\n   * @param origin - The origin whose permitted snaps to retrieve.\n   * @returns The serialized permitted snaps for the origin.\n   */\n  getPermittedSnaps(origin: string): RequestSnapsResult {\n    const permissions =\n      this.messenger.call('PermissionController:getPermissions', origin) ?? {};\n    const snaps =\n      permissions[WALLET_SNAP_PERMISSION_KEY]?.caveats?.find(\n        (caveat) => caveat.type === SnapCaveatType.SnapIds,\n      )?.value ?? {};\n    return Object.keys(snaps).reduce<RequestSnapsResult>(\n      (permittedSnaps, snapId) => {\n        const snap = this.get(snapId);\n        const truncatedSnap = this.getTruncated(snapId as SnapId);\n\n        if (truncatedSnap && snap?.status !== SnapStatus.Installing) {\n          permittedSnaps[snapId] = truncatedSnap;\n        }\n        return permittedSnaps;\n      },\n      {},\n    );\n  }\n\n  /**\n   * Installs the snaps requested by the given origin, returning the snap\n   * object if the origin is permitted to install it, and an authorization error\n   * otherwise.\n   *\n   * @param origin - The origin that requested to install the snaps.\n   * @param requestedSnaps - The snaps to install.\n   * @returns An object of snap ids and snap objects, or errors if a\n   * snap couldn't be installed.\n   */\n  async installSnaps(\n    origin: string,\n    requestedSnaps: RequestSnapsParams,\n  ): Promise<RequestSnapsResult> {\n    this.#assertCanUsePlatform();\n\n    const result: RequestSnapsResult = {};\n\n    const snapIds = Object.keys(requestedSnaps);\n\n    const pendingUpdates = [];\n    const pendingInstalls = [];\n\n    try {\n      for (const [snapId, { version: rawVersion }] of Object.entries(\n        requestedSnaps,\n      )) {\n        assertIsValidSnapId(snapId);\n\n        const [error, version] = resolveVersionRange(rawVersion);\n\n        if (error) {\n          throw rpcErrors.invalidParams(\n            `The \"version\" field must be a valid SemVer version range if specified. Received: \"${\n              rawVersion as string\n            }\".`,\n          );\n        }\n\n        const location = this.#detectSnapLocation(snapId, {\n          versionRange: version,\n          fetch: this.#fetchFunction,\n          allowLocal: this.#featureFlags.allowLocalSnaps,\n          resolveVersion: async (range) =>\n            this.#featureFlags.requireAllowlist\n              ? await this.#resolveAllowlistVersion(snapId, range)\n              : range,\n        });\n\n        // Existing snaps may need to be updated, unless they should be re-installed (e.g. local snaps)\n        // Everything else is treated as an install\n        const isUpdate = this.has(snapId) && !location.shouldAlwaysReload;\n\n        if (isUpdate && this.#isValidUpdate(snapId, version)) {\n          const existingSnap = this.getExpect(snapId);\n          pendingUpdates.push({ snapId, oldVersion: existingSnap.version });\n          let rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n          if (rollbackSnapshot === undefined) {\n            rollbackSnapshot = this.#createRollbackSnapshot(snapId);\n            rollbackSnapshot.newVersion = version;\n          } else {\n            throw new Error('This snap is already being updated.');\n          }\n        } else if (!isUpdate) {\n          pendingInstalls.push(snapId);\n        }\n\n        result[snapId] = await this.#processRequestedSnap(\n          origin,\n          snapId,\n          location,\n          version,\n        );\n      }\n\n      // Once we finish all installs / updates, emit events.\n      pendingInstalls.forEach((snapId) =>\n        this.messenger.publish(\n          `SnapController:snapInstalled`,\n          this.getTruncatedExpect(snapId),\n          origin,\n          false,\n        ),\n      );\n\n      pendingUpdates.forEach(({ snapId, oldVersion }) =>\n        this.messenger.publish(\n          `SnapController:snapUpdated`,\n          this.getTruncatedExpect(snapId),\n          oldVersion,\n          origin,\n          false,\n        ),\n      );\n\n      snapIds.forEach((snapId) => this.#rollbackSnapshots.delete(snapId));\n    } catch (error) {\n      const installed = pendingInstalls.filter((snapId) => this.has(snapId));\n      await this.removeSnaps(installed);\n      const snapshottedSnaps = [...this.#rollbackSnapshots.keys()];\n      const snapsToRollback = pendingUpdates\n        .map(({ snapId }) => snapId)\n        .filter((snapId) => snapshottedSnaps.includes(snapId));\n      await this.#rollbackSnaps(snapsToRollback);\n\n      throw error;\n    }\n\n    return result;\n  }\n\n  /**\n   * Adds, authorizes, and runs the given snap with a snap provider.\n   * Results from this method should be efficiently serializable.\n   *\n   * @param origin - The origin requesting the snap.\n   * @param snapId - The id of the snap.\n   * @param location - The location implementation of the snap.\n   * @param versionRange - The semver range of the snap to install.\n   * @returns The resulting snap object, or an error if something went wrong.\n   */\n  async #processRequestedSnap(\n    origin: string,\n    snapId: SnapId,\n    location: SnapLocation,\n    versionRange: SemVerRange,\n  ): Promise<TruncatedSnap> {\n    const existingSnap = this.getTruncated(snapId);\n\n    // For devX we always re-install local snaps.\n    if (existingSnap && !location.shouldAlwaysReload) {\n      if (satisfiesVersionRange(existingSnap.version, versionRange)) {\n        return existingSnap;\n      }\n\n      return await this.#updateSnap({\n        origin,\n        snapId,\n        location,\n        versionRange,\n      });\n    }\n\n    this.#assertCanInstallSnaps();\n\n    let pendingApproval = this.#createApproval({\n      origin,\n      snapId,\n      type: SNAP_APPROVAL_INSTALL,\n    });\n\n    this.messenger.publish(\n      'SnapController:snapInstallStarted',\n      snapId,\n      origin,\n      false,\n    );\n\n    // Existing snaps must be stopped before overwriting\n    if (existingSnap && this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    // Existing snaps that should be re-installed should not maintain their existing permissions\n    if (existingSnap && location.shouldAlwaysReload) {\n      this.#revokeAllSnapPermissions(snapId);\n    }\n\n    try {\n      const { sourceCode } = await this.#add({\n        origin,\n        id: snapId,\n        location,\n        versionRange,\n      });\n\n      await this.#authorize(snapId, pendingApproval);\n\n      pendingApproval = this.#createApproval({\n        origin,\n        snapId,\n        type: SNAP_APPROVAL_RESULT,\n      });\n\n      await this.#startSnap({\n        snapId,\n        sourceCode,\n      });\n\n      const truncated = this.getTruncatedExpect(snapId);\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        type: SNAP_APPROVAL_INSTALL,\n      });\n\n      return truncated;\n    } catch (error) {\n      logError(`Error when adding ${snapId}.`, error);\n\n      const errorString =\n        error instanceof Error ? error.message : error.toString();\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        type: SNAP_APPROVAL_INSTALL,\n        error: errorString,\n      });\n\n      this.messenger.publish(\n        'SnapController:snapInstallFailed',\n        snapId,\n        origin,\n        false,\n        errorString,\n      );\n\n      throw error;\n    }\n  }\n\n  #createApproval({\n    origin,\n    snapId,\n    type,\n  }: {\n    origin: string;\n    snapId: SnapId;\n    type: string;\n  }): PendingApproval {\n    const id = nanoid();\n    const promise = this.messenger.call(\n      'ApprovalController:addRequest',\n      {\n        origin,\n        id,\n        type,\n        requestData: {\n          // Mirror previous installation metadata\n          metadata: { id, origin: snapId, dappOrigin: origin },\n          snapId,\n        },\n        requestState: {\n          loading: true,\n        },\n      },\n      true,\n    );\n\n    return { id, promise };\n  }\n\n  #updateApproval(id: string, requestState: Record<string, Json>) {\n    try {\n      this.messenger.call('ApprovalController:updateRequestState', {\n        id,\n        requestState,\n      });\n    } catch {\n      // Do nothing\n    }\n  }\n\n  /**\n   * Updates an installed snap. The flow is similar to\n   * {@link SnapController.installSnaps}. The user will be asked if they want\n   * to update, then approve any permission changes, and finally the snap will\n   * be restarted.\n   *\n   * The update will fail if the user rejects any prompt or if the new version\n   * of the snap is blocked.\n   *\n   * If the original version of the snap was blocked and the update succeeded,\n   * the snap will be unblocked and enabled before it is restarted.\n   *\n   * @param options - An options bag.\n   * @param options.origin - The origin requesting the snap update.\n   * @param options.snapId - The id of the Snap to be updated.\n   * @param options.location - The location implementation of the snap.\n   * @param options.versionRange - A semver version range in which the maximum version will be chosen.\n   * @param options.automaticUpdate - An optional boolean flag to indicate whether this update should be done\n   * automatically.\n   * @returns The snap metadata if updated, `null` otherwise.\n   */\n  async #updateSnap({\n    origin,\n    snapId,\n    location,\n    versionRange,\n    automaticUpdate = false,\n  }: {\n    origin: string;\n    snapId: SnapId;\n    location: SnapLocation;\n    versionRange: SemVerRange;\n    automaticUpdate?: boolean;\n  }): Promise<TruncatedSnap> {\n    this.#assertCanInstallSnaps();\n    this.#assertCanUsePlatform();\n\n    const snap = this.getExpect(snapId);\n\n    const { preinstalled, removable, hidden, hideSnapBranding } = snap;\n\n    if (preinstalled && !automaticUpdate) {\n      throw new Error('Preinstalled Snaps cannot be manually updated.');\n    }\n\n    let pendingApproval = automaticUpdate\n      ? null\n      : this.#createApproval({\n          origin,\n          snapId,\n          type: SNAP_APPROVAL_UPDATE,\n        });\n\n    try {\n      this.messenger.publish(\n        'SnapController:snapInstallStarted',\n        snapId,\n        origin,\n        true,\n      );\n\n      const oldManifest = snap.manifest;\n\n      const newSnap = await fetchSnap(snapId, location);\n      const { sourceCode: sourceCodeFile, manifest: manifestFile } = newSnap;\n\n      const manifest = manifestFile.result;\n\n      const newVersion = manifest.version;\n      if (!gtVersion(newVersion, snap.version)) {\n        throw rpcErrors.invalidParams(\n          `Snap \"${snapId}@${snap.version}\" is already installed. Couldn't update to a version inside requested \"${versionRange}\" range.`,\n        );\n      }\n\n      if (!satisfiesVersionRange(newVersion, versionRange)) {\n        throw new Error(\n          `Version mismatch. Manifest for \"${snapId}\" specifies version \"${newVersion}\" which doesn't satisfy requested version range \"${versionRange}\".`,\n        );\n      }\n\n      await this.#assertIsInstallAllowed(snapId, {\n        version: newVersion,\n        checksum: manifest.source.shasum,\n        permissions: manifest.initialPermissions,\n        platformVersion: manifest.platformVersion,\n      });\n\n      const processedPermissions = processSnapPermissions(\n        manifest.initialPermissions,\n      );\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      const { newPermissions, unusedPermissions, approvedPermissions } =\n        this.#calculatePermissionsChange(snapId, processedPermissions);\n\n      const { newConnections, unusedConnections, approvedConnections } =\n        this.#calculateConnectionsChange(\n          snapId,\n          oldManifest.initialConnections ?? {},\n          manifest.initialConnections ?? {},\n        );\n\n      let approvedNewPermissions;\n      let requestData;\n\n      if (pendingApproval) {\n        this.#updateApproval(pendingApproval.id, {\n          permissions: newPermissions,\n          newVersion: manifest.version,\n          newPermissions,\n          approvedPermissions,\n          unusedPermissions,\n          newConnections,\n          unusedConnections,\n          approvedConnections,\n          loading: false,\n        });\n\n        const { permissions, ...rest } =\n          (await pendingApproval.promise) as PermissionsRequest;\n\n        approvedNewPermissions = permissions;\n        requestData = rest;\n\n        pendingApproval = this.#createApproval({\n          origin,\n          snapId,\n          type: SNAP_APPROVAL_RESULT,\n        });\n      } else {\n        assert(automaticUpdate);\n        approvedNewPermissions = newPermissions;\n      }\n\n      if (this.isRunning(snapId)) {\n        await this.stopSnap(snapId, SnapStatusEvents.Stop);\n      }\n\n      this.#transition(snapId, SnapStatusEvents.Update);\n\n      this.#set({\n        origin,\n        id: snapId,\n        files: newSnap,\n        removable,\n        preinstalled,\n        hidden,\n        hideSnapBranding,\n        isUpdate: true,\n      });\n\n      this.#updatePermissions({\n        snapId,\n        unusedPermissions,\n        newPermissions: approvedNewPermissions,\n        requestData,\n      });\n\n      const previousInitialConnections = oldManifest.initialConnections ?? null;\n      const newInitialConnections = manifest.initialConnections ?? {};\n      this.#handleInitialConnections(\n        snapId,\n        previousInitialConnections,\n        newInitialConnections,\n      );\n\n      const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n      if (rollbackSnapshot !== undefined) {\n        rollbackSnapshot.permissions.revoked = unusedPermissions;\n        rollbackSnapshot.permissions.granted = approvedNewPermissions;\n        rollbackSnapshot.permissions.requestData = requestData;\n        rollbackSnapshot.previousInitialConnections =\n          previousInitialConnections;\n        rollbackSnapshot.newInitialConnections = newInitialConnections;\n      }\n\n      const sourceCode = sourceCodeFile.toString();\n\n      assert(\n        typeof sourceCode === 'string' && sourceCode.length > 0,\n        `Invalid source code for snap \"${snapId}\".`,\n      );\n\n      try {\n        await this.#startSnap({ snapId, sourceCode });\n      } catch {\n        throw new Error(`Snap ${snapId} crashed with updated source code.`);\n      }\n\n      const truncatedSnap = this.getTruncatedExpect(snapId);\n\n      if (pendingApproval) {\n        this.#updateApproval(pendingApproval.id, {\n          loading: false,\n          type: SNAP_APPROVAL_UPDATE,\n        });\n      }\n\n      return truncatedSnap;\n    } catch (error) {\n      logError(`Error when updating ${snapId},`, error);\n\n      const errorString =\n        error instanceof Error ? error.message : error.toString();\n\n      if (pendingApproval) {\n        this.#updateApproval(pendingApproval.id, {\n          loading: false,\n          error: errorString,\n          type: SNAP_APPROVAL_UPDATE,\n        });\n      }\n\n      this.messenger.publish(\n        'SnapController:snapInstallFailed',\n        snapId,\n        origin,\n        true,\n        errorString,\n      );\n\n      throw error;\n    }\n  }\n\n  async #resolveAllowlistVersion(\n    snapId: SnapId,\n    versionRange: SemVerRange,\n  ): Promise<SemVerRange> {\n    return await this.messenger.call(\n      'SnapsRegistry:resolveVersion',\n      snapId,\n      versionRange,\n    );\n  }\n\n  /**\n   * Returns a promise representing the complete installation of the requested snap.\n   * If the snap is already being installed, the previously pending promise will be returned.\n   *\n   * @param args - Object containing the snap id and either the URL of the snap's manifest,\n   * or the snap's manifest and source code. The object may also optionally contain a target\n   * version.\n   * @returns The resulting snap object.\n   */\n  async #add(args: AddSnapArgs): Promise<PersistedSnap> {\n    const { id: snapId, location, versionRange } = args;\n\n    this.#setupRuntime(snapId);\n    const runtime = this.#getRuntimeExpect(snapId);\n    if (!runtime.installPromise) {\n      log(`Adding snap: ${snapId}`);\n\n      // If fetching and setting the snap succeeds, this property will be set\n      // to null in the authorize() method.\n      runtime.installPromise = (async () => {\n        const fetchedSnap = await fetchSnap(snapId, location);\n        const manifest = fetchedSnap.manifest.result;\n        if (!satisfiesVersionRange(manifest.version, versionRange)) {\n          throw new Error(\n            `Version mismatch. Manifest for \"${snapId}\" specifies version \"${manifest.version}\" which doesn't satisfy requested version range \"${versionRange}\".`,\n          );\n        }\n\n        await this.#assertIsInstallAllowed(snapId, {\n          version: manifest.version,\n          checksum: manifest.source.shasum,\n          permissions: manifest.initialPermissions,\n          platformVersion: manifest.platformVersion,\n        });\n\n        const preinstalledArgs =\n          this.#featureFlags.forcePreinstalledSnaps && isLocalSnapId(snapId)\n            ? {\n                preinstalled: true,\n                hideSnapBranding: true,\n                hidden: false,\n              }\n            : {};\n\n        return this.#set({\n          ...args,\n          files: fetchedSnap,\n          id: snapId,\n          ...preinstalledArgs,\n        });\n      })();\n    }\n\n    try {\n      return await runtime.installPromise;\n    } catch (error) {\n      // Reset promise so users can retry installation in case the problem is\n      // temporary.\n      runtime.installPromise = null;\n      throw error;\n    }\n  }\n\n  async #startSnap(snapData: { snapId: SnapId; sourceCode: string }) {\n    const { snapId } = snapData;\n    if (this.isRunning(snapId)) {\n      throw new Error(`Snap \"${snapId}\" is already started.`);\n    }\n\n    try {\n      const runtime = this.#getRuntimeExpect(snapId);\n      const result = await this.messenger.call('ExecutionService:executeSnap', {\n        ...snapData,\n        endowments: await this.#getEndowments(snapId),\n      });\n\n      this.#transition(snapId, SnapStatusEvents.Start);\n      // We treat the initialization of the snap as the first request, for idle timing purposes.\n      runtime.lastRequest = Date.now();\n      return result;\n    } catch (error) {\n      await this.#terminateSnap(snapId);\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the names of all endowments that will be added to the Snap's\n   * Compartment when it executes. These should be the names of global\n   * JavaScript APIs accessible in the root realm of the execution environment.\n   *\n   * Throws an error if the endowment getter for a permission returns a truthy\n   * value that is not an array of strings.\n   *\n   * @param snapId - The id of the snap whose SES endowments to get.\n   * @returns An array of the names of the endowments.\n   */\n  async #getEndowments(snapId: string): Promise<string[]> {\n    let allEndowments: string[] = [];\n\n    for (const permissionName of this.#environmentEndowmentPermissions) {\n      if (\n        this.messenger.call(\n          'PermissionController:hasPermission',\n          snapId,\n          permissionName,\n        )\n      ) {\n        const endowments = await this.messenger.call(\n          'PermissionController:getEndowments',\n          snapId,\n          permissionName,\n        );\n\n        if (endowments) {\n          // We don't have any guarantees about the type of the endowments\n          // value, so we have to guard at runtime.\n          if (\n            !Array.isArray(endowments) ||\n            endowments.some((value) => typeof value !== 'string')\n          ) {\n            throw new Error('Expected an array of string endowment names.');\n          }\n\n          allEndowments = allEndowments.concat(endowments as string[]);\n        }\n      }\n    }\n\n    const dedupedEndowments = [\n      ...new Set([...DEFAULT_ENDOWMENTS, ...allEndowments]),\n    ];\n\n    if (\n      dedupedEndowments.length <\n      DEFAULT_ENDOWMENTS.length + allEndowments.length\n    ) {\n      logError(\n        `Duplicate endowments found for ${snapId}. Default endowments should not be requested.`,\n        allEndowments,\n      );\n    }\n    return dedupedEndowments;\n  }\n\n  /**\n   * Sets a snap in state. Called when a snap is installed or updated. Performs\n   * various validation checks on the received arguments, and will throw if\n   * validation fails.\n   *\n   * The snap will be enabled and unblocked by the time this method returns,\n   * regardless of its previous state.\n   *\n   * See {@link SnapController.add} and {@link SnapController.updateSnap} for\n   * usage.\n   *\n   * @param args - The add snap args.\n   * @returns The resulting snap object.\n   */\n  #set(args: SetSnapArgs): PersistedSnap {\n    const {\n      id: snapId,\n      origin,\n      files,\n      isUpdate = false,\n      removable,\n      preinstalled,\n      hidden,\n      hideSnapBranding,\n    } = args;\n\n    const {\n      manifest,\n      sourceCode: sourceCodeFile,\n      svgIcon,\n      auxiliaryFiles: rawAuxiliaryFiles,\n      localizationFiles,\n    } = files;\n\n    assertIsSnapManifest(manifest.result);\n    const { version } = manifest.result;\n\n    const sourceCode = sourceCodeFile.toString();\n\n    assert(\n      typeof sourceCode === 'string' && sourceCode.length > 0,\n      `Invalid source code for snap \"${snapId}\".`,\n    );\n\n    const auxiliaryFiles = rawAuxiliaryFiles.map((file) => {\n      assert(typeof file.data.base64 === 'string');\n      return {\n        path: file.path,\n        value: file.data.base64,\n      };\n    });\n\n    const snapsState = this.state.snaps;\n\n    const existingSnap = snapsState[snapId];\n\n    const previousVersionHistory = existingSnap?.versionHistory ?? [];\n    const versionHistory = [\n      ...previousVersionHistory,\n      {\n        version,\n        date: Date.now(),\n        origin,\n      },\n    ];\n\n    const localizedFiles = localizationFiles.map((file) => file.result);\n\n    const snap: Snap = {\n      // Restore relevant snap state if it exists\n      ...existingSnap,\n\n      // Note that the snap will be unblocked and enabled, regardless of its\n      // previous state.\n      blocked: false,\n      enabled: true,\n\n      removable,\n      preinstalled,\n      hidden,\n      hideSnapBranding,\n\n      id: snapId,\n      initialConnections: manifest.result.initialConnections,\n      initialPermissions: manifest.result.initialPermissions,\n      manifest: manifest.result,\n      status: this.#statusMachine.config.initial as StatusStates['value'],\n      sourceCode,\n      version,\n      versionHistory,\n      auxiliaryFiles,\n      localizationFiles: localizedFiles,\n    };\n\n    // If the snap was blocked, it isn't any longer\n    delete snap.blockInformation;\n\n    // store the snap back in state\n    const { inversePatches } = this.update((state: any) => {\n      state.snaps[snapId] = snap;\n    });\n\n    // checking for isUpdate here as this function is also used in\n    // the install flow, we do not care to create snapshots for installs\n    if (isUpdate) {\n      const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n      if (rollbackSnapshot !== undefined) {\n        rollbackSnapshot.statePatches = inversePatches;\n      }\n    }\n\n    // In case the Snap uses a localized manifest, we need to get the\n    // proposed name from the localized manifest.\n    const { proposedName } = getLocalizedSnapManifest(\n      manifest.result,\n      'en',\n      localizedFiles,\n    );\n\n    this.messenger.call('SubjectMetadataController:addSubjectMetadata', {\n      subjectType: SubjectType.Snap,\n      name: proposedName,\n      origin: snap.id,\n      version,\n      svgIcon: svgIcon?.toString() ?? null,\n    });\n\n    return { ...snap, sourceCode };\n  }\n\n  #validateSnapPermissions(\n    processedPermissions: Record<string, Pick<PermissionConstraint, 'caveats'>>,\n  ) {\n    const permissionKeys = Object.keys(processedPermissions);\n    const handlerPermissions = Array.from(\n      new Set(Object.values(handlerEndowments)),\n    );\n\n    assert(\n      permissionKeys.some((key) => handlerPermissions.includes(key)),\n      `A snap must request at least one of the following permissions: ${handlerPermissions\n        .filter((handler) => handler !== null)\n        .join(', ')}.`,\n    );\n\n    const excludedPermissionErrors = permissionKeys.reduce<string[]>(\n      (errors, permission) => {\n        if (hasProperty(this.#excludedPermissions, permission)) {\n          errors.push(this.#excludedPermissions[permission]);\n        }\n\n        return errors;\n      },\n      [],\n    );\n\n    assert(\n      excludedPermissionErrors.length === 0,\n      `One or more permissions are not allowed:\\n${excludedPermissionErrors.join(\n        '\\n',\n      )}`,\n    );\n  }\n\n  /**\n   * Validate that the platform version specified in the manifest (if any) is\n   * compatible with the current platform version.\n   *\n   * @param snapId - The ID of the Snap.\n   * @param platformVersion - The platform version to validate against.\n   * @throws If the platform version is greater than the current platform\n   * version.\n   */\n  #validatePlatformVersion(\n    snapId: SnapId,\n    platformVersion: string | undefined,\n  ) {\n    if (platformVersion === undefined) {\n      return;\n    }\n\n    if (gt(platformVersion, getPlatformVersion())) {\n      const message = `The Snap \"${snapId}\" requires platform version \"${platformVersion}\" which is greater than the current platform version \"${getPlatformVersion()}\".`;\n\n      if (this.#featureFlags.rejectInvalidPlatformVersion) {\n        throw new Error(message);\n      }\n\n      logWarning(message);\n    }\n  }\n\n  /**\n   * Initiates a request for the given snap's initial permissions.\n   * Must be called in order. See processRequestedSnap.\n   *\n   * @param snapId - The id of the Snap.\n   * @param pendingApproval - Pending approval to update.\n   * @returns The snap's approvedPermissions.\n   */\n  async #authorize(\n    snapId: SnapId,\n    pendingApproval: PendingApproval,\n  ): Promise<void> {\n    log(`Authorizing snap: ${snapId}`);\n    const snapsState = this.state.snaps;\n    const snap = snapsState[snapId];\n    const { initialPermissions, initialConnections } = snap;\n\n    try {\n      const processedPermissions = processSnapPermissions(initialPermissions);\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        connections: initialConnections ?? {},\n        permissions: processedPermissions,\n      });\n\n      const { permissions: approvedPermissions, ...requestData } =\n        (await pendingApproval.promise) as PermissionsRequest;\n\n      this.#updatePermissions({\n        snapId,\n        newPermissions: approvedPermissions,\n        requestData,\n      });\n\n      if (snap.manifest.initialConnections) {\n        this.#handleInitialConnections(\n          snapId,\n          null,\n          snap.manifest.initialConnections,\n        );\n      }\n    } finally {\n      const runtime = this.#getRuntimeExpect(snapId);\n      runtime.installPromise = null;\n    }\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this.#timeoutForLastRequestStatus) {\n      clearTimeout(this.#timeoutForLastRequestStatus);\n    }\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messenger.unsubscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messenger.unsubscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messenger.unsubscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n\n    this.messenger.clearEventSubscriptions('SnapController:snapInstalled');\n\n    this.messenger.clearEventSubscriptions('SnapController:snapUpdated');\n    /* eslint-enable @typescript-eslint/unbound-method */\n  }\n\n  /**\n   * Passes a JSON-RPC request object to the RPC handler function of a snap.\n   *\n   * @param options - A bag of options.\n   * @param options.snapId - The ID of the recipient snap.\n   * @param options.origin - The origin of the RPC request.\n   * @param options.handler - The handler to trigger on the snap for the request.\n   * @param options.request - The JSON-RPC request object.\n   * @returns The result of the JSON-RPC request.\n   */\n  async handleRequest({\n    snapId,\n    origin,\n    handler: handlerType,\n    request: rawRequest,\n  }: SnapRpcHookArgs & { snapId: SnapId }): Promise<unknown> {\n    this.#assertCanUsePlatform();\n\n    const snap = this.get(snapId);\n\n    assert(\n      snap,\n      `The Snap \"${snapId}\" is not installed. Please install it before invoking it.`,\n    );\n\n    assert(\n      origin === METAMASK_ORIGIN || isValidUrl(origin),\n      \"'origin' must be a valid URL or 'metamask'.\",\n    );\n\n    const request = {\n      jsonrpc: '2.0',\n      id: nanoid(),\n      ...rawRequest,\n    };\n\n    assertIsJsonRpcRequest(request);\n\n    const permissionName = handlerEndowments[handlerType];\n\n    assert(\n      typeof permissionName === 'string' || permissionName === null,\n      \"'permissionName' must be either a string or null.\",\n    );\n\n    const permissions = this.messenger.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n\n    // If permissionName is null, the handler does not require a permission.\n    if (\n      permissionName !== null &&\n      (!permissions || !hasProperty(permissions, permissionName))\n    ) {\n      throw new Error(\n        `Snap \"${snapId}\" is not permitted to use \"${permissionName}\".`,\n      );\n    }\n\n    const handlerPermissions = permissionName\n      ? (permissions as SubjectPermissions<PermissionConstraint>)[\n          permissionName\n        ]\n      : undefined;\n\n    if (\n      permissionName === SnapEndowments.Rpc ||\n      permissionName === SnapEndowments.Keyring\n    ) {\n      assert(handlerPermissions);\n\n      const subject = this.messenger.call(\n        'SubjectMetadataController:getSubjectMetadata',\n        origin,\n      );\n\n      const origins =\n        permissionName === SnapEndowments.Rpc\n          ? getRpcCaveatOrigins(handlerPermissions)\n          : getKeyringCaveatOrigins(handlerPermissions);\n      assert(origins);\n\n      if (\n        !isOriginAllowed(\n          origins,\n          subject?.subjectType ?? SubjectType.Website,\n          origin,\n        )\n      ) {\n        throw new Error(\n          `Snap \"${snapId}\" is not permitted to handle requests from \"${origin}\".`,\n        );\n      }\n    }\n\n    if (\n      origin !== METAMASK_ORIGIN &&\n      CLIENT_ONLY_HANDLERS.includes(handlerType)\n    ) {\n      throw new Error(`\"${handlerType}\" can only be invoked by MetaMask.`);\n    }\n\n    if (!snap.enabled) {\n      throw new Error(`Snap \"${snapId}\" is disabled.`);\n    }\n\n    if (snap.status === SnapStatus.Installing) {\n      throw new Error(\n        `Snap \"${snapId}\" is currently being installed. Please try again later.`,\n      );\n    }\n\n    const timeout = this.#getExecutionTimeout(handlerPermissions);\n\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (runtime.stopPromise) {\n      await runtime.stopPromise;\n    }\n\n    if (!this.isRunning(snapId)) {\n      if (!runtime.startPromise) {\n        runtime.startPromise = this.startSnap(snapId);\n      }\n\n      try {\n        await runtime.startPromise;\n      } finally {\n        runtime.startPromise = null;\n      }\n    }\n\n    const transformedRequest = this.#transformSnapRpcRequest(\n      snapId,\n      handlerType,\n      request,\n    );\n\n    const timer = new Timer(timeout);\n    this.#recordSnapRpcRequestStart(snapId, transformedRequest.id, timer);\n\n    const handleRpcRequestPromise = this.messenger.call(\n      'ExecutionService:handleRpcRequest',\n      snapId,\n      { origin, handler: handlerType, request: transformedRequest },\n    );\n\n    // This will either get the result or reject due to the timeout.\n    try {\n      const result = await withTimeout(handleRpcRequestPromise, timer);\n\n      if (result === hasTimedOut) {\n        const stopping =\n          runtime.stopPromise !== null || !this.isRunning(snapId);\n        throw new Error(\n          stopping\n            ? `${snapId} was stopped and the request was cancelled. This is likely because the Snap crashed.`\n            : `${snapId} failed to respond to the request in time.`,\n        );\n      }\n\n      await this.#assertSnapRpcResponse(snapId, handlerType, result);\n\n      const transformedResult = await this.#transformSnapRpcResponse(\n        snapId,\n        handlerType,\n        transformedRequest,\n        result,\n      );\n\n      this.#recordSnapRpcRequestFinish(\n        snapId,\n        transformedRequest.id,\n        handlerType,\n        origin,\n        true,\n      );\n\n      return transformedResult;\n    } catch (error) {\n      // We flag the RPC request as finished early since termination may affect pending requests\n      this.#recordSnapRpcRequestFinish(\n        snapId,\n        transformedRequest.id,\n        handlerType,\n        origin,\n        false,\n      );\n\n      const [jsonRpcError, handled] = unwrapError(error);\n\n      const stopping = runtime.stopPromise !== null || !this.isRunning(snapId);\n\n      if (!handled) {\n        if (!stopping) {\n          logError(\n            `\"${snapId}\" crashed due to an unhandled error:`,\n            jsonRpcError,\n          );\n        }\n        await this.stopSnap(snapId, SnapStatusEvents.Crash);\n      }\n\n      throw jsonRpcError;\n    }\n  }\n\n  /**\n   * Set the active state of the client. This will trigger the `onActive` or\n   * `onInactive` lifecycle hooks for all Snaps.\n   *\n   * @param active - A boolean indicating whether the client is active or not.\n   */\n  setClientActive(active: boolean) {\n    if (active) {\n      this.#callLifecycleHooks(METAMASK_ORIGIN, HandlerType.OnActive);\n    } else {\n      this.#callLifecycleHooks(METAMASK_ORIGIN, HandlerType.OnInactive);\n    }\n  }\n\n  /**\n   * Determine the execution timeout for a given handler permission.\n   *\n   * If no permission is specified or the permission itself has no execution timeout defined\n   * the constructor argument `maxRequestTime` will be used.\n   *\n   * @param permission - An optional permission constraint for the handler being called.\n   * @returns The execution timeout for the given handler.\n   */\n  #getExecutionTimeout(permission?: PermissionConstraint): number {\n    return getMaxRequestTimeCaveat(permission) ?? this.maxRequestTime;\n  }\n\n  /**\n   * Create a dynamic interface in the SnapInterfaceController.\n   *\n   * @param snapId - The snap ID.\n   * @param content - The initial interface content.\n   * @param contentType - The type of content.\n   * @returns An identifier that can be used to identify the interface.\n   */\n  async #createInterface(\n    snapId: SnapId,\n    content: ComponentOrElement,\n    contentType?: ContentType,\n  ): Promise<string> {\n    return this.messenger.call(\n      'SnapInterfaceController:createInterface',\n      snapId,\n      content,\n      undefined,\n      contentType,\n    );\n  }\n\n  #assertInterfaceExists(snapId: SnapId, id: string) {\n    // This will throw if the interface isn't accessible, but we assert nevertheless.\n    assert(\n      this.messenger.call('SnapInterfaceController:getInterface', snapId, id),\n    );\n  }\n\n  /**\n   * Transform a RPC response if necessary.\n   *\n   * @param snapId - The snap ID of the snap that produced the result.\n   * @param handlerType - The handler type that produced the result.\n   * @param request - The request that returned the result.\n   * @param result - The response.\n   * @returns The transformed result if applicable, otherwise the original result.\n   */\n  async #transformSnapRpcResponse(\n    snapId: SnapId,\n    handlerType: HandlerType,\n    request: Record<string, unknown>,\n    result: unknown,\n  ) {\n    switch (handlerType) {\n      case HandlerType.OnTransaction:\n      case HandlerType.OnSignature:\n      case HandlerType.OnHomePage:\n      case HandlerType.OnSettingsPage: {\n        // Since this type has been asserted earlier we can cast\n        const castResult = result as Record<string, Json> | null;\n\n        // If a handler returns static content, we turn it into a dynamic UI\n        if (castResult && hasProperty(castResult, 'content')) {\n          const { content, ...rest } = castResult;\n          const id = await this.#createInterface(\n            snapId,\n            content as ComponentOrElement,\n          );\n\n          return { ...rest, id };\n        }\n        return result;\n      }\n      case HandlerType.OnAssetsLookup:\n        // We can cast since the request and result have already been validated.\n        return this.#transformOnAssetsLookupResult(\n          snapId,\n          request as { params: OnAssetsLookupArguments },\n          result as OnAssetsLookupResponse,\n        );\n\n      case HandlerType.OnAssetsConversion:\n        // We can cast since the request and result have already been validated.\n        return this.#transformOnAssetsConversionResult(\n          request as {\n            params: OnAssetsConversionArguments;\n          },\n          result as OnAssetsConversionResponse,\n        );\n\n      case HandlerType.OnAssetsMarketData:\n        // We can cast since the request and result have already been validated.\n        return this.#transformOnAssetsMarketDataResult(\n          request as { params: OnAssetsMarketDataArguments },\n          result as OnAssetsMarketDataResponse,\n        );\n\n      default:\n        return result;\n    }\n  }\n\n  /**\n   * Transform an RPC response coming from the `onAssetsLookup` handler.\n   *\n   * This filters out responses that are out of scope for the Snap based on\n   * its permissions and the incoming request.\n   *\n   * @param snapId - The snap ID of the snap that produced the result.\n   * @param request - The request that returned the result.\n   * @param request.params - The parameters for the request.\n   * @param result - The result.\n   * @param result.assets - The assets returned by the Snap.\n   * @returns The transformed result.\n   */\n  #transformOnAssetsLookupResult(\n    snapId: SnapId,\n    { params: requestedParams }: { params: OnAssetsLookupArguments },\n    { assets }: OnAssetsLookupResponse,\n  ) {\n    const permissions = this.messenger.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n    // We know the permissions are guaranteed to be set here.\n    assert(permissions);\n\n    const permission = permissions[SnapEndowments.Assets];\n    const scopes = getChainIdsCaveat(permission);\n    assert(scopes);\n\n    const { assets: requestedAssets } = requestedParams;\n\n    const filteredAssets = Object.keys(assets).reduce<\n      Record<CaipAssetType, AssetMetadata | null>\n    >((accumulator, assetType) => {\n      const castAssetType = assetType as CaipAssetTypeOrId;\n      const isValid =\n        scopes.some((scope) => castAssetType.startsWith(scope)) &&\n        requestedAssets.includes(castAssetType);\n      // Filter out unrequested assets and assets for scopes the Snap hasn't registered for.\n      if (isValid) {\n        accumulator[castAssetType] = assets[castAssetType];\n      }\n      return accumulator;\n    }, {});\n    return { assets: filteredAssets };\n  }\n\n  /**\n   * Transform an RPC response coming from the `onAssetsConversion` handler.\n   *\n   * This filters out responses that are out of scope for the Snap based on\n   * the incoming request.\n   *\n   * @param request - The request that returned the result.\n   * @param request.params - The parameters for the request.\n   * @param result - The result.\n   * @param result.conversionRates - The conversion rates returned by the Snap.\n   * @returns The transformed result.\n   */\n  #transformOnAssetsConversionResult(\n    { params: requestedParams }: { params: OnAssetsConversionArguments },\n    { conversionRates }: OnAssetsConversionResponse,\n  ) {\n    const { conversions: requestedConversions } = requestedParams;\n\n    const filteredConversionRates = requestedConversions.reduce<\n      Record<CaipAssetType, Record<CaipAssetType, AssetConversion>>\n    >((accumulator, conversion) => {\n      const rate = conversionRates[conversion.from]?.[conversion.to];\n      // Only include rates that were actually requested.\n      if (rate) {\n        accumulator[conversion.from] ??= {};\n        accumulator[conversion.from][conversion.to] = rate;\n      }\n      return accumulator;\n    }, {});\n    return { conversionRates: filteredConversionRates };\n  }\n\n  /**\n   * Transforms an RPC response coming from the `onAssetsMarketData` handler.\n   *\n   * This filters out responses that are out of scope for the Snap based on\n   * the incoming request.\n   *\n   * @param request - The request that returned the result.\n   * @param request.params - The parameters for the request.\n   * @param result - The result.\n   * @param result.marketData - The market data returned by the Snap.\n   * @returns The transformed result.\n   */\n  #transformOnAssetsMarketDataResult(\n    { params: requestedParams }: { params: OnAssetsMarketDataArguments },\n    { marketData }: OnAssetsMarketDataResponse,\n  ) {\n    const { assets: requestedAssets } = requestedParams;\n\n    const filteredMarketData = requestedAssets.reduce<\n      Record<CaipAssetTypeOrId, Record<CaipAssetType, AssetMarketData | null>>\n    >((accumulator, assets) => {\n      const result = marketData[assets.asset]?.[assets.unit];\n      // Only include rates that were actually requested.\n      if (result) {\n        accumulator[assets.asset] ??= {};\n        accumulator[assets.asset][assets.unit] = result;\n      }\n      return accumulator;\n    }, {});\n    return { marketData: filteredMarketData };\n  }\n\n  /**\n   * Transforms a JSON-RPC request before sending it to the Snap, if required for a given handler.\n   *\n   * @param snapId - The Snap ID.\n   * @param handlerType - The handler being called.\n   * @param request - The JSON-RPC request.\n   * @returns The potentially transformed JSON-RPC request.\n   */\n  #transformSnapRpcRequest(\n    snapId: SnapId,\n    handlerType: HandlerType,\n    request: JsonRpcRequest,\n  ) {\n    switch (handlerType) {\n      // For onUserInput we inject context, so the client doesn't have to worry about keeping it in sync.\n      case HandlerType.OnUserInput: {\n        assert(request.params && hasProperty(request.params, 'id'));\n\n        const interfaceId = request.params.id as string;\n        const { context } = this.messenger.call(\n          'SnapInterfaceController:getInterface',\n          snapId,\n          interfaceId,\n        );\n\n        return {\n          ...request,\n          params: { ...request.params, context },\n        };\n      }\n\n      default:\n        return request;\n    }\n  }\n\n  /**\n   * Assert that the returned result of a Snap RPC call is the expected shape.\n   *\n   * @param snapId - The snap ID.\n   * @param handlerType - The handler type of the RPC Request.\n   * @param result - The result of the RPC request.\n   */\n  async #assertSnapRpcResponse(\n    snapId: SnapId,\n    handlerType: HandlerType,\n    result: unknown,\n  ) {\n    switch (handlerType) {\n      case HandlerType.OnTransaction: {\n        assertStruct(result, OnTransactionResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnSignature: {\n        assertStruct(result, OnSignatureResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnHomePage: {\n        assertStruct(result, OnHomePageResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnSettingsPage: {\n        assertStruct(result, OnSettingsPageResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnNameLookup:\n        assertStruct(result, OnNameLookupResponseStruct);\n        break;\n      case HandlerType.OnAssetsLookup:\n        assertStruct(result, OnAssetsLookupResponseStruct);\n        break;\n      case HandlerType.OnAssetsConversion:\n        assertStruct(result, OnAssetsConversionResponseStruct);\n        break;\n      case HandlerType.OnAssetHistoricalPrice:\n        assertStruct(result, OnAssetHistoricalPriceResponseStruct);\n        break;\n      case HandlerType.OnAssetsMarketData:\n        assertStruct(result, OnAssetsMarketDataResponseStruct);\n        break;\n      default:\n        break;\n    }\n  }\n\n  #recordSnapRpcRequestStart(snapId: SnapId, requestId: unknown, timer: Timer) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests.push({ requestId, timer });\n    runtime.lastRequest = null;\n  }\n\n  #recordSnapRpcRequestFinish(\n    snapId: SnapId,\n    requestId: unknown,\n    handlerType: HandlerType,\n    origin: string,\n    success: boolean,\n  ) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests = runtime.pendingInboundRequests.filter(\n      (request) => request.requestId !== requestId,\n    );\n\n    if (runtime.pendingInboundRequests.length === 0) {\n      runtime.lastRequest = Date.now();\n    }\n\n    const snap = this.get(snapId);\n\n    if (isTrackableHandler(handlerType) && !snap?.preinstalled) {\n      try {\n        this.#trackSnapExport(snapId, handlerType, success, origin);\n      } catch (error) {\n        logError(\n          `Error when calling MetaMetrics hook for snap \"${snap?.id}\": ${getErrorMessage(\n            error,\n          )}`,\n        );\n      }\n    }\n  }\n\n  /**\n   * Retrieves the rollback snapshot of a snap.\n   *\n   * @param snapId - The snap id.\n   * @returns A `RollbackSnapshot` or `undefined` if one doesn't exist.\n   */\n  #getRollbackSnapshot(snapId: SnapId): RollbackSnapshot | undefined {\n    return this.#rollbackSnapshots.get(snapId);\n  }\n\n  /**\n   * Creates a `RollbackSnapshot` that is used to help ensure\n   * atomicity in multiple snap updates.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If the snap exists before creation or if creation fails.\n   * @returns A `RollbackSnapshot`.\n   */\n  #createRollbackSnapshot(snapId: SnapId): RollbackSnapshot {\n    assert(\n      this.#rollbackSnapshots.get(snapId) === undefined,\n      `Snap \"${snapId}\" rollback snapshot already exists.`,\n    );\n\n    this.#rollbackSnapshots.set(snapId, {\n      statePatches: [],\n      permissions: {},\n      newVersion: '',\n    });\n\n    const newRollbackSnapshot = this.#rollbackSnapshots.get(snapId);\n\n    assert(\n      newRollbackSnapshot !== undefined,\n      `Snapshot creation failed for ${snapId}.`,\n    );\n    return newRollbackSnapshot;\n  }\n\n  /**\n   * Rolls back a snap to its previous state, permissions\n   * and source code based on the `RollbackSnapshot` that\n   * is captured during the update process. After rolling back,\n   * the function also emits an event indicating that the\n   * snap has been rolled back and it clears the snapshot\n   * for that snap.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If a snapshot does not exist.\n   */\n  async #rollbackSnap(snapId: SnapId) {\n    const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n    if (!rollbackSnapshot) {\n      throw new Error('A snapshot does not exist for this snap.');\n    }\n\n    await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    // Always set to stopped even if it wasn't running initially\n    if (this.get(snapId)?.status !== SnapStatus.Stopped) {\n      this.#transition(snapId, SnapStatusEvents.Stop);\n    }\n\n    const {\n      statePatches,\n      permissions,\n      previousInitialConnections,\n      newInitialConnections,\n    } = rollbackSnapshot;\n\n    if (statePatches?.length) {\n      this.applyPatches(statePatches);\n    }\n\n    // Reset snap status, as we may have been in another state when we stored state patches\n    // But now we are 100% in a stopped state\n    if (this.get(snapId)?.status !== SnapStatus.Stopped) {\n      this.update((state) => {\n        state.snaps[snapId].status = SnapStatus.Stopped;\n      });\n    }\n\n    this.#updatePermissions({\n      snapId,\n      unusedPermissions: permissions.granted,\n      newPermissions: permissions.revoked,\n      requestData: permissions.requestData,\n    });\n\n    // Calling this in reverse order to undo the changes\n    this.#handleInitialConnections(\n      snapId,\n      newInitialConnections ?? null,\n      previousInitialConnections ?? {},\n    );\n\n    const truncatedSnap = this.getTruncatedExpect(snapId);\n\n    this.messenger.publish(\n      'SnapController:snapRolledback',\n      truncatedSnap,\n      rollbackSnapshot.newVersion,\n    );\n\n    this.#rollbackSnapshots.delete(snapId);\n  }\n\n  /**\n   * Iterates through an array of snap ids\n   * and calls `rollbackSnap` on them.\n   *\n   * @param snapIds - An array of snap ids.\n   */\n  async #rollbackSnaps(snapIds: SnapId[]) {\n    for (const snapId of snapIds) {\n      await this.#rollbackSnap(snapId);\n    }\n  }\n\n  #getRuntime(snapId: SnapId): SnapRuntimeData | undefined {\n    return this.#snapsRuntimeData.get(snapId);\n  }\n\n  #getRuntimeExpect(snapId: SnapId): SnapRuntimeData {\n    const runtime = this.#getRuntime(snapId);\n    assert(runtime !== undefined, `Snap \"${snapId}\" runtime data not found`);\n    return runtime;\n  }\n\n  #setupRuntime(snapId: SnapId) {\n    if (this.#snapsRuntimeData.has(snapId)) {\n      return;\n    }\n\n    const snap = this.get(snapId);\n    const interpreter = interpret(this.#statusMachine);\n    interpreter.start({\n      context: { snapId },\n      value:\n        snap?.status ??\n        (this.#statusMachine.config.initial as StatusStates['value']),\n    });\n\n    forceStrict(interpreter);\n\n    this.#snapsRuntimeData.set(snapId, {\n      lastRequest: null,\n      startPromise: null,\n      stopPromise: null,\n      installPromise: null,\n      encryptionKey: null,\n      encryptionSalt: null,\n      activeReferences: 0,\n      pendingInboundRequests: [],\n      pendingOutboundRequests: 0,\n      interpreter,\n      stateMutex: new Mutex(),\n      getStateMutex: new Mutex(),\n    });\n  }\n\n  #calculatePermissionsChange(\n    snapId: SnapId,\n    desiredPermissionsSet: Record<\n      string,\n      Pick<PermissionConstraint, 'caveats'>\n    >,\n  ): {\n    newPermissions: Record<string, Pick<PermissionConstraint, 'caveats'>>;\n    unusedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n    approvedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n  } {\n    const oldPermissions =\n      this.messenger.call('PermissionController:getPermissions', snapId) ?? {};\n\n    const newPermissions = permissionsDiff(\n      desiredPermissionsSet,\n      oldPermissions,\n    );\n    // TODO(ritave): The assumption that these are unused only holds so long as we do not\n    //               permit dynamic permission requests.\n    const unusedPermissions = permissionsDiff(\n      oldPermissions,\n      desiredPermissionsSet,\n    );\n\n    // It's a Set Intersection of oldPermissions and desiredPermissionsSet\n    // oldPermissions ∖ (oldPermissions ∖ desiredPermissionsSet) ⟺ oldPermissions ∩ desiredPermissionsSet\n    const approvedPermissions = permissionsDiff(\n      oldPermissions,\n      unusedPermissions,\n    );\n\n    return { newPermissions, unusedPermissions, approvedPermissions };\n  }\n\n  #isSubjectConnectedToSnap(snapId: SnapId, origin: string) {\n    const subjectPermissions = this.messenger.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const existingCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds);\n\n    return Boolean((existingCaveat?.value as Record<string, Json>)?.[snapId]);\n  }\n\n  #calculateConnectionsChange(\n    snapId: SnapId,\n    oldConnectionsSet: Record<string, Json>,\n    desiredConnectionsSet: Record<string, Json>,\n  ): {\n    newConnections: Record<string, Json>;\n    unusedConnections: Record<string, Json>;\n    approvedConnections: Record<string, Json>;\n  } {\n    // Filter out any origins that have been revoked since last install/update.\n    // That way they will be represented as new.\n    const filteredOldConnections = Object.keys(oldConnectionsSet)\n      .filter((origin) => this.#isSubjectConnectedToSnap(snapId, origin))\n      .reduce<Record<string, Json>>((accumulator, origin) => {\n        accumulator[origin] = oldConnectionsSet[origin];\n        return accumulator;\n      }, {});\n\n    const newConnections = setDiff(\n      desiredConnectionsSet,\n      filteredOldConnections,\n    );\n\n    const unusedConnections = setDiff(\n      filteredOldConnections,\n      desiredConnectionsSet,\n    );\n\n    // It's a Set Intersection of oldConnections and desiredConnectionsSet\n    // oldConnections ∖ (oldConnections ∖ desiredConnectionsSet) ⟺ oldConnections ∩ desiredConnectionsSet\n    const approvedConnections = setDiff(\n      filteredOldConnections,\n      unusedConnections,\n    );\n\n    return { newConnections, unusedConnections, approvedConnections };\n  }\n\n  /**\n   * Get the permissions to grant to a Snap following an install, update or\n   * rollback.\n   *\n   * @param snapId - The snap ID.\n   * @param newPermissions - The new permissions to be granted.\n   * @returns The permissions to grant to the Snap.\n   */\n  #getPermissionsToGrant(snapId: SnapId, newPermissions: RequestedPermissions) {\n    if (Object.keys(newPermissions).includes(SnapEndowments.EthereumProvider)) {\n      // This will return the globally selected network if the Snap doesn't have\n      // one set.\n      const networkClientId = this.messenger.call(\n        'SelectedNetworkController:getNetworkClientIdForDomain',\n        snapId,\n      );\n\n      const { configuration } = this.messenger.call(\n        'NetworkController:getNetworkClientById',\n        networkClientId,\n      );\n\n      const chainId = hexToNumber(configuration.chainId);\n\n      // This needs to be assigned to have proper type inference.\n      const modifiedPermissions: RequestedPermissions = {\n        ...newPermissions,\n        'endowment:caip25': {\n          caveats: [\n            {\n              type: 'authorizedScopes',\n              value: {\n                requiredScopes: {},\n                optionalScopes: {\n                  [`eip155:${chainId}`]: {\n                    accounts: [],\n                  },\n                },\n                sessionProperties: {},\n                isMultichainOrigin: false,\n              },\n            },\n          ],\n        },\n      };\n\n      return modifiedPermissions;\n    }\n\n    return newPermissions;\n  }\n\n  /**\n   * Update the permissions for a snap following an install, update or rollback.\n   *\n   * Grants newly requested permissions and revokes unused/revoked permissions.\n   *\n   * @param args - An options bag.\n   * @param args.snapId - The snap ID.\n   * @param args.newPermissions - New permissions to be granted.\n   * @param args.unusedPermissions - Unused permissions to be revoked.\n   * @param args.requestData - Optional request data from an approval.\n   */\n  #updatePermissions({\n    snapId,\n    unusedPermissions = {},\n    newPermissions = {},\n    requestData,\n  }: {\n    snapId: SnapId;\n    newPermissions?:\n      | RequestedPermissions\n      | Record<string, Pick<PermissionConstraint, 'caveats'>>;\n    unusedPermissions?:\n      | RequestedPermissions\n      | SubjectPermissions<ValidPermission<string, Caveat<string, any>>>;\n    requestData?: Record<string, unknown>;\n  }) {\n    const unusedPermissionsKeys = Object.keys(unusedPermissions);\n    if (isNonEmptyArray(unusedPermissionsKeys)) {\n      this.messenger.call('PermissionController:revokePermissions', {\n        [snapId]: unusedPermissionsKeys,\n      });\n    }\n\n    if (isNonEmptyArray(Object.keys(newPermissions))) {\n      const approvedPermissions = this.#getPermissionsToGrant(\n        snapId,\n        newPermissions,\n      );\n\n      this.messenger.call('PermissionController:grantPermissions', {\n        approvedPermissions,\n        subject: { origin: snapId },\n        requestData,\n      });\n    }\n  }\n\n  /**\n   * Checks if a snap will pass version validation checks\n   * with the new version range that is requested. The first\n   * check that is done is to check if the existing snap version\n   * falls inside the requested range. If it does, we want to return\n   * false because we do not care to create a rollback snapshot in\n   * that scenario. The second check is to ensure that the current\n   * snap version is not greater than all possible versions in\n   * the requested version range. If it is, then we also want\n   * to return false in that scenario.\n   *\n   * @param snapId - The snap id.\n   * @param newVersionRange - The new version range being requested.\n   * @returns `true` if validation checks pass and `false` if they do not.\n   */\n  #isValidUpdate(snapId: SnapId, newVersionRange: SemVerRange): boolean {\n    const existingSnap = this.getExpect(snapId);\n\n    if (satisfiesVersionRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    if (gtRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Call a lifecycle hook for all runnable Snaps.\n   *\n   * @param origin - The origin of the request.\n   * @param handler - The lifecycle hook to call. This should be one of the\n   * supported lifecycle hooks.\n   */\n  #callLifecycleHooks(origin: string, handler: HandlerType) {\n    const snaps = this.getRunnableSnaps();\n    for (const { id } of snaps) {\n      const hasLifecycleHooksEndowment = this.messenger.call(\n        'PermissionController:hasPermission',\n        id,\n        SnapEndowments.LifecycleHooks,\n      );\n\n      if (!hasLifecycleHooksEndowment) {\n        continue;\n      }\n\n      this.#callLifecycleHook(origin, id, handler).catch((error) => {\n        logError(\n          `Error calling lifecycle hook \"${handler}\" for Snap \"${id}\": ${getErrorMessage(\n            error,\n          )}`,\n        );\n      });\n    }\n  }\n\n  /**\n   * Call a lifecycle hook on a snap, if the snap has the\n   * `endowment:lifecycle-hooks` permission. If the snap does not have the\n   * permission, nothing happens.\n   *\n   * @param origin - The origin.\n   * @param snapId - The snap ID.\n   * @param handler - The lifecycle hook to call. This should be one of the\n   * supported lifecycle hooks.\n   * @private\n   */\n  async #callLifecycleHook(\n    origin: string,\n    snapId: SnapId,\n    handler: HandlerType,\n  ) {\n    const permissionName = handlerEndowments[handler];\n\n    assert(permissionName, 'Lifecycle hook must have an endowment.');\n\n    const hasPermission = this.messenger.call(\n      'PermissionController:hasPermission',\n      snapId,\n      permissionName,\n    );\n\n    if (!hasPermission) {\n      return;\n    }\n\n    await this.handleRequest({\n      snapId,\n      handler,\n      origin,\n      request: {\n        jsonrpc: '2.0',\n        method: handler,\n      },\n    });\n  }\n\n  /**\n   * Handle the `KeyringController:lock` event.\n   *\n   * Currently this clears the cached encrypted state (if any) for all Snaps.\n   */\n  #handleLock() {\n    for (const runtime of this.#snapsRuntimeData.values()) {\n      runtime.encryptionKey = null;\n      runtime.encryptionSalt = null;\n      runtime.state = undefined;\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/snaps/registry/json.cjs b/dist/snaps/registry/json.cjs
index caf95fcc34cf07af5d10ed9dd5c410a5fd6c4fed..f06c3520de798b8a02a40302347a6338dcd13a96 100644
--- a/dist/snaps/registry/json.cjs
+++ b/dist/snaps/registry/json.cjs
@@ -1,7 +1,7 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.JsonSnapsRegistry = void 0;
-const base_controller_1 = require("@metamask/base-controller");
+const next_1 = require("@metamask/base-controller/next");
 const snaps_registry_1 = require("@metamask/snaps-registry");
 const snaps_utils_1 = require("@metamask/snaps-utils");
 const utils_1 = require("@metamask/utils");
@@ -15,7 +15,7 @@ const defaultState = {
     lastUpdated: null,
     databaseUnavailable: false,
 };
-class JsonSnapsRegistry extends base_controller_1.BaseController {
+class JsonSnapsRegistry extends next_1.BaseController {
     #url;
     #publicKey;
     #fetchFunction;
@@ -32,19 +32,19 @@ class JsonSnapsRegistry extends base_controller_1.BaseController {
                 database: {
                     includeInStateLogs: true,
                     persist: true,
-                    anonymous: false,
+                    includeInDebugSnapshot: false,
                     usedInUi: true,
                 },
                 lastUpdated: {
                     includeInStateLogs: true,
                     persist: true,
-                    anonymous: false,
+                    includeInDebugSnapshot: true,
                     usedInUi: false,
                 },
                 databaseUnavailable: {
                     includeInStateLogs: true,
                     persist: true,
-                    anonymous: false,
+                    includeInDebugSnapshot: true,
                     usedInUi: false,
                 },
             },
@@ -60,10 +60,10 @@ class JsonSnapsRegistry extends base_controller_1.BaseController {
         this.#recentFetchThreshold = recentFetchThreshold;
         this.#refetchOnAllowlistMiss = refetchOnAllowlistMiss;
         this.#currentUpdate = null;
-        this.messagingSystem.registerActionHandler('SnapsRegistry:get', async (...args) => this.#get(...args));
-        this.messagingSystem.registerActionHandler('SnapsRegistry:getMetadata', (...args) => this.#getMetadata(...args));
-        this.messagingSystem.registerActionHandler('SnapsRegistry:resolveVersion', async (...args) => this.#resolveVersion(...args));
-        this.messagingSystem.registerActionHandler('SnapsRegistry:update', async () => this.#triggerUpdate());
+        this.messenger.registerActionHandler('SnapsRegistry:get', async (...args) => this.#get(...args));
+        this.messenger.registerActionHandler('SnapsRegistry:getMetadata', (...args) => this.#getMetadata(...args));
+        this.messenger.registerActionHandler('SnapsRegistry:resolveVersion', async (...args) => this.#resolveVersion(...args));
+        this.messenger.registerActionHandler('SnapsRegistry:update', async () => this.#triggerUpdate());
     }
     #wasRecentlyFetched() {
         return (this.state.lastUpdated &&
diff --git a/dist/snaps/registry/json.cjs.map b/dist/snaps/registry/json.cjs.map
index 98448cc11cc08ef46a36e3aff07c27d19ea3a2f4..5058f5b124e447df9ee156715cf24d6b50fba0ec 100644
--- a/dist/snaps/registry/json.cjs.map
+++ b/dist/snaps/registry/json.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"json.cjs","sourceRoot":"","sources":["../../../src/snaps/registry/json.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { SnapsRegistryDatabase } from '@metamask/snaps-registry';\nimport { verify } from '@metamask/snaps-registry';\nimport { getTargetVersion } from '@metamask/snaps-utils';\nimport type { Hex, SemVerRange, SemVerVersion } from '@metamask/utils';\nimport {\n  assert,\n  assertIsSemVerRange,\n  Duration,\n  inMilliseconds,\n  satisfiesVersionRange,\n} from '@metamask/utils';\n\nimport type {\n  SnapsRegistry,\n  SnapsRegistryInfo,\n  SnapsRegistryMetadata,\n  SnapsRegistryRequest,\n  SnapsRegistryResult,\n} from './registry';\nimport { SnapsRegistryStatus } from './registry';\n\nconst SNAP_REGISTRY_URL =\n  'https://acl.execution.metamask.io/latest/registry.json';\n\nconst SNAP_REGISTRY_SIGNATURE_URL =\n  'https://acl.execution.metamask.io/latest/signature.json';\n\nconst DEFAULT_PUBLIC_KEY =\n  '0x025b65308f0f0fb8bc7f7ff87bfc296e0330eee5d3c1d1ee4a048b2fd6a86fa0a6';\n\ntype JsonSnapsRegistryUrl = {\n  registry: string;\n  signature: string;\n};\n\nexport type JsonSnapsRegistryArgs = {\n  messenger: SnapsRegistryMessenger;\n  state?: SnapsRegistryState;\n  fetchFunction?: typeof fetch;\n  url?: JsonSnapsRegistryUrl;\n  recentFetchThreshold?: number;\n  refetchOnAllowlistMiss?: boolean;\n  publicKey?: Hex;\n};\n\nexport type GetResult = {\n  type: `${typeof controllerName}:get`;\n  handler: SnapsRegistry['get'];\n};\n\nexport type ResolveVersion = {\n  type: `${typeof controllerName}:resolveVersion`;\n  handler: SnapsRegistry['resolveVersion'];\n};\n\nexport type GetMetadata = {\n  type: `${typeof controllerName}:getMetadata`;\n  handler: SnapsRegistry['getMetadata'];\n};\n\nexport type Update = {\n  type: `${typeof controllerName}:update`;\n  handler: SnapsRegistry['update'];\n};\n\nexport type SnapsRegistryGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapsRegistryState\n>;\n\nexport type SnapsRegistryActions =\n  | SnapsRegistryGetStateAction\n  | GetResult\n  | GetMetadata\n  | Update\n  | ResolveVersion;\n\nexport type SnapsRegistryStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  SnapsRegistryState\n>;\n\nexport type SnapsRegistryEvents = SnapsRegistryStateChangeEvent;\n\nexport type SnapsRegistryMessenger = RestrictedMessenger<\n  'SnapsRegistry',\n  SnapsRegistryActions,\n  SnapsRegistryEvents,\n  SnapsRegistryActions['type'],\n  SnapsRegistryEvents['type']\n>;\n\nexport type SnapsRegistryState = {\n  database: SnapsRegistryDatabase | null;\n  lastUpdated: number | null;\n  databaseUnavailable: boolean;\n};\n\nconst controllerName = 'SnapsRegistry';\n\nconst defaultState = {\n  database: null,\n  lastUpdated: null,\n  databaseUnavailable: false,\n};\n\nexport class JsonSnapsRegistry extends BaseController<\n  typeof controllerName,\n  SnapsRegistryState,\n  SnapsRegistryMessenger\n> {\n  readonly #url: JsonSnapsRegistryUrl;\n\n  readonly #publicKey: Hex;\n\n  readonly #fetchFunction: typeof fetch;\n\n  readonly #recentFetchThreshold: number;\n\n  readonly #refetchOnAllowlistMiss: boolean;\n\n  #currentUpdate: Promise<void> | null;\n\n  constructor({\n    messenger,\n    state,\n    url = {\n      registry: SNAP_REGISTRY_URL,\n      signature: SNAP_REGISTRY_SIGNATURE_URL,\n    },\n    publicKey = DEFAULT_PUBLIC_KEY,\n    fetchFunction = globalThis.fetch.bind(undefined),\n    recentFetchThreshold = inMilliseconds(5, Duration.Minute),\n    refetchOnAllowlistMiss = true,\n  }: JsonSnapsRegistryArgs) {\n    super({\n      messenger,\n      metadata: {\n        database: {\n          includeInStateLogs: true,\n          persist: true,\n          anonymous: false,\n          usedInUi: true,\n        },\n        lastUpdated: {\n          includeInStateLogs: true,\n          persist: true,\n          anonymous: false,\n          usedInUi: false,\n        },\n        databaseUnavailable: {\n          includeInStateLogs: true,\n          persist: true,\n          anonymous: false,\n          usedInUi: false,\n        },\n      },\n      name: controllerName,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n    this.#url = url;\n    this.#publicKey = publicKey;\n    this.#fetchFunction = fetchFunction;\n    this.#recentFetchThreshold = recentFetchThreshold;\n    this.#refetchOnAllowlistMiss = refetchOnAllowlistMiss;\n    this.#currentUpdate = null;\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:get',\n      async (...args) => this.#get(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:getMetadata',\n      (...args) => this.#getMetadata(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:resolveVersion',\n      async (...args) => this.#resolveVersion(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:update',\n      async () => this.#triggerUpdate(),\n    );\n  }\n\n  #wasRecentlyFetched() {\n    return (\n      this.state.lastUpdated &&\n      Date.now() - this.state.lastUpdated < this.#recentFetchThreshold\n    );\n  }\n\n  /**\n   * Triggers an update of the registry database.\n   *\n   * If an existing update is in progress this function will await that update.\n   */\n  async #triggerUpdate() {\n    // If an update is ongoing, wait for that.\n    if (this.#currentUpdate) {\n      await this.#currentUpdate;\n      return;\n    }\n    // If no update exists, create promise and store globally.\n    if (this.#currentUpdate === null) {\n      this.#currentUpdate = this.#update();\n    }\n    await this.#currentUpdate;\n    this.#currentUpdate = null;\n  }\n\n  /**\n   * Updates the registry database if the registry hasn't been updated recently.\n   *\n   * NOTE: SHOULD NOT be called directly, instead `triggerUpdate` should be used.\n   */\n  async #update() {\n    // No-op if we recently fetched the registry.\n    if (this.#wasRecentlyFetched()) {\n      return;\n    }\n\n    try {\n      const [database, signature] = await Promise.all([\n        this.#safeFetch(this.#url.registry),\n        this.#safeFetch(this.#url.signature),\n      ]);\n\n      this.#verifySignature(database, signature);\n\n      this.update((state) => {\n        state.database = JSON.parse(database);\n        state.lastUpdated = Date.now();\n        state.databaseUnavailable = false;\n      });\n    } catch {\n      // Ignore\n      this.update((state) => {\n        state.databaseUnavailable = true;\n      });\n    }\n  }\n\n  async #getDatabase(): Promise<SnapsRegistryDatabase | null> {\n    if (this.state.database === null) {\n      await this.#triggerUpdate();\n    }\n\n    return this.state.database;\n  }\n\n  async #getSingle(\n    snapId: string,\n    snapInfo: SnapsRegistryInfo,\n    refetch = false,\n  ): Promise<SnapsRegistryResult> {\n    const database = await this.#getDatabase();\n\n    const blockedEntry = database?.blockedSnaps.find((blocked) => {\n      if ('id' in blocked) {\n        return (\n          blocked.id === snapId &&\n          satisfiesVersionRange(snapInfo.version, blocked.versionRange)\n        );\n      }\n\n      return blocked.checksum === snapInfo.checksum;\n    });\n\n    if (blockedEntry) {\n      return {\n        status: SnapsRegistryStatus.Blocked,\n        reason: blockedEntry.reason,\n      };\n    }\n\n    const verified = database?.verifiedSnaps[snapId];\n    const version = verified?.versions?.[snapInfo.version];\n    if (version && version.checksum === snapInfo.checksum) {\n      return { status: SnapsRegistryStatus.Verified };\n    }\n    // For now, if we have an allowlist miss, we can refetch once and try again.\n    if (this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#getSingle(snapId, snapInfo, true);\n    }\n    return {\n      status: this.state.databaseUnavailable\n        ? SnapsRegistryStatus.Unavailable\n        : SnapsRegistryStatus.Unverified,\n    };\n  }\n\n  async #get(\n    snaps: SnapsRegistryRequest,\n  ): Promise<Record<string, SnapsRegistryResult>> {\n    return Object.entries(snaps).reduce<\n      Promise<Record<string, SnapsRegistryResult>>\n    >(async (previousPromise, [snapId, snapInfo]) => {\n      const result = await this.#getSingle(snapId, snapInfo);\n      const acc = await previousPromise;\n      acc[snapId] = result;\n      return acc;\n    }, Promise.resolve({}));\n  }\n\n  /**\n   * Find an allowlisted version within a specified version range. Otherwise return the version range itself.\n   *\n   * @param snapId - The ID of the snap we are trying to resolve a version for.\n   * @param versionRange - The version range.\n   * @param refetch - An optional flag used to determine if we are refetching the registry.\n   * @returns An allowlisted version within the specified version range if available otherwise returns the input version range.\n   */\n  async #resolveVersion(\n    snapId: string,\n    versionRange: SemVerRange,\n    refetch = false,\n  ): Promise<SemVerRange> {\n    const database = await this.#getDatabase();\n    const versions = database?.verifiedSnaps[snapId]?.versions ?? null;\n\n    if (!versions && this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#resolveVersion(snapId, versionRange, true);\n    }\n\n    // If we cannot narrow down the version range we return the unaltered version range.\n    if (!versions) {\n      return versionRange;\n    }\n\n    const targetVersion = getTargetVersion(\n      Object.keys(versions) as SemVerVersion[],\n      versionRange,\n    );\n\n    if (!targetVersion && this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#resolveVersion(snapId, versionRange, true);\n    }\n\n    // If we cannot narrow down the version range we return the unaltered version range.\n    if (!targetVersion) {\n      return versionRange;\n    }\n\n    // A semver version is technically also a valid semver range.\n    assertIsSemVerRange(targetVersion);\n    return targetVersion;\n  }\n\n  /**\n   * Get metadata for the given snap ID, if available, without updating registry.\n   *\n   * @param snapId - The ID of the snap to get metadata for.\n   * @returns The metadata for the given snap ID, or `null` if the snap is not\n   * verified.\n   */\n  #getMetadata(snapId: string): SnapsRegistryMetadata | null {\n    return this.state?.database?.verifiedSnaps[snapId]?.metadata ?? null;\n  }\n\n  /**\n   * Verify the signature of the registry.\n   *\n   * @param database - The registry database.\n   * @param signature - The signature of the registry.\n   * @throws If the signature is invalid.\n   * @private\n   */\n  #verifySignature(database: string, signature: string) {\n    assert(this.#publicKey, 'No public key provided.');\n\n    const valid = verify({\n      registry: database,\n      signature: JSON.parse(signature),\n      publicKey: this.#publicKey,\n    });\n\n    assert(valid, 'Invalid registry signature.');\n  }\n\n  /**\n   * Fetch the given URL, throwing if the response is not OK.\n   *\n   * @param url - The URL to fetch.\n   * @returns The response body.\n   * @private\n   */\n  async #safeFetch(url: string) {\n    const response = await this.#fetchFunction(url);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${url}.`);\n    }\n\n    return await response.text();\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"json.cjs","sourceRoot":"","sources":["../../../src/snaps/registry/json.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller/next';\nimport { BaseController } from '@metamask/base-controller/next';\nimport type { Messenger } from '@metamask/messenger';\nimport type { SnapsRegistryDatabase } from '@metamask/snaps-registry';\nimport { verify } from '@metamask/snaps-registry';\nimport { getTargetVersion } from '@metamask/snaps-utils';\nimport type { Hex, SemVerRange, SemVerVersion } from '@metamask/utils';\nimport {\n  assert,\n  assertIsSemVerRange,\n  Duration,\n  inMilliseconds,\n  satisfiesVersionRange,\n} from '@metamask/utils';\n\nimport type {\n  SnapsRegistry,\n  SnapsRegistryInfo,\n  SnapsRegistryMetadata,\n  SnapsRegistryRequest,\n  SnapsRegistryResult,\n} from './registry';\nimport { SnapsRegistryStatus } from './registry';\n\nconst SNAP_REGISTRY_URL =\n  'https://acl.execution.metamask.io/latest/registry.json';\n\nconst SNAP_REGISTRY_SIGNATURE_URL =\n  'https://acl.execution.metamask.io/latest/signature.json';\n\nconst DEFAULT_PUBLIC_KEY =\n  '0x025b65308f0f0fb8bc7f7ff87bfc296e0330eee5d3c1d1ee4a048b2fd6a86fa0a6';\n\ntype JsonSnapsRegistryUrl = {\n  registry: string;\n  signature: string;\n};\n\nexport type JsonSnapsRegistryArgs = {\n  messenger: SnapsRegistryMessenger;\n  state?: SnapsRegistryState;\n  fetchFunction?: typeof fetch;\n  url?: JsonSnapsRegistryUrl;\n  recentFetchThreshold?: number;\n  refetchOnAllowlistMiss?: boolean;\n  publicKey?: Hex;\n};\n\nexport type GetResult = {\n  type: `${typeof controllerName}:get`;\n  handler: SnapsRegistry['get'];\n};\n\nexport type ResolveVersion = {\n  type: `${typeof controllerName}:resolveVersion`;\n  handler: SnapsRegistry['resolveVersion'];\n};\n\nexport type GetMetadata = {\n  type: `${typeof controllerName}:getMetadata`;\n  handler: SnapsRegistry['getMetadata'];\n};\n\nexport type Update = {\n  type: `${typeof controllerName}:update`;\n  handler: SnapsRegistry['update'];\n};\n\nexport type SnapsRegistryGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapsRegistryState\n>;\n\nexport type SnapsRegistryActions =\n  | SnapsRegistryGetStateAction\n  | GetResult\n  | GetMetadata\n  | Update\n  | ResolveVersion;\n\nexport type SnapsRegistryStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  SnapsRegistryState\n>;\n\nexport type SnapsRegistryEvents = SnapsRegistryStateChangeEvent;\n\nexport type SnapsRegistryMessenger = Messenger<\n  'SnapsRegistry',\n  SnapsRegistryActions,\n  SnapsRegistryEvents\n>;\n\nexport type SnapsRegistryState = {\n  database: SnapsRegistryDatabase | null;\n  lastUpdated: number | null;\n  databaseUnavailable: boolean;\n};\n\nconst controllerName = 'SnapsRegistry';\n\nconst defaultState = {\n  database: null,\n  lastUpdated: null,\n  databaseUnavailable: false,\n};\n\nexport class JsonSnapsRegistry extends BaseController<\n  typeof controllerName,\n  SnapsRegistryState,\n  SnapsRegistryMessenger\n> {\n  readonly #url: JsonSnapsRegistryUrl;\n\n  readonly #publicKey: Hex;\n\n  readonly #fetchFunction: typeof fetch;\n\n  readonly #recentFetchThreshold: number;\n\n  readonly #refetchOnAllowlistMiss: boolean;\n\n  #currentUpdate: Promise<void> | null;\n\n  constructor({\n    messenger,\n    state,\n    url = {\n      registry: SNAP_REGISTRY_URL,\n      signature: SNAP_REGISTRY_SIGNATURE_URL,\n    },\n    publicKey = DEFAULT_PUBLIC_KEY,\n    fetchFunction = globalThis.fetch.bind(undefined),\n    recentFetchThreshold = inMilliseconds(5, Duration.Minute),\n    refetchOnAllowlistMiss = true,\n  }: JsonSnapsRegistryArgs) {\n    super({\n      messenger,\n      metadata: {\n        database: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n        lastUpdated: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: true,\n          usedInUi: false,\n        },\n        databaseUnavailable: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: true,\n          usedInUi: false,\n        },\n      },\n      name: controllerName,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n    this.#url = url;\n    this.#publicKey = publicKey;\n    this.#fetchFunction = fetchFunction;\n    this.#recentFetchThreshold = recentFetchThreshold;\n    this.#refetchOnAllowlistMiss = refetchOnAllowlistMiss;\n    this.#currentUpdate = null;\n\n    this.messenger.registerActionHandler('SnapsRegistry:get', async (...args) =>\n      this.#get(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      'SnapsRegistry:getMetadata',\n      (...args) => this.#getMetadata(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      'SnapsRegistry:resolveVersion',\n      async (...args) => this.#resolveVersion(...args),\n    );\n\n    this.messenger.registerActionHandler('SnapsRegistry:update', async () =>\n      this.#triggerUpdate(),\n    );\n  }\n\n  #wasRecentlyFetched() {\n    return (\n      this.state.lastUpdated &&\n      Date.now() - this.state.lastUpdated < this.#recentFetchThreshold\n    );\n  }\n\n  /**\n   * Triggers an update of the registry database.\n   *\n   * If an existing update is in progress this function will await that update.\n   */\n  async #triggerUpdate() {\n    // If an update is ongoing, wait for that.\n    if (this.#currentUpdate) {\n      await this.#currentUpdate;\n      return;\n    }\n    // If no update exists, create promise and store globally.\n    if (this.#currentUpdate === null) {\n      this.#currentUpdate = this.#update();\n    }\n    await this.#currentUpdate;\n    this.#currentUpdate = null;\n  }\n\n  /**\n   * Updates the registry database if the registry hasn't been updated recently.\n   *\n   * NOTE: SHOULD NOT be called directly, instead `triggerUpdate` should be used.\n   */\n  async #update() {\n    // No-op if we recently fetched the registry.\n    if (this.#wasRecentlyFetched()) {\n      return;\n    }\n\n    try {\n      const [database, signature] = await Promise.all([\n        this.#safeFetch(this.#url.registry),\n        this.#safeFetch(this.#url.signature),\n      ]);\n\n      this.#verifySignature(database, signature);\n\n      this.update((state) => {\n        state.database = JSON.parse(database);\n        state.lastUpdated = Date.now();\n        state.databaseUnavailable = false;\n      });\n    } catch {\n      // Ignore\n      this.update((state) => {\n        state.databaseUnavailable = true;\n      });\n    }\n  }\n\n  async #getDatabase(): Promise<SnapsRegistryDatabase | null> {\n    if (this.state.database === null) {\n      await this.#triggerUpdate();\n    }\n\n    return this.state.database;\n  }\n\n  async #getSingle(\n    snapId: string,\n    snapInfo: SnapsRegistryInfo,\n    refetch = false,\n  ): Promise<SnapsRegistryResult> {\n    const database = await this.#getDatabase();\n\n    const blockedEntry = database?.blockedSnaps.find((blocked) => {\n      if ('id' in blocked) {\n        return (\n          blocked.id === snapId &&\n          satisfiesVersionRange(snapInfo.version, blocked.versionRange)\n        );\n      }\n\n      return blocked.checksum === snapInfo.checksum;\n    });\n\n    if (blockedEntry) {\n      return {\n        status: SnapsRegistryStatus.Blocked,\n        reason: blockedEntry.reason,\n      };\n    }\n\n    const verified = database?.verifiedSnaps[snapId];\n    const version = verified?.versions?.[snapInfo.version];\n    if (version && version.checksum === snapInfo.checksum) {\n      return { status: SnapsRegistryStatus.Verified };\n    }\n    // For now, if we have an allowlist miss, we can refetch once and try again.\n    if (this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#getSingle(snapId, snapInfo, true);\n    }\n    return {\n      status: this.state.databaseUnavailable\n        ? SnapsRegistryStatus.Unavailable\n        : SnapsRegistryStatus.Unverified,\n    };\n  }\n\n  async #get(\n    snaps: SnapsRegistryRequest,\n  ): Promise<Record<string, SnapsRegistryResult>> {\n    return Object.entries(snaps).reduce<\n      Promise<Record<string, SnapsRegistryResult>>\n    >(async (previousPromise, [snapId, snapInfo]) => {\n      const result = await this.#getSingle(snapId, snapInfo);\n      const acc = await previousPromise;\n      acc[snapId] = result;\n      return acc;\n    }, Promise.resolve({}));\n  }\n\n  /**\n   * Find an allowlisted version within a specified version range. Otherwise return the version range itself.\n   *\n   * @param snapId - The ID of the snap we are trying to resolve a version for.\n   * @param versionRange - The version range.\n   * @param refetch - An optional flag used to determine if we are refetching the registry.\n   * @returns An allowlisted version within the specified version range if available otherwise returns the input version range.\n   */\n  async #resolveVersion(\n    snapId: string,\n    versionRange: SemVerRange,\n    refetch = false,\n  ): Promise<SemVerRange> {\n    const database = await this.#getDatabase();\n    const versions = database?.verifiedSnaps[snapId]?.versions ?? null;\n\n    if (!versions && this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#resolveVersion(snapId, versionRange, true);\n    }\n\n    // If we cannot narrow down the version range we return the unaltered version range.\n    if (!versions) {\n      return versionRange;\n    }\n\n    const targetVersion = getTargetVersion(\n      Object.keys(versions) as SemVerVersion[],\n      versionRange,\n    );\n\n    if (!targetVersion && this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#resolveVersion(snapId, versionRange, true);\n    }\n\n    // If we cannot narrow down the version range we return the unaltered version range.\n    if (!targetVersion) {\n      return versionRange;\n    }\n\n    // A semver version is technically also a valid semver range.\n    assertIsSemVerRange(targetVersion);\n    return targetVersion;\n  }\n\n  /**\n   * Get metadata for the given snap ID, if available, without updating registry.\n   *\n   * @param snapId - The ID of the snap to get metadata for.\n   * @returns The metadata for the given snap ID, or `null` if the snap is not\n   * verified.\n   */\n  #getMetadata(snapId: string): SnapsRegistryMetadata | null {\n    return this.state?.database?.verifiedSnaps[snapId]?.metadata ?? null;\n  }\n\n  /**\n   * Verify the signature of the registry.\n   *\n   * @param database - The registry database.\n   * @param signature - The signature of the registry.\n   * @throws If the signature is invalid.\n   * @private\n   */\n  #verifySignature(database: string, signature: string) {\n    assert(this.#publicKey, 'No public key provided.');\n\n    const valid = verify({\n      registry: database,\n      signature: JSON.parse(signature),\n      publicKey: this.#publicKey,\n    });\n\n    assert(valid, 'Invalid registry signature.');\n  }\n\n  /**\n   * Fetch the given URL, throwing if the response is not OK.\n   *\n   * @param url - The URL to fetch.\n   * @returns The response body.\n   * @private\n   */\n  async #safeFetch(url: string) {\n    const response = await this.#fetchFunction(url);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${url}.`);\n    }\n\n    return await response.text();\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/snaps/registry/json.d.cts b/dist/snaps/registry/json.d.cts
index 1c454eed31f7d48ce7a079cd41b81cb9dcdde551..62c2bc04d2f88aafaff22928fdb8bd380c894d1a 100644
--- a/dist/snaps/registry/json.d.cts
+++ b/dist/snaps/registry/json.d.cts
@@ -1,5 +1,6 @@
-import type { ControllerGetStateAction, ControllerStateChangeEvent, RestrictedMessenger } from "@metamask/base-controller";
-import { BaseController } from "@metamask/base-controller";
+import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller/next";
+import { BaseController } from "@metamask/base-controller/next";
+import type { Messenger } from "@metamask/messenger";
 import type { SnapsRegistryDatabase } from "@metamask/snaps-registry";
 import type { Hex } from "@metamask/utils";
 import type { SnapsRegistry } from "./registry.cjs";
@@ -36,7 +37,7 @@ export type SnapsRegistryGetStateAction = ControllerGetStateAction<typeof contro
 export type SnapsRegistryActions = SnapsRegistryGetStateAction | GetResult | GetMetadata | Update | ResolveVersion;
 export type SnapsRegistryStateChangeEvent = ControllerStateChangeEvent<typeof controllerName, SnapsRegistryState>;
 export type SnapsRegistryEvents = SnapsRegistryStateChangeEvent;
-export type SnapsRegistryMessenger = RestrictedMessenger<'SnapsRegistry', SnapsRegistryActions, SnapsRegistryEvents, SnapsRegistryActions['type'], SnapsRegistryEvents['type']>;
+export type SnapsRegistryMessenger = Messenger<'SnapsRegistry', SnapsRegistryActions, SnapsRegistryEvents>;
 export type SnapsRegistryState = {
     database: SnapsRegistryDatabase | null;
     lastUpdated: number | null;
diff --git a/dist/snaps/registry/json.d.cts.map b/dist/snaps/registry/json.d.cts.map
index 796e4970a9f5f745c040abbb277bc37425b77bbe..fc1c622b003302b69d4c6f71953354723ddd34ea 100644
--- a/dist/snaps/registry/json.d.cts.map
+++ b/dist/snaps/registry/json.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"json.d.cts","sourceRoot":"","sources":["../../../src/snaps/registry/json.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAC1B,mBAAmB,EACpB,kCAAkC;AACnC,OAAO,EAAE,cAAc,EAAE,kCAAkC;AAC3D,OAAO,KAAK,EAAE,qBAAqB,EAAE,iCAAiC;AAGtE,OAAO,KAAK,EAAE,GAAG,EAA8B,wBAAwB;AASvE,OAAO,KAAK,EACV,aAAa,EAKd,uBAAmB;AAYpB,KAAK,oBAAoB,GAAG;IAC1B,QAAQ,EAAE,MAAM,CAAC;IACjB,SAAS,EAAE,MAAM,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,qBAAqB,GAAG;IAClC,SAAS,EAAE,sBAAsB,CAAC;IAClC,KAAK,CAAC,EAAE,kBAAkB,CAAC;IAC3B,aAAa,CAAC,EAAE,OAAO,KAAK,CAAC;IAC7B,GAAG,CAAC,EAAE,oBAAoB,CAAC;IAC3B,oBAAoB,CAAC,EAAE,MAAM,CAAC;IAC9B,sBAAsB,CAAC,EAAE,OAAO,CAAC;IACjC,SAAS,CAAC,EAAE,GAAG,CAAC;CACjB,CAAC;AAEF,MAAM,MAAM,SAAS,GAAG;IACtB,IAAI,EAAE,GAAG,OAAO,cAAc,MAAM,CAAC;IACrC,OAAO,EAAE,aAAa,CAAC,KAAK,CAAC,CAAC;CAC/B,CAAC;AAEF,MAAM,MAAM,cAAc,GAAG;IAC3B,IAAI,EAAE,GAAG,OAAO,cAAc,iBAAiB,CAAC;IAChD,OAAO,EAAE,aAAa,CAAC,gBAAgB,CAAC,CAAC;CAC1C,CAAC;AAEF,MAAM,MAAM,WAAW,GAAG;IACxB,IAAI,EAAE,GAAG,OAAO,cAAc,cAAc,CAAC;IAC7C,OAAO,EAAE,aAAa,CAAC,aAAa,CAAC,CAAC;CACvC,CAAC;AAEF,MAAM,MAAM,MAAM,GAAG;IACnB,IAAI,EAAE,GAAG,OAAO,cAAc,SAAS,CAAC;IACxC,OAAO,EAAE,aAAa,CAAC,QAAQ,CAAC,CAAC;CAClC,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG,wBAAwB,CAChE,OAAO,cAAc,EACrB,kBAAkB,CACnB,CAAC;AAEF,MAAM,MAAM,oBAAoB,GAC5B,2BAA2B,GAC3B,SAAS,GACT,WAAW,GACX,MAAM,GACN,cAAc,CAAC;AAEnB,MAAM,MAAM,6BAA6B,GAAG,0BAA0B,CACpE,OAAO,cAAc,EACrB,kBAAkB,CACnB,CAAC;AAEF,MAAM,MAAM,mBAAmB,GAAG,6BAA6B,CAAC;AAEhE,MAAM,MAAM,sBAAsB,GAAG,mBAAmB,CACtD,eAAe,EACf,oBAAoB,EACpB,mBAAmB,EACnB,oBAAoB,CAAC,MAAM,CAAC,EAC5B,mBAAmB,CAAC,MAAM,CAAC,CAC5B,CAAC;AAEF,MAAM,MAAM,kBAAkB,GAAG;IAC/B,QAAQ,EAAE,qBAAqB,GAAG,IAAI,CAAC;IACvC,WAAW,EAAE,MAAM,GAAG,IAAI,CAAC;IAC3B,mBAAmB,EAAE,OAAO,CAAC;CAC9B,CAAC;AAEF,QAAA,MAAM,cAAc,kBAAkB,CAAC;AAQvC,qBAAa,iBAAkB,SAAQ,cAAc,CACnD,OAAO,cAAc,EACrB,kBAAkB,EAClB,sBAAsB,CACvB;;gBAaa,EACV,SAAS,EACT,KAAK,EACL,GAGC,EACD,SAA8B,EAC9B,aAAgD,EAChD,oBAAyD,EACzD,sBAA6B,GAC9B,EAAE,qBAAqB;CA8QzB"}
\ No newline at end of file
+{"version":3,"file":"json.d.cts","sourceRoot":"","sources":["../../../src/snaps/registry/json.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAC3B,uCAAuC;AACxC,OAAO,EAAE,cAAc,EAAE,uCAAuC;AAChE,OAAO,KAAK,EAAE,SAAS,EAAE,4BAA4B;AACrD,OAAO,KAAK,EAAE,qBAAqB,EAAE,iCAAiC;AAGtE,OAAO,KAAK,EAAE,GAAG,EAA8B,wBAAwB;AASvE,OAAO,KAAK,EACV,aAAa,EAKd,uBAAmB;AAYpB,KAAK,oBAAoB,GAAG;IAC1B,QAAQ,EAAE,MAAM,CAAC;IACjB,SAAS,EAAE,MAAM,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,qBAAqB,GAAG;IAClC,SAAS,EAAE,sBAAsB,CAAC;IAClC,KAAK,CAAC,EAAE,kBAAkB,CAAC;IAC3B,aAAa,CAAC,EAAE,OAAO,KAAK,CAAC;IAC7B,GAAG,CAAC,EAAE,oBAAoB,CAAC;IAC3B,oBAAoB,CAAC,EAAE,MAAM,CAAC;IAC9B,sBAAsB,CAAC,EAAE,OAAO,CAAC;IACjC,SAAS,CAAC,EAAE,GAAG,CAAC;CACjB,CAAC;AAEF,MAAM,MAAM,SAAS,GAAG;IACtB,IAAI,EAAE,GAAG,OAAO,cAAc,MAAM,CAAC;IACrC,OAAO,EAAE,aAAa,CAAC,KAAK,CAAC,CAAC;CAC/B,CAAC;AAEF,MAAM,MAAM,cAAc,GAAG;IAC3B,IAAI,EAAE,GAAG,OAAO,cAAc,iBAAiB,CAAC;IAChD,OAAO,EAAE,aAAa,CAAC,gBAAgB,CAAC,CAAC;CAC1C,CAAC;AAEF,MAAM,MAAM,WAAW,GAAG;IACxB,IAAI,EAAE,GAAG,OAAO,cAAc,cAAc,CAAC;IAC7C,OAAO,EAAE,aAAa,CAAC,aAAa,CAAC,CAAC;CACvC,CAAC;AAEF,MAAM,MAAM,MAAM,GAAG;IACnB,IAAI,EAAE,GAAG,OAAO,cAAc,SAAS,CAAC;IACxC,OAAO,EAAE,aAAa,CAAC,QAAQ,CAAC,CAAC;CAClC,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG,wBAAwB,CAChE,OAAO,cAAc,EACrB,kBAAkB,CACnB,CAAC;AAEF,MAAM,MAAM,oBAAoB,GAC5B,2BAA2B,GAC3B,SAAS,GACT,WAAW,GACX,MAAM,GACN,cAAc,CAAC;AAEnB,MAAM,MAAM,6BAA6B,GAAG,0BAA0B,CACpE,OAAO,cAAc,EACrB,kBAAkB,CACnB,CAAC;AAEF,MAAM,MAAM,mBAAmB,GAAG,6BAA6B,CAAC;AAEhE,MAAM,MAAM,sBAAsB,GAAG,SAAS,CAC5C,eAAe,EACf,oBAAoB,EACpB,mBAAmB,CACpB,CAAC;AAEF,MAAM,MAAM,kBAAkB,GAAG;IAC/B,QAAQ,EAAE,qBAAqB,GAAG,IAAI,CAAC;IACvC,WAAW,EAAE,MAAM,GAAG,IAAI,CAAC;IAC3B,mBAAmB,EAAE,OAAO,CAAC;CAC9B,CAAC;AAEF,QAAA,MAAM,cAAc,kBAAkB,CAAC;AAQvC,qBAAa,iBAAkB,SAAQ,cAAc,CACnD,OAAO,cAAc,EACrB,kBAAkB,EAClB,sBAAsB,CACvB;;gBAaa,EACV,SAAS,EACT,KAAK,EACL,GAGC,EACD,SAA8B,EAC9B,aAAgD,EAChD,oBAAyD,EACzD,sBAA6B,GAC9B,EAAE,qBAAqB;CA4QzB"}
\ No newline at end of file
diff --git a/dist/snaps/registry/json.d.mts b/dist/snaps/registry/json.d.mts
index 5f93fbe4d283677f18b984515a5107c17e74f373..80f6d7220269fe1fdfd38a783e6bcd04c1f2b4fe 100644
--- a/dist/snaps/registry/json.d.mts
+++ b/dist/snaps/registry/json.d.mts
@@ -1,5 +1,6 @@
-import type { ControllerGetStateAction, ControllerStateChangeEvent, RestrictedMessenger } from "@metamask/base-controller";
-import { BaseController } from "@metamask/base-controller";
+import type { ControllerGetStateAction, ControllerStateChangeEvent } from "@metamask/base-controller/next";
+import { BaseController } from "@metamask/base-controller/next";
+import type { Messenger } from "@metamask/messenger";
 import type { SnapsRegistryDatabase } from "@metamask/snaps-registry";
 import type { Hex } from "@metamask/utils";
 import type { SnapsRegistry } from "./registry.mjs";
@@ -36,7 +37,7 @@ export type SnapsRegistryGetStateAction = ControllerGetStateAction<typeof contro
 export type SnapsRegistryActions = SnapsRegistryGetStateAction | GetResult | GetMetadata | Update | ResolveVersion;
 export type SnapsRegistryStateChangeEvent = ControllerStateChangeEvent<typeof controllerName, SnapsRegistryState>;
 export type SnapsRegistryEvents = SnapsRegistryStateChangeEvent;
-export type SnapsRegistryMessenger = RestrictedMessenger<'SnapsRegistry', SnapsRegistryActions, SnapsRegistryEvents, SnapsRegistryActions['type'], SnapsRegistryEvents['type']>;
+export type SnapsRegistryMessenger = Messenger<'SnapsRegistry', SnapsRegistryActions, SnapsRegistryEvents>;
 export type SnapsRegistryState = {
     database: SnapsRegistryDatabase | null;
     lastUpdated: number | null;
diff --git a/dist/snaps/registry/json.d.mts.map b/dist/snaps/registry/json.d.mts.map
index 13a0131456f0df7e5e96f360fe832fd438c97d82..4356c222e28826171ebbd4d614f57a97dc235c7c 100644
--- a/dist/snaps/registry/json.d.mts.map
+++ b/dist/snaps/registry/json.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"json.d.mts","sourceRoot":"","sources":["../../../src/snaps/registry/json.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAC1B,mBAAmB,EACpB,kCAAkC;AACnC,OAAO,EAAE,cAAc,EAAE,kCAAkC;AAC3D,OAAO,KAAK,EAAE,qBAAqB,EAAE,iCAAiC;AAGtE,OAAO,KAAK,EAAE,GAAG,EAA8B,wBAAwB;AASvE,OAAO,KAAK,EACV,aAAa,EAKd,uBAAmB;AAYpB,KAAK,oBAAoB,GAAG;IAC1B,QAAQ,EAAE,MAAM,CAAC;IACjB,SAAS,EAAE,MAAM,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,qBAAqB,GAAG;IAClC,SAAS,EAAE,sBAAsB,CAAC;IAClC,KAAK,CAAC,EAAE,kBAAkB,CAAC;IAC3B,aAAa,CAAC,EAAE,OAAO,KAAK,CAAC;IAC7B,GAAG,CAAC,EAAE,oBAAoB,CAAC;IAC3B,oBAAoB,CAAC,EAAE,MAAM,CAAC;IAC9B,sBAAsB,CAAC,EAAE,OAAO,CAAC;IACjC,SAAS,CAAC,EAAE,GAAG,CAAC;CACjB,CAAC;AAEF,MAAM,MAAM,SAAS,GAAG;IACtB,IAAI,EAAE,GAAG,OAAO,cAAc,MAAM,CAAC;IACrC,OAAO,EAAE,aAAa,CAAC,KAAK,CAAC,CAAC;CAC/B,CAAC;AAEF,MAAM,MAAM,cAAc,GAAG;IAC3B,IAAI,EAAE,GAAG,OAAO,cAAc,iBAAiB,CAAC;IAChD,OAAO,EAAE,aAAa,CAAC,gBAAgB,CAAC,CAAC;CAC1C,CAAC;AAEF,MAAM,MAAM,WAAW,GAAG;IACxB,IAAI,EAAE,GAAG,OAAO,cAAc,cAAc,CAAC;IAC7C,OAAO,EAAE,aAAa,CAAC,aAAa,CAAC,CAAC;CACvC,CAAC;AAEF,MAAM,MAAM,MAAM,GAAG;IACnB,IAAI,EAAE,GAAG,OAAO,cAAc,SAAS,CAAC;IACxC,OAAO,EAAE,aAAa,CAAC,QAAQ,CAAC,CAAC;CAClC,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG,wBAAwB,CAChE,OAAO,cAAc,EACrB,kBAAkB,CACnB,CAAC;AAEF,MAAM,MAAM,oBAAoB,GAC5B,2BAA2B,GAC3B,SAAS,GACT,WAAW,GACX,MAAM,GACN,cAAc,CAAC;AAEnB,MAAM,MAAM,6BAA6B,GAAG,0BAA0B,CACpE,OAAO,cAAc,EACrB,kBAAkB,CACnB,CAAC;AAEF,MAAM,MAAM,mBAAmB,GAAG,6BAA6B,CAAC;AAEhE,MAAM,MAAM,sBAAsB,GAAG,mBAAmB,CACtD,eAAe,EACf,oBAAoB,EACpB,mBAAmB,EACnB,oBAAoB,CAAC,MAAM,CAAC,EAC5B,mBAAmB,CAAC,MAAM,CAAC,CAC5B,CAAC;AAEF,MAAM,MAAM,kBAAkB,GAAG;IAC/B,QAAQ,EAAE,qBAAqB,GAAG,IAAI,CAAC;IACvC,WAAW,EAAE,MAAM,GAAG,IAAI,CAAC;IAC3B,mBAAmB,EAAE,OAAO,CAAC;CAC9B,CAAC;AAEF,QAAA,MAAM,cAAc,kBAAkB,CAAC;AAQvC,qBAAa,iBAAkB,SAAQ,cAAc,CACnD,OAAO,cAAc,EACrB,kBAAkB,EAClB,sBAAsB,CACvB;;gBAaa,EACV,SAAS,EACT,KAAK,EACL,GAGC,EACD,SAA8B,EAC9B,aAAgD,EAChD,oBAAyD,EACzD,sBAA6B,GAC9B,EAAE,qBAAqB;CA8QzB"}
\ No newline at end of file
+{"version":3,"file":"json.d.mts","sourceRoot":"","sources":["../../../src/snaps/registry/json.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,wBAAwB,EACxB,0BAA0B,EAC3B,uCAAuC;AACxC,OAAO,EAAE,cAAc,EAAE,uCAAuC;AAChE,OAAO,KAAK,EAAE,SAAS,EAAE,4BAA4B;AACrD,OAAO,KAAK,EAAE,qBAAqB,EAAE,iCAAiC;AAGtE,OAAO,KAAK,EAAE,GAAG,EAA8B,wBAAwB;AASvE,OAAO,KAAK,EACV,aAAa,EAKd,uBAAmB;AAYpB,KAAK,oBAAoB,GAAG;IAC1B,QAAQ,EAAE,MAAM,CAAC;IACjB,SAAS,EAAE,MAAM,CAAC;CACnB,CAAC;AAEF,MAAM,MAAM,qBAAqB,GAAG;IAClC,SAAS,EAAE,sBAAsB,CAAC;IAClC,KAAK,CAAC,EAAE,kBAAkB,CAAC;IAC3B,aAAa,CAAC,EAAE,OAAO,KAAK,CAAC;IAC7B,GAAG,CAAC,EAAE,oBAAoB,CAAC;IAC3B,oBAAoB,CAAC,EAAE,MAAM,CAAC;IAC9B,sBAAsB,CAAC,EAAE,OAAO,CAAC;IACjC,SAAS,CAAC,EAAE,GAAG,CAAC;CACjB,CAAC;AAEF,MAAM,MAAM,SAAS,GAAG;IACtB,IAAI,EAAE,GAAG,OAAO,cAAc,MAAM,CAAC;IACrC,OAAO,EAAE,aAAa,CAAC,KAAK,CAAC,CAAC;CAC/B,CAAC;AAEF,MAAM,MAAM,cAAc,GAAG;IAC3B,IAAI,EAAE,GAAG,OAAO,cAAc,iBAAiB,CAAC;IAChD,OAAO,EAAE,aAAa,CAAC,gBAAgB,CAAC,CAAC;CAC1C,CAAC;AAEF,MAAM,MAAM,WAAW,GAAG;IACxB,IAAI,EAAE,GAAG,OAAO,cAAc,cAAc,CAAC;IAC7C,OAAO,EAAE,aAAa,CAAC,aAAa,CAAC,CAAC;CACvC,CAAC;AAEF,MAAM,MAAM,MAAM,GAAG;IACnB,IAAI,EAAE,GAAG,OAAO,cAAc,SAAS,CAAC;IACxC,OAAO,EAAE,aAAa,CAAC,QAAQ,CAAC,CAAC;CAClC,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG,wBAAwB,CAChE,OAAO,cAAc,EACrB,kBAAkB,CACnB,CAAC;AAEF,MAAM,MAAM,oBAAoB,GAC5B,2BAA2B,GAC3B,SAAS,GACT,WAAW,GACX,MAAM,GACN,cAAc,CAAC;AAEnB,MAAM,MAAM,6BAA6B,GAAG,0BAA0B,CACpE,OAAO,cAAc,EACrB,kBAAkB,CACnB,CAAC;AAEF,MAAM,MAAM,mBAAmB,GAAG,6BAA6B,CAAC;AAEhE,MAAM,MAAM,sBAAsB,GAAG,SAAS,CAC5C,eAAe,EACf,oBAAoB,EACpB,mBAAmB,CACpB,CAAC;AAEF,MAAM,MAAM,kBAAkB,GAAG;IAC/B,QAAQ,EAAE,qBAAqB,GAAG,IAAI,CAAC;IACvC,WAAW,EAAE,MAAM,GAAG,IAAI,CAAC;IAC3B,mBAAmB,EAAE,OAAO,CAAC;CAC9B,CAAC;AAEF,QAAA,MAAM,cAAc,kBAAkB,CAAC;AAQvC,qBAAa,iBAAkB,SAAQ,cAAc,CACnD,OAAO,cAAc,EACrB,kBAAkB,EAClB,sBAAsB,CACvB;;gBAaa,EACV,SAAS,EACT,KAAK,EACL,GAGC,EACD,SAA8B,EAC9B,aAAgD,EAChD,oBAAyD,EACzD,sBAA6B,GAC9B,EAAE,qBAAqB;CA4QzB"}
\ No newline at end of file
diff --git a/dist/snaps/registry/json.mjs b/dist/snaps/registry/json.mjs
index b9a58208de86919eab1779cd7478143586d31459..f94e24ac6c4aba0befd616eaded1ad9ce981811c 100644
--- a/dist/snaps/registry/json.mjs
+++ b/dist/snaps/registry/json.mjs
@@ -1,4 +1,4 @@
-import { BaseController } from "@metamask/base-controller";
+import { BaseController } from "@metamask/base-controller/next";
 import { verify } from "@metamask/snaps-registry";
 import { getTargetVersion } from "@metamask/snaps-utils";
 import { assert, assertIsSemVerRange, Duration, inMilliseconds, satisfiesVersionRange } from "@metamask/utils";
@@ -29,19 +29,19 @@ export class JsonSnapsRegistry extends BaseController {
                 database: {
                     includeInStateLogs: true,
                     persist: true,
-                    anonymous: false,
+                    includeInDebugSnapshot: false,
                     usedInUi: true,
                 },
                 lastUpdated: {
                     includeInStateLogs: true,
                     persist: true,
-                    anonymous: false,
+                    includeInDebugSnapshot: true,
                     usedInUi: false,
                 },
                 databaseUnavailable: {
                     includeInStateLogs: true,
                     persist: true,
-                    anonymous: false,
+                    includeInDebugSnapshot: true,
                     usedInUi: false,
                 },
             },
@@ -57,10 +57,10 @@ export class JsonSnapsRegistry extends BaseController {
         this.#recentFetchThreshold = recentFetchThreshold;
         this.#refetchOnAllowlistMiss = refetchOnAllowlistMiss;
         this.#currentUpdate = null;
-        this.messagingSystem.registerActionHandler('SnapsRegistry:get', async (...args) => this.#get(...args));
-        this.messagingSystem.registerActionHandler('SnapsRegistry:getMetadata', (...args) => this.#getMetadata(...args));
-        this.messagingSystem.registerActionHandler('SnapsRegistry:resolveVersion', async (...args) => this.#resolveVersion(...args));
-        this.messagingSystem.registerActionHandler('SnapsRegistry:update', async () => this.#triggerUpdate());
+        this.messenger.registerActionHandler('SnapsRegistry:get', async (...args) => this.#get(...args));
+        this.messenger.registerActionHandler('SnapsRegistry:getMetadata', (...args) => this.#getMetadata(...args));
+        this.messenger.registerActionHandler('SnapsRegistry:resolveVersion', async (...args) => this.#resolveVersion(...args));
+        this.messenger.registerActionHandler('SnapsRegistry:update', async () => this.#triggerUpdate());
     }
     #wasRecentlyFetched() {
         return (this.state.lastUpdated &&
diff --git a/dist/snaps/registry/json.mjs.map b/dist/snaps/registry/json.mjs.map
index 3c6534a1a7af9099779f5bb4e5635befc32cd3af..97316e917f655450c4e744d5f02bef354cc9e1ae 100644
--- a/dist/snaps/registry/json.mjs.map
+++ b/dist/snaps/registry/json.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"json.mjs","sourceRoot":"","sources":["../../../src/snaps/registry/json.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n  RestrictedMessenger,\n} from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type { SnapsRegistryDatabase } from '@metamask/snaps-registry';\nimport { verify } from '@metamask/snaps-registry';\nimport { getTargetVersion } from '@metamask/snaps-utils';\nimport type { Hex, SemVerRange, SemVerVersion } from '@metamask/utils';\nimport {\n  assert,\n  assertIsSemVerRange,\n  Duration,\n  inMilliseconds,\n  satisfiesVersionRange,\n} from '@metamask/utils';\n\nimport type {\n  SnapsRegistry,\n  SnapsRegistryInfo,\n  SnapsRegistryMetadata,\n  SnapsRegistryRequest,\n  SnapsRegistryResult,\n} from './registry';\nimport { SnapsRegistryStatus } from './registry';\n\nconst SNAP_REGISTRY_URL =\n  'https://acl.execution.metamask.io/latest/registry.json';\n\nconst SNAP_REGISTRY_SIGNATURE_URL =\n  'https://acl.execution.metamask.io/latest/signature.json';\n\nconst DEFAULT_PUBLIC_KEY =\n  '0x025b65308f0f0fb8bc7f7ff87bfc296e0330eee5d3c1d1ee4a048b2fd6a86fa0a6';\n\ntype JsonSnapsRegistryUrl = {\n  registry: string;\n  signature: string;\n};\n\nexport type JsonSnapsRegistryArgs = {\n  messenger: SnapsRegistryMessenger;\n  state?: SnapsRegistryState;\n  fetchFunction?: typeof fetch;\n  url?: JsonSnapsRegistryUrl;\n  recentFetchThreshold?: number;\n  refetchOnAllowlistMiss?: boolean;\n  publicKey?: Hex;\n};\n\nexport type GetResult = {\n  type: `${typeof controllerName}:get`;\n  handler: SnapsRegistry['get'];\n};\n\nexport type ResolveVersion = {\n  type: `${typeof controllerName}:resolveVersion`;\n  handler: SnapsRegistry['resolveVersion'];\n};\n\nexport type GetMetadata = {\n  type: `${typeof controllerName}:getMetadata`;\n  handler: SnapsRegistry['getMetadata'];\n};\n\nexport type Update = {\n  type: `${typeof controllerName}:update`;\n  handler: SnapsRegistry['update'];\n};\n\nexport type SnapsRegistryGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapsRegistryState\n>;\n\nexport type SnapsRegistryActions =\n  | SnapsRegistryGetStateAction\n  | GetResult\n  | GetMetadata\n  | Update\n  | ResolveVersion;\n\nexport type SnapsRegistryStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  SnapsRegistryState\n>;\n\nexport type SnapsRegistryEvents = SnapsRegistryStateChangeEvent;\n\nexport type SnapsRegistryMessenger = RestrictedMessenger<\n  'SnapsRegistry',\n  SnapsRegistryActions,\n  SnapsRegistryEvents,\n  SnapsRegistryActions['type'],\n  SnapsRegistryEvents['type']\n>;\n\nexport type SnapsRegistryState = {\n  database: SnapsRegistryDatabase | null;\n  lastUpdated: number | null;\n  databaseUnavailable: boolean;\n};\n\nconst controllerName = 'SnapsRegistry';\n\nconst defaultState = {\n  database: null,\n  lastUpdated: null,\n  databaseUnavailable: false,\n};\n\nexport class JsonSnapsRegistry extends BaseController<\n  typeof controllerName,\n  SnapsRegistryState,\n  SnapsRegistryMessenger\n> {\n  readonly #url: JsonSnapsRegistryUrl;\n\n  readonly #publicKey: Hex;\n\n  readonly #fetchFunction: typeof fetch;\n\n  readonly #recentFetchThreshold: number;\n\n  readonly #refetchOnAllowlistMiss: boolean;\n\n  #currentUpdate: Promise<void> | null;\n\n  constructor({\n    messenger,\n    state,\n    url = {\n      registry: SNAP_REGISTRY_URL,\n      signature: SNAP_REGISTRY_SIGNATURE_URL,\n    },\n    publicKey = DEFAULT_PUBLIC_KEY,\n    fetchFunction = globalThis.fetch.bind(undefined),\n    recentFetchThreshold = inMilliseconds(5, Duration.Minute),\n    refetchOnAllowlistMiss = true,\n  }: JsonSnapsRegistryArgs) {\n    super({\n      messenger,\n      metadata: {\n        database: {\n          includeInStateLogs: true,\n          persist: true,\n          anonymous: false,\n          usedInUi: true,\n        },\n        lastUpdated: {\n          includeInStateLogs: true,\n          persist: true,\n          anonymous: false,\n          usedInUi: false,\n        },\n        databaseUnavailable: {\n          includeInStateLogs: true,\n          persist: true,\n          anonymous: false,\n          usedInUi: false,\n        },\n      },\n      name: controllerName,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n    this.#url = url;\n    this.#publicKey = publicKey;\n    this.#fetchFunction = fetchFunction;\n    this.#recentFetchThreshold = recentFetchThreshold;\n    this.#refetchOnAllowlistMiss = refetchOnAllowlistMiss;\n    this.#currentUpdate = null;\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:get',\n      async (...args) => this.#get(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:getMetadata',\n      (...args) => this.#getMetadata(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:resolveVersion',\n      async (...args) => this.#resolveVersion(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      'SnapsRegistry:update',\n      async () => this.#triggerUpdate(),\n    );\n  }\n\n  #wasRecentlyFetched() {\n    return (\n      this.state.lastUpdated &&\n      Date.now() - this.state.lastUpdated < this.#recentFetchThreshold\n    );\n  }\n\n  /**\n   * Triggers an update of the registry database.\n   *\n   * If an existing update is in progress this function will await that update.\n   */\n  async #triggerUpdate() {\n    // If an update is ongoing, wait for that.\n    if (this.#currentUpdate) {\n      await this.#currentUpdate;\n      return;\n    }\n    // If no update exists, create promise and store globally.\n    if (this.#currentUpdate === null) {\n      this.#currentUpdate = this.#update();\n    }\n    await this.#currentUpdate;\n    this.#currentUpdate = null;\n  }\n\n  /**\n   * Updates the registry database if the registry hasn't been updated recently.\n   *\n   * NOTE: SHOULD NOT be called directly, instead `triggerUpdate` should be used.\n   */\n  async #update() {\n    // No-op if we recently fetched the registry.\n    if (this.#wasRecentlyFetched()) {\n      return;\n    }\n\n    try {\n      const [database, signature] = await Promise.all([\n        this.#safeFetch(this.#url.registry),\n        this.#safeFetch(this.#url.signature),\n      ]);\n\n      this.#verifySignature(database, signature);\n\n      this.update((state) => {\n        state.database = JSON.parse(database);\n        state.lastUpdated = Date.now();\n        state.databaseUnavailable = false;\n      });\n    } catch {\n      // Ignore\n      this.update((state) => {\n        state.databaseUnavailable = true;\n      });\n    }\n  }\n\n  async #getDatabase(): Promise<SnapsRegistryDatabase | null> {\n    if (this.state.database === null) {\n      await this.#triggerUpdate();\n    }\n\n    return this.state.database;\n  }\n\n  async #getSingle(\n    snapId: string,\n    snapInfo: SnapsRegistryInfo,\n    refetch = false,\n  ): Promise<SnapsRegistryResult> {\n    const database = await this.#getDatabase();\n\n    const blockedEntry = database?.blockedSnaps.find((blocked) => {\n      if ('id' in blocked) {\n        return (\n          blocked.id === snapId &&\n          satisfiesVersionRange(snapInfo.version, blocked.versionRange)\n        );\n      }\n\n      return blocked.checksum === snapInfo.checksum;\n    });\n\n    if (blockedEntry) {\n      return {\n        status: SnapsRegistryStatus.Blocked,\n        reason: blockedEntry.reason,\n      };\n    }\n\n    const verified = database?.verifiedSnaps[snapId];\n    const version = verified?.versions?.[snapInfo.version];\n    if (version && version.checksum === snapInfo.checksum) {\n      return { status: SnapsRegistryStatus.Verified };\n    }\n    // For now, if we have an allowlist miss, we can refetch once and try again.\n    if (this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#getSingle(snapId, snapInfo, true);\n    }\n    return {\n      status: this.state.databaseUnavailable\n        ? SnapsRegistryStatus.Unavailable\n        : SnapsRegistryStatus.Unverified,\n    };\n  }\n\n  async #get(\n    snaps: SnapsRegistryRequest,\n  ): Promise<Record<string, SnapsRegistryResult>> {\n    return Object.entries(snaps).reduce<\n      Promise<Record<string, SnapsRegistryResult>>\n    >(async (previousPromise, [snapId, snapInfo]) => {\n      const result = await this.#getSingle(snapId, snapInfo);\n      const acc = await previousPromise;\n      acc[snapId] = result;\n      return acc;\n    }, Promise.resolve({}));\n  }\n\n  /**\n   * Find an allowlisted version within a specified version range. Otherwise return the version range itself.\n   *\n   * @param snapId - The ID of the snap we are trying to resolve a version for.\n   * @param versionRange - The version range.\n   * @param refetch - An optional flag used to determine if we are refetching the registry.\n   * @returns An allowlisted version within the specified version range if available otherwise returns the input version range.\n   */\n  async #resolveVersion(\n    snapId: string,\n    versionRange: SemVerRange,\n    refetch = false,\n  ): Promise<SemVerRange> {\n    const database = await this.#getDatabase();\n    const versions = database?.verifiedSnaps[snapId]?.versions ?? null;\n\n    if (!versions && this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#resolveVersion(snapId, versionRange, true);\n    }\n\n    // If we cannot narrow down the version range we return the unaltered version range.\n    if (!versions) {\n      return versionRange;\n    }\n\n    const targetVersion = getTargetVersion(\n      Object.keys(versions) as SemVerVersion[],\n      versionRange,\n    );\n\n    if (!targetVersion && this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#resolveVersion(snapId, versionRange, true);\n    }\n\n    // If we cannot narrow down the version range we return the unaltered version range.\n    if (!targetVersion) {\n      return versionRange;\n    }\n\n    // A semver version is technically also a valid semver range.\n    assertIsSemVerRange(targetVersion);\n    return targetVersion;\n  }\n\n  /**\n   * Get metadata for the given snap ID, if available, without updating registry.\n   *\n   * @param snapId - The ID of the snap to get metadata for.\n   * @returns The metadata for the given snap ID, or `null` if the snap is not\n   * verified.\n   */\n  #getMetadata(snapId: string): SnapsRegistryMetadata | null {\n    return this.state?.database?.verifiedSnaps[snapId]?.metadata ?? null;\n  }\n\n  /**\n   * Verify the signature of the registry.\n   *\n   * @param database - The registry database.\n   * @param signature - The signature of the registry.\n   * @throws If the signature is invalid.\n   * @private\n   */\n  #verifySignature(database: string, signature: string) {\n    assert(this.#publicKey, 'No public key provided.');\n\n    const valid = verify({\n      registry: database,\n      signature: JSON.parse(signature),\n      publicKey: this.#publicKey,\n    });\n\n    assert(valid, 'Invalid registry signature.');\n  }\n\n  /**\n   * Fetch the given URL, throwing if the response is not OK.\n   *\n   * @param url - The URL to fetch.\n   * @returns The response body.\n   * @private\n   */\n  async #safeFetch(url: string) {\n    const response = await this.#fetchFunction(url);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${url}.`);\n    }\n\n    return await response.text();\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"json.mjs","sourceRoot":"","sources":["../../../src/snaps/registry/json.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,cAAc,EAAE,uCAAuC;AAGhE,OAAO,EAAE,MAAM,EAAE,iCAAiC;AAClD,OAAO,EAAE,gBAAgB,EAAE,8BAA8B;AAEzD,OAAO,EACL,MAAM,EACN,mBAAmB,EACnB,QAAQ,EACR,cAAc,EACd,qBAAqB,EACtB,wBAAwB;AASzB,OAAO,EAAE,mBAAmB,EAAE,uBAAmB;AAEjD,MAAM,iBAAiB,GACrB,wDAAwD,CAAC;AAE3D,MAAM,2BAA2B,GAC/B,yDAAyD,CAAC;AAE5D,MAAM,kBAAkB,GACtB,sEAAsE,CAAC;AAoEzE,MAAM,cAAc,GAAG,eAAe,CAAC;AAEvC,MAAM,YAAY,GAAG;IACnB,QAAQ,EAAE,IAAI;IACd,WAAW,EAAE,IAAI;IACjB,mBAAmB,EAAE,KAAK;CAC3B,CAAC;AAEF,MAAM,OAAO,iBAAkB,SAAQ,cAItC;IACU,IAAI,CAAuB;IAE3B,UAAU,CAAM;IAEhB,cAAc,CAAe;IAE7B,qBAAqB,CAAS;IAE9B,uBAAuB,CAAU;IAE1C,cAAc,CAAuB;IAErC,YAAY,EACV,SAAS,EACT,KAAK,EACL,GAAG,GAAG;QACJ,QAAQ,EAAE,iBAAiB;QAC3B,SAAS,EAAE,2BAA2B;KACvC,EACD,SAAS,GAAG,kBAAkB,EAC9B,aAAa,GAAG,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,EAChD,oBAAoB,GAAG,cAAc,CAAC,CAAC,EAAE,QAAQ,CAAC,MAAM,CAAC,EACzD,sBAAsB,GAAG,IAAI,GACP;QACtB,KAAK,CAAC;YACJ,SAAS;YACT,QAAQ,EAAE;gBACR,QAAQ,EAAE;oBACR,kBAAkB,EAAE,IAAI;oBACxB,OAAO,EAAE,IAAI;oBACb,sBAAsB,EAAE,KAAK;oBAC7B,QAAQ,EAAE,IAAI;iBACf;gBACD,WAAW,EAAE;oBACX,kBAAkB,EAAE,IAAI;oBACxB,OAAO,EAAE,IAAI;oBACb,sBAAsB,EAAE,IAAI;oBAC5B,QAAQ,EAAE,KAAK;iBAChB;gBACD,mBAAmB,EAAE;oBACnB,kBAAkB,EAAE,IAAI;oBACxB,OAAO,EAAE,IAAI;oBACb,sBAAsB,EAAE,IAAI;oBAC5B,QAAQ,EAAE,KAAK;iBAChB;aACF;YACD,IAAI,EAAE,cAAc;YACpB,KAAK,EAAE;gBACL,GAAG,YAAY;gBACf,GAAG,KAAK;aACT;SACF,CAAC,CAAC;QACH,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;QAChB,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,CAAC,cAAc,GAAG,aAAa,CAAC;QACpC,IAAI,CAAC,qBAAqB,GAAG,oBAAoB,CAAC;QAClD,IAAI,CAAC,uBAAuB,GAAG,sBAAsB,CAAC;QACtD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;QAE3B,IAAI,CAAC,SAAS,CAAC,qBAAqB,CAAC,mBAAmB,EAAE,KAAK,EAAE,GAAG,IAAI,EAAE,EAAE,CAC1E,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,CACnB,CAAC;QAEF,IAAI,CAAC,SAAS,CAAC,qBAAqB,CAClC,2BAA2B,EAC3B,CAAC,GAAG,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,CACxC,CAAC;QAEF,IAAI,CAAC,SAAS,CAAC,qBAAqB,CAClC,8BAA8B,EAC9B,KAAK,EAAE,GAAG,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG,IAAI,CAAC,CACjD,CAAC;QAEF,IAAI,CAAC,SAAS,CAAC,qBAAqB,CAAC,sBAAsB,EAAE,KAAK,IAAI,EAAE,CACtE,IAAI,CAAC,cAAc,EAAE,CACtB,CAAC;IACJ,CAAC;IAED,mBAAmB;QACjB,OAAO,CACL,IAAI,CAAC,KAAK,CAAC,WAAW;YACtB,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC,qBAAqB,CACjE,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,cAAc;QAClB,0CAA0C;QAC1C,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YACxB,MAAM,IAAI,CAAC,cAAc,CAAC;YAC1B,OAAO;QACT,CAAC;QACD,0DAA0D;QAC1D,IAAI,IAAI,CAAC,cAAc,KAAK,IAAI,EAAE,CAAC;YACjC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;QACvC,CAAC;QACD,MAAM,IAAI,CAAC,cAAc,CAAC;QAC1B,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;IAC7B,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,OAAO;QACX,6CAA6C;QAC7C,IAAI,IAAI,CAAC,mBAAmB,EAAE,EAAE,CAAC;YAC/B,OAAO;QACT,CAAC;QAED,IAAI,CAAC;YACH,MAAM,CAAC,QAAQ,EAAE,SAAS,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;gBAC9C,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;gBACnC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC;aACrC,CAAC,CAAC;YAEH,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;YAE3C,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;gBACpB,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;gBACtC,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;gBAC/B,KAAK,CAAC,mBAAmB,GAAG,KAAK,CAAC;YACpC,CAAC,CAAC,CAAC;QACL,CAAC;QAAC,MAAM,CAAC;YACP,SAAS;YACT,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;gBACpB,KAAK,CAAC,mBAAmB,GAAG,IAAI,CAAC;YACnC,CAAC,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAED,KAAK,CAAC,YAAY;QAChB,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,KAAK,IAAI,EAAE,CAAC;YACjC,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;QAC9B,CAAC;QAED,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;IAC7B,CAAC;IAED,KAAK,CAAC,UAAU,CACd,MAAc,EACd,QAA2B,EAC3B,OAAO,GAAG,KAAK;QAEf,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,EAAE,CAAC;QAE3C,MAAM,YAAY,GAAG,QAAQ,EAAE,YAAY,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE;YAC3D,IAAI,IAAI,IAAI,OAAO,EAAE,CAAC;gBACpB,OAAO,CACL,OAAO,CAAC,EAAE,KAAK,MAAM;oBACrB,qBAAqB,CAAC,QAAQ,CAAC,OAAO,EAAE,OAAO,CAAC,YAAY,CAAC,CAC9D,CAAC;YACJ,CAAC;YAED,OAAO,OAAO,CAAC,QAAQ,KAAK,QAAQ,CAAC,QAAQ,CAAC;QAChD,CAAC,CAAC,CAAC;QAEH,IAAI,YAAY,EAAE,CAAC;YACjB,OAAO;gBACL,MAAM,EAAE,mBAAmB,CAAC,OAAO;gBACnC,MAAM,EAAE,YAAY,CAAC,MAAM;aAC5B,CAAC;QACJ,CAAC;QAED,MAAM,QAAQ,GAAG,QAAQ,EAAE,aAAa,CAAC,MAAM,CAAC,CAAC;QACjD,MAAM,OAAO,GAAG,QAAQ,EAAE,QAAQ,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QACvD,IAAI,OAAO,IAAI,OAAO,CAAC,QAAQ,KAAK,QAAQ,CAAC,QAAQ,EAAE,CAAC;YACtD,OAAO,EAAE,MAAM,EAAE,mBAAmB,CAAC,QAAQ,EAAE,CAAC;QAClD,CAAC;QACD,4EAA4E;QAC5E,IAAI,IAAI,CAAC,uBAAuB,IAAI,CAAC,OAAO,EAAE,CAAC;YAC7C,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;YAC5B,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC;QACjD,CAAC;QACD,OAAO;YACL,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,mBAAmB;gBACpC,CAAC,CAAC,mBAAmB,CAAC,WAAW;gBACjC,CAAC,CAAC,mBAAmB,CAAC,UAAU;SACnC,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,IAAI,CACR,KAA2B;QAE3B,OAAO,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,MAAM,CAEjC,KAAK,EAAE,eAAe,EAAE,CAAC,MAAM,EAAE,QAAQ,CAAC,EAAE,EAAE;YAC9C,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;YACvD,MAAM,GAAG,GAAG,MAAM,eAAe,CAAC;YAClC,GAAG,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;YACrB,OAAO,GAAG,CAAC;QACb,CAAC,EAAE,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;IAC1B,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,eAAe,CACnB,MAAc,EACd,YAAyB,EACzB,OAAO,GAAG,KAAK;QAEf,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,EAAE,CAAC;QAC3C,MAAM,QAAQ,GAAG,QAAQ,EAAE,aAAa,CAAC,MAAM,CAAC,EAAE,QAAQ,IAAI,IAAI,CAAC;QAEnE,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,uBAAuB,IAAI,CAAC,OAAO,EAAE,CAAC;YAC1D,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;YAC5B,OAAO,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;QAC1D,CAAC;QAED,oFAAoF;QACpF,IAAI,CAAC,QAAQ,EAAE,CAAC;YACd,OAAO,YAAY,CAAC;QACtB,CAAC;QAED,MAAM,aAAa,GAAG,gBAAgB,CACpC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAoB,EACxC,YAAY,CACb,CAAC;QAEF,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,uBAAuB,IAAI,CAAC,OAAO,EAAE,CAAC;YAC/D,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;YAC5B,OAAO,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;QAC1D,CAAC;QAED,oFAAoF;QACpF,IAAI,CAAC,aAAa,EAAE,CAAC;YACnB,OAAO,YAAY,CAAC;QACtB,CAAC;QAED,6DAA6D;QAC7D,mBAAmB,CAAC,aAAa,CAAC,CAAC;QACnC,OAAO,aAAa,CAAC;IACvB,CAAC;IAED;;;;;;OAMG;IACH,YAAY,CAAC,MAAc;QACzB,OAAO,IAAI,CAAC,KAAK,EAAE,QAAQ,EAAE,aAAa,CAAC,MAAM,CAAC,EAAE,QAAQ,IAAI,IAAI,CAAC;IACvE,CAAC;IAED;;;;;;;OAOG;IACH,gBAAgB,CAAC,QAAgB,EAAE,SAAiB;QAClD,MAAM,CAAC,IAAI,CAAC,UAAU,EAAE,yBAAyB,CAAC,CAAC;QAEnD,MAAM,KAAK,GAAG,MAAM,CAAC;YACnB,QAAQ,EAAE,QAAQ;YAClB,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC;YAChC,SAAS,EAAE,IAAI,CAAC,UAAU;SAC3B,CAAC,CAAC;QAEH,MAAM,CAAC,KAAK,EAAE,6BAA6B,CAAC,CAAC;IAC/C,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,UAAU,CAAC,GAAW;QAC1B,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;QAChD,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;YACjB,MAAM,IAAI,KAAK,CAAC,mBAAmB,GAAG,GAAG,CAAC,CAAC;QAC7C,CAAC;QAED,OAAO,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC;IAC/B,CAAC;CACF","sourcesContent":["import type {\n  ControllerGetStateAction,\n  ControllerStateChangeEvent,\n} from '@metamask/base-controller/next';\nimport { BaseController } from '@metamask/base-controller/next';\nimport type { Messenger } from '@metamask/messenger';\nimport type { SnapsRegistryDatabase } from '@metamask/snaps-registry';\nimport { verify } from '@metamask/snaps-registry';\nimport { getTargetVersion } from '@metamask/snaps-utils';\nimport type { Hex, SemVerRange, SemVerVersion } from '@metamask/utils';\nimport {\n  assert,\n  assertIsSemVerRange,\n  Duration,\n  inMilliseconds,\n  satisfiesVersionRange,\n} from '@metamask/utils';\n\nimport type {\n  SnapsRegistry,\n  SnapsRegistryInfo,\n  SnapsRegistryMetadata,\n  SnapsRegistryRequest,\n  SnapsRegistryResult,\n} from './registry';\nimport { SnapsRegistryStatus } from './registry';\n\nconst SNAP_REGISTRY_URL =\n  'https://acl.execution.metamask.io/latest/registry.json';\n\nconst SNAP_REGISTRY_SIGNATURE_URL =\n  'https://acl.execution.metamask.io/latest/signature.json';\n\nconst DEFAULT_PUBLIC_KEY =\n  '0x025b65308f0f0fb8bc7f7ff87bfc296e0330eee5d3c1d1ee4a048b2fd6a86fa0a6';\n\ntype JsonSnapsRegistryUrl = {\n  registry: string;\n  signature: string;\n};\n\nexport type JsonSnapsRegistryArgs = {\n  messenger: SnapsRegistryMessenger;\n  state?: SnapsRegistryState;\n  fetchFunction?: typeof fetch;\n  url?: JsonSnapsRegistryUrl;\n  recentFetchThreshold?: number;\n  refetchOnAllowlistMiss?: boolean;\n  publicKey?: Hex;\n};\n\nexport type GetResult = {\n  type: `${typeof controllerName}:get`;\n  handler: SnapsRegistry['get'];\n};\n\nexport type ResolveVersion = {\n  type: `${typeof controllerName}:resolveVersion`;\n  handler: SnapsRegistry['resolveVersion'];\n};\n\nexport type GetMetadata = {\n  type: `${typeof controllerName}:getMetadata`;\n  handler: SnapsRegistry['getMetadata'];\n};\n\nexport type Update = {\n  type: `${typeof controllerName}:update`;\n  handler: SnapsRegistry['update'];\n};\n\nexport type SnapsRegistryGetStateAction = ControllerGetStateAction<\n  typeof controllerName,\n  SnapsRegistryState\n>;\n\nexport type SnapsRegistryActions =\n  | SnapsRegistryGetStateAction\n  | GetResult\n  | GetMetadata\n  | Update\n  | ResolveVersion;\n\nexport type SnapsRegistryStateChangeEvent = ControllerStateChangeEvent<\n  typeof controllerName,\n  SnapsRegistryState\n>;\n\nexport type SnapsRegistryEvents = SnapsRegistryStateChangeEvent;\n\nexport type SnapsRegistryMessenger = Messenger<\n  'SnapsRegistry',\n  SnapsRegistryActions,\n  SnapsRegistryEvents\n>;\n\nexport type SnapsRegistryState = {\n  database: SnapsRegistryDatabase | null;\n  lastUpdated: number | null;\n  databaseUnavailable: boolean;\n};\n\nconst controllerName = 'SnapsRegistry';\n\nconst defaultState = {\n  database: null,\n  lastUpdated: null,\n  databaseUnavailable: false,\n};\n\nexport class JsonSnapsRegistry extends BaseController<\n  typeof controllerName,\n  SnapsRegistryState,\n  SnapsRegistryMessenger\n> {\n  readonly #url: JsonSnapsRegistryUrl;\n\n  readonly #publicKey: Hex;\n\n  readonly #fetchFunction: typeof fetch;\n\n  readonly #recentFetchThreshold: number;\n\n  readonly #refetchOnAllowlistMiss: boolean;\n\n  #currentUpdate: Promise<void> | null;\n\n  constructor({\n    messenger,\n    state,\n    url = {\n      registry: SNAP_REGISTRY_URL,\n      signature: SNAP_REGISTRY_SIGNATURE_URL,\n    },\n    publicKey = DEFAULT_PUBLIC_KEY,\n    fetchFunction = globalThis.fetch.bind(undefined),\n    recentFetchThreshold = inMilliseconds(5, Duration.Minute),\n    refetchOnAllowlistMiss = true,\n  }: JsonSnapsRegistryArgs) {\n    super({\n      messenger,\n      metadata: {\n        database: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: false,\n          usedInUi: true,\n        },\n        lastUpdated: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: true,\n          usedInUi: false,\n        },\n        databaseUnavailable: {\n          includeInStateLogs: true,\n          persist: true,\n          includeInDebugSnapshot: true,\n          usedInUi: false,\n        },\n      },\n      name: controllerName,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n    this.#url = url;\n    this.#publicKey = publicKey;\n    this.#fetchFunction = fetchFunction;\n    this.#recentFetchThreshold = recentFetchThreshold;\n    this.#refetchOnAllowlistMiss = refetchOnAllowlistMiss;\n    this.#currentUpdate = null;\n\n    this.messenger.registerActionHandler('SnapsRegistry:get', async (...args) =>\n      this.#get(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      'SnapsRegistry:getMetadata',\n      (...args) => this.#getMetadata(...args),\n    );\n\n    this.messenger.registerActionHandler(\n      'SnapsRegistry:resolveVersion',\n      async (...args) => this.#resolveVersion(...args),\n    );\n\n    this.messenger.registerActionHandler('SnapsRegistry:update', async () =>\n      this.#triggerUpdate(),\n    );\n  }\n\n  #wasRecentlyFetched() {\n    return (\n      this.state.lastUpdated &&\n      Date.now() - this.state.lastUpdated < this.#recentFetchThreshold\n    );\n  }\n\n  /**\n   * Triggers an update of the registry database.\n   *\n   * If an existing update is in progress this function will await that update.\n   */\n  async #triggerUpdate() {\n    // If an update is ongoing, wait for that.\n    if (this.#currentUpdate) {\n      await this.#currentUpdate;\n      return;\n    }\n    // If no update exists, create promise and store globally.\n    if (this.#currentUpdate === null) {\n      this.#currentUpdate = this.#update();\n    }\n    await this.#currentUpdate;\n    this.#currentUpdate = null;\n  }\n\n  /**\n   * Updates the registry database if the registry hasn't been updated recently.\n   *\n   * NOTE: SHOULD NOT be called directly, instead `triggerUpdate` should be used.\n   */\n  async #update() {\n    // No-op if we recently fetched the registry.\n    if (this.#wasRecentlyFetched()) {\n      return;\n    }\n\n    try {\n      const [database, signature] = await Promise.all([\n        this.#safeFetch(this.#url.registry),\n        this.#safeFetch(this.#url.signature),\n      ]);\n\n      this.#verifySignature(database, signature);\n\n      this.update((state) => {\n        state.database = JSON.parse(database);\n        state.lastUpdated = Date.now();\n        state.databaseUnavailable = false;\n      });\n    } catch {\n      // Ignore\n      this.update((state) => {\n        state.databaseUnavailable = true;\n      });\n    }\n  }\n\n  async #getDatabase(): Promise<SnapsRegistryDatabase | null> {\n    if (this.state.database === null) {\n      await this.#triggerUpdate();\n    }\n\n    return this.state.database;\n  }\n\n  async #getSingle(\n    snapId: string,\n    snapInfo: SnapsRegistryInfo,\n    refetch = false,\n  ): Promise<SnapsRegistryResult> {\n    const database = await this.#getDatabase();\n\n    const blockedEntry = database?.blockedSnaps.find((blocked) => {\n      if ('id' in blocked) {\n        return (\n          blocked.id === snapId &&\n          satisfiesVersionRange(snapInfo.version, blocked.versionRange)\n        );\n      }\n\n      return blocked.checksum === snapInfo.checksum;\n    });\n\n    if (blockedEntry) {\n      return {\n        status: SnapsRegistryStatus.Blocked,\n        reason: blockedEntry.reason,\n      };\n    }\n\n    const verified = database?.verifiedSnaps[snapId];\n    const version = verified?.versions?.[snapInfo.version];\n    if (version && version.checksum === snapInfo.checksum) {\n      return { status: SnapsRegistryStatus.Verified };\n    }\n    // For now, if we have an allowlist miss, we can refetch once and try again.\n    if (this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#getSingle(snapId, snapInfo, true);\n    }\n    return {\n      status: this.state.databaseUnavailable\n        ? SnapsRegistryStatus.Unavailable\n        : SnapsRegistryStatus.Unverified,\n    };\n  }\n\n  async #get(\n    snaps: SnapsRegistryRequest,\n  ): Promise<Record<string, SnapsRegistryResult>> {\n    return Object.entries(snaps).reduce<\n      Promise<Record<string, SnapsRegistryResult>>\n    >(async (previousPromise, [snapId, snapInfo]) => {\n      const result = await this.#getSingle(snapId, snapInfo);\n      const acc = await previousPromise;\n      acc[snapId] = result;\n      return acc;\n    }, Promise.resolve({}));\n  }\n\n  /**\n   * Find an allowlisted version within a specified version range. Otherwise return the version range itself.\n   *\n   * @param snapId - The ID of the snap we are trying to resolve a version for.\n   * @param versionRange - The version range.\n   * @param refetch - An optional flag used to determine if we are refetching the registry.\n   * @returns An allowlisted version within the specified version range if available otherwise returns the input version range.\n   */\n  async #resolveVersion(\n    snapId: string,\n    versionRange: SemVerRange,\n    refetch = false,\n  ): Promise<SemVerRange> {\n    const database = await this.#getDatabase();\n    const versions = database?.verifiedSnaps[snapId]?.versions ?? null;\n\n    if (!versions && this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#resolveVersion(snapId, versionRange, true);\n    }\n\n    // If we cannot narrow down the version range we return the unaltered version range.\n    if (!versions) {\n      return versionRange;\n    }\n\n    const targetVersion = getTargetVersion(\n      Object.keys(versions) as SemVerVersion[],\n      versionRange,\n    );\n\n    if (!targetVersion && this.#refetchOnAllowlistMiss && !refetch) {\n      await this.#triggerUpdate();\n      return this.#resolveVersion(snapId, versionRange, true);\n    }\n\n    // If we cannot narrow down the version range we return the unaltered version range.\n    if (!targetVersion) {\n      return versionRange;\n    }\n\n    // A semver version is technically also a valid semver range.\n    assertIsSemVerRange(targetVersion);\n    return targetVersion;\n  }\n\n  /**\n   * Get metadata for the given snap ID, if available, without updating registry.\n   *\n   * @param snapId - The ID of the snap to get metadata for.\n   * @returns The metadata for the given snap ID, or `null` if the snap is not\n   * verified.\n   */\n  #getMetadata(snapId: string): SnapsRegistryMetadata | null {\n    return this.state?.database?.verifiedSnaps[snapId]?.metadata ?? null;\n  }\n\n  /**\n   * Verify the signature of the registry.\n   *\n   * @param database - The registry database.\n   * @param signature - The signature of the registry.\n   * @throws If the signature is invalid.\n   * @private\n   */\n  #verifySignature(database: string, signature: string) {\n    assert(this.#publicKey, 'No public key provided.');\n\n    const valid = verify({\n      registry: database,\n      signature: JSON.parse(signature),\n      publicKey: this.#publicKey,\n    });\n\n    assert(valid, 'Invalid registry signature.');\n  }\n\n  /**\n   * Fetch the given URL, throwing if the response is not OK.\n   *\n   * @param url - The URL to fetch.\n   * @returns The response body.\n   * @private\n   */\n  async #safeFetch(url: string) {\n    const response = await this.#fetchFunction(url);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${url}.`);\n    }\n\n    return await response.text();\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/types/controllers.cjs.map b/dist/types/controllers.cjs.map
index d994a6f200da2c4b2743eb6bfecf860cf0874b38..9837c85e1879e208bffd5c49bdb47cdf3b8b2060 100644
--- a/dist/types/controllers.cjs.map
+++ b/dist/types/controllers.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"controllers.cjs","sourceRoot":"","sources":["../../src/types/controllers.ts"],"names":[],"mappings":"","sourcesContent":["import type { ControllerStateChangeEvent } from '@metamask/base-controller';\nimport type { Hex, Json } from '@metamask/utils';\n\n// Partial types that should overlap with types from controllers.\nexport type TransactionMeta = {\n  /**\n   * Generated UUID associated with this transaction.\n   */\n  id: string;\n\n  /**\n   * Network code as per EIP-155 for this transaction.\n   */\n  chainId: Hex;\n\n  /**\n   * Origin this transaction was sent from.\n   */\n  origin?: string;\n\n  /**\n   * Underlying Transaction object.\n   */\n  txParams: TransactionParams;\n\n  /**\n   * The status of the transaction.\n   */\n  status: string;\n};\n\n/**\n * Standard data concerning a transaction to be processed by the blockchain.\n */\nexport type TransactionParams = {\n  /**\n   * Chain ID as per EIP-155.\n   */\n  chainId?: Hex;\n\n  /**\n   * Data to pass with this transaction.\n   */\n  data?: string;\n\n  /**\n   * Error message for gas estimation failure.\n   */\n  estimateGasError?: string;\n\n  /**\n   * Estimated base fee for this transaction.\n   */\n  estimatedBaseFee?: string;\n\n  /**\n   * Which estimate level that the API suggested.\n   */\n  estimateSuggested?: string;\n\n  /**\n   * Which estimate level was used\n   */\n  estimateUsed?: string;\n\n  /**\n   * Address to send this transaction from.\n   */\n  from: string;\n\n  /**\n   * same as gasLimit?\n   */\n  gas?: string;\n\n  /**\n   * Maximum number of units of gas to use for this transaction.\n   */\n  gasLimit?: string;\n\n  /**\n   * Price per gas for legacy txs\n   */\n  gasPrice?: string;\n\n  /**\n   * Gas used in the transaction.\n   */\n  gasUsed?: string;\n\n  /**\n   * Maximum amount per gas to pay for the transaction, including the priority\n   * fee.\n   */\n  maxFeePerGas?: string;\n\n  /**\n   * Maximum amount per gas to give to validator as incentive.\n   */\n  maxPriorityFeePerGas?: string;\n\n  /**\n   * Unique number to prevent replay attacks.\n   */\n  nonce?: string;\n\n  /**\n   * Address to send this transaction to.\n   */\n  to?: string;\n\n  /**\n   * Value associated with this transaction.\n   */\n  value?: string;\n\n  /**\n   * Type of transaction.\n   * 0x0 indicates a legacy transaction.\n   */\n  type?: string;\n};\n\nexport type TransactionControllerUnapprovedTransactionAddedEvent = {\n  type: `TransactionController:unapprovedTransactionAdded`;\n  payload: [transactionMeta: TransactionMeta];\n};\n\nexport type TransactionControllerTransactionStatusUpdatedEvent = {\n  type: `TransactionController:transactionStatusUpdated`;\n  payload: [\n    {\n      transactionMeta: TransactionMeta;\n    },\n  ];\n};\n\nexport type StateSignatureParams = {\n  from: string;\n  origin?: string;\n  deferSetAsSigned?: boolean;\n  data: string | Record<string, Json>;\n  signatureMethod: string;\n};\n\nexport type StateSignature = {\n  id: string;\n  msgParams: StateSignatureParams;\n};\n\nexport type SignatureControllerState = {\n  unapprovedPersonalMsgs: Record<string, StateSignature>;\n  unapprovedTypedMessages: Record<string, StateSignature>;\n  unapprovedPersonalMsgCount: number;\n  unapprovedTypedMessagesCount: number;\n};\n\nexport type SignatureStateChange = ControllerStateChangeEvent<\n  'SignatureController',\n  SignatureControllerState\n>;\n"]}
\ No newline at end of file
+{"version":3,"file":"controllers.cjs","sourceRoot":"","sources":["../../src/types/controllers.ts"],"names":[],"mappings":"","sourcesContent":["import type { ControllerStateChangeEvent } from '@metamask/base-controller/next';\nimport type { Hex, Json } from '@metamask/utils';\n\n// Partial types that should overlap with types from controllers.\nexport type TransactionMeta = {\n  /**\n   * Generated UUID associated with this transaction.\n   */\n  id: string;\n\n  /**\n   * Network code as per EIP-155 for this transaction.\n   */\n  chainId: Hex;\n\n  /**\n   * Origin this transaction was sent from.\n   */\n  origin?: string;\n\n  /**\n   * Underlying Transaction object.\n   */\n  txParams: TransactionParams;\n\n  /**\n   * The status of the transaction.\n   */\n  status: string;\n};\n\n/**\n * Standard data concerning a transaction to be processed by the blockchain.\n */\nexport type TransactionParams = {\n  /**\n   * Chain ID as per EIP-155.\n   */\n  chainId?: Hex;\n\n  /**\n   * Data to pass with this transaction.\n   */\n  data?: string;\n\n  /**\n   * Error message for gas estimation failure.\n   */\n  estimateGasError?: string;\n\n  /**\n   * Estimated base fee for this transaction.\n   */\n  estimatedBaseFee?: string;\n\n  /**\n   * Which estimate level that the API suggested.\n   */\n  estimateSuggested?: string;\n\n  /**\n   * Which estimate level was used\n   */\n  estimateUsed?: string;\n\n  /**\n   * Address to send this transaction from.\n   */\n  from: string;\n\n  /**\n   * same as gasLimit?\n   */\n  gas?: string;\n\n  /**\n   * Maximum number of units of gas to use for this transaction.\n   */\n  gasLimit?: string;\n\n  /**\n   * Price per gas for legacy txs\n   */\n  gasPrice?: string;\n\n  /**\n   * Gas used in the transaction.\n   */\n  gasUsed?: string;\n\n  /**\n   * Maximum amount per gas to pay for the transaction, including the priority\n   * fee.\n   */\n  maxFeePerGas?: string;\n\n  /**\n   * Maximum amount per gas to give to validator as incentive.\n   */\n  maxPriorityFeePerGas?: string;\n\n  /**\n   * Unique number to prevent replay attacks.\n   */\n  nonce?: string;\n\n  /**\n   * Address to send this transaction to.\n   */\n  to?: string;\n\n  /**\n   * Value associated with this transaction.\n   */\n  value?: string;\n\n  /**\n   * Type of transaction.\n   * 0x0 indicates a legacy transaction.\n   */\n  type?: string;\n};\n\nexport type TransactionControllerUnapprovedTransactionAddedEvent = {\n  type: `TransactionController:unapprovedTransactionAdded`;\n  payload: [transactionMeta: TransactionMeta];\n};\n\nexport type TransactionControllerTransactionStatusUpdatedEvent = {\n  type: `TransactionController:transactionStatusUpdated`;\n  payload: [\n    {\n      transactionMeta: TransactionMeta;\n    },\n  ];\n};\n\nexport type StateSignatureParams = {\n  from: string;\n  origin?: string;\n  deferSetAsSigned?: boolean;\n  data: string | Record<string, Json>;\n  signatureMethod: string;\n};\n\nexport type StateSignature = {\n  id: string;\n  msgParams: StateSignatureParams;\n};\n\nexport type SignatureControllerState = {\n  unapprovedPersonalMsgs: Record<string, StateSignature>;\n  unapprovedTypedMessages: Record<string, StateSignature>;\n  unapprovedPersonalMsgCount: number;\n  unapprovedTypedMessagesCount: number;\n};\n\nexport type SignatureStateChange = ControllerStateChangeEvent<\n  'SignatureController',\n  SignatureControllerState\n>;\n"]}
\ No newline at end of file
diff --git a/dist/types/controllers.d.cts b/dist/types/controllers.d.cts
index 898befbb9b6e1a991ae4f53bd48646d9c1113688..694b1be47ae88ce718b5f6b33c643a41b1ff3d05 100644
--- a/dist/types/controllers.d.cts
+++ b/dist/types/controllers.d.cts
@@ -1,4 +1,4 @@
-import type { ControllerStateChangeEvent } from "@metamask/base-controller";
+import type { ControllerStateChangeEvent } from "@metamask/base-controller/next";
 import type { Hex, Json } from "@metamask/utils";
 export type TransactionMeta = {
     /**
diff --git a/dist/types/controllers.d.cts.map b/dist/types/controllers.d.cts.map
index 3b993f5e8ae48e1a7be3f54f2eafec75c1289872..f9527b0191c03c10e5077243e2efb87928c2256b 100644
--- a/dist/types/controllers.d.cts.map
+++ b/dist/types/controllers.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"controllers.d.cts","sourceRoot":"","sources":["../../src/types/controllers.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,0BAA0B,EAAE,kCAAkC;AAC5E,OAAO,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,wBAAwB;AAGjD,MAAM,MAAM,eAAe,GAAG;IAC5B;;OAEG;IACH,EAAE,EAAE,MAAM,CAAC;IAEX;;OAEG;IACH,OAAO,EAAE,GAAG,CAAC;IAEb;;OAEG;IACH,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB;;OAEG;IACH,QAAQ,EAAE,iBAAiB,CAAC;IAE5B;;OAEG;IACH,MAAM,EAAE,MAAM,CAAC;CAChB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,iBAAiB,GAAG;IAC9B;;OAEG;IACH,OAAO,CAAC,EAAE,GAAG,CAAC;IAEd;;OAEG;IACH,IAAI,CAAC,EAAE,MAAM,CAAC;IAEd;;OAEG;IACH,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAE1B;;OAEG;IACH,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAE1B;;OAEG;IACH,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAE3B;;OAEG;IACH,YAAY,CAAC,EAAE,MAAM,CAAC;IAEtB;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IAEb;;OAEG;IACH,GAAG,CAAC,EAAE,MAAM,CAAC;IAEb;;OAEG;IACH,QAAQ,CAAC,EAAE,MAAM,CAAC;IAElB;;OAEG;IACH,QAAQ,CAAC,EAAE,MAAM,CAAC;IAElB;;OAEG;IACH,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB;;;OAGG;IACH,YAAY,CAAC,EAAE,MAAM,CAAC;IAEtB;;OAEG;IACH,oBAAoB,CAAC,EAAE,MAAM,CAAC;IAE9B;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,CAAC;IAEf;;OAEG;IACH,EAAE,CAAC,EAAE,MAAM,CAAC;IAEZ;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,CAAC;IAEf;;;OAGG;IACH,IAAI,CAAC,EAAE,MAAM,CAAC;CACf,CAAC;AAEF,MAAM,MAAM,oDAAoD,GAAG;IACjE,IAAI,EAAE,kDAAkD,CAAC;IACzD,OAAO,EAAE,CAAC,eAAe,EAAE,eAAe,CAAC,CAAC;CAC7C,CAAC;AAEF,MAAM,MAAM,kDAAkD,GAAG;IAC/D,IAAI,EAAE,gDAAgD,CAAC;IACvD,OAAO,EAAE;QACP;YACE,eAAe,EAAE,eAAe,CAAC;SAClC;KACF,CAAC;CACH,CAAC;AAEF,MAAM,MAAM,oBAAoB,GAAG;IACjC,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,gBAAgB,CAAC,EAAE,OAAO,CAAC;IAC3B,IAAI,EAAE,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;IACpC,eAAe,EAAE,MAAM,CAAC;CACzB,CAAC;AAEF,MAAM,MAAM,cAAc,GAAG;IAC3B,EAAE,EAAE,MAAM,CAAC;IACX,SAAS,EAAE,oBAAoB,CAAC;CACjC,CAAC;AAEF,MAAM,MAAM,wBAAwB,GAAG;IACrC,sBAAsB,EAAE,MAAM,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;IACvD,uBAAuB,EAAE,MAAM,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;IACxD,0BAA0B,EAAE,MAAM,CAAC;IACnC,4BAA4B,EAAE,MAAM,CAAC;CACtC,CAAC;AAEF,MAAM,MAAM,oBAAoB,GAAG,0BAA0B,CAC3D,qBAAqB,EACrB,wBAAwB,CACzB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"controllers.d.cts","sourceRoot":"","sources":["../../src/types/controllers.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,0BAA0B,EAAE,uCAAuC;AACjF,OAAO,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,wBAAwB;AAGjD,MAAM,MAAM,eAAe,GAAG;IAC5B;;OAEG;IACH,EAAE,EAAE,MAAM,CAAC;IAEX;;OAEG;IACH,OAAO,EAAE,GAAG,CAAC;IAEb;;OAEG;IACH,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB;;OAEG;IACH,QAAQ,EAAE,iBAAiB,CAAC;IAE5B;;OAEG;IACH,MAAM,EAAE,MAAM,CAAC;CAChB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,iBAAiB,GAAG;IAC9B;;OAEG;IACH,OAAO,CAAC,EAAE,GAAG,CAAC;IAEd;;OAEG;IACH,IAAI,CAAC,EAAE,MAAM,CAAC;IAEd;;OAEG;IACH,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAE1B;;OAEG;IACH,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAE1B;;OAEG;IACH,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAE3B;;OAEG;IACH,YAAY,CAAC,EAAE,MAAM,CAAC;IAEtB;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IAEb;;OAEG;IACH,GAAG,CAAC,EAAE,MAAM,CAAC;IAEb;;OAEG;IACH,QAAQ,CAAC,EAAE,MAAM,CAAC;IAElB;;OAEG;IACH,QAAQ,CAAC,EAAE,MAAM,CAAC;IAElB;;OAEG;IACH,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB;;;OAGG;IACH,YAAY,CAAC,EAAE,MAAM,CAAC;IAEtB;;OAEG;IACH,oBAAoB,CAAC,EAAE,MAAM,CAAC;IAE9B;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,CAAC;IAEf;;OAEG;IACH,EAAE,CAAC,EAAE,MAAM,CAAC;IAEZ;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,CAAC;IAEf;;;OAGG;IACH,IAAI,CAAC,EAAE,MAAM,CAAC;CACf,CAAC;AAEF,MAAM,MAAM,oDAAoD,GAAG;IACjE,IAAI,EAAE,kDAAkD,CAAC;IACzD,OAAO,EAAE,CAAC,eAAe,EAAE,eAAe,CAAC,CAAC;CAC7C,CAAC;AAEF,MAAM,MAAM,kDAAkD,GAAG;IAC/D,IAAI,EAAE,gDAAgD,CAAC;IACvD,OAAO,EAAE;QACP;YACE,eAAe,EAAE,eAAe,CAAC;SAClC;KACF,CAAC;CACH,CAAC;AAEF,MAAM,MAAM,oBAAoB,GAAG;IACjC,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,gBAAgB,CAAC,EAAE,OAAO,CAAC;IAC3B,IAAI,EAAE,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;IACpC,eAAe,EAAE,MAAM,CAAC;CACzB,CAAC;AAEF,MAAM,MAAM,cAAc,GAAG;IAC3B,EAAE,EAAE,MAAM,CAAC;IACX,SAAS,EAAE,oBAAoB,CAAC;CACjC,CAAC;AAEF,MAAM,MAAM,wBAAwB,GAAG;IACrC,sBAAsB,EAAE,MAAM,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;IACvD,uBAAuB,EAAE,MAAM,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;IACxD,0BAA0B,EAAE,MAAM,CAAC;IACnC,4BAA4B,EAAE,MAAM,CAAC;CACtC,CAAC;AAEF,MAAM,MAAM,oBAAoB,GAAG,0BAA0B,CAC3D,qBAAqB,EACrB,wBAAwB,CACzB,CAAC"}
\ No newline at end of file
diff --git a/dist/types/controllers.d.mts b/dist/types/controllers.d.mts
index 2c95049c5bee1e234ae91b26234dab2f5f4b6385..2002ed634998c7dc0c07b38258723fd04f1b6536 100644
--- a/dist/types/controllers.d.mts
+++ b/dist/types/controllers.d.mts
@@ -1,4 +1,4 @@
-import type { ControllerStateChangeEvent } from "@metamask/base-controller";
+import type { ControllerStateChangeEvent } from "@metamask/base-controller/next";
 import type { Hex, Json } from "@metamask/utils";
 export type TransactionMeta = {
     /**
diff --git a/dist/types/controllers.d.mts.map b/dist/types/controllers.d.mts.map
index 2e6b782be952ad7832586b2aa4eff775badacb8a..5acbe50acef4b573e4c524be6c17f023ebffb9de 100644
--- a/dist/types/controllers.d.mts.map
+++ b/dist/types/controllers.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"controllers.d.mts","sourceRoot":"","sources":["../../src/types/controllers.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,0BAA0B,EAAE,kCAAkC;AAC5E,OAAO,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,wBAAwB;AAGjD,MAAM,MAAM,eAAe,GAAG;IAC5B;;OAEG;IACH,EAAE,EAAE,MAAM,CAAC;IAEX;;OAEG;IACH,OAAO,EAAE,GAAG,CAAC;IAEb;;OAEG;IACH,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB;;OAEG;IACH,QAAQ,EAAE,iBAAiB,CAAC;IAE5B;;OAEG;IACH,MAAM,EAAE,MAAM,CAAC;CAChB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,iBAAiB,GAAG;IAC9B;;OAEG;IACH,OAAO,CAAC,EAAE,GAAG,CAAC;IAEd;;OAEG;IACH,IAAI,CAAC,EAAE,MAAM,CAAC;IAEd;;OAEG;IACH,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAE1B;;OAEG;IACH,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAE1B;;OAEG;IACH,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAE3B;;OAEG;IACH,YAAY,CAAC,EAAE,MAAM,CAAC;IAEtB;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IAEb;;OAEG;IACH,GAAG,CAAC,EAAE,MAAM,CAAC;IAEb;;OAEG;IACH,QAAQ,CAAC,EAAE,MAAM,CAAC;IAElB;;OAEG;IACH,QAAQ,CAAC,EAAE,MAAM,CAAC;IAElB;;OAEG;IACH,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB;;;OAGG;IACH,YAAY,CAAC,EAAE,MAAM,CAAC;IAEtB;;OAEG;IACH,oBAAoB,CAAC,EAAE,MAAM,CAAC;IAE9B;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,CAAC;IAEf;;OAEG;IACH,EAAE,CAAC,EAAE,MAAM,CAAC;IAEZ;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,CAAC;IAEf;;;OAGG;IACH,IAAI,CAAC,EAAE,MAAM,CAAC;CACf,CAAC;AAEF,MAAM,MAAM,oDAAoD,GAAG;IACjE,IAAI,EAAE,kDAAkD,CAAC;IACzD,OAAO,EAAE,CAAC,eAAe,EAAE,eAAe,CAAC,CAAC;CAC7C,CAAC;AAEF,MAAM,MAAM,kDAAkD,GAAG;IAC/D,IAAI,EAAE,gDAAgD,CAAC;IACvD,OAAO,EAAE;QACP;YACE,eAAe,EAAE,eAAe,CAAC;SAClC;KACF,CAAC;CACH,CAAC;AAEF,MAAM,MAAM,oBAAoB,GAAG;IACjC,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,gBAAgB,CAAC,EAAE,OAAO,CAAC;IAC3B,IAAI,EAAE,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;IACpC,eAAe,EAAE,MAAM,CAAC;CACzB,CAAC;AAEF,MAAM,MAAM,cAAc,GAAG;IAC3B,EAAE,EAAE,MAAM,CAAC;IACX,SAAS,EAAE,oBAAoB,CAAC;CACjC,CAAC;AAEF,MAAM,MAAM,wBAAwB,GAAG;IACrC,sBAAsB,EAAE,MAAM,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;IACvD,uBAAuB,EAAE,MAAM,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;IACxD,0BAA0B,EAAE,MAAM,CAAC;IACnC,4BAA4B,EAAE,MAAM,CAAC;CACtC,CAAC;AAEF,MAAM,MAAM,oBAAoB,GAAG,0BAA0B,CAC3D,qBAAqB,EACrB,wBAAwB,CACzB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"controllers.d.mts","sourceRoot":"","sources":["../../src/types/controllers.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,0BAA0B,EAAE,uCAAuC;AACjF,OAAO,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,wBAAwB;AAGjD,MAAM,MAAM,eAAe,GAAG;IAC5B;;OAEG;IACH,EAAE,EAAE,MAAM,CAAC;IAEX;;OAEG;IACH,OAAO,EAAE,GAAG,CAAC;IAEb;;OAEG;IACH,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB;;OAEG;IACH,QAAQ,EAAE,iBAAiB,CAAC;IAE5B;;OAEG;IACH,MAAM,EAAE,MAAM,CAAC;CAChB,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,iBAAiB,GAAG;IAC9B;;OAEG;IACH,OAAO,CAAC,EAAE,GAAG,CAAC;IAEd;;OAEG;IACH,IAAI,CAAC,EAAE,MAAM,CAAC;IAEd;;OAEG;IACH,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAE1B;;OAEG;IACH,gBAAgB,CAAC,EAAE,MAAM,CAAC;IAE1B;;OAEG;IACH,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAE3B;;OAEG;IACH,YAAY,CAAC,EAAE,MAAM,CAAC;IAEtB;;OAEG;IACH,IAAI,EAAE,MAAM,CAAC;IAEb;;OAEG;IACH,GAAG,CAAC,EAAE,MAAM,CAAC;IAEb;;OAEG;IACH,QAAQ,CAAC,EAAE,MAAM,CAAC;IAElB;;OAEG;IACH,QAAQ,CAAC,EAAE,MAAM,CAAC;IAElB;;OAEG;IACH,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB;;;OAGG;IACH,YAAY,CAAC,EAAE,MAAM,CAAC;IAEtB;;OAEG;IACH,oBAAoB,CAAC,EAAE,MAAM,CAAC;IAE9B;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,CAAC;IAEf;;OAEG;IACH,EAAE,CAAC,EAAE,MAAM,CAAC;IAEZ;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,CAAC;IAEf;;;OAGG;IACH,IAAI,CAAC,EAAE,MAAM,CAAC;CACf,CAAC;AAEF,MAAM,MAAM,oDAAoD,GAAG;IACjE,IAAI,EAAE,kDAAkD,CAAC;IACzD,OAAO,EAAE,CAAC,eAAe,EAAE,eAAe,CAAC,CAAC;CAC7C,CAAC;AAEF,MAAM,MAAM,kDAAkD,GAAG;IAC/D,IAAI,EAAE,gDAAgD,CAAC;IACvD,OAAO,EAAE;QACP;YACE,eAAe,EAAE,eAAe,CAAC;SAClC;KACF,CAAC;CACH,CAAC;AAEF,MAAM,MAAM,oBAAoB,GAAG;IACjC,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,gBAAgB,CAAC,EAAE,OAAO,CAAC;IAC3B,IAAI,EAAE,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;IACpC,eAAe,EAAE,MAAM,CAAC;CACzB,CAAC;AAEF,MAAM,MAAM,cAAc,GAAG;IAC3B,EAAE,EAAE,MAAM,CAAC;IACX,SAAS,EAAE,oBAAoB,CAAC;CACjC,CAAC;AAEF,MAAM,MAAM,wBAAwB,GAAG;IACrC,sBAAsB,EAAE,MAAM,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;IACvD,uBAAuB,EAAE,MAAM,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;IACxD,0BAA0B,EAAE,MAAM,CAAC;IACnC,4BAA4B,EAAE,MAAM,CAAC;CACtC,CAAC;AAEF,MAAM,MAAM,oBAAoB,GAAG,0BAA0B,CAC3D,qBAAqB,EACrB,wBAAwB,CACzB,CAAC"}
\ No newline at end of file
diff --git a/dist/types/controllers.mjs.map b/dist/types/controllers.mjs.map
index 9847e01c7787274dd3f815620632f0e543f88cc6..c9f2b057046df01148b0e7f73a331d63843234b7 100644
--- a/dist/types/controllers.mjs.map
+++ b/dist/types/controllers.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"controllers.mjs","sourceRoot":"","sources":["../../src/types/controllers.ts"],"names":[],"mappings":"","sourcesContent":["import type { ControllerStateChangeEvent } from '@metamask/base-controller';\nimport type { Hex, Json } from '@metamask/utils';\n\n// Partial types that should overlap with types from controllers.\nexport type TransactionMeta = {\n  /**\n   * Generated UUID associated with this transaction.\n   */\n  id: string;\n\n  /**\n   * Network code as per EIP-155 for this transaction.\n   */\n  chainId: Hex;\n\n  /**\n   * Origin this transaction was sent from.\n   */\n  origin?: string;\n\n  /**\n   * Underlying Transaction object.\n   */\n  txParams: TransactionParams;\n\n  /**\n   * The status of the transaction.\n   */\n  status: string;\n};\n\n/**\n * Standard data concerning a transaction to be processed by the blockchain.\n */\nexport type TransactionParams = {\n  /**\n   * Chain ID as per EIP-155.\n   */\n  chainId?: Hex;\n\n  /**\n   * Data to pass with this transaction.\n   */\n  data?: string;\n\n  /**\n   * Error message for gas estimation failure.\n   */\n  estimateGasError?: string;\n\n  /**\n   * Estimated base fee for this transaction.\n   */\n  estimatedBaseFee?: string;\n\n  /**\n   * Which estimate level that the API suggested.\n   */\n  estimateSuggested?: string;\n\n  /**\n   * Which estimate level was used\n   */\n  estimateUsed?: string;\n\n  /**\n   * Address to send this transaction from.\n   */\n  from: string;\n\n  /**\n   * same as gasLimit?\n   */\n  gas?: string;\n\n  /**\n   * Maximum number of units of gas to use for this transaction.\n   */\n  gasLimit?: string;\n\n  /**\n   * Price per gas for legacy txs\n   */\n  gasPrice?: string;\n\n  /**\n   * Gas used in the transaction.\n   */\n  gasUsed?: string;\n\n  /**\n   * Maximum amount per gas to pay for the transaction, including the priority\n   * fee.\n   */\n  maxFeePerGas?: string;\n\n  /**\n   * Maximum amount per gas to give to validator as incentive.\n   */\n  maxPriorityFeePerGas?: string;\n\n  /**\n   * Unique number to prevent replay attacks.\n   */\n  nonce?: string;\n\n  /**\n   * Address to send this transaction to.\n   */\n  to?: string;\n\n  /**\n   * Value associated with this transaction.\n   */\n  value?: string;\n\n  /**\n   * Type of transaction.\n   * 0x0 indicates a legacy transaction.\n   */\n  type?: string;\n};\n\nexport type TransactionControllerUnapprovedTransactionAddedEvent = {\n  type: `TransactionController:unapprovedTransactionAdded`;\n  payload: [transactionMeta: TransactionMeta];\n};\n\nexport type TransactionControllerTransactionStatusUpdatedEvent = {\n  type: `TransactionController:transactionStatusUpdated`;\n  payload: [\n    {\n      transactionMeta: TransactionMeta;\n    },\n  ];\n};\n\nexport type StateSignatureParams = {\n  from: string;\n  origin?: string;\n  deferSetAsSigned?: boolean;\n  data: string | Record<string, Json>;\n  signatureMethod: string;\n};\n\nexport type StateSignature = {\n  id: string;\n  msgParams: StateSignatureParams;\n};\n\nexport type SignatureControllerState = {\n  unapprovedPersonalMsgs: Record<string, StateSignature>;\n  unapprovedTypedMessages: Record<string, StateSignature>;\n  unapprovedPersonalMsgCount: number;\n  unapprovedTypedMessagesCount: number;\n};\n\nexport type SignatureStateChange = ControllerStateChangeEvent<\n  'SignatureController',\n  SignatureControllerState\n>;\n"]}
\ No newline at end of file
+{"version":3,"file":"controllers.mjs","sourceRoot":"","sources":["../../src/types/controllers.ts"],"names":[],"mappings":"","sourcesContent":["import type { ControllerStateChangeEvent } from '@metamask/base-controller/next';\nimport type { Hex, Json } from '@metamask/utils';\n\n// Partial types that should overlap with types from controllers.\nexport type TransactionMeta = {\n  /**\n   * Generated UUID associated with this transaction.\n   */\n  id: string;\n\n  /**\n   * Network code as per EIP-155 for this transaction.\n   */\n  chainId: Hex;\n\n  /**\n   * Origin this transaction was sent from.\n   */\n  origin?: string;\n\n  /**\n   * Underlying Transaction object.\n   */\n  txParams: TransactionParams;\n\n  /**\n   * The status of the transaction.\n   */\n  status: string;\n};\n\n/**\n * Standard data concerning a transaction to be processed by the blockchain.\n */\nexport type TransactionParams = {\n  /**\n   * Chain ID as per EIP-155.\n   */\n  chainId?: Hex;\n\n  /**\n   * Data to pass with this transaction.\n   */\n  data?: string;\n\n  /**\n   * Error message for gas estimation failure.\n   */\n  estimateGasError?: string;\n\n  /**\n   * Estimated base fee for this transaction.\n   */\n  estimatedBaseFee?: string;\n\n  /**\n   * Which estimate level that the API suggested.\n   */\n  estimateSuggested?: string;\n\n  /**\n   * Which estimate level was used\n   */\n  estimateUsed?: string;\n\n  /**\n   * Address to send this transaction from.\n   */\n  from: string;\n\n  /**\n   * same as gasLimit?\n   */\n  gas?: string;\n\n  /**\n   * Maximum number of units of gas to use for this transaction.\n   */\n  gasLimit?: string;\n\n  /**\n   * Price per gas for legacy txs\n   */\n  gasPrice?: string;\n\n  /**\n   * Gas used in the transaction.\n   */\n  gasUsed?: string;\n\n  /**\n   * Maximum amount per gas to pay for the transaction, including the priority\n   * fee.\n   */\n  maxFeePerGas?: string;\n\n  /**\n   * Maximum amount per gas to give to validator as incentive.\n   */\n  maxPriorityFeePerGas?: string;\n\n  /**\n   * Unique number to prevent replay attacks.\n   */\n  nonce?: string;\n\n  /**\n   * Address to send this transaction to.\n   */\n  to?: string;\n\n  /**\n   * Value associated with this transaction.\n   */\n  value?: string;\n\n  /**\n   * Type of transaction.\n   * 0x0 indicates a legacy transaction.\n   */\n  type?: string;\n};\n\nexport type TransactionControllerUnapprovedTransactionAddedEvent = {\n  type: `TransactionController:unapprovedTransactionAdded`;\n  payload: [transactionMeta: TransactionMeta];\n};\n\nexport type TransactionControllerTransactionStatusUpdatedEvent = {\n  type: `TransactionController:transactionStatusUpdated`;\n  payload: [\n    {\n      transactionMeta: TransactionMeta;\n    },\n  ];\n};\n\nexport type StateSignatureParams = {\n  from: string;\n  origin?: string;\n  deferSetAsSigned?: boolean;\n  data: string | Record<string, Json>;\n  signatureMethod: string;\n};\n\nexport type StateSignature = {\n  id: string;\n  msgParams: StateSignatureParams;\n};\n\nexport type SignatureControllerState = {\n  unapprovedPersonalMsgs: Record<string, StateSignature>;\n  unapprovedTypedMessages: Record<string, StateSignature>;\n  unapprovedPersonalMsgCount: number;\n  unapprovedTypedMessagesCount: number;\n};\n\nexport type SignatureStateChange = ControllerStateChangeEvent<\n  'SignatureController',\n  SignatureControllerState\n>;\n"]}
\ No newline at end of file
diff --git a/dist/websocket/WebSocketService.cjs.map b/dist/websocket/WebSocketService.cjs.map
index 1d8e8f4485b49bb02fe1fbbcd54d0a77169a7033..840129fa9e7afe77aa0ac2be8dd956a1c56cd43f 100644
--- a/dist/websocket/WebSocketService.cjs.map
+++ b/dist/websocket/WebSocketService.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"WebSocketService.cjs","sourceRoot":"","sources":["../../src/websocket/WebSocketService.ts"],"names":[],"mappings":"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","sourcesContent":["import type { RestrictedMessenger } from '@metamask/base-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type {\n  GetWebSocketsResult,\n  SnapId,\n  WebSocketEvent,\n} from '@metamask/snaps-sdk';\nimport { HandlerType, isEqual, logError } from '@metamask/snaps-utils';\nimport { assert, createDeferredPromise } from '@metamask/utils';\nimport { nanoid } from 'nanoid';\n\nimport type {\n  HandleSnapRequest,\n  SnapInstalled,\n  SnapUninstalled,\n  SnapUpdated,\n} from '../snaps';\nimport { METAMASK_ORIGIN } from '../snaps';\n\nconst serviceName = 'WebSocketService';\n\nexport type WebSocketServiceOpenAction = {\n  type: `${typeof serviceName}:open`;\n  handler: (\n    snapId: SnapId,\n    url: string,\n    protocols?: string[],\n  ) => Promise<string>;\n};\n\nexport type WebSocketServiceCloseAction = {\n  type: `${typeof serviceName}:close`;\n  handler: (snapId: SnapId, id: string) => void;\n};\n\nexport type WebSocketServiceSendMessageAction = {\n  type: `${typeof serviceName}:sendMessage`;\n  handler: (\n    snapId: SnapId,\n    id: string,\n    data: string | number[],\n  ) => Promise<void>;\n};\n\nexport type WebSocketServiceGetAllAction = {\n  type: `${typeof serviceName}:getAll`;\n  handler: (snapId: SnapId) => GetWebSocketsResult;\n};\n\nexport type WebSocketServiceActions =\n  | WebSocketServiceOpenAction\n  | WebSocketServiceCloseAction\n  | WebSocketServiceSendMessageAction\n  | WebSocketServiceGetAllAction;\n\nexport type WebSocketServiceAllowedActions = HandleSnapRequest;\n\nexport type WebSocketServiceEvents =\n  | SnapUninstalled\n  | SnapUpdated\n  | SnapInstalled;\n\nexport type WebSocketServiceMessenger = RestrictedMessenger<\n  'WebSocketService',\n  WebSocketServiceActions | WebSocketServiceAllowedActions,\n  WebSocketServiceEvents,\n  WebSocketServiceAllowedActions['type'],\n  WebSocketServiceEvents['type']\n>;\n\ntype WebSocketServiceArgs = {\n  messenger: WebSocketServiceMessenger;\n};\n\ntype InternalSocket = {\n  id: string;\n  snapId: SnapId;\n  url: string;\n  protocols: string[];\n  openPromise: Promise<void>;\n  // eslint-disable-next-line no-restricted-globals\n  socket: WebSocket;\n};\n\nexport class WebSocketService {\n  name: typeof serviceName = serviceName;\n\n  state = null;\n\n  readonly #messenger: WebSocketServiceMessenger;\n\n  readonly #sockets: Map<string, InternalSocket>;\n\n  constructor({ messenger }: WebSocketServiceArgs) {\n    this.#messenger = messenger;\n    this.#sockets = new Map();\n\n    this.#messenger.registerActionHandler(\n      `${serviceName}:open`,\n      async (...args) => this.#open(...args),\n    );\n\n    this.#messenger.registerActionHandler(`${serviceName}:close`, (...args) =>\n      this.#close(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${serviceName}:sendMessage`,\n      async (...args) => this.#sendMessage(...args),\n    );\n\n    this.#messenger.registerActionHandler(`${serviceName}:getAll`, (...args) =>\n      this.#getAll(...args),\n    );\n\n    this.#messenger.subscribe('SnapController:snapUpdated', (snap) => {\n      this.#closeAll(snap.id);\n    });\n\n    this.#messenger.subscribe('SnapController:snapUninstalled', (snap) => {\n      this.#closeAll(snap.id);\n    });\n\n    // Due to local Snaps not currently emitting snapUninstalled we also have to\n    // listen to snapInstalled.\n    this.#messenger.subscribe('SnapController:snapInstalled', (snap) => {\n      this.#closeAll(snap.id);\n    });\n  }\n\n  /**\n   * Get information about a given WebSocket connection with an ID.\n   *\n   * @param snapId - The Snap ID.\n   * @param id - The identifier for the WebSocket connection.\n   * @returns Information about the WebSocket connection.\n   * @throws If the WebSocket connection cannot be found.\n   */\n  #get(snapId: SnapId, id: string) {\n    const socket = this.#sockets.get(id);\n\n    assert(\n      socket && socket.snapId === snapId,\n      `Socket with ID \"${id}\" not found.`,\n    );\n\n    return socket;\n  }\n\n  /**\n   * Check whether a given Snap ID already has an open connection for a URL and protocol.\n   *\n   * @param snapId - The Snap ID.\n   * @param url - The URL.\n   * @param protocols - A protocols parameter.\n   * @returns True if a matching connection already exists, otherwise false.\n   */\n  #exists(snapId: SnapId, url: string, protocols: string[]) {\n    return this.#getAll(snapId).some(\n      (socket) => socket.url === url && isEqual(socket.protocols, protocols),\n    );\n  }\n\n  /**\n   * Handle sending a specific WebSocketEvent to a Snap.\n   *\n   * @param snapId - The Snap ID.\n   * @param event - The WebSocketEvent.\n   */\n  #handleEvent(snapId: SnapId, event: WebSocketEvent) {\n    this.#messenger\n      .call('SnapController:handleRequest', {\n        origin: METAMASK_ORIGIN,\n        snapId,\n        handler: HandlerType.OnWebSocketEvent,\n        request: { method: '', params: { event } },\n      })\n      .catch((error) => {\n        logError(\n          `An error occurred while handling a WebSocket message for Snap \"${snapId}\":`,\n          error,\n        );\n      });\n  }\n\n  /**\n   * Open a WebSocket connection.\n   *\n   * @param snapId - The Snap ID.\n   * @param url - The URL for the WebSocket connection.\n   * @param protocols - An optional parameter for protocols.\n   * @returns The identifier for the opened connection.\n   * @throws If the connection fails.\n   */\n  async #open(snapId: SnapId, url: string, protocols: string[] = []) {\n    assert(\n      !this.#exists(snapId, url, protocols),\n      `An open WebSocket connection to ${url} already exists.`,\n    );\n\n    const parsedUrl = new URL(url);\n    const { origin } = parsedUrl;\n\n    const id = nanoid();\n\n    // eslint-disable-next-line no-restricted-globals\n    const socket = new WebSocket(url, protocols);\n    socket.binaryType = 'arraybuffer';\n\n    const { promise, resolve, reject } = createDeferredPromise();\n\n    socket.addEventListener('open', () => {\n      resolve();\n      this.#handleEvent(snapId, {\n        type: 'open',\n        id,\n        origin,\n      });\n    });\n\n    socket.addEventListener('close', (event) => {\n      this.#sockets.delete(id);\n\n      this.#handleEvent(snapId, {\n        type: 'close',\n        id,\n        origin,\n        code: event.code,\n        reason: event.reason,\n        // wasClean is not available on mobile.\n        wasClean: event.wasClean ?? null,\n      });\n    });\n\n    const errorListener = () => {\n      reject(\n        rpcErrors.resourceUnavailable(\n          'An error occurred while opening the WebSocket.',\n        ),\n      );\n    };\n\n    socket.addEventListener('error', errorListener);\n\n    socket.addEventListener('message', (event) => {\n      const isText = typeof event.data === 'string';\n      const data = isText\n        ? { type: 'text' as const, message: event.data }\n        : {\n            type: 'binary' as const,\n            // We request that the WebSocket gives us an array buffer.\n            message: Array.from(new Uint8Array(event.data)),\n          };\n\n      this.#handleEvent(snapId, {\n        type: 'message',\n        id,\n        origin,\n        data,\n      });\n    });\n\n    this.#sockets.set(id, {\n      id,\n      snapId,\n      url,\n      protocols,\n      socket,\n      openPromise: promise,\n    });\n\n    await promise;\n\n    socket.removeEventListener('error', errorListener);\n\n    return id;\n  }\n\n  /**\n   * Close a given WebSocket connection.\n   *\n   * @param snapId - The Snap ID.\n   * @param id - The identifier for the WebSocket connection.\n   */\n  #close(snapId: SnapId, id: string) {\n    const { socket } = this.#get(snapId, id);\n\n    socket.close();\n  }\n\n  /**\n   * Close all open connections for a given Snap ID.\n   *\n   * @param snapId - The Snap ID.\n   */\n  #closeAll(snapId: SnapId) {\n    for (const socket of this.#getAll(snapId)) {\n      this.#close(snapId, socket.id);\n    }\n  }\n\n  /**\n   * Send a message from a given Snap ID to a WebSocket connection.\n   *\n   * @param snapId - The Snap ID.\n   * @param id - The identifier for the WebSocket connection.\n   * @param data - The message to send.\n   */\n  async #sendMessage(snapId: SnapId, id: string, data: string | number[]) {\n    const { socket, openPromise } = this.#get(snapId, id);\n\n    await openPromise;\n\n    const wrappedData = Array.isArray(data) ? new Uint8Array(data) : data;\n\n    socket.send(wrappedData);\n  }\n\n  /**\n   * Get a list of all open WebSocket connections for a Snap ID.\n   *\n   * @param snapId - The Snap ID.\n   * @returns A list of WebSocket connections.\n   */\n  #getAll(snapId: SnapId) {\n    return [...this.#sockets.values()]\n      .filter((socket) => socket.snapId === snapId)\n      .map((socket) => ({\n        id: socket.id,\n        url: socket.url,\n        protocols: socket.protocols,\n      }));\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"WebSocketService.cjs","sourceRoot":"","sources":["../../src/websocket/WebSocketService.ts"],"names":[],"mappings":";;;AACA,qDAAiD;AAMjD,uDAAuE;AACvE,2CAAgE;AAChE,mCAAgC;AAQhC,8CAA2C;AAE3C,MAAM,WAAW,GAAG,kBAAkB,CAAC;AA+DvC,MAAa,gBAAgB;IAC3B,IAAI,GAAuB,WAAW,CAAC;IAEvC,KAAK,GAAG,IAAI,CAAC;IAEJ,UAAU,CAA4B;IAEtC,QAAQ,CAA8B;IAE/C,YAAY,EAAE,SAAS,EAAwB;QAC7C,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;QAC5B,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,EAAE,CAAC;QAE1B,IAAI,CAAC,UAAU,CAAC,qBAAqB,CACnC,GAAG,WAAW,OAAO,EACrB,KAAK,EAAE,GAAG,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,CACvC,CAAC;QAEF,IAAI,CAAC,UAAU,CAAC,qBAAqB,CAAC,GAAG,WAAW,QAAQ,EAAE,CAAC,GAAG,IAAI,EAAE,EAAE,CACxE,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,CACrB,CAAC;QAEF,IAAI,CAAC,UAAU,CAAC,qBAAqB,CACnC,GAAG,WAAW,cAAc,EAC5B,KAAK,EAAE,GAAG,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,CAC9C,CAAC;QAEF,IAAI,CAAC,UAAU,CAAC,qBAAqB,CAAC,GAAG,WAAW,SAAS,EAAE,CAAC,GAAG,IAAI,EAAE,EAAE,CACzE,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,CACtB,CAAC;QAEF,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,4BAA4B,EAAE,CAAC,IAAI,EAAE,EAAE;YAC/D,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAC1B,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,gCAAgC,EAAE,CAAC,IAAI,EAAE,EAAE;YACnE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAC1B,CAAC,CAAC,CAAC;QAEH,4EAA4E;QAC5E,2BAA2B;QAC3B,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,8BAA8B,EAAE,CAAC,IAAI,EAAE,EAAE;YACjE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAC1B,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;OAOG;IACH,IAAI,CAAC,MAAc,EAAE,EAAU;QAC7B,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAErC,IAAA,cAAM,EACJ,MAAM,IAAI,MAAM,CAAC,MAAM,KAAK,MAAM,EAClC,mBAAmB,EAAE,cAAc,CACpC,CAAC;QAEF,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;;;;;OAOG;IACH,OAAO,CAAC,MAAc,EAAE,GAAW,EAAE,SAAmB;QACtD,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,CAC9B,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,GAAG,KAAK,GAAG,IAAI,IAAA,qBAAO,EAAC,MAAM,CAAC,SAAS,EAAE,SAAS,CAAC,CACvE,CAAC;IACJ,CAAC;IAED;;;;;OAKG;IACH,YAAY,CAAC,MAAc,EAAE,KAAqB;QAChD,IAAI,CAAC,UAAU;aACZ,IAAI,CAAC,8BAA8B,EAAE;YACpC,MAAM,EAAE,uBAAe;YACvB,MAAM;YACN,OAAO,EAAE,yBAAW,CAAC,gBAAgB;YACrC,OAAO,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,KAAK,EAAE,EAAE;SAC3C,CAAC;aACD,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;YACf,IAAA,sBAAQ,EACN,kEAAkE,MAAM,IAAI,EAC5E,KAAK,CACN,CAAC;QACJ,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;;;OAQG;IACH,KAAK,CAAC,KAAK,CAAC,MAAc,EAAE,GAAW,EAAE,YAAsB,EAAE;QAC/D,IAAA,cAAM,EACJ,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,GAAG,EAAE,SAAS,CAAC,EACrC,mCAAmC,GAAG,kBAAkB,CACzD,CAAC;QAEF,MAAM,SAAS,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;QAC/B,MAAM,EAAE,MAAM,EAAE,GAAG,SAAS,CAAC;QAE7B,MAAM,EAAE,GAAG,IAAA,eAAM,GAAE,CAAC;QAEpB,iDAAiD;QACjD,MAAM,MAAM,GAAG,IAAI,SAAS,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;QAC7C,MAAM,CAAC,UAAU,GAAG,aAAa,CAAC;QAElC,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,IAAA,6BAAqB,GAAE,CAAC;QAE7D,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE,GAAG,EAAE;YACnC,OAAO,EAAE,CAAC;YACV,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE;gBACxB,IAAI,EAAE,MAAM;gBACZ,EAAE;gBACF,MAAM;aACP,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,CAAC,KAAK,EAAE,EAAE;YACzC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YAEzB,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE;gBACxB,IAAI,EAAE,OAAO;gBACb,EAAE;gBACF,MAAM;gBACN,IAAI,EAAE,KAAK,CAAC,IAAI;gBAChB,MAAM,EAAE,KAAK,CAAC,MAAM;gBACpB,uCAAuC;gBACvC,QAAQ,EAAE,KAAK,CAAC,QAAQ,IAAI,IAAI;aACjC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,MAAM,aAAa,GAAG,GAAG,EAAE;YACzB,MAAM,CACJ,sBAAS,CAAC,mBAAmB,CAC3B,gDAAgD,CACjD,CACF,CAAC;QACJ,CAAC,CAAC;QAEF,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;QAEhD,MAAM,CAAC,gBAAgB,CAAC,SAAS,EAAE,CAAC,KAAK,EAAE,EAAE;YAC3C,MAAM,MAAM,GAAG,OAAO,KAAK,CAAC,IAAI,KAAK,QAAQ,CAAC;YAC9C,MAAM,IAAI,GAAG,MAAM;gBACjB,CAAC,CAAC,EAAE,IAAI,EAAE,MAAe,EAAE,OAAO,EAAE,KAAK,CAAC,IAAI,EAAE;gBAChD,CAAC,CAAC;oBACE,IAAI,EAAE,QAAiB;oBACvB,0DAA0D;oBAC1D,OAAO,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;iBAChD,CAAC;YAEN,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE;gBACxB,IAAI,EAAE,SAAS;gBACf,EAAE;gBACF,MAAM;gBACN,IAAI;aACL,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,EAAE;YACpB,EAAE;YACF,MAAM;YACN,GAAG;YACH,SAAS;YACT,MAAM;YACN,WAAW,EAAE,OAAO;SACrB,CAAC,CAAC;QAEH,MAAM,OAAO,CAAC;QAEd,MAAM,CAAC,mBAAmB,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;QAEnD,OAAO,EAAE,CAAC;IACZ,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,MAAc,EAAE,EAAU;QAC/B,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAEzC,MAAM,CAAC,KAAK,EAAE,CAAC;IACjB,CAAC;IAED;;;;OAIG;IACH,SAAS,CAAC,MAAc;QACtB,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC;YAC1C,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC,CAAC;QACjC,CAAC;IACH,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,YAAY,CAAC,MAAc,EAAE,EAAU,EAAE,IAAuB;QACpE,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAEtD,MAAM,WAAW,CAAC;QAElB,MAAM,WAAW,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;QAEtE,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IAC3B,CAAC;IAED;;;;;OAKG;IACH,OAAO,CAAC,MAAc;QACpB,OAAO,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC;aAC/B,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,MAAM,KAAK,MAAM,CAAC;aAC5C,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;YAChB,EAAE,EAAE,MAAM,CAAC,EAAE;YACb,GAAG,EAAE,MAAM,CAAC,GAAG;YACf,SAAS,EAAE,MAAM,CAAC,SAAS;SAC5B,CAAC,CAAC,CAAC;IACR,CAAC;CACF;AAzPD,4CAyPC","sourcesContent":["import type { Messenger } from '@metamask/messenger';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type {\n  GetWebSocketsResult,\n  SnapId,\n  WebSocketEvent,\n} from '@metamask/snaps-sdk';\nimport { HandlerType, isEqual, logError } from '@metamask/snaps-utils';\nimport { assert, createDeferredPromise } from '@metamask/utils';\nimport { nanoid } from 'nanoid';\n\nimport type {\n  HandleSnapRequest,\n  SnapInstalled,\n  SnapUninstalled,\n  SnapUpdated,\n} from '../snaps';\nimport { METAMASK_ORIGIN } from '../snaps';\n\nconst serviceName = 'WebSocketService';\n\nexport type WebSocketServiceOpenAction = {\n  type: `${typeof serviceName}:open`;\n  handler: (\n    snapId: SnapId,\n    url: string,\n    protocols?: string[],\n  ) => Promise<string>;\n};\n\nexport type WebSocketServiceCloseAction = {\n  type: `${typeof serviceName}:close`;\n  handler: (snapId: SnapId, id: string) => void;\n};\n\nexport type WebSocketServiceSendMessageAction = {\n  type: `${typeof serviceName}:sendMessage`;\n  handler: (\n    snapId: SnapId,\n    id: string,\n    data: string | number[],\n  ) => Promise<void>;\n};\n\nexport type WebSocketServiceGetAllAction = {\n  type: `${typeof serviceName}:getAll`;\n  handler: (snapId: SnapId) => GetWebSocketsResult;\n};\n\nexport type WebSocketServiceActions =\n  | WebSocketServiceOpenAction\n  | WebSocketServiceCloseAction\n  | WebSocketServiceSendMessageAction\n  | WebSocketServiceGetAllAction;\n\nexport type WebSocketServiceAllowedActions = HandleSnapRequest;\n\nexport type WebSocketServiceEvents =\n  | SnapUninstalled\n  | SnapUpdated\n  | SnapInstalled;\n\nexport type WebSocketServiceMessenger = Messenger<\n  'WebSocketService',\n  WebSocketServiceActions | WebSocketServiceAllowedActions,\n  WebSocketServiceEvents\n>;\n\ntype WebSocketServiceArgs = {\n  messenger: WebSocketServiceMessenger;\n};\n\ntype InternalSocket = {\n  id: string;\n  snapId: SnapId;\n  url: string;\n  protocols: string[];\n  openPromise: Promise<void>;\n  // eslint-disable-next-line no-restricted-globals\n  socket: WebSocket;\n};\n\nexport class WebSocketService {\n  name: typeof serviceName = serviceName;\n\n  state = null;\n\n  readonly #messenger: WebSocketServiceMessenger;\n\n  readonly #sockets: Map<string, InternalSocket>;\n\n  constructor({ messenger }: WebSocketServiceArgs) {\n    this.#messenger = messenger;\n    this.#sockets = new Map();\n\n    this.#messenger.registerActionHandler(\n      `${serviceName}:open`,\n      async (...args) => this.#open(...args),\n    );\n\n    this.#messenger.registerActionHandler(`${serviceName}:close`, (...args) =>\n      this.#close(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${serviceName}:sendMessage`,\n      async (...args) => this.#sendMessage(...args),\n    );\n\n    this.#messenger.registerActionHandler(`${serviceName}:getAll`, (...args) =>\n      this.#getAll(...args),\n    );\n\n    this.#messenger.subscribe('SnapController:snapUpdated', (snap) => {\n      this.#closeAll(snap.id);\n    });\n\n    this.#messenger.subscribe('SnapController:snapUninstalled', (snap) => {\n      this.#closeAll(snap.id);\n    });\n\n    // Due to local Snaps not currently emitting snapUninstalled we also have to\n    // listen to snapInstalled.\n    this.#messenger.subscribe('SnapController:snapInstalled', (snap) => {\n      this.#closeAll(snap.id);\n    });\n  }\n\n  /**\n   * Get information about a given WebSocket connection with an ID.\n   *\n   * @param snapId - The Snap ID.\n   * @param id - The identifier for the WebSocket connection.\n   * @returns Information about the WebSocket connection.\n   * @throws If the WebSocket connection cannot be found.\n   */\n  #get(snapId: SnapId, id: string) {\n    const socket = this.#sockets.get(id);\n\n    assert(\n      socket && socket.snapId === snapId,\n      `Socket with ID \"${id}\" not found.`,\n    );\n\n    return socket;\n  }\n\n  /**\n   * Check whether a given Snap ID already has an open connection for a URL and protocol.\n   *\n   * @param snapId - The Snap ID.\n   * @param url - The URL.\n   * @param protocols - A protocols parameter.\n   * @returns True if a matching connection already exists, otherwise false.\n   */\n  #exists(snapId: SnapId, url: string, protocols: string[]) {\n    return this.#getAll(snapId).some(\n      (socket) => socket.url === url && isEqual(socket.protocols, protocols),\n    );\n  }\n\n  /**\n   * Handle sending a specific WebSocketEvent to a Snap.\n   *\n   * @param snapId - The Snap ID.\n   * @param event - The WebSocketEvent.\n   */\n  #handleEvent(snapId: SnapId, event: WebSocketEvent) {\n    this.#messenger\n      .call('SnapController:handleRequest', {\n        origin: METAMASK_ORIGIN,\n        snapId,\n        handler: HandlerType.OnWebSocketEvent,\n        request: { method: '', params: { event } },\n      })\n      .catch((error) => {\n        logError(\n          `An error occurred while handling a WebSocket message for Snap \"${snapId}\":`,\n          error,\n        );\n      });\n  }\n\n  /**\n   * Open a WebSocket connection.\n   *\n   * @param snapId - The Snap ID.\n   * @param url - The URL for the WebSocket connection.\n   * @param protocols - An optional parameter for protocols.\n   * @returns The identifier for the opened connection.\n   * @throws If the connection fails.\n   */\n  async #open(snapId: SnapId, url: string, protocols: string[] = []) {\n    assert(\n      !this.#exists(snapId, url, protocols),\n      `An open WebSocket connection to ${url} already exists.`,\n    );\n\n    const parsedUrl = new URL(url);\n    const { origin } = parsedUrl;\n\n    const id = nanoid();\n\n    // eslint-disable-next-line no-restricted-globals\n    const socket = new WebSocket(url, protocols);\n    socket.binaryType = 'arraybuffer';\n\n    const { promise, resolve, reject } = createDeferredPromise();\n\n    socket.addEventListener('open', () => {\n      resolve();\n      this.#handleEvent(snapId, {\n        type: 'open',\n        id,\n        origin,\n      });\n    });\n\n    socket.addEventListener('close', (event) => {\n      this.#sockets.delete(id);\n\n      this.#handleEvent(snapId, {\n        type: 'close',\n        id,\n        origin,\n        code: event.code,\n        reason: event.reason,\n        // wasClean is not available on mobile.\n        wasClean: event.wasClean ?? null,\n      });\n    });\n\n    const errorListener = () => {\n      reject(\n        rpcErrors.resourceUnavailable(\n          'An error occurred while opening the WebSocket.',\n        ),\n      );\n    };\n\n    socket.addEventListener('error', errorListener);\n\n    socket.addEventListener('message', (event) => {\n      const isText = typeof event.data === 'string';\n      const data = isText\n        ? { type: 'text' as const, message: event.data }\n        : {\n            type: 'binary' as const,\n            // We request that the WebSocket gives us an array buffer.\n            message: Array.from(new Uint8Array(event.data)),\n          };\n\n      this.#handleEvent(snapId, {\n        type: 'message',\n        id,\n        origin,\n        data,\n      });\n    });\n\n    this.#sockets.set(id, {\n      id,\n      snapId,\n      url,\n      protocols,\n      socket,\n      openPromise: promise,\n    });\n\n    await promise;\n\n    socket.removeEventListener('error', errorListener);\n\n    return id;\n  }\n\n  /**\n   * Close a given WebSocket connection.\n   *\n   * @param snapId - The Snap ID.\n   * @param id - The identifier for the WebSocket connection.\n   */\n  #close(snapId: SnapId, id: string) {\n    const { socket } = this.#get(snapId, id);\n\n    socket.close();\n  }\n\n  /**\n   * Close all open connections for a given Snap ID.\n   *\n   * @param snapId - The Snap ID.\n   */\n  #closeAll(snapId: SnapId) {\n    for (const socket of this.#getAll(snapId)) {\n      this.#close(snapId, socket.id);\n    }\n  }\n\n  /**\n   * Send a message from a given Snap ID to a WebSocket connection.\n   *\n   * @param snapId - The Snap ID.\n   * @param id - The identifier for the WebSocket connection.\n   * @param data - The message to send.\n   */\n  async #sendMessage(snapId: SnapId, id: string, data: string | number[]) {\n    const { socket, openPromise } = this.#get(snapId, id);\n\n    await openPromise;\n\n    const wrappedData = Array.isArray(data) ? new Uint8Array(data) : data;\n\n    socket.send(wrappedData);\n  }\n\n  /**\n   * Get a list of all open WebSocket connections for a Snap ID.\n   *\n   * @param snapId - The Snap ID.\n   * @returns A list of WebSocket connections.\n   */\n  #getAll(snapId: SnapId) {\n    return [...this.#sockets.values()]\n      .filter((socket) => socket.snapId === snapId)\n      .map((socket) => ({\n        id: socket.id,\n        url: socket.url,\n        protocols: socket.protocols,\n      }));\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/websocket/WebSocketService.d.cts b/dist/websocket/WebSocketService.d.cts
index a98536ebf99c6a59fd851277f42fb68afa63d112..f79129c9710f7dbe56cf972cd9e3825a7d9ce028 100644
--- a/dist/websocket/WebSocketService.d.cts
+++ b/dist/websocket/WebSocketService.d.cts
@@ -1,4 +1,4 @@
-import type { RestrictedMessenger } from "@metamask/base-controller";
+import type { Messenger } from "@metamask/messenger";
 import type { GetWebSocketsResult, SnapId } from "@metamask/snaps-sdk";
 import type { HandleSnapRequest, SnapInstalled, SnapUninstalled, SnapUpdated } from "../snaps/index.cjs";
 declare const serviceName = "WebSocketService";
@@ -21,7 +21,7 @@ export type WebSocketServiceGetAllAction = {
 export type WebSocketServiceActions = WebSocketServiceOpenAction | WebSocketServiceCloseAction | WebSocketServiceSendMessageAction | WebSocketServiceGetAllAction;
 export type WebSocketServiceAllowedActions = HandleSnapRequest;
 export type WebSocketServiceEvents = SnapUninstalled | SnapUpdated | SnapInstalled;
-export type WebSocketServiceMessenger = RestrictedMessenger<'WebSocketService', WebSocketServiceActions | WebSocketServiceAllowedActions, WebSocketServiceEvents, WebSocketServiceAllowedActions['type'], WebSocketServiceEvents['type']>;
+export type WebSocketServiceMessenger = Messenger<'WebSocketService', WebSocketServiceActions | WebSocketServiceAllowedActions, WebSocketServiceEvents>;
 type WebSocketServiceArgs = {
     messenger: WebSocketServiceMessenger;
 };
diff --git a/dist/websocket/WebSocketService.d.cts.map b/dist/websocket/WebSocketService.d.cts.map
index 0954b34c09b3882d311c33e0fe8249fa6a84ab61..255feb0112956c1892a7a07adce535e53606154a 100644
--- a/dist/websocket/WebSocketService.d.cts.map
+++ b/dist/websocket/WebSocketService.d.cts.map
@@ -1 +1 @@
-{"version":3,"file":"WebSocketService.d.cts","sourceRoot":"","sources":["../../src/websocket/WebSocketService.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,mBAAmB,EAAE,kCAAkC;AAErE,OAAO,KAAK,EACV,mBAAmB,EACnB,MAAM,EAEP,4BAA4B;AAK7B,OAAO,KAAK,EACV,iBAAiB,EACjB,aAAa,EACb,eAAe,EACf,WAAW,EACZ,2BAAiB;AAGlB,QAAA,MAAM,WAAW,qBAAqB,CAAC;AAEvC,MAAM,MAAM,0BAA0B,GAAG;IACvC,IAAI,EAAE,GAAG,OAAO,WAAW,OAAO,CAAC;IACnC,OAAO,EAAE,CACP,MAAM,EAAE,MAAM,EACd,GAAG,EAAE,MAAM,EACX,SAAS,CAAC,EAAE,MAAM,EAAE,KACjB,OAAO,CAAC,MAAM,CAAC,CAAC;CACtB,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG;IACxC,IAAI,EAAE,GAAG,OAAO,WAAW,QAAQ,CAAC;IACpC,OAAO,EAAE,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,KAAK,IAAI,CAAC;CAC/C,CAAC;AAEF,MAAM,MAAM,iCAAiC,GAAG;IAC9C,IAAI,EAAE,GAAG,OAAO,WAAW,cAAc,CAAC;IAC1C,OAAO,EAAE,CACP,MAAM,EAAE,MAAM,EACd,EAAE,EAAE,MAAM,EACV,IAAI,EAAE,MAAM,GAAG,MAAM,EAAE,KACpB,OAAO,CAAC,IAAI,CAAC,CAAC;CACpB,CAAC;AAEF,MAAM,MAAM,4BAA4B,GAAG;IACzC,IAAI,EAAE,GAAG,OAAO,WAAW,SAAS,CAAC;IACrC,OAAO,EAAE,CAAC,MAAM,EAAE,MAAM,KAAK,mBAAmB,CAAC;CAClD,CAAC;AAEF,MAAM,MAAM,uBAAuB,GAC/B,0BAA0B,GAC1B,2BAA2B,GAC3B,iCAAiC,GACjC,4BAA4B,CAAC;AAEjC,MAAM,MAAM,8BAA8B,GAAG,iBAAiB,CAAC;AAE/D,MAAM,MAAM,sBAAsB,GAC9B,eAAe,GACf,WAAW,GACX,aAAa,CAAC;AAElB,MAAM,MAAM,yBAAyB,GAAG,mBAAmB,CACzD,kBAAkB,EAClB,uBAAuB,GAAG,8BAA8B,EACxD,sBAAsB,EACtB,8BAA8B,CAAC,MAAM,CAAC,EACtC,sBAAsB,CAAC,MAAM,CAAC,CAC/B,CAAC;AAEF,KAAK,oBAAoB,GAAG;IAC1B,SAAS,EAAE,yBAAyB,CAAC;CACtC,CAAC;AAYF,qBAAa,gBAAgB;;IAC3B,IAAI,EAAE,OAAO,WAAW,CAAe;IAEvC,KAAK,OAAQ;gBAMD,EAAE,SAAS,EAAE,EAAE,oBAAoB;CAgPhD"}
\ No newline at end of file
+{"version":3,"file":"WebSocketService.d.cts","sourceRoot":"","sources":["../../src/websocket/WebSocketService.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,SAAS,EAAE,4BAA4B;AAErD,OAAO,KAAK,EACV,mBAAmB,EACnB,MAAM,EAEP,4BAA4B;AAK7B,OAAO,KAAK,EACV,iBAAiB,EACjB,aAAa,EACb,eAAe,EACf,WAAW,EACZ,2BAAiB;AAGlB,QAAA,MAAM,WAAW,qBAAqB,CAAC;AAEvC,MAAM,MAAM,0BAA0B,GAAG;IACvC,IAAI,EAAE,GAAG,OAAO,WAAW,OAAO,CAAC;IACnC,OAAO,EAAE,CACP,MAAM,EAAE,MAAM,EACd,GAAG,EAAE,MAAM,EACX,SAAS,CAAC,EAAE,MAAM,EAAE,KACjB,OAAO,CAAC,MAAM,CAAC,CAAC;CACtB,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG;IACxC,IAAI,EAAE,GAAG,OAAO,WAAW,QAAQ,CAAC;IACpC,OAAO,EAAE,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,KAAK,IAAI,CAAC;CAC/C,CAAC;AAEF,MAAM,MAAM,iCAAiC,GAAG;IAC9C,IAAI,EAAE,GAAG,OAAO,WAAW,cAAc,CAAC;IAC1C,OAAO,EAAE,CACP,MAAM,EAAE,MAAM,EACd,EAAE,EAAE,MAAM,EACV,IAAI,EAAE,MAAM,GAAG,MAAM,EAAE,KACpB,OAAO,CAAC,IAAI,CAAC,CAAC;CACpB,CAAC;AAEF,MAAM,MAAM,4BAA4B,GAAG;IACzC,IAAI,EAAE,GAAG,OAAO,WAAW,SAAS,CAAC;IACrC,OAAO,EAAE,CAAC,MAAM,EAAE,MAAM,KAAK,mBAAmB,CAAC;CAClD,CAAC;AAEF,MAAM,MAAM,uBAAuB,GAC/B,0BAA0B,GAC1B,2BAA2B,GAC3B,iCAAiC,GACjC,4BAA4B,CAAC;AAEjC,MAAM,MAAM,8BAA8B,GAAG,iBAAiB,CAAC;AAE/D,MAAM,MAAM,sBAAsB,GAC9B,eAAe,GACf,WAAW,GACX,aAAa,CAAC;AAElB,MAAM,MAAM,yBAAyB,GAAG,SAAS,CAC/C,kBAAkB,EAClB,uBAAuB,GAAG,8BAA8B,EACxD,sBAAsB,CACvB,CAAC;AAEF,KAAK,oBAAoB,GAAG;IAC1B,SAAS,EAAE,yBAAyB,CAAC;CACtC,CAAC;AAYF,qBAAa,gBAAgB;;IAC3B,IAAI,EAAE,OAAO,WAAW,CAAe;IAEvC,KAAK,OAAQ;gBAMD,EAAE,SAAS,EAAE,EAAE,oBAAoB;CAgPhD"}
\ No newline at end of file
diff --git a/dist/websocket/WebSocketService.d.mts b/dist/websocket/WebSocketService.d.mts
index fff1252789150c35cbe745f089083cbd25e65eda..aa4468f4d8ffa76e0e1dd5d771cfde2b73a24fa0 100644
--- a/dist/websocket/WebSocketService.d.mts
+++ b/dist/websocket/WebSocketService.d.mts
@@ -1,4 +1,4 @@
-import type { RestrictedMessenger } from "@metamask/base-controller";
+import type { Messenger } from "@metamask/messenger";
 import type { GetWebSocketsResult, SnapId } from "@metamask/snaps-sdk";
 import type { HandleSnapRequest, SnapInstalled, SnapUninstalled, SnapUpdated } from "../snaps/index.mjs";
 declare const serviceName = "WebSocketService";
@@ -21,7 +21,7 @@ export type WebSocketServiceGetAllAction = {
 export type WebSocketServiceActions = WebSocketServiceOpenAction | WebSocketServiceCloseAction | WebSocketServiceSendMessageAction | WebSocketServiceGetAllAction;
 export type WebSocketServiceAllowedActions = HandleSnapRequest;
 export type WebSocketServiceEvents = SnapUninstalled | SnapUpdated | SnapInstalled;
-export type WebSocketServiceMessenger = RestrictedMessenger<'WebSocketService', WebSocketServiceActions | WebSocketServiceAllowedActions, WebSocketServiceEvents, WebSocketServiceAllowedActions['type'], WebSocketServiceEvents['type']>;
+export type WebSocketServiceMessenger = Messenger<'WebSocketService', WebSocketServiceActions | WebSocketServiceAllowedActions, WebSocketServiceEvents>;
 type WebSocketServiceArgs = {
     messenger: WebSocketServiceMessenger;
 };
diff --git a/dist/websocket/WebSocketService.d.mts.map b/dist/websocket/WebSocketService.d.mts.map
index e3fd8b22776cda79cf3d4f0875356e3f290d24eb..155192d4ed152d0c2fcb4f920bfe8d966f6a907c 100644
--- a/dist/websocket/WebSocketService.d.mts.map
+++ b/dist/websocket/WebSocketService.d.mts.map
@@ -1 +1 @@
-{"version":3,"file":"WebSocketService.d.mts","sourceRoot":"","sources":["../../src/websocket/WebSocketService.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,mBAAmB,EAAE,kCAAkC;AAErE,OAAO,KAAK,EACV,mBAAmB,EACnB,MAAM,EAEP,4BAA4B;AAK7B,OAAO,KAAK,EACV,iBAAiB,EACjB,aAAa,EACb,eAAe,EACf,WAAW,EACZ,2BAAiB;AAGlB,QAAA,MAAM,WAAW,qBAAqB,CAAC;AAEvC,MAAM,MAAM,0BAA0B,GAAG;IACvC,IAAI,EAAE,GAAG,OAAO,WAAW,OAAO,CAAC;IACnC,OAAO,EAAE,CACP,MAAM,EAAE,MAAM,EACd,GAAG,EAAE,MAAM,EACX,SAAS,CAAC,EAAE,MAAM,EAAE,KACjB,OAAO,CAAC,MAAM,CAAC,CAAC;CACtB,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG;IACxC,IAAI,EAAE,GAAG,OAAO,WAAW,QAAQ,CAAC;IACpC,OAAO,EAAE,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,KAAK,IAAI,CAAC;CAC/C,CAAC;AAEF,MAAM,MAAM,iCAAiC,GAAG;IAC9C,IAAI,EAAE,GAAG,OAAO,WAAW,cAAc,CAAC;IAC1C,OAAO,EAAE,CACP,MAAM,EAAE,MAAM,EACd,EAAE,EAAE,MAAM,EACV,IAAI,EAAE,MAAM,GAAG,MAAM,EAAE,KACpB,OAAO,CAAC,IAAI,CAAC,CAAC;CACpB,CAAC;AAEF,MAAM,MAAM,4BAA4B,GAAG;IACzC,IAAI,EAAE,GAAG,OAAO,WAAW,SAAS,CAAC;IACrC,OAAO,EAAE,CAAC,MAAM,EAAE,MAAM,KAAK,mBAAmB,CAAC;CAClD,CAAC;AAEF,MAAM,MAAM,uBAAuB,GAC/B,0BAA0B,GAC1B,2BAA2B,GAC3B,iCAAiC,GACjC,4BAA4B,CAAC;AAEjC,MAAM,MAAM,8BAA8B,GAAG,iBAAiB,CAAC;AAE/D,MAAM,MAAM,sBAAsB,GAC9B,eAAe,GACf,WAAW,GACX,aAAa,CAAC;AAElB,MAAM,MAAM,yBAAyB,GAAG,mBAAmB,CACzD,kBAAkB,EAClB,uBAAuB,GAAG,8BAA8B,EACxD,sBAAsB,EACtB,8BAA8B,CAAC,MAAM,CAAC,EACtC,sBAAsB,CAAC,MAAM,CAAC,CAC/B,CAAC;AAEF,KAAK,oBAAoB,GAAG;IAC1B,SAAS,EAAE,yBAAyB,CAAC;CACtC,CAAC;AAYF,qBAAa,gBAAgB;;IAC3B,IAAI,EAAE,OAAO,WAAW,CAAe;IAEvC,KAAK,OAAQ;gBAMD,EAAE,SAAS,EAAE,EAAE,oBAAoB;CAgPhD"}
\ No newline at end of file
+{"version":3,"file":"WebSocketService.d.mts","sourceRoot":"","sources":["../../src/websocket/WebSocketService.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,SAAS,EAAE,4BAA4B;AAErD,OAAO,KAAK,EACV,mBAAmB,EACnB,MAAM,EAEP,4BAA4B;AAK7B,OAAO,KAAK,EACV,iBAAiB,EACjB,aAAa,EACb,eAAe,EACf,WAAW,EACZ,2BAAiB;AAGlB,QAAA,MAAM,WAAW,qBAAqB,CAAC;AAEvC,MAAM,MAAM,0BAA0B,GAAG;IACvC,IAAI,EAAE,GAAG,OAAO,WAAW,OAAO,CAAC;IACnC,OAAO,EAAE,CACP,MAAM,EAAE,MAAM,EACd,GAAG,EAAE,MAAM,EACX,SAAS,CAAC,EAAE,MAAM,EAAE,KACjB,OAAO,CAAC,MAAM,CAAC,CAAC;CACtB,CAAC;AAEF,MAAM,MAAM,2BAA2B,GAAG;IACxC,IAAI,EAAE,GAAG,OAAO,WAAW,QAAQ,CAAC;IACpC,OAAO,EAAE,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,KAAK,IAAI,CAAC;CAC/C,CAAC;AAEF,MAAM,MAAM,iCAAiC,GAAG;IAC9C,IAAI,EAAE,GAAG,OAAO,WAAW,cAAc,CAAC;IAC1C,OAAO,EAAE,CACP,MAAM,EAAE,MAAM,EACd,EAAE,EAAE,MAAM,EACV,IAAI,EAAE,MAAM,GAAG,MAAM,EAAE,KACpB,OAAO,CAAC,IAAI,CAAC,CAAC;CACpB,CAAC;AAEF,MAAM,MAAM,4BAA4B,GAAG;IACzC,IAAI,EAAE,GAAG,OAAO,WAAW,SAAS,CAAC;IACrC,OAAO,EAAE,CAAC,MAAM,EAAE,MAAM,KAAK,mBAAmB,CAAC;CAClD,CAAC;AAEF,MAAM,MAAM,uBAAuB,GAC/B,0BAA0B,GAC1B,2BAA2B,GAC3B,iCAAiC,GACjC,4BAA4B,CAAC;AAEjC,MAAM,MAAM,8BAA8B,GAAG,iBAAiB,CAAC;AAE/D,MAAM,MAAM,sBAAsB,GAC9B,eAAe,GACf,WAAW,GACX,aAAa,CAAC;AAElB,MAAM,MAAM,yBAAyB,GAAG,SAAS,CAC/C,kBAAkB,EAClB,uBAAuB,GAAG,8BAA8B,EACxD,sBAAsB,CACvB,CAAC;AAEF,KAAK,oBAAoB,GAAG;IAC1B,SAAS,EAAE,yBAAyB,CAAC;CACtC,CAAC;AAYF,qBAAa,gBAAgB;;IAC3B,IAAI,EAAE,OAAO,WAAW,CAAe;IAEvC,KAAK,OAAQ;gBAMD,EAAE,SAAS,EAAE,EAAE,oBAAoB;CAgPhD"}
\ No newline at end of file
diff --git a/dist/websocket/WebSocketService.mjs.map b/dist/websocket/WebSocketService.mjs.map
index 201a26c4db772a410be4305baab0f7a1035eb745..b22e272465f8927a3dd172e30a219ccc810ce5c7 100644
--- a/dist/websocket/WebSocketService.mjs.map
+++ b/dist/websocket/WebSocketService.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"WebSocketService.mjs","sourceRoot":"","sources":["../../src/websocket/WebSocketService.ts"],"names":[],"mappings":"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","sourcesContent":["import type { RestrictedMessenger } from '@metamask/base-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type {\n  GetWebSocketsResult,\n  SnapId,\n  WebSocketEvent,\n} from '@metamask/snaps-sdk';\nimport { HandlerType, isEqual, logError } from '@metamask/snaps-utils';\nimport { assert, createDeferredPromise } from '@metamask/utils';\nimport { nanoid } from 'nanoid';\n\nimport type {\n  HandleSnapRequest,\n  SnapInstalled,\n  SnapUninstalled,\n  SnapUpdated,\n} from '../snaps';\nimport { METAMASK_ORIGIN } from '../snaps';\n\nconst serviceName = 'WebSocketService';\n\nexport type WebSocketServiceOpenAction = {\n  type: `${typeof serviceName}:open`;\n  handler: (\n    snapId: SnapId,\n    url: string,\n    protocols?: string[],\n  ) => Promise<string>;\n};\n\nexport type WebSocketServiceCloseAction = {\n  type: `${typeof serviceName}:close`;\n  handler: (snapId: SnapId, id: string) => void;\n};\n\nexport type WebSocketServiceSendMessageAction = {\n  type: `${typeof serviceName}:sendMessage`;\n  handler: (\n    snapId: SnapId,\n    id: string,\n    data: string | number[],\n  ) => Promise<void>;\n};\n\nexport type WebSocketServiceGetAllAction = {\n  type: `${typeof serviceName}:getAll`;\n  handler: (snapId: SnapId) => GetWebSocketsResult;\n};\n\nexport type WebSocketServiceActions =\n  | WebSocketServiceOpenAction\n  | WebSocketServiceCloseAction\n  | WebSocketServiceSendMessageAction\n  | WebSocketServiceGetAllAction;\n\nexport type WebSocketServiceAllowedActions = HandleSnapRequest;\n\nexport type WebSocketServiceEvents =\n  | SnapUninstalled\n  | SnapUpdated\n  | SnapInstalled;\n\nexport type WebSocketServiceMessenger = RestrictedMessenger<\n  'WebSocketService',\n  WebSocketServiceActions | WebSocketServiceAllowedActions,\n  WebSocketServiceEvents,\n  WebSocketServiceAllowedActions['type'],\n  WebSocketServiceEvents['type']\n>;\n\ntype WebSocketServiceArgs = {\n  messenger: WebSocketServiceMessenger;\n};\n\ntype InternalSocket = {\n  id: string;\n  snapId: SnapId;\n  url: string;\n  protocols: string[];\n  openPromise: Promise<void>;\n  // eslint-disable-next-line no-restricted-globals\n  socket: WebSocket;\n};\n\nexport class WebSocketService {\n  name: typeof serviceName = serviceName;\n\n  state = null;\n\n  readonly #messenger: WebSocketServiceMessenger;\n\n  readonly #sockets: Map<string, InternalSocket>;\n\n  constructor({ messenger }: WebSocketServiceArgs) {\n    this.#messenger = messenger;\n    this.#sockets = new Map();\n\n    this.#messenger.registerActionHandler(\n      `${serviceName}:open`,\n      async (...args) => this.#open(...args),\n    );\n\n    this.#messenger.registerActionHandler(`${serviceName}:close`, (...args) =>\n      this.#close(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${serviceName}:sendMessage`,\n      async (...args) => this.#sendMessage(...args),\n    );\n\n    this.#messenger.registerActionHandler(`${serviceName}:getAll`, (...args) =>\n      this.#getAll(...args),\n    );\n\n    this.#messenger.subscribe('SnapController:snapUpdated', (snap) => {\n      this.#closeAll(snap.id);\n    });\n\n    this.#messenger.subscribe('SnapController:snapUninstalled', (snap) => {\n      this.#closeAll(snap.id);\n    });\n\n    // Due to local Snaps not currently emitting snapUninstalled we also have to\n    // listen to snapInstalled.\n    this.#messenger.subscribe('SnapController:snapInstalled', (snap) => {\n      this.#closeAll(snap.id);\n    });\n  }\n\n  /**\n   * Get information about a given WebSocket connection with an ID.\n   *\n   * @param snapId - The Snap ID.\n   * @param id - The identifier for the WebSocket connection.\n   * @returns Information about the WebSocket connection.\n   * @throws If the WebSocket connection cannot be found.\n   */\n  #get(snapId: SnapId, id: string) {\n    const socket = this.#sockets.get(id);\n\n    assert(\n      socket && socket.snapId === snapId,\n      `Socket with ID \"${id}\" not found.`,\n    );\n\n    return socket;\n  }\n\n  /**\n   * Check whether a given Snap ID already has an open connection for a URL and protocol.\n   *\n   * @param snapId - The Snap ID.\n   * @param url - The URL.\n   * @param protocols - A protocols parameter.\n   * @returns True if a matching connection already exists, otherwise false.\n   */\n  #exists(snapId: SnapId, url: string, protocols: string[]) {\n    return this.#getAll(snapId).some(\n      (socket) => socket.url === url && isEqual(socket.protocols, protocols),\n    );\n  }\n\n  /**\n   * Handle sending a specific WebSocketEvent to a Snap.\n   *\n   * @param snapId - The Snap ID.\n   * @param event - The WebSocketEvent.\n   */\n  #handleEvent(snapId: SnapId, event: WebSocketEvent) {\n    this.#messenger\n      .call('SnapController:handleRequest', {\n        origin: METAMASK_ORIGIN,\n        snapId,\n        handler: HandlerType.OnWebSocketEvent,\n        request: { method: '', params: { event } },\n      })\n      .catch((error) => {\n        logError(\n          `An error occurred while handling a WebSocket message for Snap \"${snapId}\":`,\n          error,\n        );\n      });\n  }\n\n  /**\n   * Open a WebSocket connection.\n   *\n   * @param snapId - The Snap ID.\n   * @param url - The URL for the WebSocket connection.\n   * @param protocols - An optional parameter for protocols.\n   * @returns The identifier for the opened connection.\n   * @throws If the connection fails.\n   */\n  async #open(snapId: SnapId, url: string, protocols: string[] = []) {\n    assert(\n      !this.#exists(snapId, url, protocols),\n      `An open WebSocket connection to ${url} already exists.`,\n    );\n\n    const parsedUrl = new URL(url);\n    const { origin } = parsedUrl;\n\n    const id = nanoid();\n\n    // eslint-disable-next-line no-restricted-globals\n    const socket = new WebSocket(url, protocols);\n    socket.binaryType = 'arraybuffer';\n\n    const { promise, resolve, reject } = createDeferredPromise();\n\n    socket.addEventListener('open', () => {\n      resolve();\n      this.#handleEvent(snapId, {\n        type: 'open',\n        id,\n        origin,\n      });\n    });\n\n    socket.addEventListener('close', (event) => {\n      this.#sockets.delete(id);\n\n      this.#handleEvent(snapId, {\n        type: 'close',\n        id,\n        origin,\n        code: event.code,\n        reason: event.reason,\n        // wasClean is not available on mobile.\n        wasClean: event.wasClean ?? null,\n      });\n    });\n\n    const errorListener = () => {\n      reject(\n        rpcErrors.resourceUnavailable(\n          'An error occurred while opening the WebSocket.',\n        ),\n      );\n    };\n\n    socket.addEventListener('error', errorListener);\n\n    socket.addEventListener('message', (event) => {\n      const isText = typeof event.data === 'string';\n      const data = isText\n        ? { type: 'text' as const, message: event.data }\n        : {\n            type: 'binary' as const,\n            // We request that the WebSocket gives us an array buffer.\n            message: Array.from(new Uint8Array(event.data)),\n          };\n\n      this.#handleEvent(snapId, {\n        type: 'message',\n        id,\n        origin,\n        data,\n      });\n    });\n\n    this.#sockets.set(id, {\n      id,\n      snapId,\n      url,\n      protocols,\n      socket,\n      openPromise: promise,\n    });\n\n    await promise;\n\n    socket.removeEventListener('error', errorListener);\n\n    return id;\n  }\n\n  /**\n   * Close a given WebSocket connection.\n   *\n   * @param snapId - The Snap ID.\n   * @param id - The identifier for the WebSocket connection.\n   */\n  #close(snapId: SnapId, id: string) {\n    const { socket } = this.#get(snapId, id);\n\n    socket.close();\n  }\n\n  /**\n   * Close all open connections for a given Snap ID.\n   *\n   * @param snapId - The Snap ID.\n   */\n  #closeAll(snapId: SnapId) {\n    for (const socket of this.#getAll(snapId)) {\n      this.#close(snapId, socket.id);\n    }\n  }\n\n  /**\n   * Send a message from a given Snap ID to a WebSocket connection.\n   *\n   * @param snapId - The Snap ID.\n   * @param id - The identifier for the WebSocket connection.\n   * @param data - The message to send.\n   */\n  async #sendMessage(snapId: SnapId, id: string, data: string | number[]) {\n    const { socket, openPromise } = this.#get(snapId, id);\n\n    await openPromise;\n\n    const wrappedData = Array.isArray(data) ? new Uint8Array(data) : data;\n\n    socket.send(wrappedData);\n  }\n\n  /**\n   * Get a list of all open WebSocket connections for a Snap ID.\n   *\n   * @param snapId - The Snap ID.\n   * @returns A list of WebSocket connections.\n   */\n  #getAll(snapId: SnapId) {\n    return [...this.#sockets.values()]\n      .filter((socket) => socket.snapId === snapId)\n      .map((socket) => ({\n        id: socket.id,\n        url: socket.url,\n        protocols: socket.protocols,\n      }));\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"WebSocketService.mjs","sourceRoot":"","sources":["../../src/websocket/WebSocketService.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Messenger } from '@metamask/messenger';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type {\n  GetWebSocketsResult,\n  SnapId,\n  WebSocketEvent,\n} from '@metamask/snaps-sdk';\nimport { HandlerType, isEqual, logError } from '@metamask/snaps-utils';\nimport { assert, createDeferredPromise } from '@metamask/utils';\nimport { nanoid } from 'nanoid';\n\nimport type {\n  HandleSnapRequest,\n  SnapInstalled,\n  SnapUninstalled,\n  SnapUpdated,\n} from '../snaps';\nimport { METAMASK_ORIGIN } from '../snaps';\n\nconst serviceName = 'WebSocketService';\n\nexport type WebSocketServiceOpenAction = {\n  type: `${typeof serviceName}:open`;\n  handler: (\n    snapId: SnapId,\n    url: string,\n    protocols?: string[],\n  ) => Promise<string>;\n};\n\nexport type WebSocketServiceCloseAction = {\n  type: `${typeof serviceName}:close`;\n  handler: (snapId: SnapId, id: string) => void;\n};\n\nexport type WebSocketServiceSendMessageAction = {\n  type: `${typeof serviceName}:sendMessage`;\n  handler: (\n    snapId: SnapId,\n    id: string,\n    data: string | number[],\n  ) => Promise<void>;\n};\n\nexport type WebSocketServiceGetAllAction = {\n  type: `${typeof serviceName}:getAll`;\n  handler: (snapId: SnapId) => GetWebSocketsResult;\n};\n\nexport type WebSocketServiceActions =\n  | WebSocketServiceOpenAction\n  | WebSocketServiceCloseAction\n  | WebSocketServiceSendMessageAction\n  | WebSocketServiceGetAllAction;\n\nexport type WebSocketServiceAllowedActions = HandleSnapRequest;\n\nexport type WebSocketServiceEvents =\n  | SnapUninstalled\n  | SnapUpdated\n  | SnapInstalled;\n\nexport type WebSocketServiceMessenger = Messenger<\n  'WebSocketService',\n  WebSocketServiceActions | WebSocketServiceAllowedActions,\n  WebSocketServiceEvents\n>;\n\ntype WebSocketServiceArgs = {\n  messenger: WebSocketServiceMessenger;\n};\n\ntype InternalSocket = {\n  id: string;\n  snapId: SnapId;\n  url: string;\n  protocols: string[];\n  openPromise: Promise<void>;\n  // eslint-disable-next-line no-restricted-globals\n  socket: WebSocket;\n};\n\nexport class WebSocketService {\n  name: typeof serviceName = serviceName;\n\n  state = null;\n\n  readonly #messenger: WebSocketServiceMessenger;\n\n  readonly #sockets: Map<string, InternalSocket>;\n\n  constructor({ messenger }: WebSocketServiceArgs) {\n    this.#messenger = messenger;\n    this.#sockets = new Map();\n\n    this.#messenger.registerActionHandler(\n      `${serviceName}:open`,\n      async (...args) => this.#open(...args),\n    );\n\n    this.#messenger.registerActionHandler(`${serviceName}:close`, (...args) =>\n      this.#close(...args),\n    );\n\n    this.#messenger.registerActionHandler(\n      `${serviceName}:sendMessage`,\n      async (...args) => this.#sendMessage(...args),\n    );\n\n    this.#messenger.registerActionHandler(`${serviceName}:getAll`, (...args) =>\n      this.#getAll(...args),\n    );\n\n    this.#messenger.subscribe('SnapController:snapUpdated', (snap) => {\n      this.#closeAll(snap.id);\n    });\n\n    this.#messenger.subscribe('SnapController:snapUninstalled', (snap) => {\n      this.#closeAll(snap.id);\n    });\n\n    // Due to local Snaps not currently emitting snapUninstalled we also have to\n    // listen to snapInstalled.\n    this.#messenger.subscribe('SnapController:snapInstalled', (snap) => {\n      this.#closeAll(snap.id);\n    });\n  }\n\n  /**\n   * Get information about a given WebSocket connection with an ID.\n   *\n   * @param snapId - The Snap ID.\n   * @param id - The identifier for the WebSocket connection.\n   * @returns Information about the WebSocket connection.\n   * @throws If the WebSocket connection cannot be found.\n   */\n  #get(snapId: SnapId, id: string) {\n    const socket = this.#sockets.get(id);\n\n    assert(\n      socket && socket.snapId === snapId,\n      `Socket with ID \"${id}\" not found.`,\n    );\n\n    return socket;\n  }\n\n  /**\n   * Check whether a given Snap ID already has an open connection for a URL and protocol.\n   *\n   * @param snapId - The Snap ID.\n   * @param url - The URL.\n   * @param protocols - A protocols parameter.\n   * @returns True if a matching connection already exists, otherwise false.\n   */\n  #exists(snapId: SnapId, url: string, protocols: string[]) {\n    return this.#getAll(snapId).some(\n      (socket) => socket.url === url && isEqual(socket.protocols, protocols),\n    );\n  }\n\n  /**\n   * Handle sending a specific WebSocketEvent to a Snap.\n   *\n   * @param snapId - The Snap ID.\n   * @param event - The WebSocketEvent.\n   */\n  #handleEvent(snapId: SnapId, event: WebSocketEvent) {\n    this.#messenger\n      .call('SnapController:handleRequest', {\n        origin: METAMASK_ORIGIN,\n        snapId,\n        handler: HandlerType.OnWebSocketEvent,\n        request: { method: '', params: { event } },\n      })\n      .catch((error) => {\n        logError(\n          `An error occurred while handling a WebSocket message for Snap \"${snapId}\":`,\n          error,\n        );\n      });\n  }\n\n  /**\n   * Open a WebSocket connection.\n   *\n   * @param snapId - The Snap ID.\n   * @param url - The URL for the WebSocket connection.\n   * @param protocols - An optional parameter for protocols.\n   * @returns The identifier for the opened connection.\n   * @throws If the connection fails.\n   */\n  async #open(snapId: SnapId, url: string, protocols: string[] = []) {\n    assert(\n      !this.#exists(snapId, url, protocols),\n      `An open WebSocket connection to ${url} already exists.`,\n    );\n\n    const parsedUrl = new URL(url);\n    const { origin } = parsedUrl;\n\n    const id = nanoid();\n\n    // eslint-disable-next-line no-restricted-globals\n    const socket = new WebSocket(url, protocols);\n    socket.binaryType = 'arraybuffer';\n\n    const { promise, resolve, reject } = createDeferredPromise();\n\n    socket.addEventListener('open', () => {\n      resolve();\n      this.#handleEvent(snapId, {\n        type: 'open',\n        id,\n        origin,\n      });\n    });\n\n    socket.addEventListener('close', (event) => {\n      this.#sockets.delete(id);\n\n      this.#handleEvent(snapId, {\n        type: 'close',\n        id,\n        origin,\n        code: event.code,\n        reason: event.reason,\n        // wasClean is not available on mobile.\n        wasClean: event.wasClean ?? null,\n      });\n    });\n\n    const errorListener = () => {\n      reject(\n        rpcErrors.resourceUnavailable(\n          'An error occurred while opening the WebSocket.',\n        ),\n      );\n    };\n\n    socket.addEventListener('error', errorListener);\n\n    socket.addEventListener('message', (event) => {\n      const isText = typeof event.data === 'string';\n      const data = isText\n        ? { type: 'text' as const, message: event.data }\n        : {\n            type: 'binary' as const,\n            // We request that the WebSocket gives us an array buffer.\n            message: Array.from(new Uint8Array(event.data)),\n          };\n\n      this.#handleEvent(snapId, {\n        type: 'message',\n        id,\n        origin,\n        data,\n      });\n    });\n\n    this.#sockets.set(id, {\n      id,\n      snapId,\n      url,\n      protocols,\n      socket,\n      openPromise: promise,\n    });\n\n    await promise;\n\n    socket.removeEventListener('error', errorListener);\n\n    return id;\n  }\n\n  /**\n   * Close a given WebSocket connection.\n   *\n   * @param snapId - The Snap ID.\n   * @param id - The identifier for the WebSocket connection.\n   */\n  #close(snapId: SnapId, id: string) {\n    const { socket } = this.#get(snapId, id);\n\n    socket.close();\n  }\n\n  /**\n   * Close all open connections for a given Snap ID.\n   *\n   * @param snapId - The Snap ID.\n   */\n  #closeAll(snapId: SnapId) {\n    for (const socket of this.#getAll(snapId)) {\n      this.#close(snapId, socket.id);\n    }\n  }\n\n  /**\n   * Send a message from a given Snap ID to a WebSocket connection.\n   *\n   * @param snapId - The Snap ID.\n   * @param id - The identifier for the WebSocket connection.\n   * @param data - The message to send.\n   */\n  async #sendMessage(snapId: SnapId, id: string, data: string | number[]) {\n    const { socket, openPromise } = this.#get(snapId, id);\n\n    await openPromise;\n\n    const wrappedData = Array.isArray(data) ? new Uint8Array(data) : data;\n\n    socket.send(wrappedData);\n  }\n\n  /**\n   * Get a list of all open WebSocket connections for a Snap ID.\n   *\n   * @param snapId - The Snap ID.\n   * @returns A list of WebSocket connections.\n   */\n  #getAll(snapId: SnapId) {\n    return [...this.#sockets.values()]\n      .filter((socket) => socket.snapId === snapId)\n      .map((socket) => ({\n        id: socket.id,\n        url: socket.url,\n        protocols: socket.protocols,\n      }));\n  }\n}\n"]}
\ No newline at end of file
diff --git a/package.json b/package.json
index e5d49bd61a56bcc71e686f6cb8891772f036eaca..cf800f8531cd20e1c10f3132700693ce7bdbbcae 100644
--- a/package.json
+++ b/package.json
@@ -84,15 +84,16 @@
     "@metamask/json-rpc-engine": "^10.1.0",
     "@metamask/json-rpc-middleware-stream": "^8.0.8",
     "@metamask/key-tree": "^10.1.1",
+    "@metamask/messenger": "^0.3.0",
     "@metamask/object-multiplex": "^2.1.0",
     "@metamask/permission-controller": "^11.0.6",
     "@metamask/phishing-controller": "^13.1.0",
     "@metamask/post-message-stream": "^10.0.0",
     "@metamask/rpc-errors": "^7.0.3",
     "@metamask/snaps-registry": "^3.2.3",
-    "@metamask/snaps-rpc-methods": "^13.5.3",
-    "@metamask/snaps-sdk": "^10.0.0",
-    "@metamask/snaps-utils": "^11.6.0",
+    "@metamask/snaps-rpc-methods": "workspace:^",
+    "@metamask/snaps-sdk": "workspace:^",
+    "@metamask/snaps-utils": "workspace:^",
     "@metamask/utils": "^11.8.1",
     "@xstate/fsm": "^2.0.0",
     "async-mutex": "^0.5.0",
@@ -146,7 +147,7 @@
     "vitest": "^3.1.1"
   },
   "peerDependencies": {
-    "@metamask/snaps-execution-environments": "^10.2.2"
+    "@metamask/snaps-execution-environments": "workspace:^"
   },
   "peerDependenciesMeta": {
     "@metamask/snaps-execution-environments": {
