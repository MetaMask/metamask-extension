diff --git a/dist/snaps/SnapController.d.ts b/dist/snaps/SnapController.d.ts
index 132ded2cbd7d10ecf9c978a7a8570dd26168fdf4..5af5c86a27805a246a5305bbed4748db7e5bd39e 100644
--- a/dist/snaps/SnapController.d.ts
+++ b/dist/snaps/SnapController.d.ts
@@ -1,7 +1,7 @@
 import { AddApprovalRequest } from '@metamask/approval-controller';
 import { BaseControllerV2 as BaseController, RestrictedControllerMessenger } from '@metamask/base-controller';
 import { GetEndowments, GetPermissions, GrantPermissions, HasPermission, HasPermissions, RevokeAllPermissions, RevokePermissionForAllSubjects, RevokePermissions } from '@metamask/permission-controller';
-import { BlockedSnapInfo, InstallSnapsResult, PersistedSnap, RequestedSnapPermissions, Snap, SnapId, SnapRpcHook, SnapRpcHookArgs, SnapStatusEvents, StatusContext, StatusEvents, StatusStates, TruncatedSnap, ValidatedSnapId } from '@metamask/snaps-utils';
+import { InstallSnapsResult, PersistedSnap, RequestedSnapPermissions, Snap, SnapId, SnapRpcHook, SnapRpcHookArgs, SnapStatusEvents, StatusContext, StatusEvents, StatusStates, TruncatedSnap, ValidatedSnapId, SnapRegistry, SnapRegistryBlockReason } from '@metamask/snaps-utils';
 import { GetSubjectMetadata } from '@metamask/subject-metadata-controller';
 import { Json } from '@metamask/utils';
 import { StateMachine } from '@xstate/fsm';
@@ -185,7 +185,7 @@ export declare type SnapAdded = {
  */
 export declare type SnapBlocked = {
     type: `${typeof controllerName}:snapBlocked`;
-    payload: [snapId: string, blockedSnapInfo: BlockedSnapInfo];
+    payload: [snapId: string, blockedSnapInfo?: SnapRegistryBlockReason];
 };
 /**
  * Emitted when a snap has been started after being added and authorized during
@@ -244,24 +244,8 @@ declare type FeatureFlags = {
      * @see {SnapController.processRequestedSnap}
      */
     dappsCanUpdateSnaps?: true;
+    requireAllowlist?: true;
 };
-declare type SemVerVersion = string;
-declare type SnapInfo = {
-    version: SemVerVersion;
-    shasum: string;
-};
-export declare type CheckSnapBlockListArg = Record<SnapId, SnapInfo>;
-export declare type CheckSnapBlockListResult = Record<SnapId, {
-    blocked: true;
-    reason?: string;
-    infoUrl?: string;
-} | {
-    blocked: false;
-}>;
-/**
- * Checks whether a version of a snap is blocked.
- */
-export declare type CheckSnapBlockList = (snapsToCheck: CheckSnapBlockListArg) => Promise<CheckSnapBlockListResult>;
 declare type SnapControllerArgs = {
     /**
      * A teardown function that allows the host to clean up its instrumentation
@@ -288,9 +272,9 @@ declare type SnapControllerArgs = {
      */
     idleTimeCheckInterval?: number;
     /**
-     * A function that checks whether the specified snap and version is blocked.
+     * TODO
      */
-    checkBlockList: CheckSnapBlockList;
+    registry: SnapRegistry;
     /**
      * The maximum amount of time that a snap may be idle.
      */
@@ -323,21 +307,13 @@ export declare class SnapController extends BaseController<string, SnapControlle
     #private;
     private readonly maxRequestTime;
     private readonly snapsRuntimeData;
-    constructor({ closeAllConnections, messenger, state, environmentEndowmentPermissions, idleTimeCheckInterval, checkBlockList, maxIdleTime, maxRequestTime, fetchFunction, featureFlags, detectSnapLocation: detectSnapLocationFunction, }: SnapControllerArgs);
+    constructor({ closeAllConnections, messenger, state, environmentEndowmentPermissions, idleTimeCheckInterval, registry, maxIdleTime, maxRequestTime, fetchFunction, featureFlags, detectSnapLocation: detectSnapLocationFunction, }: SnapControllerArgs);
     /**
      * Checks all installed snaps against the block list and
      * blocks/unblocks snaps as appropriate. See {@link SnapController.blockSnap}
      * for more information.
      */
     updateBlockedSnaps(): Promise<void>;
-    /**
-     * Checks the block list to determine whether a version of a snap is blocked.
-     *
-     * @param snapId - The snap id to check.
-     * @param snapInfo - Snap information containing version and shasum.
-     * @returns Whether the version of the snap is blocked or not.
-     */
-    isBlocked(snapId: ValidatedSnapId, snapInfo: SnapInfo): Promise<boolean>;
     _onUnhandledSnapError(snapId: SnapId, error: SnapErrorJson): void;
     _onOutboundRequest(snapId: SnapId): void;
     _onOutboundResponse(snapId: SnapId): void;
diff --git a/dist/snaps/SnapController.js b/dist/snaps/SnapController.js
index f04e671adb2a8259b5dcf30227d15ff987a07d25..63bead8b5a8d7dc7312c2711c152cf0be0bd94f9 100644
--- a/dist/snaps/SnapController.js
+++ b/dist/snaps/SnapController.js
@@ -21,7 +21,7 @@ var __rest = (this && this.__rest) || function (s, e) {
         }
     return t;
 };
-var _SnapController_instances, _SnapController_closeAllConnections, _SnapController_environmentEndowmentPermissions, _SnapController_featureFlags, _SnapController_fetchFunction, _SnapController_idleTimeCheckInterval, _SnapController_checkSnapBlockList, _SnapController_maxIdleTime, _SnapController_detectSnapLocation, _SnapController_rollbackSnapshots, _SnapController_timeoutForLastRequestStatus, _SnapController_statusMachine, _SnapController_initializeStateMachine, _SnapController_registerMessageHandlers, _SnapController_pollForLastRequestStatus, _SnapController_blockSnap, _SnapController_unblockSnap, _SnapController_assertIsUnblocked, _SnapController_stopSnapsLastRequestPastMax, _SnapController_transition, _SnapController_terminateSnap, _SnapController_add, _SnapController_startSnap, _SnapController_getEndowments, _SnapController_set, _SnapController_fetchSnap, _SnapController_processSnapPermissions, _SnapController_getRpcRequestHandler, _SnapController_executeWithTimeout, _SnapController_recordSnapRpcRequestStart, _SnapController_recordSnapRpcRequestFinish, _SnapController_getRollbackSnapshot, _SnapController_createRollbackSnapshot, _SnapController_rollbackSnap, _SnapController_rollbackSnaps, _SnapController_getRuntime, _SnapController_getRuntimeExpect, _SnapController_setupRuntime, _SnapController_calculatePermissionsChange, _SnapController_isValidUpdate;
+var _SnapController_instances, _SnapController_closeAllConnections, _SnapController_environmentEndowmentPermissions, _SnapController_featureFlags, _SnapController_fetchFunction, _SnapController_idleTimeCheckInterval, _SnapController_registry, _SnapController_maxIdleTime, _SnapController_detectSnapLocation, _SnapController_rollbackSnapshots, _SnapController_timeoutForLastRequestStatus, _SnapController_statusMachine, _SnapController_initializeStateMachine, _SnapController_registerMessageHandlers, _SnapController_pollForLastRequestStatus, _SnapController_blockSnap, _SnapController_unblockSnap, _SnapController_assertIsInstallAllowed, _SnapController_stopSnapsLastRequestPastMax, _SnapController_transition, _SnapController_terminateSnap, _SnapController_add, _SnapController_startSnap, _SnapController_getEndowments, _SnapController_set, _SnapController_fetchSnap, _SnapController_processSnapPermissions, _SnapController_getRpcRequestHandler, _SnapController_executeWithTimeout, _SnapController_recordSnapRpcRequestStart, _SnapController_recordSnapRpcRequestFinish, _SnapController_getRollbackSnapshot, _SnapController_createRollbackSnapshot, _SnapController_rollbackSnap, _SnapController_rollbackSnaps, _SnapController_getRuntime, _SnapController_getRuntimeExpect, _SnapController_setupRuntime, _SnapController_calculatePermissionsChange, _SnapController_isValidUpdate;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.SnapController = exports.SNAP_APPROVAL_UPDATE = exports.SNAP_APPROVAL_INSTALL = exports.controllerName = void 0;
 const base_controller_1 = require("@metamask/base-controller");
@@ -37,6 +37,7 @@ const utils_2 = require("../utils");
 const endowments_1 = require("./endowments");
 const rpc_1 = require("./endowments/rpc");
 const location_1 = require("./location");
+const registry_1 = require("./registry");
 const RequestQueue_1 = require("./RequestQueue");
 const Timer_1 = require("./Timer");
 exports.controllerName = 'SnapController';
@@ -80,7 +81,7 @@ const name = 'SnapController';
  * - Start: Initializes the snap in its SES realm with the authorized permissions.
  */
 class SnapController extends base_controller_1.BaseControllerV2 {
-    constructor({ closeAllConnections, messenger, state, environmentEndowmentPermissions = [], idleTimeCheckInterval = (0, utils_1.inMilliseconds)(5, utils_1.Duration.Second), checkBlockList, maxIdleTime = (0, utils_1.inMilliseconds)(30, utils_1.Duration.Second), maxRequestTime = (0, utils_1.inMilliseconds)(60, utils_1.Duration.Second), fetchFunction = globalThis.fetch.bind(globalThis), featureFlags = {}, detectSnapLocation: detectSnapLocationFunction = location_1.detectSnapLocation, }) {
+    constructor({ closeAllConnections, messenger, state, environmentEndowmentPermissions = [], idleTimeCheckInterval = (0, utils_1.inMilliseconds)(5, utils_1.Duration.Second), registry = new registry_1.JsonSnapRegistry(), maxIdleTime = (0, utils_1.inMilliseconds)(30, utils_1.Duration.Second), maxRequestTime = (0, utils_1.inMilliseconds)(60, utils_1.Duration.Second), fetchFunction = globalThis.fetch.bind(globalThis), featureFlags = {}, detectSnapLocation: detectSnapLocationFunction = location_1.detectSnapLocation, }) {
         var _a, _b;
         super({
             messenger,
@@ -128,7 +129,7 @@ class SnapController extends base_controller_1.BaseControllerV2 {
         _SnapController_featureFlags.set(this, void 0);
         _SnapController_fetchFunction.set(this, void 0);
         _SnapController_idleTimeCheckInterval.set(this, void 0);
-        _SnapController_checkSnapBlockList.set(this, void 0);
+        _SnapController_registry.set(this, void 0);
         _SnapController_maxIdleTime.set(this, void 0);
         _SnapController_detectSnapLocation.set(this, void 0);
         _SnapController_rollbackSnapshots.set(this, void 0);
@@ -139,7 +140,7 @@ class SnapController extends base_controller_1.BaseControllerV2 {
         __classPrivateFieldSet(this, _SnapController_featureFlags, featureFlags, "f");
         __classPrivateFieldSet(this, _SnapController_fetchFunction, fetchFunction, "f");
         __classPrivateFieldSet(this, _SnapController_idleTimeCheckInterval, idleTimeCheckInterval, "f");
-        __classPrivateFieldSet(this, _SnapController_checkSnapBlockList, checkBlockList, "f");
+        __classPrivateFieldSet(this, _SnapController_registry, registry, "f");
         __classPrivateFieldSet(this, _SnapController_maxIdleTime, maxIdleTime, "f");
         this.maxRequestTime = maxRequestTime;
         __classPrivateFieldSet(this, _SnapController_detectSnapLocation, detectSnapLocationFunction, "f");
@@ -170,34 +171,20 @@ class SnapController extends base_controller_1.BaseControllerV2 {
      * for more information.
      */
     async updateBlockedSnaps() {
-        const blockedSnaps = await __classPrivateFieldGet(this, _SnapController_checkSnapBlockList, "f").call(this, Object.values(this.state.snaps).reduce((blockListArg, snap) => {
+        const blockedSnaps = await __classPrivateFieldGet(this, _SnapController_registry, "f").get(Object.values(this.state.snaps).reduce((blockListArg, snap) => {
             blockListArg[snap.id] = {
                 version: snap.version,
-                shasum: snap.manifest.source.shasum,
+                checksum: snap.manifest.source.shasum,
             };
             return blockListArg;
         }, {}));
-        await Promise.all(Object.entries(blockedSnaps).map(async (_a) => {
-            var [snapId, _b] = _a, { blocked } = _b, blockData = __rest(_b, ["blocked"]);
-            if (blocked) {
-                return __classPrivateFieldGet(this, _SnapController_instances, "m", _SnapController_blockSnap).call(this, snapId, blockData);
+        await Promise.all(Object.entries(blockedSnaps).map(async ([snapId, { status, reason }]) => {
+            if (status === snaps_utils_1.SnapRegistryStatus.Blocked) {
+                return __classPrivateFieldGet(this, _SnapController_instances, "m", _SnapController_blockSnap).call(this, snapId, reason);
             }
             return __classPrivateFieldGet(this, _SnapController_instances, "m", _SnapController_unblockSnap).call(this, snapId);
         }));
     }
-    /**
-     * Checks the block list to determine whether a version of a snap is blocked.
-     *
-     * @param snapId - The snap id to check.
-     * @param snapInfo - Snap information containing version and shasum.
-     * @returns Whether the version of the snap is blocked or not.
-     */
-    async isBlocked(snapId, snapInfo) {
-        const result = await __classPrivateFieldGet(this, _SnapController_checkSnapBlockList, "f").call(this, {
-            [snapId]: snapInfo,
-        });
-        return result[snapId].blocked;
-    }
     _onUnhandledSnapError(snapId, error) {
         this.stopSnap(snapId, snaps_utils_1.SnapStatusEvents.Crash)
             .then(() => this.addSnapError(error))
@@ -681,9 +668,9 @@ class SnapController extends base_controller_1.BaseControllerV2 {
             console.warn(`Tried updating snap "${snapId}" within "${newVersionRange}" version range, but newer version "${snap.version}" is already installed`);
             return null;
         }
-        await __classPrivateFieldGet(this, _SnapController_instances, "m", _SnapController_assertIsUnblocked).call(this, snapId, {
+        await __classPrivateFieldGet(this, _SnapController_instances, "m", _SnapController_assertIsInstallAllowed).call(this, snapId, {
             version: newVersion,
-            shasum: newSnap.manifest.result.source.shasum,
+            checksum: newSnap.manifest.result.source.shasum,
         });
         const processedPermissions = __classPrivateFieldGet(this, _SnapController_instances, "m", _SnapController_processSnapPermissions).call(this, newSnap.manifest.result.initialPermissions);
         const { newPermissions, unusedPermissions, approvedPermissions } = __classPrivateFieldGet(this, _SnapController_instances, "m", _SnapController_calculatePermissionsChange).call(this, snapId, processedPermissions);
@@ -836,7 +823,7 @@ class SnapController extends base_controller_1.BaseControllerV2 {
     }
 }
 exports.SnapController = SnapController;
-_SnapController_closeAllConnections = new WeakMap(), _SnapController_environmentEndowmentPermissions = new WeakMap(), _SnapController_featureFlags = new WeakMap(), _SnapController_fetchFunction = new WeakMap(), _SnapController_idleTimeCheckInterval = new WeakMap(), _SnapController_checkSnapBlockList = new WeakMap(), _SnapController_maxIdleTime = new WeakMap(), _SnapController_detectSnapLocation = new WeakMap(), _SnapController_rollbackSnapshots = new WeakMap(), _SnapController_timeoutForLastRequestStatus = new WeakMap(), _SnapController_statusMachine = new WeakMap(), _SnapController_instances = new WeakSet(), _SnapController_initializeStateMachine = function _SnapController_initializeStateMachine() {
+_SnapController_closeAllConnections = new WeakMap(), _SnapController_environmentEndowmentPermissions = new WeakMap(), _SnapController_featureFlags = new WeakMap(), _SnapController_fetchFunction = new WeakMap(), _SnapController_idleTimeCheckInterval = new WeakMap(), _SnapController_registry = new WeakMap(), _SnapController_maxIdleTime = new WeakMap(), _SnapController_detectSnapLocation = new WeakMap(), _SnapController_rollbackSnapshots = new WeakMap(), _SnapController_timeoutForLastRequestStatus = new WeakMap(), _SnapController_statusMachine = new WeakMap(), _SnapController_instances = new WeakSet(), _SnapController_initializeStateMachine = function _SnapController_initializeStateMachine() {
     const disableGuard = ({ snapId }) => {
         return this.getExpect(snapId).enabled;
     };
@@ -943,18 +930,18 @@ async function _SnapController_blockSnap(snapId, blockedSnapInfo) {
         delete state.snaps[snapId].blockInformation;
     });
     this.messagingSystem.publish(`${exports.controllerName}:snapUnblocked`, snapId);
-}, _SnapController_assertIsUnblocked = 
-/**
- * Asserts that a version of a snap is not blocked. Succeeds automatically
- * if {@link SnapController._checkSnapBlockList} is undefined.
- *
- * @param snapId - The id of the snap to check.
- * @param snapInfo - Snap information containing version and shasum.
- */
-async function _SnapController_assertIsUnblocked(snapId, snapInfo) {
-    if (await this.isBlocked(snapId, snapInfo)) {
+}, _SnapController_assertIsInstallAllowed = async function _SnapController_assertIsInstallAllowed(snapId, snapInfo) {
+    const results = await __classPrivateFieldGet(this, _SnapController_registry, "f").get({
+        [snapId]: snapInfo,
+    });
+    const result = results[snapId];
+    if (result.status === snaps_utils_1.SnapRegistryStatus.Blocked) {
         throw new Error(`Cannot install version "${snapInfo.version}" of snap "${snapId}": the version is blocked.`);
     }
+    else if (__classPrivateFieldGet(this, _SnapController_featureFlags, "f").requireAllowlist &&
+        result.status !== snaps_utils_1.SnapRegistryStatus.Verified) {
+        throw new Error(`Cannot install version "${snapInfo.version}" of snap "${snapId}": the snap is not allowlisted.`);
+    }
 }, _SnapController_stopSnapsLastRequestPastMax = async function _SnapController_stopSnapsLastRequestPastMax() {
     const entries = [...this.snapsRuntimeData.entries()];
     return Promise.all(entries
@@ -1001,9 +988,9 @@ async function _SnapController_add(args) {
         // to null in the authorize() method.
         runtime.installPromise = (async () => {
             const fetchedSnap = await __classPrivateFieldGet(this, _SnapController_instances, "m", _SnapController_fetchSnap).call(this, snapId, location);
-            await __classPrivateFieldGet(this, _SnapController_instances, "m", _SnapController_assertIsUnblocked).call(this, snapId, {
+            await __classPrivateFieldGet(this, _SnapController_instances, "m", _SnapController_assertIsInstallAllowed).call(this, snapId, {
                 version: fetchedSnap.manifest.result.version,
-                shasum: fetchedSnap.manifest.result.source.shasum,
+                checksum: fetchedSnap.manifest.result.source.shasum,
             });
             return __classPrivateFieldGet(this, _SnapController_instances, "m", _SnapController_set).call(this, Object.assign(Object.assign(Object.assign({}, args), fetchedSnap), { id: snapId }));
         })();
diff --git a/dist/snaps/SnapController.js.map b/dist/snaps/SnapController.js.map
index 102d191a7603c0b18ebd0429e8b7bf2fda659e1e..0f44233e7507dd195c6941a7c78577510bd5b8df 100644
--- a/dist/snaps/SnapController.js.map
+++ b/dist/snaps/SnapController.js.map
@@ -1 +1 @@
-{"version":3,"file":"SnapController.js","sourceRoot":"","sources":["../../src/snaps/SnapController.ts"],"names":[],"mappings":"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","sourcesContent":["import { AddApprovalRequest } from '@metamask/approval-controller';\nimport {\n  BaseControllerV2 as BaseController,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport {\n  Caveat,\n  GetEndowments,\n  GetPermissions,\n  GrantPermissions,\n  HasPermission,\n  HasPermissions,\n  PermissionConstraint,\n  PermissionsRequest,\n  RequestedPermissions,\n  RevokeAllPermissions,\n  RevokePermissionForAllSubjects,\n  RevokePermissions,\n  SubjectPermissions,\n  ValidPermission,\n} from '@metamask/permission-controller';\nimport { caveatMappers } from '@metamask/rpc-methods';\nimport {\n  assertIsSnapManifest,\n  BlockedSnapInfo,\n  DEFAULT_ENDOWMENTS,\n  DEFAULT_REQUESTED_SNAP_VERSION,\n  fromEntries,\n  getSnapPermissionName,\n  gtVersion,\n  gtRange,\n  InstallSnapsResult,\n  isValidSemVerRange,\n  PersistedSnap,\n  ProcessSnapResult,\n  RequestedSnapPermissions,\n  resolveVersionRange,\n  satisfiesVersionRange,\n  SemVerRange,\n  Snap,\n  SnapId,\n  SnapManifest,\n  SnapPermissions,\n  SnapRpcHook,\n  SnapRpcHookArgs,\n  SnapStatus,\n  SnapStatusEvents,\n  SNAP_PREFIX,\n  SNAP_PREFIX_REGEX,\n  StatusContext,\n  StatusEvents,\n  StatusStates,\n  TruncatedSnap,\n  TruncatedSnapFields,\n  ValidatedSnapId,\n  validateSnapId,\n  validateSnapShasum,\n  VirtualFile,\n} from '@metamask/snaps-utils';\nimport {\n  GetSubjectMetadata,\n  SubjectType,\n} from '@metamask/subject-metadata-controller';\nimport {\n  assert,\n  Duration,\n  hasProperty,\n  inMilliseconds,\n  isNonEmptyArray,\n  Json,\n  NonEmptyArray,\n  timeSince,\n} from '@metamask/utils';\nimport { createMachine, interpret, StateMachine } from '@xstate/fsm';\nimport { ethErrors } from 'eth-rpc-errors';\nimport type { Patch } from 'immer';\nimport { nanoid } from 'nanoid';\n\nimport { forceStrict, validateMachine } from '../fsm';\nimport {\n  ExecuteSnapAction,\n  ExecutionServiceEvents,\n  HandleRpcRequestAction,\n  SnapErrorJson,\n  TerminateAllSnapsAction,\n  TerminateSnapAction,\n} from '../services';\nimport { hasTimedOut, setDiff, withTimeout } from '../utils';\nimport {\n  endowmentCaveatMappers,\n  handlerEndowments,\n  SnapEndowments,\n} from './endowments';\nimport { getRpcCaveatOrigins } from './endowments/rpc';\nimport { detectSnapLocation, SnapLocation } from './location';\nimport { RequestQueue } from './RequestQueue';\nimport { Timer } from './Timer';\n\nexport const controllerName = 'SnapController';\n\n// TODO: Figure out how to name these\nexport const SNAP_APPROVAL_INSTALL = 'wallet_installSnap';\nexport const SNAP_APPROVAL_UPDATE = 'wallet_updateSnap';\n\nconst TRUNCATED_SNAP_PROPERTIES = new Set<TruncatedSnapFields>([\n  'initialPermissions',\n  'id',\n  'permissionName',\n  'version',\n  'enabled',\n  'blocked',\n]);\n\nexport type PendingRequest = {\n  requestId: unknown;\n  timer: Timer;\n};\n\n/**\n * A wrapper type for any data stored during runtime of Snaps.\n * It is not persisted in state as it contains non-serializable data and is only relevant for the\n * current session.\n */\nexport interface SnapRuntimeData {\n  /**\n   * A promise that resolves when the Snap has finished installing\n   */\n  installPromise: null | Promise<PersistedSnap>;\n\n  /**\n   * A Unix timestamp for the last time the Snap received an RPC request\n   */\n  lastRequest: null | number;\n\n  /**\n   * The current number of active references where this Snap is being used\n   */\n  activeReferences: number;\n\n  /**\n   * The current pending inbound requests, meaning requests that are processed by snaps.\n   */\n  pendingInboundRequests: PendingRequest[];\n\n  /**\n   * The current pending outbound requests, meaning requests made from snaps towards the MetaMask\n   * extension.\n   */\n  pendingOutboundRequests: number;\n\n  /**\n   * RPC handler designated for the Snap\n   */\n  rpcHandler: null | SnapRpcHook;\n\n  /**\n   * The finite state machine interpreter for possible states that the Snap can be in such as\n   * stopped, running, blocked\n   *\n   * @see {@link SnapController:constructor}\n   */\n  interpreter: StateMachine.Service<StatusContext, StatusEvents, StatusStates>;\n\n  /**\n   * The snap source code\n   */\n  sourceCode: null | string;\n\n  /**\n   * The snap state (encrypted)\n   */\n  state: null | string;\n}\n\nexport type SnapError = {\n  message: string;\n  code: number;\n  data?: Json;\n};\n\n/**\n * The return type of {@link SnapController.#fetchSnap} and its sibling methods.\n */\ntype FetchSnapResult = {\n  /**\n   * The manifest of the fetched Snap.\n   */\n  manifest: VirtualFile<SnapManifest>;\n\n  /**\n   * Auxillary files references in manifest.\n   */\n  files: VirtualFile[];\n\n  /**\n   * Location that was used to fetch the snap.\n   *\n   * Helpful if you want to pass it forward since files will be still cached.\n   */\n  location: SnapLocation;\n};\n\n// Types that probably should be defined elsewhere in prod\ntype CloseAllConnectionsFunction = (origin: string) => void;\ntype StoredSnaps = Record<SnapId, Snap>;\n\nexport type SnapControllerState = {\n  snaps: StoredSnaps;\n  // This type needs to be defined but is always empty in practice.\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  snapStates: {};\n  snapErrors: {\n    [internalID: string]: SnapError & { internalID: string };\n  };\n};\n\nexport type PersistedSnapControllerState = SnapControllerState & {\n  snaps: Record<SnapId, PersistedSnap>;\n  snapStates: Record<SnapId, string>;\n};\n\ntype RollbackSnapshot = {\n  statePatches: Patch[];\n  sourceCode: string | null;\n  permissions: {\n    revoked: unknown;\n    granted: unknown[];\n    requestData: unknown;\n  };\n  newVersion: string;\n};\n\n// Controller Messenger Actions\n\n/**\n * Gets the specified Snap from state.\n */\nexport type GetSnap = {\n  type: `${typeof controllerName}:get`;\n  handler: SnapController['get'];\n};\n\n/**\n * Handles sending an inbound request to a snap and returns its result.\n */\nexport type HandleSnapRequest = {\n  type: `${typeof controllerName}:handleRequest`;\n  handler: SnapController['handleRequest'];\n};\n\n/**\n * Gets the specified Snap's persisted state.\n */\nexport type GetSnapState = {\n  type: `${typeof controllerName}:getSnapState`;\n  handler: SnapController['getSnapState'];\n};\n\n/**\n * Checks if the specified snap exists in state.\n */\nexport type HasSnap = {\n  type: `${typeof controllerName}:has`;\n  handler: SnapController['has'];\n};\n\n/**\n * Updates the specified Snap's persisted state.\n */\nexport type UpdateSnapState = {\n  type: `${typeof controllerName}:updateSnapState`;\n  handler: SnapController['updateSnapState'];\n};\n\n/**\n * Clears the specified Snap's persisted state.\n */\nexport type ClearSnapState = {\n  type: `${typeof controllerName}:clearSnapState`;\n  handler: SnapController['clearSnapState'];\n};\n\n/**\n * Checks all installed snaps against the blocklist.\n */\nexport type UpdateBlockedSnaps = {\n  type: `${typeof controllerName}:updateBlockedSnaps`;\n  handler: SnapController['updateBlockedSnaps'];\n};\n\nexport type EnableSnap = {\n  type: `${typeof controllerName}:enable`;\n  handler: SnapController['enableSnap'];\n};\n\nexport type DisableSnap = {\n  type: `${typeof controllerName}:disable`;\n  handler: SnapController['disableSnap'];\n};\n\nexport type RemoveSnap = {\n  type: `${typeof controllerName}:remove`;\n  handler: SnapController['removeSnap'];\n};\n\nexport type GetPermittedSnaps = {\n  type: `${typeof controllerName}:getPermitted`;\n  handler: SnapController['getPermittedSnaps'];\n};\n\nexport type GetAllSnaps = {\n  type: `${typeof controllerName}:getAll`;\n  handler: SnapController['getAllSnaps'];\n};\n\nexport type IncrementActiveReferences = {\n  type: `${typeof controllerName}:incrementActiveReferences`;\n  handler: SnapController['incrementActiveReferences'];\n};\n\nexport type DecrementActiveReferences = {\n  type: `${typeof controllerName}:decrementActiveReferences`;\n  handler: SnapController['decrementActiveReferences'];\n};\n\nexport type InstallSnaps = {\n  type: `${typeof controllerName}:install`;\n  handler: SnapController['installSnaps'];\n};\n\nexport type RemoveSnapError = {\n  type: `${typeof controllerName}:removeSnapError`;\n  handler: SnapController['removeSnapError'];\n};\n\nexport type SnapControllerActions =\n  | ClearSnapState\n  | GetSnap\n  | GetSnapState\n  | HandleSnapRequest\n  | HasSnap\n  | UpdateBlockedSnaps\n  | UpdateSnapState\n  | EnableSnap\n  | DisableSnap\n  | RemoveSnap\n  | GetPermittedSnaps\n  | InstallSnaps\n  | RemoveSnapError\n  | GetAllSnaps\n  | IncrementActiveReferences\n  | DecrementActiveReferences;\n\n// Controller Messenger Events\n\nexport type SnapStateChange = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [SnapControllerState, Patch[]];\n};\n\n/**\n * Emitted when a Snap has been added to state during installation.\n */\nexport type SnapAdded = {\n  type: `${typeof controllerName}:snapAdded`;\n  payload: [snap: Snap, svgIcon: string | undefined];\n};\n\n/**\n * Emitted when an installed snap has been blocked.\n */\nexport type SnapBlocked = {\n  type: `${typeof controllerName}:snapBlocked`;\n  payload: [snapId: string, blockedSnapInfo: BlockedSnapInfo];\n};\n\n/**\n * Emitted when a snap has been started after being added and authorized during\n * installation.\n */\nexport type SnapInstalled = {\n  type: `${typeof controllerName}:snapInstalled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when a snap is removed.\n */\nexport type SnapRemoved = {\n  type: `${typeof controllerName}:snapRemoved`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when an installed snap has been unblocked.\n */\nexport type SnapUnblocked = {\n  type: `${typeof controllerName}:snapUnblocked`;\n  payload: [snapId: string];\n};\n\n/**\n * Emitted when a snap is updated.\n */\nexport type SnapUpdated = {\n  type: `${typeof controllerName}:snapUpdated`;\n  payload: [snap: TruncatedSnap, oldVersion: string];\n};\n\n/**\n * Emitted when a snap is rolled back.\n */\nexport type SnapRolledback = {\n  type: `${typeof controllerName}:snapRolledback`;\n  payload: [snap: TruncatedSnap, failedVersion: string];\n};\n/**\n * Emitted when a Snap is terminated. This is different from the snap being\n * stopped as it can also be triggered when a snap fails initialization.\n */\nexport type SnapTerminated = {\n  type: `${typeof controllerName}:snapTerminated`;\n  payload: [snap: TruncatedSnap];\n};\n\nexport type SnapControllerEvents =\n  | SnapAdded\n  | SnapBlocked\n  | SnapInstalled\n  | SnapRemoved\n  | SnapStateChange\n  | SnapUnblocked\n  | SnapUpdated\n  | SnapRolledback\n  | SnapTerminated;\n\nexport type AllowedActions =\n  | GetEndowments\n  | GetPermissions\n  | GetSubjectMetadata\n  | HasPermission\n  | HasPermissions\n  | RevokePermissions\n  | RevokeAllPermissions\n  | RevokePermissionForAllSubjects\n  | GrantPermissions\n  | AddApprovalRequest\n  | HandleRpcRequestAction\n  | ExecuteSnapAction\n  | TerminateAllSnapsAction\n  | TerminateSnapAction;\n\nexport type AllowedEvents = ExecutionServiceEvents;\n\ntype SnapControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  SnapControllerActions | AllowedActions,\n  SnapControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\ntype FeatureFlags = {\n  /**\n   * We still need to implement new UI approval page in metamask-extension before we can allow\n   * DApps to update Snaps. After it's added, this flag can be removed.\n   *\n   * @see {SNAP_APPROVAL_UPDATE}\n   * @see {SnapController.processRequestedSnap}\n   */\n  dappsCanUpdateSnaps?: true;\n};\n\ntype SemVerVersion = string;\ntype SnapInfo = { version: SemVerVersion; shasum: string };\nexport type CheckSnapBlockListArg = Record<SnapId, SnapInfo>;\n\nexport type CheckSnapBlockListResult = Record<\n  SnapId,\n  | {\n      blocked: true;\n      reason?: string;\n      infoUrl?: string;\n    }\n  | { blocked: false }\n>;\n\n/**\n * Checks whether a version of a snap is blocked.\n */\nexport type CheckSnapBlockList = (\n  snapsToCheck: CheckSnapBlockListArg,\n) => Promise<CheckSnapBlockListResult>;\n\ntype SnapControllerArgs = {\n  /**\n   * A teardown function that allows the host to clean up its instrumentation\n   * for a running snap.\n   */\n  closeAllConnections: CloseAllConnectionsFunction;\n\n  /**\n   * The names of endowment permissions whose values are the names of JavaScript\n   * APIs that will be added to the snap execution environment at runtime.\n   */\n  environmentEndowmentPermissions: string[];\n\n  /**\n   * The function that will be used by the controller fo make network requests.\n   * Should be compatible with {@link fetch}.\n   */\n  fetchFunction?: typeof fetch;\n\n  /**\n   * Flags that enable or disable features in the controller.\n   * See {@link FeatureFlags}.\n   */\n  featureFlags: FeatureFlags;\n\n  /**\n   * How frequently to check whether a snap is idle.\n   */\n  idleTimeCheckInterval?: number;\n\n  /**\n   * A function that checks whether the specified snap and version is blocked.\n   */\n  checkBlockList: CheckSnapBlockList;\n\n  /**\n   * The maximum amount of time that a snap may be idle.\n   */\n  maxIdleTime?: number;\n\n  /**\n   * The controller messenger.\n   */\n  messenger: SnapControllerMessenger;\n\n  /**\n   * The maximum amount of time a snap may take to process an RPC request,\n   * unless it is permitted to take longer.\n   */\n  maxRequestTime?: number;\n\n  /**\n   * The npm registry URL that will be used to fetch published snaps.\n   */\n  npmRegistryUrl?: string;\n\n  /**\n   * Persisted state that will be used for rehydration.\n   */\n  state?: PersistedSnapControllerState;\n\n  /**\n   * A function that takes Snap Id and converts it into a class that fetches files.\n   *\n   * Used for test overrides.\n   */\n  detectSnapLocation?: typeof detectSnapLocation;\n};\ntype AddSnapArgs = {\n  id: SnapId;\n  origin: string;\n  location: SnapLocation;\n};\n\n// When we set a snap, we need all required properties to be present and\n// validated.\ntype SetSnapArgs = Omit<AddSnapArgs, 'id' | 'location'> & {\n  id: ValidatedSnapId;\n  manifest: VirtualFile<SnapManifest>;\n  files: VirtualFile[];\n  /**\n   * @default '*'\n   */\n  // TODO(ritave): Used only for validation in #set, should be moved elsewhere.\n  versionRange?: SemVerRange;\n  isUpdate?: boolean;\n};\n\nconst defaultState: SnapControllerState = {\n  snapErrors: {},\n  snaps: {},\n  snapStates: {},\n};\n\n/**\n * Truncates the properties of a snap to only ones that are easily serializable.\n *\n * @param snap - The snap to truncate.\n * @returns Object with serializable snap properties.\n */\nfunction truncateSnap(snap: Snap): TruncatedSnap {\n  const truncatedSnap = Object.keys(snap).reduce<Partial<TruncatedSnap>>(\n    (serialized, key) => {\n      if (TRUNCATED_SNAP_PROPERTIES.has(key as any)) {\n        serialized[key as keyof TruncatedSnap] = snap[\n          key as keyof TruncatedSnap\n        ] as any;\n      }\n\n      return serialized;\n    },\n    {},\n  );\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return truncatedSnap as TruncatedSnap;\n}\n\nconst name = 'SnapController';\n\n/*\n * A snap is initialized in three phases:\n * - Add: Loads the snap from a remote source and parses it.\n * - Authorize: Requests the snap's required permissions from the user.\n * - Start: Initializes the snap in its SES realm with the authorized permissions.\n */\n\nexport class SnapController extends BaseController<\n  string,\n  SnapControllerState,\n  SnapControllerMessenger\n> {\n  #closeAllConnections: CloseAllConnectionsFunction;\n\n  #environmentEndowmentPermissions: string[];\n\n  #featureFlags: FeatureFlags;\n\n  #fetchFunction: typeof fetch;\n\n  #idleTimeCheckInterval: number;\n\n  #checkSnapBlockList: CheckSnapBlockList;\n\n  #maxIdleTime: number;\n\n  // This property cannot be hash private yet because of tests.\n  private readonly maxRequestTime: number;\n\n  #detectSnapLocation: typeof detectSnapLocation;\n\n  // This property cannot be hash private yet because of tests.\n  private readonly snapsRuntimeData: Map<SnapId, SnapRuntimeData>;\n\n  #rollbackSnapshots: Map<SnapId, RollbackSnapshot>;\n\n  #timeoutForLastRequestStatus?: number;\n\n  #statusMachine!: StateMachine.Machine<\n    StatusContext,\n    StatusEvents,\n    StatusStates\n  >;\n\n  constructor({\n    closeAllConnections,\n    messenger,\n    state,\n    environmentEndowmentPermissions = [],\n    idleTimeCheckInterval = inMilliseconds(5, Duration.Second),\n    checkBlockList,\n    maxIdleTime = inMilliseconds(30, Duration.Second),\n    maxRequestTime = inMilliseconds(60, Duration.Second),\n    fetchFunction = globalThis.fetch.bind(globalThis),\n    featureFlags = {},\n    detectSnapLocation: detectSnapLocationFunction = detectSnapLocation,\n  }: SnapControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        snapErrors: {\n          persist: false,\n          anonymous: false,\n        },\n        snapStates: {\n          persist: () => {\n            return Object.keys(this.state.snaps).reduce<\n              Record<string, string | null>\n            >((acc, cur) => {\n              acc[cur] = this.#getRuntimeExpect(cur).state;\n              return acc;\n            }, {});\n          },\n          anonymous: false,\n        },\n        snaps: {\n          persist: (snaps) => {\n            return Object.values(snaps)\n              .map((snap) => {\n                return {\n                  ...snap,\n                  sourceCode: this.#getRuntimeExpect(snap.id).sourceCode,\n                  // At the time state is rehydrated, no snap will be running.\n                  status: SnapStatus.Stopped,\n                };\n              })\n              .reduce((memo: Record<string, Snap>, snap) => {\n                memo[snap.id] = snap;\n                return memo;\n              }, {});\n          },\n          anonymous: false,\n        },\n      },\n      name,\n      state: {\n        ...defaultState,\n        ...{\n          ...state,\n          snaps: Object.values(state?.snaps ?? {}).reduce(\n            (memo: Record<string, Snap>, snap) => {\n              // eslint-disable-next-line @typescript-eslint/no-unused-vars\n              const { sourceCode, ...rest } = snap;\n              memo[snap.id] = rest;\n              return memo;\n            },\n            {},\n          ),\n        },\n      },\n    });\n\n    this.#closeAllConnections = closeAllConnections;\n    this.#environmentEndowmentPermissions = environmentEndowmentPermissions;\n    this.#featureFlags = featureFlags;\n    this.#fetchFunction = fetchFunction;\n    this.#idleTimeCheckInterval = idleTimeCheckInterval;\n    this.#checkSnapBlockList = checkBlockList;\n    this.#maxIdleTime = maxIdleTime;\n    this.maxRequestTime = maxRequestTime;\n    this.#detectSnapLocation = detectSnapLocationFunction;\n    this._onUnhandledSnapError = this._onUnhandledSnapError.bind(this);\n    this._onOutboundRequest = this._onOutboundRequest.bind(this);\n    this._onOutboundResponse = this._onOutboundResponse.bind(this);\n    this.#rollbackSnapshots = new Map();\n    this.snapsRuntimeData = new Map();\n    this.#pollForLastRequestStatus();\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.subscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messagingSystem.subscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messagingSystem.subscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n    this.#initializeStateMachine();\n    this.#registerMessageHandlers();\n\n    Object.values(state?.snaps ?? {}).forEach((snap) =>\n      this.#setupRuntime(snap.id, {\n        sourceCode: snap.sourceCode,\n        state: state?.snapStates?.[snap.id] ?? null,\n      }),\n    );\n  }\n\n  /**\n   * We track status of a Snap using a finite-state-machine.\n   * It keeps track of whether the snap is started / stopped / etc.\n   *\n   * @see {@link SnapController.transition} for interacting with the machine.\n   */\n  // We initialize the machine in the instance because the status is currently tightly coupled\n  // with the SnapController - the guard checks for enabled status inside the SnapController state.\n  // In the future, side-effects could be added to the machine during transitions.\n  #initializeStateMachine() {\n    const disableGuard = ({ snapId }: StatusContext) => {\n      return this.getExpect(snapId).enabled;\n    };\n\n    const statusConfig: StateMachine.Config<\n      StatusContext,\n      StatusEvents,\n      StatusStates\n    > = {\n      initial: SnapStatus.Installing,\n      states: {\n        [SnapStatus.Installing]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n          },\n        },\n        [SnapStatus.Updating]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n          },\n        },\n        [SnapStatus.Running]: {\n          on: {\n            [SnapStatusEvents.Stop]: SnapStatus.Stopped,\n            [SnapStatusEvents.Crash]: SnapStatus.Crashed,\n          },\n        },\n        [SnapStatus.Stopped]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Update]: SnapStatus.Updating,\n          },\n        },\n        [SnapStatus.Crashed]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n          },\n        },\n      },\n    };\n    this.#statusMachine = createMachine(statusConfig);\n    validateMachine(this.#statusMachine);\n  }\n\n  /**\n   * Constructor helper for registering the controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers(): void {\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:clearSnapState`,\n      (...args) => this.clearSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:get`,\n      (...args) => this.get(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getSnapState`,\n      async (...args) => this.getSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:handleRequest`,\n      async (...args) => this.handleRequest(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:has`,\n      (...args) => this.has(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateBlockedSnaps`,\n      async () => this.updateBlockedSnaps(),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateSnapState`,\n      async (...args) => this.updateSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:enable`,\n      (...args) => this.enableSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:disable`,\n      async (...args) => this.disableSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:remove`,\n      async (...args) => this.removeSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getPermitted`,\n      (...args) => this.getPermittedSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:install`,\n      async (...args) => this.installSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:removeSnapError`,\n      (...args) => this.removeSnapError(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getAll`,\n      (...args) => this.getAllSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:incrementActiveReferences`,\n      (...args) => this.incrementActiveReferences(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:decrementActiveReferences`,\n      (...args) => this.decrementActiveReferences(...args),\n    );\n  }\n\n  #pollForLastRequestStatus() {\n    this.#timeoutForLastRequestStatus = setTimeout(() => {\n      this.#stopSnapsLastRequestPastMax().catch((error) => {\n        // TODO: Decide how to handle errors.\n        console.error(error);\n      });\n\n      this.#pollForLastRequestStatus();\n    }, this.#idleTimeCheckInterval) as unknown as number;\n  }\n\n  /**\n   * Checks all installed snaps against the block list and\n   * blocks/unblocks snaps as appropriate. See {@link SnapController.blockSnap}\n   * for more information.\n   */\n  async updateBlockedSnaps(): Promise<void> {\n    const blockedSnaps = await this.#checkSnapBlockList(\n      Object.values(this.state.snaps).reduce<CheckSnapBlockListArg>(\n        (blockListArg, snap) => {\n          blockListArg[snap.id] = {\n            version: snap.version,\n            shasum: snap.manifest.source.shasum,\n          };\n          return blockListArg;\n        },\n        {},\n      ),\n    );\n\n    await Promise.all(\n      Object.entries(blockedSnaps).map(\n        async ([snapId, { blocked, ...blockData }]) => {\n          if (blocked) {\n            return this.#blockSnap(snapId, blockData);\n          }\n\n          return this.#unblockSnap(snapId);\n        },\n      ),\n    );\n  }\n\n  /**\n   * Blocks an installed snap and prevents it from being started again. Emits\n   * {@link SnapBlocked}. Does nothing if the snap is not installed.\n   *\n   * @param snapId - The snap to block.\n   * @param blockedSnapInfo - Information detailing why the snap is blocked.\n   */\n  async #blockSnap(\n    snapId: SnapId,\n    blockedSnapInfo: BlockedSnapInfo,\n  ): Promise<void> {\n    if (!this.has(snapId)) {\n      return;\n    }\n\n    try {\n      this.update((state: any) => {\n        state.snaps[snapId].blocked = true;\n        state.snaps[snapId].blockInformation = blockedSnapInfo;\n      });\n\n      await this.disableSnap(snapId);\n    } catch (error) {\n      console.error(\n        `Encountered error when stopping blocked snap \"${snapId}\".`,\n        error,\n      );\n    }\n\n    this.messagingSystem.publish(\n      `${controllerName}:snapBlocked`,\n      snapId,\n      blockedSnapInfo,\n    );\n  }\n\n  /**\n   * Unblocks a snap so that it can be enabled and started again. Emits\n   * {@link SnapUnblocked}. Does nothing if the snap is not installed or already\n   * unblocked.\n   *\n   * @param snapId - The id of the snap to unblock.\n   */\n  #unblockSnap(snapId: SnapId) {\n    if (!this.has(snapId) || !this.state.snaps[snapId].blocked) {\n      return;\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].blocked = false;\n      delete state.snaps[snapId].blockInformation;\n    });\n\n    this.messagingSystem.publish(`${controllerName}:snapUnblocked`, snapId);\n  }\n\n  /**\n   * Checks the block list to determine whether a version of a snap is blocked.\n   *\n   * @param snapId - The snap id to check.\n   * @param snapInfo - Snap information containing version and shasum.\n   * @returns Whether the version of the snap is blocked or not.\n   */\n  async isBlocked(\n    snapId: ValidatedSnapId,\n    snapInfo: SnapInfo,\n  ): Promise<boolean> {\n    const result = await this.#checkSnapBlockList({\n      [snapId]: snapInfo,\n    });\n    return result[snapId].blocked;\n  }\n\n  /**\n   * Asserts that a version of a snap is not blocked. Succeeds automatically\n   * if {@link SnapController._checkSnapBlockList} is undefined.\n   *\n   * @param snapId - The id of the snap to check.\n   * @param snapInfo - Snap information containing version and shasum.\n   */\n  async #assertIsUnblocked(snapId: ValidatedSnapId, snapInfo: SnapInfo) {\n    if (await this.isBlocked(snapId, snapInfo)) {\n      throw new Error(\n        `Cannot install version \"${snapInfo.version}\" of snap \"${snapId}\": the version is blocked.`,\n      );\n    }\n  }\n\n  async #stopSnapsLastRequestPastMax() {\n    const entries = [...this.snapsRuntimeData.entries()];\n    return Promise.all(\n      entries\n        .filter(\n          ([_snapId, runtime]) =>\n            runtime.activeReferences === 0 &&\n            runtime.pendingInboundRequests.length === 0 &&\n            // lastRequest should always be set here but TypeScript wants this check\n            runtime.lastRequest &&\n            this.#maxIdleTime &&\n            timeSince(runtime.lastRequest) > this.#maxIdleTime,\n        )\n        .map(async ([snapId]) => this.stopSnap(snapId, SnapStatusEvents.Stop)),\n    );\n  }\n\n  _onUnhandledSnapError(snapId: SnapId, error: SnapErrorJson) {\n    this.stopSnap(snapId, SnapStatusEvents.Crash)\n      .then(() => this.addSnapError(error))\n      .catch((stopSnapError) => {\n        // TODO: Decide how to handle errors.\n        console.error(stopSnapError);\n      });\n  }\n\n  _onOutboundRequest(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    // Ideally we would only pause the pending request that is making the outbound request\n    // but right now we don't have a way to know which request initiated the outbound request\n    runtime.pendingInboundRequests\n      .filter((pendingRequest) => pendingRequest.timer.status === 'running')\n      .forEach((pendingRequest) => pendingRequest.timer.pause());\n    runtime.pendingOutboundRequests += 1;\n  }\n\n  _onOutboundResponse(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingOutboundRequests -= 1;\n    if (runtime.pendingOutboundRequests === 0) {\n      runtime.pendingInboundRequests\n        .filter((pendingRequest) => pendingRequest.timer.status === 'paused')\n        .forEach((pendingRequest) => pendingRequest.timer.resume());\n    }\n  }\n\n  /**\n   * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out\n   * the next state. This transition function uses a very minimal subset of XState conventions:\n   * - supports initial state\n   * - .on supports raw event target string\n   * - .on supports {target, cond} object\n   * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event,\n   * context) => boolean`\n   *\n   * @param snapId - The id of the snap to transition.\n   * @param event - The event enum to use to transition.\n   */\n  #transition(snapId: SnapId, event: StatusEvents | StatusEvents['type']) {\n    const { interpreter } = this.#getRuntimeExpect(snapId);\n    interpreter.send(event);\n    this.update((state: any) => {\n      state.snaps[snapId].status = interpreter.state.value;\n    });\n  }\n\n  /**\n   * Starts the given snap. Throws an error if no such snap exists\n   * or if it is already running.\n   *\n   * @param snapId - The id of the Snap to start.\n   */\n  async startSnap(snapId: SnapId): Promise<void> {\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (this.state.snaps[snapId].enabled === false) {\n      throw new Error(`Snap \"${snapId}\" is disabled.`);\n    }\n\n    assert(runtime.sourceCode);\n\n    await this.#startSnap({\n      snapId,\n      sourceCode: runtime.sourceCode,\n    });\n  }\n\n  /**\n   * Enables the given snap. A snap can only be started if it is enabled. A snap\n   * can only be enabled if it isn't blocked.\n   *\n   * @param snapId - The id of the Snap to enable.\n   */\n  enableSnap(snapId: SnapId): void {\n    this.getExpect(snapId);\n\n    if (this.state.snaps[snapId].blocked) {\n      throw new Error(`Snap \"${snapId}\" is blocked and cannot be enabled.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = true;\n    });\n  }\n\n  /**\n   * Disables the given snap. A snap can only be started if it is enabled.\n   *\n   * @param snapId - The id of the Snap to disable.\n   * @returns A promise that resolves once the snap has been disabled.\n   */\n  async disableSnap(snapId: SnapId): Promise<void> {\n    if (!this.has(snapId)) {\n      throw new Error(`Snap \"${snapId}\" not found.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = false;\n    });\n\n    if (this.isRunning(snapId)) {\n      return this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Stops the given snap, removes all hooks, closes all connections, and\n   * terminates its worker.\n   *\n   * @param snapId - The id of the Snap to stop.\n   * @param statusEvent - The Snap status event that caused the snap to be\n   * stopped.\n   */\n  public async stopSnap(\n    snapId: SnapId,\n    statusEvent:\n      | SnapStatusEvents.Stop\n      | SnapStatusEvents.Crash = SnapStatusEvents.Stop,\n  ): Promise<void> {\n    const runtime = this.#getRuntime(snapId);\n    if (!runtime) {\n      throw new Error(`The snap \"${snapId}\" is not running.`);\n    }\n\n    // Reset request tracking\n    runtime.lastRequest = null;\n    runtime.pendingInboundRequests = [];\n    runtime.pendingOutboundRequests = 0;\n    try {\n      if (this.isRunning(snapId)) {\n        this.#closeAllConnections(snapId);\n        await this.#terminateSnap(snapId);\n      }\n    } finally {\n      if (this.isRunning(snapId)) {\n        this.#transition(snapId, statusEvent);\n      }\n    }\n  }\n\n  /**\n   * Terminates the specified snap and emits the `snapTerminated` event.\n   *\n   * @param snapId - The snap to terminate.\n   */\n  async #terminateSnap(snapId: SnapId) {\n    await this.messagingSystem.call('ExecutionService:terminateSnap', snapId);\n    this.messagingSystem.publish(\n      'SnapController:snapTerminated',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Returns whether the given snap is running.\n   * Throws an error if the snap doesn't exist.\n   *\n   * @param snapId - The id of the Snap to check.\n   * @returns `true` if the snap is running, otherwise `false`.\n   */\n  isRunning(snapId: SnapId): boolean {\n    return this.getExpect(snapId).status === 'running';\n  }\n\n  /**\n   * Returns whether the given snap has been added to state.\n   *\n   * @param snapId - The id of the Snap to check for.\n   * @returns `true` if the snap exists in the controller state, otherwise `false`.\n   */\n  has(snapId: SnapId): boolean {\n    return Boolean(this.get(snapId));\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, including all data.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns The entire snap object from the controller state.\n   */\n  get(snapId: SnapId): Snap | undefined {\n    return this.state.snaps[snapId];\n  }\n\n  /**\n   * Gets the snap with the given id, throws if doesn't.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @see {@link SnapController.get}\n   * @throws {@link Error}. If the snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns The entire snap object.\n   */\n  getExpect(snapId: SnapId): Snap {\n    const snap = this.get(snapId);\n    assert(snap !== undefined, new Error(`Snap \"${snapId}\" not found.`));\n    return snap;\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, excluding any\n   * non-serializable or expensive-to-serialize data.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  // TODO(ritave): this.get returns undefined, this.getTruncated returns null\n  getTruncated(snapId: SnapId): TruncatedSnap | null {\n    const snap = this.get(snapId);\n\n    return snap ? truncateSnap(snap) : null;\n  }\n\n  /**\n   * Gets the snap with the given id, throw if it doesn't exist.\n   *\n   * @throws {@link Error}. If snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  getTruncatedExpect(snapId: SnapId): TruncatedSnap {\n    return truncateSnap(this.getExpect(snapId));\n  }\n\n  /**\n   * Updates the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be updated.\n   * @param newSnapState - The new state of the snap.\n   */\n  async updateSnapState(snapId: SnapId, newSnapState: string): Promise<void> {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.state = newSnapState;\n  }\n\n  /**\n   * Clears the state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be cleared.\n   */\n  clearSnapState(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.state = null;\n  }\n\n  /**\n   * Adds error from a snap to the SnapController state.\n   *\n   * @param snapError - The error to store on the SnapController.\n   */\n  addSnapError(snapError: SnapError): void {\n    this.update((state: any) => {\n      const id = nanoid();\n      state.snapErrors[id] = {\n        ...snapError,\n        internalID: id,\n      };\n    });\n  }\n\n  /**\n   * Removes an error by internalID from the SnapControllers state.\n   *\n   * @param internalID - The internal error ID to remove on the SnapController.\n   */\n  removeSnapError(internalID: string) {\n    this.update((state: any) => {\n      delete state.snapErrors[internalID];\n    });\n  }\n\n  /**\n   * Clears all errors from the SnapControllers state.\n   */\n  clearSnapErrors() {\n    this.update((state: any) => {\n      state.snapErrors = {};\n    });\n  }\n\n  /**\n   * Gets the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state to get.\n   * @returns A promise that resolves with the decrypted snap state or null if no state exists.\n   * @throws If the snap state decryption fails.\n   */\n  async getSnapState(snapId: SnapId): Promise<Json> {\n    const { state } = this.#getRuntimeExpect(snapId);\n    return state ?? null;\n  }\n\n  /**\n   * Completely clear the controller's state: delete all associated data,\n   * handlers, event listeners, and permissions; tear down all snap providers.\n   */\n  async clearState() {\n    const snapIds = Object.keys(this.state.snaps);\n    snapIds.forEach((snapId) => {\n      this.#closeAllConnections(snapId);\n    });\n\n    await this.messagingSystem.call('ExecutionService:terminateAllSnaps');\n    snapIds.forEach((snapId) => this.revokeAllSnapPermissions(snapId));\n\n    this.update((state: any) => {\n      state.snaps = {};\n      state.snapStates = {};\n    });\n  }\n\n  /**\n   * Removes the given snap from state, and clears all associated handlers\n   * and listeners.\n   *\n   * @param snapId - The id of the Snap.\n   * @returns A promise that resolves once the snap has been removed.\n   */\n  async removeSnap(snapId: SnapId): Promise<void> {\n    return this.removeSnaps([snapId]);\n  }\n\n  /**\n   * Stops the given snaps, removes them from state, and clears all associated\n   * permissions, handlers, and listeners.\n   *\n   * @param snapIds - The ids of the Snaps.\n   */\n  async removeSnaps(snapIds: string[]): Promise<void> {\n    if (!Array.isArray(snapIds)) {\n      throw new Error('Expected array of snap ids.');\n    }\n\n    await Promise.all(\n      snapIds.map(async (snapId) => {\n        const truncated = this.getTruncatedExpect(snapId);\n        // Disable the snap and revoke all of its permissions before deleting\n        // it. This ensures that the snap will not be restarted or otherwise\n        // affect the host environment while we are deleting it.\n        await this.disableSnap(snapId);\n        this.revokeAllSnapPermissions(snapId);\n\n        const permissionName = getSnapPermissionName(snapId);\n        // Revoke all subjects access to the snap\n        this.messagingSystem.call(\n          'PermissionController:revokePermissionForAllSubjects',\n          permissionName,\n        );\n\n        this.snapsRuntimeData.delete(snapId);\n\n        this.update((state: any) => {\n          delete state.snaps[snapId];\n          delete state.snapStates[snapId];\n        });\n\n        this.messagingSystem.publish(`SnapController:snapRemoved`, truncated);\n      }),\n    );\n  }\n\n  /**\n   * Safely revokes all permissions granted to a Snap.\n   *\n   * @param snapId - The snap ID.\n   */\n  private revokeAllSnapPermissions(snapId: string) {\n    if (\n      this.messagingSystem.call('PermissionController:hasPermissions', snapId)\n    ) {\n      this.messagingSystem.call(\n        'PermissionController:revokeAllPermissions',\n        snapId,\n      );\n    }\n  }\n\n  /**\n   * Handles incrementing the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced.\n   */\n  incrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.activeReferences += 1;\n  }\n\n  /**\n   * Handles decrement the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced..\n   */\n  decrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    assert(\n      runtime.activeReferences > 0,\n      'SnapController reference management is in an invalid state.',\n    );\n    runtime.activeReferences -= 1;\n  }\n\n  /**\n   * Gets all snaps in their truncated format.\n   *\n   * @returns All installed snaps in their truncated format.\n   */\n  getAllSnaps(): TruncatedSnap[] {\n    return Object.values(this.state.snaps).map(truncateSnap);\n  }\n\n  /**\n   * Gets the serialized permitted snaps of the given origin, if any.\n   *\n   * @param origin - The origin whose permitted snaps to retrieve.\n   * @returns The serialized permitted snaps for the origin.\n   */\n  getPermittedSnaps(origin: string): InstallSnapsResult {\n    return Object.values(\n      this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        origin,\n      ) ?? {},\n    ).reduce<InstallSnapsResult>((permittedSnaps, perm) => {\n      if (perm.parentCapability.startsWith(SNAP_PREFIX)) {\n        const snapId = perm.parentCapability.replace(SNAP_PREFIX_REGEX, '');\n        const snap = this.get(snapId);\n        const truncatedSnap = this.getTruncated(snapId);\n\n        if (truncatedSnap && snap?.status !== SnapStatus.Installing) {\n          permittedSnaps[snapId] = truncatedSnap;\n        }\n      }\n      return permittedSnaps;\n    }, {});\n  }\n\n  /**\n   * Installs the snaps requested by the given origin, returning the snap\n   * object if the origin is permitted to install it, and an authorization error\n   * otherwise.\n   *\n   * @param origin - The origin that requested to install the snaps.\n   * @param requestedSnaps - The snaps to install.\n   * @returns An object of snap ids and snap objects, or errors if a\n   * snap couldn't be installed.\n   */\n  async installSnaps(\n    origin: string,\n    requestedSnaps: RequestedSnapPermissions,\n  ): Promise<InstallSnapsResult> {\n    const result: InstallSnapsResult = {};\n\n    const snapIds = Object.keys(requestedSnaps);\n\n    // Existing snaps may need to be updated\n    const pendingUpdates = snapIds.filter((snapId) => this.has(snapId));\n\n    // Non-existing snaps will need to be installed\n    const pendingInstalls = snapIds.filter(\n      (snapId) => !pendingUpdates.includes(snapId),\n    );\n\n    try {\n      for (const [snapId, { version: rawVersion }] of Object.entries(\n        requestedSnaps,\n      )) {\n        const [error, version] = resolveVersionRange(rawVersion);\n\n        if (error) {\n          throw ethErrors.rpc.invalidParams(\n            `The \"version\" field must be a valid SemVer version range if specified. Received: \"${rawVersion}\".`,\n          );\n        }\n\n        const permissionName = getSnapPermissionName(snapId);\n\n        if (\n          !this.messagingSystem.call(\n            'PermissionController:hasPermission',\n            origin,\n            permissionName,\n          )\n        ) {\n          throw ethErrors.provider.unauthorized(\n            `Not authorized to install snap \"${snapId}\". Request the permission for the snap before attempting to install it.`,\n          );\n        }\n\n        const isUpdate = pendingUpdates.includes(snapId);\n\n        if (isUpdate && this.#isValidUpdate(snapId, version)) {\n          let rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n          if (rollbackSnapshot === undefined) {\n            const prevSourceCode = this.#getRuntimeExpect(snapId).sourceCode;\n            rollbackSnapshot = this.#createRollbackSnapshot(snapId);\n            rollbackSnapshot.sourceCode = prevSourceCode;\n            rollbackSnapshot.newVersion = version;\n          } else {\n            throw new Error('This snap is already being updated.');\n          }\n        }\n\n        result[snapId] = await this.processRequestedSnap(\n          origin,\n          snapId,\n          version,\n        );\n      }\n      snapIds.forEach((snapId) => this.#rollbackSnapshots.delete(snapId));\n    } catch (error) {\n      const installed = pendingInstalls.filter((snapId) => this.has(snapId));\n      await this.removeSnaps(installed);\n      const snapshottedSnaps = [...this.#rollbackSnapshots.keys()];\n      const snapsToRollback = pendingUpdates.filter((snapId) =>\n        snapshottedSnaps.includes(snapId),\n      );\n      await this.#rollbackSnaps(snapsToRollback);\n\n      throw error;\n    }\n    return result;\n  }\n\n  /**\n   * Adds, authorizes, and runs the given snap with a snap provider.\n   * Results from this method should be efficiently serializable.\n   *\n   * @param origin - The origin requesting the snap.\n   * @param snapId - The id of the snap.\n   * @param versionRange - The semver range of the snap to install.\n   * @returns The resulting snap object, or an error if something went wrong.\n   */\n  private async processRequestedSnap(\n    origin: string,\n    snapId: SnapId,\n    versionRange: SemVerRange,\n  ): Promise<ProcessSnapResult> {\n    validateSnapId(snapId);\n\n    const location = this.#detectSnapLocation(snapId, {\n      versionRange,\n      fetch: this.#fetchFunction,\n    });\n\n    const existingSnap = this.getTruncated(snapId);\n    // For devX we always re-install local snaps.\n    if (existingSnap && !location.shouldAlwaysReload) {\n      if (satisfiesVersionRange(existingSnap.version, versionRange)) {\n        return existingSnap;\n      }\n\n      if (this.#featureFlags.dappsCanUpdateSnaps === true) {\n        const updateResult = await this.updateSnap(\n          origin,\n          snapId,\n          versionRange,\n          location,\n        );\n        if (updateResult === null) {\n          throw ethErrors.rpc.invalidParams(\n            `Snap \"${snapId}@${existingSnap.version}\" is already installed. Couldn't update to a version inside requested \"${versionRange}\" range.`,\n          );\n        }\n        return updateResult;\n      }\n      throw ethErrors.rpc.invalidParams(\n        `Version mismatch with already installed snap. ${snapId}@${existingSnap.version} doesn't satisfy requested version ${versionRange}.`,\n      );\n    }\n\n    // Existing snaps must be stopped before overwriting\n    if (existingSnap && this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    try {\n      const { sourceCode } = await this.#add({\n        origin,\n        id: snapId,\n        location,\n      });\n\n      await this.authorize(origin, snapId);\n\n      await this.#startSnap({\n        snapId,\n        sourceCode,\n      });\n\n      const truncated = this.getTruncatedExpect(snapId);\n\n      this.messagingSystem.publish(`SnapController:snapInstalled`, truncated);\n      return truncated;\n    } catch (error) {\n      console.error(`Error when adding snap.`, error);\n\n      throw error;\n    }\n  }\n\n  /**\n   * Updates an installed snap. The flow is similar to\n   * {@link SnapController.installSnaps}. The user will be asked if they want\n   * to update, then approve any permission changes, and finally the snap will\n   * be restarted.\n   *\n   * The update will fail if the user rejects any prompt or if the new version\n   * of the snap is blocked.\n   *\n   * If the original version of the snap was blocked and the update succeeded,\n   * the snap will be unblocked and enabled before it is restarted.\n   *\n   * @param origin - The origin requesting the snap update.\n   * @param snapId - The id of the Snap to be updated.\n   * @param newVersionRange - A semver version range in which the maximum version will be chosen.\n   * @param location - Optional location that was already used during installation flow.\n   * @returns The snap metadata if updated, `null` otherwise.\n   */\n  async updateSnap(\n    origin: string,\n    snapId: ValidatedSnapId,\n    newVersionRange: string = DEFAULT_REQUESTED_SNAP_VERSION,\n    location?: SnapLocation,\n  ): Promise<TruncatedSnap | null> {\n    const snap = this.getExpect(snapId);\n\n    if (!isValidSemVerRange(newVersionRange)) {\n      throw new Error(\n        `Received invalid snap version range: \"${newVersionRange}\".`,\n      );\n    }\n    const newSnap = await this.#fetchSnap(\n      snapId,\n      location ??\n        this.#detectSnapLocation(snapId, { versionRange: newVersionRange }),\n    );\n    const newVersion = newSnap.manifest.result.version;\n    if (!gtVersion(newVersion, snap.version)) {\n      console.warn(\n        `Tried updating snap \"${snapId}\" within \"${newVersionRange}\" version range, but newer version \"${snap.version}\" is already installed`,\n      );\n      return null;\n    }\n\n    await this.#assertIsUnblocked(snapId, {\n      version: newVersion,\n      shasum: newSnap.manifest.result.source.shasum,\n    });\n\n    const processedPermissions = this.#processSnapPermissions(\n      newSnap.manifest.result.initialPermissions,\n    );\n\n    const { newPermissions, unusedPermissions, approvedPermissions } =\n      this.#calculatePermissionsChange(snapId, processedPermissions);\n\n    const id = nanoid();\n    const { permissions: approvedNewPermissions, ...requestData } =\n      (await this.messagingSystem.call(\n        'ApprovalController:addRequest',\n        {\n          origin,\n          id,\n          type: SNAP_APPROVAL_UPDATE,\n          requestData: {\n            // First two keys mirror installation params\n            metadata: { id, origin: snapId, dappOrigin: origin },\n            permissions: newPermissions,\n            snapId,\n            newVersion: newSnap.manifest.result.version,\n            newPermissions,\n            approvedPermissions,\n            unusedPermissions,\n          },\n        },\n        true,\n      )) as PermissionsRequest;\n\n    if (this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    this.#transition(snapId, SnapStatusEvents.Update);\n\n    this.#set({\n      origin,\n      id: snapId,\n      manifest: newSnap.manifest,\n      files: newSnap.files,\n      versionRange: newVersionRange,\n      isUpdate: true,\n    });\n\n    const unusedPermissionsKeys = Object.keys(unusedPermissions);\n    if (isNonEmptyArray(unusedPermissionsKeys)) {\n      this.messagingSystem.call('PermissionController:revokePermissions', {\n        [snapId]: unusedPermissionsKeys,\n      });\n    }\n\n    if (isNonEmptyArray(Object.keys(approvedNewPermissions))) {\n      this.messagingSystem.call('PermissionController:grantPermissions', {\n        approvedPermissions: approvedNewPermissions,\n        subject: { origin: snapId },\n        requestData,\n      });\n    }\n\n    const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n    if (rollbackSnapshot !== undefined) {\n      rollbackSnapshot.permissions.revoked = unusedPermissions;\n      rollbackSnapshot.permissions.granted = Object.keys(\n        approvedNewPermissions,\n      );\n      rollbackSnapshot.permissions.requestData = requestData;\n    }\n\n    const sourceCode = newSnap.files\n      .find(\n        (file) =>\n          file.path === newSnap.manifest.result.source.location.npm.filePath,\n      )\n      ?.toString();\n    assert(sourceCode !== undefined);\n\n    try {\n      await this.#startSnap({ snapId, sourceCode });\n    } catch {\n      throw new Error(`Snap ${snapId} crashed with updated source code.`);\n    }\n\n    const truncatedSnap = this.getTruncatedExpect(snapId);\n    this.messagingSystem.publish(\n      'SnapController:snapUpdated',\n      truncatedSnap,\n      snap.version,\n    );\n\n    return truncatedSnap;\n  }\n\n  /**\n   * Returns a promise representing the complete installation of the requested snap.\n   * If the snap is already being installed, the previously pending promise will be returned.\n   *\n   * @param args - Object containing the snap id and either the URL of the snap's manifest,\n   * or the snap's manifest and source code. The object may also optionally contain a target\n   * version.\n   * @returns The resulting snap object.\n   */\n  async #add(args: AddSnapArgs): Promise<PersistedSnap> {\n    const { id: snapId, location } = args;\n    validateSnapId(snapId);\n\n    this.#setupRuntime(snapId, { sourceCode: null, state: null });\n    const runtime = this.#getRuntimeExpect(snapId);\n    if (!runtime.installPromise) {\n      console.info(`Adding snap: ${snapId}`);\n\n      // If fetching and setting the snap succeeds, this property will be set\n      // to null in the authorize() method.\n      runtime.installPromise = (async () => {\n        const fetchedSnap = await this.#fetchSnap(snapId, location);\n        await this.#assertIsUnblocked(snapId, {\n          version: fetchedSnap.manifest.result.version,\n          shasum: fetchedSnap.manifest.result.source.shasum,\n        });\n\n        return this.#set({\n          ...args,\n          ...fetchedSnap,\n          id: snapId,\n        });\n      })();\n    }\n\n    try {\n      return await runtime.installPromise;\n    } catch (error) {\n      // Reset promise so users can retry installation in case the problem is\n      // temporary.\n      runtime.installPromise = null;\n      throw error;\n    }\n  }\n\n  async #startSnap(snapData: { snapId: string; sourceCode: string }) {\n    const { snapId } = snapData;\n    if (this.isRunning(snapId)) {\n      throw new Error(`Snap \"${snapId}\" is already started.`);\n    }\n\n    try {\n      const result = await this.#executeWithTimeout(\n        snapId,\n        this.messagingSystem.call('ExecutionService:executeSnap', {\n          ...snapData,\n          endowments: await this.#getEndowments(snapId),\n        }),\n      );\n      this.#transition(snapId, SnapStatusEvents.Start);\n      return result;\n    } catch (error) {\n      await this.#terminateSnap(snapId);\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the names of all endowments that will be added to the Snap's\n   * Compartment when it executes. These should be the names of global\n   * JavaScript APIs accessible in the root realm of the execution environment.\n   *\n   * Throws an error if the endowment getter for a permission returns a truthy\n   * value that is not an array of strings.\n   *\n   * @param snapId - The id of the snap whose SES endowments to get.\n   * @returns An array of the names of the endowments.\n   */\n  async #getEndowments(snapId: string): Promise<string[]> {\n    let allEndowments: string[] = [];\n\n    for (const permissionName of this.#environmentEndowmentPermissions) {\n      if (\n        this.messagingSystem.call(\n          'PermissionController:hasPermission',\n          snapId,\n          permissionName,\n        )\n      ) {\n        const endowments = await this.messagingSystem.call(\n          'PermissionController:getEndowments',\n          snapId,\n          permissionName,\n        );\n\n        if (endowments) {\n          // We don't have any guarantees about the type of the endowments\n          // value, so we have to guard at runtime.\n          if (\n            !Array.isArray(endowments) ||\n            endowments.some((value) => typeof value !== 'string')\n          ) {\n            throw new Error('Expected an array of string endowment names.');\n          }\n\n          allEndowments = allEndowments.concat(endowments as string[]);\n        }\n      }\n    }\n\n    const dedupedEndowments = [\n      ...new Set([...DEFAULT_ENDOWMENTS, ...allEndowments]),\n    ];\n\n    if (\n      dedupedEndowments.length <\n      // This is a bug in TypeScript: https://github.com/microsoft/TypeScript/issues/48313\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      DEFAULT_ENDOWMENTS.length + allEndowments.length\n    ) {\n      console.error(\n        'Duplicate endowments found. Default endowments should not be requested.',\n        allEndowments,\n      );\n    }\n    return dedupedEndowments;\n  }\n\n  /**\n   * Sets a snap in state. Called when a snap is installed or updated. Performs\n   * various validation checks on the received arguments, and will throw if\n   * validation fails.\n   *\n   * The snap will be enabled and unblocked by the time this method returns,\n   * regardless of its previous state.\n   *\n   * See {@link SnapController.add} and {@link SnapController.updateSnap} for\n   * usage.\n   *\n   * @param args - The add snap args.\n   * @returns The resulting snap object.\n   */\n  #set(args: SetSnapArgs): PersistedSnap {\n    const {\n      id: snapId,\n      origin,\n      manifest,\n      files,\n      versionRange = DEFAULT_REQUESTED_SNAP_VERSION,\n      isUpdate = false,\n    } = args;\n\n    assertIsSnapManifest(manifest.result);\n    const { version } = manifest.result;\n\n    if (!satisfiesVersionRange(version, versionRange)) {\n      throw new Error(\n        `Version mismatch. Manifest for \"${snapId}\" specifies version \"${version}\" which doesn't satisfy requested version range \"${versionRange}\"`,\n      );\n    }\n\n    const sourceCode = files\n      .find(\n        (file) => file.path === manifest.result.source.location.npm.filePath,\n      )\n      ?.toString();\n    const svgIcon = files.find(\n      (file) =>\n        manifest.result.source.location.npm.iconPath !== undefined &&\n        file.path === manifest.result.source.location.npm.iconPath,\n    );\n    assert(sourceCode !== undefined);\n    if (typeof sourceCode !== 'string' || sourceCode.length === 0) {\n      throw new Error(`Invalid source code for snap \"${snapId}\".`);\n    }\n\n    const snapsState = this.state.snaps;\n\n    const existingSnap = snapsState[snapId];\n\n    const previousVersionHistory = existingSnap?.versionHistory ?? [];\n    const versionHistory = [\n      ...previousVersionHistory,\n      {\n        version,\n        date: Date.now(),\n        origin,\n      },\n    ];\n\n    const snap: Snap = {\n      // Restore relevant snap state if it exists\n      ...existingSnap,\n\n      // Note that the snap will be unblocked and enabled, regardless of its\n      // previous state.\n      blocked: false,\n      enabled: true,\n\n      // So we can easily correlate the snap with its permission\n      permissionName: getSnapPermissionName(snapId),\n\n      id: snapId,\n      initialPermissions: manifest.result.initialPermissions,\n      manifest: manifest.result,\n      status: this.#statusMachine.config.initial as StatusStates['value'],\n      version,\n      versionHistory,\n    };\n    // If the snap was blocked, it isn't any longer\n    delete snap.blockInformation;\n\n    // store the snap back in state\n    const { inversePatches } = this.update((state: any) => {\n      state.snaps[snapId] = snap;\n    });\n\n    // checking for isUpdate here as this function is also used in\n    // the install flow, we do not care to create snapshots for installs\n    if (isUpdate) {\n      const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n      if (rollbackSnapshot !== undefined) {\n        rollbackSnapshot.statePatches = inversePatches;\n      }\n    }\n\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.sourceCode = sourceCode;\n\n    this.messagingSystem.publish(\n      `SnapController:snapAdded`,\n      snap,\n      svgIcon?.toString(),\n    );\n    return { ...snap, sourceCode };\n  }\n\n  /**\n   * Fetches the manifest and source code of a snap.\n   *\n   * This function is not hash private yet because of tests.\n   *\n   * @param snapId - The id of the Snap.\n   * @param location - Source from which snap will be fetched.\n   * @returns A tuple of the Snap manifest object and the Snap source code.\n   */\n  async #fetchSnap(\n    snapId: ValidatedSnapId,\n    location: SnapLocation,\n  ): Promise<FetchSnapResult> {\n    try {\n      const manifest = await location.manifest();\n      const sourceCode = await location.fetch(\n        manifest.result.source.location.npm.filePath,\n      );\n      validateSnapShasum(manifest.result, sourceCode.toString());\n      const { iconPath } = manifest.result.source.location.npm;\n\n      const files = [sourceCode];\n      if (iconPath) {\n        files.push(await location.fetch(iconPath));\n      }\n\n      return { manifest, files, location };\n    } catch (error) {\n      // TODO(ritave): Export `getErrorMessage()` from @metamask/utils and use it here\n      //               https://github.com/MetaMask/utils/blob/62d022ef83c91fa4d150e51913be4441508a0ab1/src/assert.ts\n      const message = error instanceof Error ? error.message : error.toString();\n      throw new Error(`Failed to fetch Snap \"${snapId}\": ${message}.`);\n    }\n  }\n\n  /**\n   * Map initial permissions as defined in a Snap manifest to something that can\n   * be processed by the PermissionsController. Each caveat mapping function\n   * should return a valid permission caveat value.\n   *\n   * This function does not validate the caveat values, since that is done by\n   * the PermissionsController itself, upon requesting the permissions.\n   *\n   * @param initialPermissions - The initial permissions to process.\n   * @returns The processed permissions.\n   * @private\n   */\n  #processSnapPermissions(\n    initialPermissions: SnapPermissions,\n  ): Record<string, Pick<PermissionConstraint, 'caveats'>> {\n    return fromEntries(\n      Object.entries(initialPermissions).map(([initialPermission, value]) => {\n        if (hasProperty(caveatMappers, initialPermission)) {\n          return [initialPermission, caveatMappers[initialPermission](value)];\n        } else if (hasProperty(endowmentCaveatMappers, initialPermission)) {\n          return [\n            initialPermission,\n            endowmentCaveatMappers[initialPermission](value),\n          ];\n        }\n\n        // If we have no mapping, this may be a non-snap permission, return as-is\n        return [\n          initialPermission,\n          value as Pick<PermissionConstraint, 'caveats'>,\n        ];\n      }),\n    );\n  }\n\n  /**\n   * Initiates a request for the given snap's initial permissions.\n   * Must be called in order. See processRequestedSnap.\n   *\n   * This function is not hash private yet because of tests.\n   *\n   * @param origin - The origin of the install request.\n   * @param snapId - The id of the Snap.\n   * @returns The snap's approvedPermissions.\n   */\n  private async authorize(origin: string, snapId: SnapId): Promise<void> {\n    console.info(`Authorizing snap: ${snapId}`);\n    const snapsState = this.state.snaps;\n    const snap = snapsState[snapId];\n    const { initialPermissions } = snap;\n\n    try {\n      const processedPermissions =\n        this.#processSnapPermissions(initialPermissions);\n      const id = nanoid();\n      const { permissions: approvedPermissions, ...requestData } =\n        (await this.messagingSystem.call(\n          'ApprovalController:addRequest',\n          {\n            origin,\n            id,\n            type: SNAP_APPROVAL_INSTALL,\n            requestData: {\n              // Mirror previous installation metadata\n              metadata: { id, origin: snapId, dappOrigin: origin },\n              permissions: processedPermissions,\n              snapId,\n            },\n          },\n          true,\n        )) as PermissionsRequest;\n\n      if (isNonEmptyArray(Object.keys(approvedPermissions))) {\n        this.messagingSystem.call('PermissionController:grantPermissions', {\n          approvedPermissions,\n          subject: { origin: snapId },\n          requestData,\n        });\n      }\n    } finally {\n      const runtime = this.#getRuntimeExpect(snapId);\n      runtime.installPromise = null;\n    }\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this.#timeoutForLastRequestStatus) {\n      clearTimeout(this.#timeoutForLastRequestStatus);\n    }\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n    /* eslint-enable @typescript-eslint/unbound-method */\n  }\n\n  /**\n   * Passes a JSON-RPC request object to the RPC handler function of a snap.\n   *\n   * @param options - A bag of options.\n   * @param options.snapId - The ID of the recipient snap.\n   * @param options.origin - The origin of the RPC request.\n   * @param options.handler - The handler to trigger on the snap for the request.\n   * @param options.request - The JSON-RPC request object.\n   * @returns The result of the JSON-RPC request.\n   */\n  async handleRequest({\n    snapId,\n    origin,\n    handler: handlerType,\n    request,\n  }: SnapRpcHookArgs & { snapId: SnapId }): Promise<unknown> {\n    const permissionName = handlerEndowments[handlerType];\n    const hasPermission = this.messagingSystem.call(\n      'PermissionController:hasPermission',\n      snapId,\n      permissionName,\n    );\n\n    if (!hasPermission) {\n      throw new Error(\n        `Snap \"${snapId}\" is not permitted to use \"${permissionName}\".`,\n      );\n    }\n\n    if (permissionName === SnapEndowments.Rpc) {\n      const subject = this.messagingSystem.call(\n        'SubjectMetadataController:getSubjectMetadata',\n        origin,\n      );\n      const isSnap = subject?.subjectType === SubjectType.Snap;\n\n      const permissions = this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        snapId,\n      );\n\n      const rpcPermission = permissions?.[SnapEndowments.Rpc];\n      assert(rpcPermission);\n\n      const origins = getRpcCaveatOrigins(rpcPermission);\n      assert(origins);\n\n      if ((isSnap && !origins.snaps) || (!isSnap && !origins.dapps)) {\n        throw new Error(\n          `Snap \"${snapId}\" is not permitted to handle JSON-RPC requests from \"${origin}\".`,\n        );\n      }\n    }\n\n    const handler = await this.#getRpcRequestHandler(snapId);\n    if (!handler) {\n      throw new Error(\n        `Snap RPC message handler not found for snap \"${snapId}\".`,\n      );\n    }\n\n    return handler({ origin, handler: handlerType, request });\n  }\n\n  /**\n   * Gets the RPC message handler for the given snap.\n   *\n   * @param snapId - The id of the Snap whose message handler to get.\n   * @returns The RPC handler for the given snap.\n   */\n  #getRpcRequestHandler(snapId: SnapId): SnapRpcHook {\n    const runtime = this.#getRuntimeExpect(snapId);\n    const existingHandler = runtime.rpcHandler;\n    if (existingHandler) {\n      return existingHandler;\n    }\n\n    const requestQueue = new RequestQueue(5);\n    // We need to set up this promise map to map snapIds to their respective startPromises,\n    // because otherwise we would lose context on the correct startPromise.\n    const startPromises = new Map<string, Promise<void>>();\n\n    const rpcHandler = async ({\n      origin,\n      handler: handlerType,\n      request,\n    }: SnapRpcHookArgs) => {\n      if (this.state.snaps[snapId].enabled === false) {\n        throw new Error(`Snap \"${snapId}\" is disabled.`);\n      }\n\n      if (this.state.snaps[snapId].status === SnapStatus.Installing) {\n        throw new Error(\n          `Snap \"${snapId}\" is currently being installed. Please try again later.`,\n        );\n      }\n\n      if (!this.isRunning(snapId)) {\n        let localStartPromise = startPromises.get(snapId);\n        if (!localStartPromise) {\n          localStartPromise = this.startSnap(snapId);\n          startPromises.set(snapId, localStartPromise);\n        } else if (requestQueue.get(origin) >= requestQueue.maxQueueSize) {\n          throw new Error(\n            'Exceeds maximum number of requests waiting to be resolved, please try again.',\n          );\n        }\n\n        requestQueue.increment(origin);\n        try {\n          await localStartPromise;\n        } finally {\n          requestQueue.decrement(origin);\n          // Only delete startPromise for a snap if its value hasn't changed\n          if (startPromises.get(snapId) === localStartPromise) {\n            startPromises.delete(snapId);\n          }\n        }\n      }\n\n      let _request = request;\n      if (!hasProperty(request, 'jsonrpc')) {\n        _request = { ...request, jsonrpc: '2.0' };\n      } else if (request.jsonrpc !== '2.0') {\n        throw ethErrors.rpc.invalidRequest({\n          message: 'Invalid \"jsonrpc\" property. Must be \"2.0\" if provided.',\n          data: request.jsonrpc,\n        });\n      }\n\n      const timer = new Timer(this.maxRequestTime);\n      this.#recordSnapRpcRequestStart(snapId, request.id, timer);\n\n      const handleRpcRequestPromise = this.messagingSystem.call(\n        'ExecutionService:handleRpcRequest',\n        snapId,\n        { origin, handler: handlerType, request: _request },\n      );\n\n      // This will either get the result or reject due to the timeout.\n      try {\n        const result = await this.#executeWithTimeout(\n          snapId,\n          handleRpcRequestPromise,\n          timer,\n        );\n        this.#recordSnapRpcRequestFinish(snapId, request.id);\n        return result;\n      } catch (error) {\n        await this.stopSnap(snapId, SnapStatusEvents.Crash);\n        throw error;\n      }\n    };\n\n    runtime.rpcHandler = rpcHandler;\n    return rpcHandler;\n  }\n\n  /**\n   * Awaits the specified promise and rejects if the promise doesn't resolve\n   * before the timeout.\n   *\n   * @param snapId - The snap id.\n   * @param promise - The promise to await.\n   * @param timer - An optional timer object to control the timeout.\n   * @returns The result of the promise or rejects if the promise times out.\n   * @template PromiseValue - The value of the Promise.\n   */\n  async #executeWithTimeout<PromiseValue>(\n    snapId: SnapId,\n    promise: Promise<PromiseValue>,\n    timer?: Timer,\n  ): Promise<PromiseValue> {\n    const isLongRunning = this.messagingSystem.call(\n      'PermissionController:hasPermission',\n      snapId,\n      SnapEndowments.LongRunning,\n    );\n\n    // Long running snaps have timeouts disabled\n    if (isLongRunning) {\n      return promise;\n    }\n\n    const result = await withTimeout(promise, timer ?? this.maxRequestTime);\n    if (result === hasTimedOut) {\n      throw new Error('The request timed out.');\n    }\n    return result;\n  }\n\n  #recordSnapRpcRequestStart(snapId: SnapId, requestId: unknown, timer: Timer) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests.push({ requestId, timer });\n    runtime.lastRequest = null;\n  }\n\n  #recordSnapRpcRequestFinish(snapId: SnapId, requestId: unknown) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests = runtime.pendingInboundRequests.filter(\n      (request) => request.requestId !== requestId,\n    );\n\n    if (runtime.pendingInboundRequests.length === 0) {\n      runtime.lastRequest = Date.now();\n    }\n  }\n\n  /**\n   * Retrieves the rollback snapshot of a snap.\n   *\n   * @param snapId - The snap id.\n   * @returns A `RollbackSnapshot` or `undefined` if one doesn't exist.\n   */\n  #getRollbackSnapshot(snapId: SnapId): RollbackSnapshot | undefined {\n    return this.#rollbackSnapshots.get(snapId);\n  }\n\n  /**\n   * Creates a `RollbackSnapshot` that is used to help ensure\n   * atomicity in multiple snap updates.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If the snap exists before creation or if creation fails.\n   * @returns A `RollbackSnapshot`.\n   */\n  #createRollbackSnapshot(snapId: SnapId): RollbackSnapshot {\n    assert(\n      this.#rollbackSnapshots.get(snapId) === undefined,\n      new Error(`Snap \"${snapId}\" rollback snapshot already exists.`),\n    );\n\n    this.#rollbackSnapshots.set(snapId, {\n      statePatches: [],\n      sourceCode: '',\n      permissions: { revoked: null, granted: [], requestData: null },\n      newVersion: '',\n    });\n\n    const newRollbackSnapshot = this.#rollbackSnapshots.get(snapId);\n\n    assert(\n      newRollbackSnapshot !== undefined,\n      new Error(`Snapshot creation failed for ${snapId}.`),\n    );\n    return newRollbackSnapshot;\n  }\n\n  /**\n   * Rolls back a snap to its previous state, permissions\n   * and source code based on the `RollbackSnapshot` that\n   * is captured during the update process. After rolling back,\n   * the function also emits an event indicating that the\n   * snap has been rolled back and it clears the snapshot\n   * for that snap.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If a snapshot does not exist.\n   */\n  async #rollbackSnap(snapId: SnapId) {\n    const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n    if (!rollbackSnapshot) {\n      throw new Error('A snapshot does not exist for this snap.');\n    }\n\n    await this.stopSnap(snapId, SnapStatusEvents.Stop);\n\n    const { statePatches, sourceCode, permissions } = rollbackSnapshot;\n\n    if (statePatches?.length) {\n      this.applyPatches(statePatches);\n    }\n\n    if (sourceCode) {\n      const runtime = this.#getRuntimeExpect(snapId);\n      runtime.sourceCode = sourceCode;\n    }\n\n    if (permissions.revoked && Object.keys(permissions.revoked).length) {\n      this.messagingSystem.call('PermissionController:grantPermissions', {\n        approvedPermissions: permissions.revoked as RequestedPermissions,\n        subject: { origin: snapId },\n        requestData: permissions.requestData as Record<string, unknown>,\n      });\n    }\n\n    if (permissions.granted?.length) {\n      this.messagingSystem.call('PermissionController:revokePermissions', {\n        [snapId]: permissions.granted as NonEmptyArray<string>,\n      });\n    }\n\n    const truncatedSnap = this.getTruncatedExpect(snapId);\n\n    this.messagingSystem.publish(\n      'SnapController:snapRolledback',\n      truncatedSnap,\n      rollbackSnapshot.newVersion,\n    );\n\n    this.#rollbackSnapshots.delete(snapId);\n  }\n\n  /**\n   * Iterates through an array of snap ids\n   * and calls `rollbackSnap` on them.\n   *\n   * @param snapIds - An array of snap ids.\n   */\n  async #rollbackSnaps(snapIds: SnapId[]) {\n    for (const snapId of snapIds) {\n      await this.#rollbackSnap(snapId);\n    }\n  }\n\n  #getRuntime(snapId: SnapId): SnapRuntimeData | undefined {\n    return this.snapsRuntimeData.get(snapId);\n  }\n\n  #getRuntimeExpect(snapId: SnapId): SnapRuntimeData {\n    const runtime = this.#getRuntime(snapId);\n    assert(\n      runtime !== undefined,\n      new Error(`Snap \"${snapId}\" runtime data not found`),\n    );\n    return runtime;\n  }\n\n  #setupRuntime(\n    snapId: SnapId,\n    data: { sourceCode: string | null; state: string | null },\n  ) {\n    if (this.snapsRuntimeData.has(snapId)) {\n      return;\n    }\n\n    const snap = this.get(snapId);\n    const interpreter = interpret(this.#statusMachine);\n    interpreter.start({\n      context: { snapId },\n      value:\n        snap?.status ??\n        (this.#statusMachine.config.initial as StatusStates['value']),\n    });\n\n    forceStrict(interpreter);\n\n    this.snapsRuntimeData.set(snapId, {\n      lastRequest: null,\n      rpcHandler: null,\n      installPromise: null,\n      activeReferences: 0,\n      pendingInboundRequests: [],\n      pendingOutboundRequests: 0,\n      interpreter,\n      ...data,\n    });\n  }\n\n  #calculatePermissionsChange(\n    snapId: SnapId,\n    desiredPermissionsSet: RequestedSnapPermissions,\n  ): {\n    newPermissions: RequestedSnapPermissions;\n    unusedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n    approvedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n  } {\n    const oldPermissions =\n      this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        snapId,\n      ) ?? {};\n\n    const newPermissions = setDiff(desiredPermissionsSet, oldPermissions);\n    // TODO(ritave): The assumption that these are unused only holds so long as we do not\n    //               permit dynamic permission requests.\n    const unusedPermissions = setDiff(oldPermissions, desiredPermissionsSet);\n\n    // It's a Set Intersection of oldPermissions and desiredPermissionsSet\n    // oldPermissions  (oldPermissions  desiredPermissionsSet)  oldPermissions  desiredPermissionsSet\n    const approvedPermissions = setDiff(oldPermissions, unusedPermissions);\n\n    return { newPermissions, unusedPermissions, approvedPermissions };\n  }\n\n  /**\n   * Checks if a snap will pass version validation checks\n   * with the new version range that is requested. The first\n   * check that is done is to check if the existing snap version\n   * falls inside the requested range. If it does, we want to return\n   * false because we do not care to create a rollback snapshot in\n   * that scenario. The second check is to ensure that the current\n   * snap version is not greater than all possible versions in\n   * the requested version range. If it is, then we also want\n   * to return false in that scenario.\n   *\n   * @param snapId - The snap id.\n   * @param newVersionRange - The new version range being requsted.\n   * @returns `true` if validation checks pass and `false` if they do not.\n   */\n  #isValidUpdate(snapId: SnapId, newVersionRange: SemVerRange): boolean {\n    const existingSnap = this.getExpect(snapId);\n\n    if (satisfiesVersionRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    if (gtRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    return true;\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"SnapController.js","sourceRoot":"","sources":["../../src/snaps/SnapController.ts"],"names":[],"mappings":"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","sourcesContent":["import { AddApprovalRequest } from '@metamask/approval-controller';\nimport {\n  BaseControllerV2 as BaseController,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport {\n  Caveat,\n  GetEndowments,\n  GetPermissions,\n  GrantPermissions,\n  HasPermission,\n  HasPermissions,\n  PermissionConstraint,\n  PermissionsRequest,\n  RequestedPermissions,\n  RevokeAllPermissions,\n  RevokePermissionForAllSubjects,\n  RevokePermissions,\n  SubjectPermissions,\n  ValidPermission,\n} from '@metamask/permission-controller';\nimport { caveatMappers } from '@metamask/rpc-methods';\nimport {\n  assertIsSnapManifest,\n  DEFAULT_ENDOWMENTS,\n  DEFAULT_REQUESTED_SNAP_VERSION,\n  fromEntries,\n  getSnapPermissionName,\n  gtVersion,\n  gtRange,\n  InstallSnapsResult,\n  isValidSemVerRange,\n  PersistedSnap,\n  ProcessSnapResult,\n  RequestedSnapPermissions,\n  resolveVersionRange,\n  satisfiesVersionRange,\n  SemVerRange,\n  Snap,\n  SnapId,\n  SnapManifest,\n  SnapPermissions,\n  SnapRpcHook,\n  SnapRpcHookArgs,\n  SnapStatus,\n  SnapStatusEvents,\n  SNAP_PREFIX,\n  SNAP_PREFIX_REGEX,\n  StatusContext,\n  StatusEvents,\n  StatusStates,\n  TruncatedSnap,\n  TruncatedSnapFields,\n  ValidatedSnapId,\n  validateSnapId,\n  validateSnapShasum,\n  VirtualFile,\n  SnapRegistry,\n  SnapRegistryInfo,\n  SnapRegistryRequest,\n  SnapRegistryStatus,\n  SnapRegistryBlockReason,\n} from '@metamask/snaps-utils';\nimport {\n  GetSubjectMetadata,\n  SubjectType,\n} from '@metamask/subject-metadata-controller';\nimport {\n  assert,\n  Duration,\n  hasProperty,\n  inMilliseconds,\n  isNonEmptyArray,\n  Json,\n  NonEmptyArray,\n  timeSince,\n} from '@metamask/utils';\nimport { createMachine, interpret, StateMachine } from '@xstate/fsm';\nimport { ethErrors } from 'eth-rpc-errors';\nimport type { Patch } from 'immer';\nimport { nanoid } from 'nanoid';\n\nimport { forceStrict, validateMachine } from '../fsm';\nimport {\n  ExecuteSnapAction,\n  ExecutionServiceEvents,\n  HandleRpcRequestAction,\n  SnapErrorJson,\n  TerminateAllSnapsAction,\n  TerminateSnapAction,\n} from '../services';\nimport { hasTimedOut, setDiff, withTimeout } from '../utils';\nimport {\n  endowmentCaveatMappers,\n  handlerEndowments,\n  SnapEndowments,\n} from './endowments';\nimport { getRpcCaveatOrigins } from './endowments/rpc';\nimport { detectSnapLocation, SnapLocation } from './location';\nimport { JsonSnapRegistry } from './registry';\nimport { RequestQueue } from './RequestQueue';\nimport { Timer } from './Timer';\n\nexport const controllerName = 'SnapController';\n\n// TODO: Figure out how to name these\nexport const SNAP_APPROVAL_INSTALL = 'wallet_installSnap';\nexport const SNAP_APPROVAL_UPDATE = 'wallet_updateSnap';\n\nconst TRUNCATED_SNAP_PROPERTIES = new Set<TruncatedSnapFields>([\n  'initialPermissions',\n  'id',\n  'permissionName',\n  'version',\n  'enabled',\n  'blocked',\n]);\n\nexport type PendingRequest = {\n  requestId: unknown;\n  timer: Timer;\n};\n\n/**\n * A wrapper type for any data stored during runtime of Snaps.\n * It is not persisted in state as it contains non-serializable data and is only relevant for the\n * current session.\n */\nexport interface SnapRuntimeData {\n  /**\n   * A promise that resolves when the Snap has finished installing\n   */\n  installPromise: null | Promise<PersistedSnap>;\n\n  /**\n   * A Unix timestamp for the last time the Snap received an RPC request\n   */\n  lastRequest: null | number;\n\n  /**\n   * The current number of active references where this Snap is being used\n   */\n  activeReferences: number;\n\n  /**\n   * The current pending inbound requests, meaning requests that are processed by snaps.\n   */\n  pendingInboundRequests: PendingRequest[];\n\n  /**\n   * The current pending outbound requests, meaning requests made from snaps towards the MetaMask\n   * extension.\n   */\n  pendingOutboundRequests: number;\n\n  /**\n   * RPC handler designated for the Snap\n   */\n  rpcHandler: null | SnapRpcHook;\n\n  /**\n   * The finite state machine interpreter for possible states that the Snap can be in such as\n   * stopped, running, blocked\n   *\n   * @see {@link SnapController:constructor}\n   */\n  interpreter: StateMachine.Service<StatusContext, StatusEvents, StatusStates>;\n\n  /**\n   * The snap source code\n   */\n  sourceCode: null | string;\n\n  /**\n   * The snap state (encrypted)\n   */\n  state: null | string;\n}\n\nexport type SnapError = {\n  message: string;\n  code: number;\n  data?: Json;\n};\n\n/**\n * The return type of {@link SnapController.#fetchSnap} and its sibling methods.\n */\ntype FetchSnapResult = {\n  /**\n   * The manifest of the fetched Snap.\n   */\n  manifest: VirtualFile<SnapManifest>;\n\n  /**\n   * Auxillary files references in manifest.\n   */\n  files: VirtualFile[];\n\n  /**\n   * Location that was used to fetch the snap.\n   *\n   * Helpful if you want to pass it forward since files will be still cached.\n   */\n  location: SnapLocation;\n};\n\n// Types that probably should be defined elsewhere in prod\ntype CloseAllConnectionsFunction = (origin: string) => void;\ntype StoredSnaps = Record<SnapId, Snap>;\n\nexport type SnapControllerState = {\n  snaps: StoredSnaps;\n  // This type needs to be defined but is always empty in practice.\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  snapStates: {};\n  snapErrors: {\n    [internalID: string]: SnapError & { internalID: string };\n  };\n};\n\nexport type PersistedSnapControllerState = SnapControllerState & {\n  snaps: Record<SnapId, PersistedSnap>;\n  snapStates: Record<SnapId, string>;\n};\n\ntype RollbackSnapshot = {\n  statePatches: Patch[];\n  sourceCode: string | null;\n  permissions: {\n    revoked: unknown;\n    granted: unknown[];\n    requestData: unknown;\n  };\n  newVersion: string;\n};\n\n// Controller Messenger Actions\n\n/**\n * Gets the specified Snap from state.\n */\nexport type GetSnap = {\n  type: `${typeof controllerName}:get`;\n  handler: SnapController['get'];\n};\n\n/**\n * Handles sending an inbound request to a snap and returns its result.\n */\nexport type HandleSnapRequest = {\n  type: `${typeof controllerName}:handleRequest`;\n  handler: SnapController['handleRequest'];\n};\n\n/**\n * Gets the specified Snap's persisted state.\n */\nexport type GetSnapState = {\n  type: `${typeof controllerName}:getSnapState`;\n  handler: SnapController['getSnapState'];\n};\n\n/**\n * Checks if the specified snap exists in state.\n */\nexport type HasSnap = {\n  type: `${typeof controllerName}:has`;\n  handler: SnapController['has'];\n};\n\n/**\n * Updates the specified Snap's persisted state.\n */\nexport type UpdateSnapState = {\n  type: `${typeof controllerName}:updateSnapState`;\n  handler: SnapController['updateSnapState'];\n};\n\n/**\n * Clears the specified Snap's persisted state.\n */\nexport type ClearSnapState = {\n  type: `${typeof controllerName}:clearSnapState`;\n  handler: SnapController['clearSnapState'];\n};\n\n/**\n * Checks all installed snaps against the blocklist.\n */\nexport type UpdateBlockedSnaps = {\n  type: `${typeof controllerName}:updateBlockedSnaps`;\n  handler: SnapController['updateBlockedSnaps'];\n};\n\nexport type EnableSnap = {\n  type: `${typeof controllerName}:enable`;\n  handler: SnapController['enableSnap'];\n};\n\nexport type DisableSnap = {\n  type: `${typeof controllerName}:disable`;\n  handler: SnapController['disableSnap'];\n};\n\nexport type RemoveSnap = {\n  type: `${typeof controllerName}:remove`;\n  handler: SnapController['removeSnap'];\n};\n\nexport type GetPermittedSnaps = {\n  type: `${typeof controllerName}:getPermitted`;\n  handler: SnapController['getPermittedSnaps'];\n};\n\nexport type GetAllSnaps = {\n  type: `${typeof controllerName}:getAll`;\n  handler: SnapController['getAllSnaps'];\n};\n\nexport type IncrementActiveReferences = {\n  type: `${typeof controllerName}:incrementActiveReferences`;\n  handler: SnapController['incrementActiveReferences'];\n};\n\nexport type DecrementActiveReferences = {\n  type: `${typeof controllerName}:decrementActiveReferences`;\n  handler: SnapController['decrementActiveReferences'];\n};\n\nexport type InstallSnaps = {\n  type: `${typeof controllerName}:install`;\n  handler: SnapController['installSnaps'];\n};\n\nexport type RemoveSnapError = {\n  type: `${typeof controllerName}:removeSnapError`;\n  handler: SnapController['removeSnapError'];\n};\n\nexport type SnapControllerActions =\n  | ClearSnapState\n  | GetSnap\n  | GetSnapState\n  | HandleSnapRequest\n  | HasSnap\n  | UpdateBlockedSnaps\n  | UpdateSnapState\n  | EnableSnap\n  | DisableSnap\n  | RemoveSnap\n  | GetPermittedSnaps\n  | InstallSnaps\n  | RemoveSnapError\n  | GetAllSnaps\n  | IncrementActiveReferences\n  | DecrementActiveReferences;\n\n// Controller Messenger Events\n\nexport type SnapStateChange = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [SnapControllerState, Patch[]];\n};\n\n/**\n * Emitted when a Snap has been added to state during installation.\n */\nexport type SnapAdded = {\n  type: `${typeof controllerName}:snapAdded`;\n  payload: [snap: Snap, svgIcon: string | undefined];\n};\n\n/**\n * Emitted when an installed snap has been blocked.\n */\nexport type SnapBlocked = {\n  type: `${typeof controllerName}:snapBlocked`;\n  payload: [snapId: string, blockedSnapInfo?: SnapRegistryBlockReason];\n};\n\n/**\n * Emitted when a snap has been started after being added and authorized during\n * installation.\n */\nexport type SnapInstalled = {\n  type: `${typeof controllerName}:snapInstalled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when a snap is removed.\n */\nexport type SnapRemoved = {\n  type: `${typeof controllerName}:snapRemoved`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when an installed snap has been unblocked.\n */\nexport type SnapUnblocked = {\n  type: `${typeof controllerName}:snapUnblocked`;\n  payload: [snapId: string];\n};\n\n/**\n * Emitted when a snap is updated.\n */\nexport type SnapUpdated = {\n  type: `${typeof controllerName}:snapUpdated`;\n  payload: [snap: TruncatedSnap, oldVersion: string];\n};\n\n/**\n * Emitted when a snap is rolled back.\n */\nexport type SnapRolledback = {\n  type: `${typeof controllerName}:snapRolledback`;\n  payload: [snap: TruncatedSnap, failedVersion: string];\n};\n/**\n * Emitted when a Snap is terminated. This is different from the snap being\n * stopped as it can also be triggered when a snap fails initialization.\n */\nexport type SnapTerminated = {\n  type: `${typeof controllerName}:snapTerminated`;\n  payload: [snap: TruncatedSnap];\n};\n\nexport type SnapControllerEvents =\n  | SnapAdded\n  | SnapBlocked\n  | SnapInstalled\n  | SnapRemoved\n  | SnapStateChange\n  | SnapUnblocked\n  | SnapUpdated\n  | SnapRolledback\n  | SnapTerminated;\n\nexport type AllowedActions =\n  | GetEndowments\n  | GetPermissions\n  | GetSubjectMetadata\n  | HasPermission\n  | HasPermissions\n  | RevokePermissions\n  | RevokeAllPermissions\n  | RevokePermissionForAllSubjects\n  | GrantPermissions\n  | AddApprovalRequest\n  | HandleRpcRequestAction\n  | ExecuteSnapAction\n  | TerminateAllSnapsAction\n  | TerminateSnapAction;\n\nexport type AllowedEvents = ExecutionServiceEvents;\n\ntype SnapControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  SnapControllerActions | AllowedActions,\n  SnapControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\ntype FeatureFlags = {\n  /**\n   * We still need to implement new UI approval page in metamask-extension before we can allow\n   * DApps to update Snaps. After it's added, this flag can be removed.\n   *\n   * @see {SNAP_APPROVAL_UPDATE}\n   * @see {SnapController.processRequestedSnap}\n   */\n  dappsCanUpdateSnaps?: true;\n  requireAllowlist?: true;\n};\n\ntype SnapControllerArgs = {\n  /**\n   * A teardown function that allows the host to clean up its instrumentation\n   * for a running snap.\n   */\n  closeAllConnections: CloseAllConnectionsFunction;\n\n  /**\n   * The names of endowment permissions whose values are the names of JavaScript\n   * APIs that will be added to the snap execution environment at runtime.\n   */\n  environmentEndowmentPermissions: string[];\n\n  /**\n   * The function that will be used by the controller fo make network requests.\n   * Should be compatible with {@link fetch}.\n   */\n  fetchFunction?: typeof fetch;\n\n  /**\n   * Flags that enable or disable features in the controller.\n   * See {@link FeatureFlags}.\n   */\n  featureFlags: FeatureFlags;\n\n  /**\n   * How frequently to check whether a snap is idle.\n   */\n  idleTimeCheckInterval?: number;\n\n  /**\n   * TODO\n   */\n  registry: SnapRegistry;\n\n  /**\n   * The maximum amount of time that a snap may be idle.\n   */\n  maxIdleTime?: number;\n\n  /**\n   * The controller messenger.\n   */\n  messenger: SnapControllerMessenger;\n\n  /**\n   * The maximum amount of time a snap may take to process an RPC request,\n   * unless it is permitted to take longer.\n   */\n  maxRequestTime?: number;\n\n  /**\n   * The npm registry URL that will be used to fetch published snaps.\n   */\n  npmRegistryUrl?: string;\n\n  /**\n   * Persisted state that will be used for rehydration.\n   */\n  state?: PersistedSnapControllerState;\n\n  /**\n   * A function that takes Snap Id and converts it into a class that fetches files.\n   *\n   * Used for test overrides.\n   */\n  detectSnapLocation?: typeof detectSnapLocation;\n};\ntype AddSnapArgs = {\n  id: SnapId;\n  origin: string;\n  location: SnapLocation;\n};\n\n// When we set a snap, we need all required properties to be present and\n// validated.\ntype SetSnapArgs = Omit<AddSnapArgs, 'id' | 'location'> & {\n  id: ValidatedSnapId;\n  manifest: VirtualFile<SnapManifest>;\n  files: VirtualFile[];\n  /**\n   * @default '*'\n   */\n  // TODO(ritave): Used only for validation in #set, should be moved elsewhere.\n  versionRange?: SemVerRange;\n  isUpdate?: boolean;\n};\n\nconst defaultState: SnapControllerState = {\n  snapErrors: {},\n  snaps: {},\n  snapStates: {},\n};\n\n/**\n * Truncates the properties of a snap to only ones that are easily serializable.\n *\n * @param snap - The snap to truncate.\n * @returns Object with serializable snap properties.\n */\nfunction truncateSnap(snap: Snap): TruncatedSnap {\n  const truncatedSnap = Object.keys(snap).reduce<Partial<TruncatedSnap>>(\n    (serialized, key) => {\n      if (TRUNCATED_SNAP_PROPERTIES.has(key as any)) {\n        serialized[key as keyof TruncatedSnap] = snap[\n          key as keyof TruncatedSnap\n        ] as any;\n      }\n\n      return serialized;\n    },\n    {},\n  );\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return truncatedSnap as TruncatedSnap;\n}\n\nconst name = 'SnapController';\n\n/*\n * A snap is initialized in three phases:\n * - Add: Loads the snap from a remote source and parses it.\n * - Authorize: Requests the snap's required permissions from the user.\n * - Start: Initializes the snap in its SES realm with the authorized permissions.\n */\n\nexport class SnapController extends BaseController<\n  string,\n  SnapControllerState,\n  SnapControllerMessenger\n> {\n  #closeAllConnections: CloseAllConnectionsFunction;\n\n  #environmentEndowmentPermissions: string[];\n\n  #featureFlags: FeatureFlags;\n\n  #fetchFunction: typeof fetch;\n\n  #idleTimeCheckInterval: number;\n\n  #registry: SnapRegistry;\n\n  #maxIdleTime: number;\n\n  // This property cannot be hash private yet because of tests.\n  private readonly maxRequestTime: number;\n\n  #detectSnapLocation: typeof detectSnapLocation;\n\n  // This property cannot be hash private yet because of tests.\n  private readonly snapsRuntimeData: Map<SnapId, SnapRuntimeData>;\n\n  #rollbackSnapshots: Map<SnapId, RollbackSnapshot>;\n\n  #timeoutForLastRequestStatus?: number;\n\n  #statusMachine!: StateMachine.Machine<\n    StatusContext,\n    StatusEvents,\n    StatusStates\n  >;\n\n  constructor({\n    closeAllConnections,\n    messenger,\n    state,\n    environmentEndowmentPermissions = [],\n    idleTimeCheckInterval = inMilliseconds(5, Duration.Second),\n    registry = new JsonSnapRegistry(),\n    maxIdleTime = inMilliseconds(30, Duration.Second),\n    maxRequestTime = inMilliseconds(60, Duration.Second),\n    fetchFunction = globalThis.fetch.bind(globalThis),\n    featureFlags = {},\n    detectSnapLocation: detectSnapLocationFunction = detectSnapLocation,\n  }: SnapControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        snapErrors: {\n          persist: false,\n          anonymous: false,\n        },\n        snapStates: {\n          persist: () => {\n            return Object.keys(this.state.snaps).reduce<\n              Record<string, string | null>\n            >((acc, cur) => {\n              acc[cur] = this.#getRuntimeExpect(cur).state;\n              return acc;\n            }, {});\n          },\n          anonymous: false,\n        },\n        snaps: {\n          persist: (snaps) => {\n            return Object.values(snaps)\n              .map((snap) => {\n                return {\n                  ...snap,\n                  sourceCode: this.#getRuntimeExpect(snap.id).sourceCode,\n                  // At the time state is rehydrated, no snap will be running.\n                  status: SnapStatus.Stopped,\n                };\n              })\n              .reduce((memo: Record<string, Snap>, snap) => {\n                memo[snap.id] = snap;\n                return memo;\n              }, {});\n          },\n          anonymous: false,\n        },\n      },\n      name,\n      state: {\n        ...defaultState,\n        ...{\n          ...state,\n          snaps: Object.values(state?.snaps ?? {}).reduce(\n            (memo: Record<string, Snap>, snap) => {\n              // eslint-disable-next-line @typescript-eslint/no-unused-vars\n              const { sourceCode, ...rest } = snap;\n              memo[snap.id] = rest;\n              return memo;\n            },\n            {},\n          ),\n        },\n      },\n    });\n\n    this.#closeAllConnections = closeAllConnections;\n    this.#environmentEndowmentPermissions = environmentEndowmentPermissions;\n    this.#featureFlags = featureFlags;\n    this.#fetchFunction = fetchFunction;\n    this.#idleTimeCheckInterval = idleTimeCheckInterval;\n    this.#registry = registry;\n    this.#maxIdleTime = maxIdleTime;\n    this.maxRequestTime = maxRequestTime;\n    this.#detectSnapLocation = detectSnapLocationFunction;\n    this._onUnhandledSnapError = this._onUnhandledSnapError.bind(this);\n    this._onOutboundRequest = this._onOutboundRequest.bind(this);\n    this._onOutboundResponse = this._onOutboundResponse.bind(this);\n    this.#rollbackSnapshots = new Map();\n    this.snapsRuntimeData = new Map();\n    this.#pollForLastRequestStatus();\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.subscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messagingSystem.subscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messagingSystem.subscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n    this.#initializeStateMachine();\n    this.#registerMessageHandlers();\n\n    Object.values(state?.snaps ?? {}).forEach((snap) =>\n      this.#setupRuntime(snap.id, {\n        sourceCode: snap.sourceCode,\n        state: state?.snapStates?.[snap.id] ?? null,\n      }),\n    );\n  }\n\n  /**\n   * We track status of a Snap using a finite-state-machine.\n   * It keeps track of whether the snap is started / stopped / etc.\n   *\n   * @see {@link SnapController.transition} for interacting with the machine.\n   */\n  // We initialize the machine in the instance because the status is currently tightly coupled\n  // with the SnapController - the guard checks for enabled status inside the SnapController state.\n  // In the future, side-effects could be added to the machine during transitions.\n  #initializeStateMachine() {\n    const disableGuard = ({ snapId }: StatusContext) => {\n      return this.getExpect(snapId).enabled;\n    };\n\n    const statusConfig: StateMachine.Config<\n      StatusContext,\n      StatusEvents,\n      StatusStates\n    > = {\n      initial: SnapStatus.Installing,\n      states: {\n        [SnapStatus.Installing]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n          },\n        },\n        [SnapStatus.Updating]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n          },\n        },\n        [SnapStatus.Running]: {\n          on: {\n            [SnapStatusEvents.Stop]: SnapStatus.Stopped,\n            [SnapStatusEvents.Crash]: SnapStatus.Crashed,\n          },\n        },\n        [SnapStatus.Stopped]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Update]: SnapStatus.Updating,\n          },\n        },\n        [SnapStatus.Crashed]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n          },\n        },\n      },\n    };\n    this.#statusMachine = createMachine(statusConfig);\n    validateMachine(this.#statusMachine);\n  }\n\n  /**\n   * Constructor helper for registering the controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers(): void {\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:clearSnapState`,\n      (...args) => this.clearSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:get`,\n      (...args) => this.get(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getSnapState`,\n      async (...args) => this.getSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:handleRequest`,\n      async (...args) => this.handleRequest(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:has`,\n      (...args) => this.has(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateBlockedSnaps`,\n      async () => this.updateBlockedSnaps(),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateSnapState`,\n      async (...args) => this.updateSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:enable`,\n      (...args) => this.enableSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:disable`,\n      async (...args) => this.disableSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:remove`,\n      async (...args) => this.removeSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getPermitted`,\n      (...args) => this.getPermittedSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:install`,\n      async (...args) => this.installSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:removeSnapError`,\n      (...args) => this.removeSnapError(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getAll`,\n      (...args) => this.getAllSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:incrementActiveReferences`,\n      (...args) => this.incrementActiveReferences(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:decrementActiveReferences`,\n      (...args) => this.decrementActiveReferences(...args),\n    );\n  }\n\n  #pollForLastRequestStatus() {\n    this.#timeoutForLastRequestStatus = setTimeout(() => {\n      this.#stopSnapsLastRequestPastMax().catch((error) => {\n        // TODO: Decide how to handle errors.\n        console.error(error);\n      });\n\n      this.#pollForLastRequestStatus();\n    }, this.#idleTimeCheckInterval) as unknown as number;\n  }\n\n  /**\n   * Checks all installed snaps against the block list and\n   * blocks/unblocks snaps as appropriate. See {@link SnapController.blockSnap}\n   * for more information.\n   */\n  async updateBlockedSnaps(): Promise<void> {\n    const blockedSnaps = await this.#registry.get(\n      Object.values(this.state.snaps).reduce<SnapRegistryRequest>(\n        (blockListArg, snap) => {\n          blockListArg[snap.id] = {\n            version: snap.version,\n            checksum: snap.manifest.source.shasum,\n          };\n          return blockListArg;\n        },\n        {},\n      ),\n    );\n\n    await Promise.all(\n      Object.entries(blockedSnaps).map(async ([snapId, { status, reason }]) => {\n        if (status === SnapRegistryStatus.Blocked) {\n          return this.#blockSnap(snapId, reason);\n        }\n\n        return this.#unblockSnap(snapId);\n      }),\n    );\n  }\n\n  /**\n   * Blocks an installed snap and prevents it from being started again. Emits\n   * {@link SnapBlocked}. Does nothing if the snap is not installed.\n   *\n   * @param snapId - The snap to block.\n   * @param blockedSnapInfo - Information detailing why the snap is blocked.\n   */\n  async #blockSnap(\n    snapId: SnapId,\n    blockedSnapInfo?: SnapRegistryBlockReason,\n  ): Promise<void> {\n    if (!this.has(snapId)) {\n      return;\n    }\n\n    try {\n      this.update((state: any) => {\n        state.snaps[snapId].blocked = true;\n        state.snaps[snapId].blockInformation = blockedSnapInfo;\n      });\n\n      await this.disableSnap(snapId);\n    } catch (error) {\n      console.error(\n        `Encountered error when stopping blocked snap \"${snapId}\".`,\n        error,\n      );\n    }\n\n    this.messagingSystem.publish(\n      `${controllerName}:snapBlocked`,\n      snapId,\n      blockedSnapInfo,\n    );\n  }\n\n  /**\n   * Unblocks a snap so that it can be enabled and started again. Emits\n   * {@link SnapUnblocked}. Does nothing if the snap is not installed or already\n   * unblocked.\n   *\n   * @param snapId - The id of the snap to unblock.\n   */\n  #unblockSnap(snapId: SnapId) {\n    if (!this.has(snapId) || !this.state.snaps[snapId].blocked) {\n      return;\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].blocked = false;\n      delete state.snaps[snapId].blockInformation;\n    });\n\n    this.messagingSystem.publish(`${controllerName}:snapUnblocked`, snapId);\n  }\n\n  async #assertIsInstallAllowed(\n    snapId: ValidatedSnapId,\n    snapInfo: SnapRegistryInfo,\n  ) {\n    const results = await this.#registry.get({\n      [snapId]: snapInfo,\n    });\n    const result = results[snapId];\n    if (result.status === SnapRegistryStatus.Blocked) {\n      throw new Error(\n        `Cannot install version \"${snapInfo.version}\" of snap \"${snapId}\": the version is blocked.`,\n      );\n    } else if (\n      this.#featureFlags.requireAllowlist &&\n      result.status !== SnapRegistryStatus.Verified\n    ) {\n      throw new Error(\n        `Cannot install version \"${snapInfo.version}\" of snap \"${snapId}\": the snap is not allowlisted.`,\n      );\n    }\n  }\n\n  async #stopSnapsLastRequestPastMax() {\n    const entries = [...this.snapsRuntimeData.entries()];\n    return Promise.all(\n      entries\n        .filter(\n          ([_snapId, runtime]) =>\n            runtime.activeReferences === 0 &&\n            runtime.pendingInboundRequests.length === 0 &&\n            // lastRequest should always be set here but TypeScript wants this check\n            runtime.lastRequest &&\n            this.#maxIdleTime &&\n            timeSince(runtime.lastRequest) > this.#maxIdleTime,\n        )\n        .map(async ([snapId]) => this.stopSnap(snapId, SnapStatusEvents.Stop)),\n    );\n  }\n\n  _onUnhandledSnapError(snapId: SnapId, error: SnapErrorJson) {\n    this.stopSnap(snapId, SnapStatusEvents.Crash)\n      .then(() => this.addSnapError(error))\n      .catch((stopSnapError) => {\n        // TODO: Decide how to handle errors.\n        console.error(stopSnapError);\n      });\n  }\n\n  _onOutboundRequest(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    // Ideally we would only pause the pending request that is making the outbound request\n    // but right now we don't have a way to know which request initiated the outbound request\n    runtime.pendingInboundRequests\n      .filter((pendingRequest) => pendingRequest.timer.status === 'running')\n      .forEach((pendingRequest) => pendingRequest.timer.pause());\n    runtime.pendingOutboundRequests += 1;\n  }\n\n  _onOutboundResponse(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingOutboundRequests -= 1;\n    if (runtime.pendingOutboundRequests === 0) {\n      runtime.pendingInboundRequests\n        .filter((pendingRequest) => pendingRequest.timer.status === 'paused')\n        .forEach((pendingRequest) => pendingRequest.timer.resume());\n    }\n  }\n\n  /**\n   * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out\n   * the next state. This transition function uses a very minimal subset of XState conventions:\n   * - supports initial state\n   * - .on supports raw event target string\n   * - .on supports {target, cond} object\n   * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event,\n   * context) => boolean`\n   *\n   * @param snapId - The id of the snap to transition.\n   * @param event - The event enum to use to transition.\n   */\n  #transition(snapId: SnapId, event: StatusEvents | StatusEvents['type']) {\n    const { interpreter } = this.#getRuntimeExpect(snapId);\n    interpreter.send(event);\n    this.update((state: any) => {\n      state.snaps[snapId].status = interpreter.state.value;\n    });\n  }\n\n  /**\n   * Starts the given snap. Throws an error if no such snap exists\n   * or if it is already running.\n   *\n   * @param snapId - The id of the Snap to start.\n   */\n  async startSnap(snapId: SnapId): Promise<void> {\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (this.state.snaps[snapId].enabled === false) {\n      throw new Error(`Snap \"${snapId}\" is disabled.`);\n    }\n\n    assert(runtime.sourceCode);\n\n    await this.#startSnap({\n      snapId,\n      sourceCode: runtime.sourceCode,\n    });\n  }\n\n  /**\n   * Enables the given snap. A snap can only be started if it is enabled. A snap\n   * can only be enabled if it isn't blocked.\n   *\n   * @param snapId - The id of the Snap to enable.\n   */\n  enableSnap(snapId: SnapId): void {\n    this.getExpect(snapId);\n\n    if (this.state.snaps[snapId].blocked) {\n      throw new Error(`Snap \"${snapId}\" is blocked and cannot be enabled.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = true;\n    });\n  }\n\n  /**\n   * Disables the given snap. A snap can only be started if it is enabled.\n   *\n   * @param snapId - The id of the Snap to disable.\n   * @returns A promise that resolves once the snap has been disabled.\n   */\n  async disableSnap(snapId: SnapId): Promise<void> {\n    if (!this.has(snapId)) {\n      throw new Error(`Snap \"${snapId}\" not found.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = false;\n    });\n\n    if (this.isRunning(snapId)) {\n      return this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    return Promise.resolve();\n  }\n\n  /**\n   * Stops the given snap, removes all hooks, closes all connections, and\n   * terminates its worker.\n   *\n   * @param snapId - The id of the Snap to stop.\n   * @param statusEvent - The Snap status event that caused the snap to be\n   * stopped.\n   */\n  public async stopSnap(\n    snapId: SnapId,\n    statusEvent:\n      | SnapStatusEvents.Stop\n      | SnapStatusEvents.Crash = SnapStatusEvents.Stop,\n  ): Promise<void> {\n    const runtime = this.#getRuntime(snapId);\n    if (!runtime) {\n      throw new Error(`The snap \"${snapId}\" is not running.`);\n    }\n\n    // Reset request tracking\n    runtime.lastRequest = null;\n    runtime.pendingInboundRequests = [];\n    runtime.pendingOutboundRequests = 0;\n    try {\n      if (this.isRunning(snapId)) {\n        this.#closeAllConnections(snapId);\n        await this.#terminateSnap(snapId);\n      }\n    } finally {\n      if (this.isRunning(snapId)) {\n        this.#transition(snapId, statusEvent);\n      }\n    }\n  }\n\n  /**\n   * Terminates the specified snap and emits the `snapTerminated` event.\n   *\n   * @param snapId - The snap to terminate.\n   */\n  async #terminateSnap(snapId: SnapId) {\n    await this.messagingSystem.call('ExecutionService:terminateSnap', snapId);\n    this.messagingSystem.publish(\n      'SnapController:snapTerminated',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Returns whether the given snap is running.\n   * Throws an error if the snap doesn't exist.\n   *\n   * @param snapId - The id of the Snap to check.\n   * @returns `true` if the snap is running, otherwise `false`.\n   */\n  isRunning(snapId: SnapId): boolean {\n    return this.getExpect(snapId).status === 'running';\n  }\n\n  /**\n   * Returns whether the given snap has been added to state.\n   *\n   * @param snapId - The id of the Snap to check for.\n   * @returns `true` if the snap exists in the controller state, otherwise `false`.\n   */\n  has(snapId: SnapId): boolean {\n    return Boolean(this.get(snapId));\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, including all data.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns The entire snap object from the controller state.\n   */\n  get(snapId: SnapId): Snap | undefined {\n    return this.state.snaps[snapId];\n  }\n\n  /**\n   * Gets the snap with the given id, throws if doesn't.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @see {@link SnapController.get}\n   * @throws {@link Error}. If the snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns The entire snap object.\n   */\n  getExpect(snapId: SnapId): Snap {\n    const snap = this.get(snapId);\n    assert(snap !== undefined, new Error(`Snap \"${snapId}\" not found.`));\n    return snap;\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, excluding any\n   * non-serializable or expensive-to-serialize data.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  // TODO(ritave): this.get returns undefined, this.getTruncated returns null\n  getTruncated(snapId: SnapId): TruncatedSnap | null {\n    const snap = this.get(snapId);\n\n    return snap ? truncateSnap(snap) : null;\n  }\n\n  /**\n   * Gets the snap with the given id, throw if it doesn't exist.\n   *\n   * @throws {@link Error}. If snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  getTruncatedExpect(snapId: SnapId): TruncatedSnap {\n    return truncateSnap(this.getExpect(snapId));\n  }\n\n  /**\n   * Updates the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be updated.\n   * @param newSnapState - The new state of the snap.\n   */\n  async updateSnapState(snapId: SnapId, newSnapState: string): Promise<void> {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.state = newSnapState;\n  }\n\n  /**\n   * Clears the state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be cleared.\n   */\n  clearSnapState(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.state = null;\n  }\n\n  /**\n   * Adds error from a snap to the SnapController state.\n   *\n   * @param snapError - The error to store on the SnapController.\n   */\n  addSnapError(snapError: SnapError): void {\n    this.update((state: any) => {\n      const id = nanoid();\n      state.snapErrors[id] = {\n        ...snapError,\n        internalID: id,\n      };\n    });\n  }\n\n  /**\n   * Removes an error by internalID from the SnapControllers state.\n   *\n   * @param internalID - The internal error ID to remove on the SnapController.\n   */\n  removeSnapError(internalID: string) {\n    this.update((state: any) => {\n      delete state.snapErrors[internalID];\n    });\n  }\n\n  /**\n   * Clears all errors from the SnapControllers state.\n   */\n  clearSnapErrors() {\n    this.update((state: any) => {\n      state.snapErrors = {};\n    });\n  }\n\n  /**\n   * Gets the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state to get.\n   * @returns A promise that resolves with the decrypted snap state or null if no state exists.\n   * @throws If the snap state decryption fails.\n   */\n  async getSnapState(snapId: SnapId): Promise<Json> {\n    const { state } = this.#getRuntimeExpect(snapId);\n    return state ?? null;\n  }\n\n  /**\n   * Completely clear the controller's state: delete all associated data,\n   * handlers, event listeners, and permissions; tear down all snap providers.\n   */\n  async clearState() {\n    const snapIds = Object.keys(this.state.snaps);\n    snapIds.forEach((snapId) => {\n      this.#closeAllConnections(snapId);\n    });\n\n    await this.messagingSystem.call('ExecutionService:terminateAllSnaps');\n    snapIds.forEach((snapId) => this.revokeAllSnapPermissions(snapId));\n\n    this.update((state: any) => {\n      state.snaps = {};\n      state.snapStates = {};\n    });\n  }\n\n  /**\n   * Removes the given snap from state, and clears all associated handlers\n   * and listeners.\n   *\n   * @param snapId - The id of the Snap.\n   * @returns A promise that resolves once the snap has been removed.\n   */\n  async removeSnap(snapId: SnapId): Promise<void> {\n    return this.removeSnaps([snapId]);\n  }\n\n  /**\n   * Stops the given snaps, removes them from state, and clears all associated\n   * permissions, handlers, and listeners.\n   *\n   * @param snapIds - The ids of the Snaps.\n   */\n  async removeSnaps(snapIds: string[]): Promise<void> {\n    if (!Array.isArray(snapIds)) {\n      throw new Error('Expected array of snap ids.');\n    }\n\n    await Promise.all(\n      snapIds.map(async (snapId) => {\n        const truncated = this.getTruncatedExpect(snapId);\n        // Disable the snap and revoke all of its permissions before deleting\n        // it. This ensures that the snap will not be restarted or otherwise\n        // affect the host environment while we are deleting it.\n        await this.disableSnap(snapId);\n        this.revokeAllSnapPermissions(snapId);\n\n        const permissionName = getSnapPermissionName(snapId);\n        // Revoke all subjects access to the snap\n        this.messagingSystem.call(\n          'PermissionController:revokePermissionForAllSubjects',\n          permissionName,\n        );\n\n        this.snapsRuntimeData.delete(snapId);\n\n        this.update((state: any) => {\n          delete state.snaps[snapId];\n          delete state.snapStates[snapId];\n        });\n\n        this.messagingSystem.publish(`SnapController:snapRemoved`, truncated);\n      }),\n    );\n  }\n\n  /**\n   * Safely revokes all permissions granted to a Snap.\n   *\n   * @param snapId - The snap ID.\n   */\n  private revokeAllSnapPermissions(snapId: string) {\n    if (\n      this.messagingSystem.call('PermissionController:hasPermissions', snapId)\n    ) {\n      this.messagingSystem.call(\n        'PermissionController:revokeAllPermissions',\n        snapId,\n      );\n    }\n  }\n\n  /**\n   * Handles incrementing the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced.\n   */\n  incrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.activeReferences += 1;\n  }\n\n  /**\n   * Handles decrement the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced..\n   */\n  decrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    assert(\n      runtime.activeReferences > 0,\n      'SnapController reference management is in an invalid state.',\n    );\n    runtime.activeReferences -= 1;\n  }\n\n  /**\n   * Gets all snaps in their truncated format.\n   *\n   * @returns All installed snaps in their truncated format.\n   */\n  getAllSnaps(): TruncatedSnap[] {\n    return Object.values(this.state.snaps).map(truncateSnap);\n  }\n\n  /**\n   * Gets the serialized permitted snaps of the given origin, if any.\n   *\n   * @param origin - The origin whose permitted snaps to retrieve.\n   * @returns The serialized permitted snaps for the origin.\n   */\n  getPermittedSnaps(origin: string): InstallSnapsResult {\n    return Object.values(\n      this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        origin,\n      ) ?? {},\n    ).reduce<InstallSnapsResult>((permittedSnaps, perm) => {\n      if (perm.parentCapability.startsWith(SNAP_PREFIX)) {\n        const snapId = perm.parentCapability.replace(SNAP_PREFIX_REGEX, '');\n        const snap = this.get(snapId);\n        const truncatedSnap = this.getTruncated(snapId);\n\n        if (truncatedSnap && snap?.status !== SnapStatus.Installing) {\n          permittedSnaps[snapId] = truncatedSnap;\n        }\n      }\n      return permittedSnaps;\n    }, {});\n  }\n\n  /**\n   * Installs the snaps requested by the given origin, returning the snap\n   * object if the origin is permitted to install it, and an authorization error\n   * otherwise.\n   *\n   * @param origin - The origin that requested to install the snaps.\n   * @param requestedSnaps - The snaps to install.\n   * @returns An object of snap ids and snap objects, or errors if a\n   * snap couldn't be installed.\n   */\n  async installSnaps(\n    origin: string,\n    requestedSnaps: RequestedSnapPermissions,\n  ): Promise<InstallSnapsResult> {\n    const result: InstallSnapsResult = {};\n\n    const snapIds = Object.keys(requestedSnaps);\n\n    // Existing snaps may need to be updated\n    const pendingUpdates = snapIds.filter((snapId) => this.has(snapId));\n\n    // Non-existing snaps will need to be installed\n    const pendingInstalls = snapIds.filter(\n      (snapId) => !pendingUpdates.includes(snapId),\n    );\n\n    try {\n      for (const [snapId, { version: rawVersion }] of Object.entries(\n        requestedSnaps,\n      )) {\n        const [error, version] = resolveVersionRange(rawVersion);\n\n        if (error) {\n          throw ethErrors.rpc.invalidParams(\n            `The \"version\" field must be a valid SemVer version range if specified. Received: \"${rawVersion}\".`,\n          );\n        }\n\n        const permissionName = getSnapPermissionName(snapId);\n\n        if (\n          !this.messagingSystem.call(\n            'PermissionController:hasPermission',\n            origin,\n            permissionName,\n          )\n        ) {\n          throw ethErrors.provider.unauthorized(\n            `Not authorized to install snap \"${snapId}\". Request the permission for the snap before attempting to install it.`,\n          );\n        }\n\n        const isUpdate = pendingUpdates.includes(snapId);\n\n        if (isUpdate && this.#isValidUpdate(snapId, version)) {\n          let rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n          if (rollbackSnapshot === undefined) {\n            const prevSourceCode = this.#getRuntimeExpect(snapId).sourceCode;\n            rollbackSnapshot = this.#createRollbackSnapshot(snapId);\n            rollbackSnapshot.sourceCode = prevSourceCode;\n            rollbackSnapshot.newVersion = version;\n          } else {\n            throw new Error('This snap is already being updated.');\n          }\n        }\n\n        result[snapId] = await this.processRequestedSnap(\n          origin,\n          snapId,\n          version,\n        );\n      }\n      snapIds.forEach((snapId) => this.#rollbackSnapshots.delete(snapId));\n    } catch (error) {\n      const installed = pendingInstalls.filter((snapId) => this.has(snapId));\n      await this.removeSnaps(installed);\n      const snapshottedSnaps = [...this.#rollbackSnapshots.keys()];\n      const snapsToRollback = pendingUpdates.filter((snapId) =>\n        snapshottedSnaps.includes(snapId),\n      );\n      await this.#rollbackSnaps(snapsToRollback);\n\n      throw error;\n    }\n    return result;\n  }\n\n  /**\n   * Adds, authorizes, and runs the given snap with a snap provider.\n   * Results from this method should be efficiently serializable.\n   *\n   * @param origin - The origin requesting the snap.\n   * @param snapId - The id of the snap.\n   * @param versionRange - The semver range of the snap to install.\n   * @returns The resulting snap object, or an error if something went wrong.\n   */\n  private async processRequestedSnap(\n    origin: string,\n    snapId: SnapId,\n    versionRange: SemVerRange,\n  ): Promise<ProcessSnapResult> {\n    validateSnapId(snapId);\n\n    const location = this.#detectSnapLocation(snapId, {\n      versionRange,\n      fetch: this.#fetchFunction,\n    });\n\n    const existingSnap = this.getTruncated(snapId);\n    // For devX we always re-install local snaps.\n    if (existingSnap && !location.shouldAlwaysReload) {\n      if (satisfiesVersionRange(existingSnap.version, versionRange)) {\n        return existingSnap;\n      }\n\n      if (this.#featureFlags.dappsCanUpdateSnaps === true) {\n        const updateResult = await this.updateSnap(\n          origin,\n          snapId,\n          versionRange,\n          location,\n        );\n        if (updateResult === null) {\n          throw ethErrors.rpc.invalidParams(\n            `Snap \"${snapId}@${existingSnap.version}\" is already installed. Couldn't update to a version inside requested \"${versionRange}\" range.`,\n          );\n        }\n        return updateResult;\n      }\n      throw ethErrors.rpc.invalidParams(\n        `Version mismatch with already installed snap. ${snapId}@${existingSnap.version} doesn't satisfy requested version ${versionRange}.`,\n      );\n    }\n\n    // Existing snaps must be stopped before overwriting\n    if (existingSnap && this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    try {\n      const { sourceCode } = await this.#add({\n        origin,\n        id: snapId,\n        location,\n      });\n\n      await this.authorize(origin, snapId);\n\n      await this.#startSnap({\n        snapId,\n        sourceCode,\n      });\n\n      const truncated = this.getTruncatedExpect(snapId);\n\n      this.messagingSystem.publish(`SnapController:snapInstalled`, truncated);\n      return truncated;\n    } catch (error) {\n      console.error(`Error when adding snap.`, error);\n\n      throw error;\n    }\n  }\n\n  /**\n   * Updates an installed snap. The flow is similar to\n   * {@link SnapController.installSnaps}. The user will be asked if they want\n   * to update, then approve any permission changes, and finally the snap will\n   * be restarted.\n   *\n   * The update will fail if the user rejects any prompt or if the new version\n   * of the snap is blocked.\n   *\n   * If the original version of the snap was blocked and the update succeeded,\n   * the snap will be unblocked and enabled before it is restarted.\n   *\n   * @param origin - The origin requesting the snap update.\n   * @param snapId - The id of the Snap to be updated.\n   * @param newVersionRange - A semver version range in which the maximum version will be chosen.\n   * @param location - Optional location that was already used during installation flow.\n   * @returns The snap metadata if updated, `null` otherwise.\n   */\n  async updateSnap(\n    origin: string,\n    snapId: ValidatedSnapId,\n    newVersionRange: string = DEFAULT_REQUESTED_SNAP_VERSION,\n    location?: SnapLocation,\n  ): Promise<TruncatedSnap | null> {\n    const snap = this.getExpect(snapId);\n\n    if (!isValidSemVerRange(newVersionRange)) {\n      throw new Error(\n        `Received invalid snap version range: \"${newVersionRange}\".`,\n      );\n    }\n    const newSnap = await this.#fetchSnap(\n      snapId,\n      location ??\n        this.#detectSnapLocation(snapId, { versionRange: newVersionRange }),\n    );\n    const newVersion = newSnap.manifest.result.version;\n    if (!gtVersion(newVersion, snap.version)) {\n      console.warn(\n        `Tried updating snap \"${snapId}\" within \"${newVersionRange}\" version range, but newer version \"${snap.version}\" is already installed`,\n      );\n      return null;\n    }\n\n    await this.#assertIsInstallAllowed(snapId, {\n      version: newVersion,\n      checksum: newSnap.manifest.result.source.shasum,\n    });\n\n    const processedPermissions = this.#processSnapPermissions(\n      newSnap.manifest.result.initialPermissions,\n    );\n\n    const { newPermissions, unusedPermissions, approvedPermissions } =\n      this.#calculatePermissionsChange(snapId, processedPermissions);\n\n    const id = nanoid();\n    const { permissions: approvedNewPermissions, ...requestData } =\n      (await this.messagingSystem.call(\n        'ApprovalController:addRequest',\n        {\n          origin,\n          id,\n          type: SNAP_APPROVAL_UPDATE,\n          requestData: {\n            // First two keys mirror installation params\n            metadata: { id, origin: snapId, dappOrigin: origin },\n            permissions: newPermissions,\n            snapId,\n            newVersion: newSnap.manifest.result.version,\n            newPermissions,\n            approvedPermissions,\n            unusedPermissions,\n          },\n        },\n        true,\n      )) as PermissionsRequest;\n\n    if (this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    this.#transition(snapId, SnapStatusEvents.Update);\n\n    this.#set({\n      origin,\n      id: snapId,\n      manifest: newSnap.manifest,\n      files: newSnap.files,\n      versionRange: newVersionRange,\n      isUpdate: true,\n    });\n\n    const unusedPermissionsKeys = Object.keys(unusedPermissions);\n    if (isNonEmptyArray(unusedPermissionsKeys)) {\n      this.messagingSystem.call('PermissionController:revokePermissions', {\n        [snapId]: unusedPermissionsKeys,\n      });\n    }\n\n    if (isNonEmptyArray(Object.keys(approvedNewPermissions))) {\n      this.messagingSystem.call('PermissionController:grantPermissions', {\n        approvedPermissions: approvedNewPermissions,\n        subject: { origin: snapId },\n        requestData,\n      });\n    }\n\n    const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n    if (rollbackSnapshot !== undefined) {\n      rollbackSnapshot.permissions.revoked = unusedPermissions;\n      rollbackSnapshot.permissions.granted = Object.keys(\n        approvedNewPermissions,\n      );\n      rollbackSnapshot.permissions.requestData = requestData;\n    }\n\n    const sourceCode = newSnap.files\n      .find(\n        (file) =>\n          file.path === newSnap.manifest.result.source.location.npm.filePath,\n      )\n      ?.toString();\n    assert(sourceCode !== undefined);\n\n    try {\n      await this.#startSnap({ snapId, sourceCode });\n    } catch {\n      throw new Error(`Snap ${snapId} crashed with updated source code.`);\n    }\n\n    const truncatedSnap = this.getTruncatedExpect(snapId);\n    this.messagingSystem.publish(\n      'SnapController:snapUpdated',\n      truncatedSnap,\n      snap.version,\n    );\n\n    return truncatedSnap;\n  }\n\n  /**\n   * Returns a promise representing the complete installation of the requested snap.\n   * If the snap is already being installed, the previously pending promise will be returned.\n   *\n   * @param args - Object containing the snap id and either the URL of the snap's manifest,\n   * or the snap's manifest and source code. The object may also optionally contain a target\n   * version.\n   * @returns The resulting snap object.\n   */\n  async #add(args: AddSnapArgs): Promise<PersistedSnap> {\n    const { id: snapId, location } = args;\n    validateSnapId(snapId);\n\n    this.#setupRuntime(snapId, { sourceCode: null, state: null });\n    const runtime = this.#getRuntimeExpect(snapId);\n    if (!runtime.installPromise) {\n      console.info(`Adding snap: ${snapId}`);\n\n      // If fetching and setting the snap succeeds, this property will be set\n      // to null in the authorize() method.\n      runtime.installPromise = (async () => {\n        const fetchedSnap = await this.#fetchSnap(snapId, location);\n        await this.#assertIsInstallAllowed(snapId, {\n          version: fetchedSnap.manifest.result.version,\n          checksum: fetchedSnap.manifest.result.source.shasum,\n        });\n\n        return this.#set({\n          ...args,\n          ...fetchedSnap,\n          id: snapId,\n        });\n      })();\n    }\n\n    try {\n      return await runtime.installPromise;\n    } catch (error) {\n      // Reset promise so users can retry installation in case the problem is\n      // temporary.\n      runtime.installPromise = null;\n      throw error;\n    }\n  }\n\n  async #startSnap(snapData: { snapId: string; sourceCode: string }) {\n    const { snapId } = snapData;\n    if (this.isRunning(snapId)) {\n      throw new Error(`Snap \"${snapId}\" is already started.`);\n    }\n\n    try {\n      const result = await this.#executeWithTimeout(\n        snapId,\n        this.messagingSystem.call('ExecutionService:executeSnap', {\n          ...snapData,\n          endowments: await this.#getEndowments(snapId),\n        }),\n      );\n      this.#transition(snapId, SnapStatusEvents.Start);\n      return result;\n    } catch (error) {\n      await this.#terminateSnap(snapId);\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the names of all endowments that will be added to the Snap's\n   * Compartment when it executes. These should be the names of global\n   * JavaScript APIs accessible in the root realm of the execution environment.\n   *\n   * Throws an error if the endowment getter for a permission returns a truthy\n   * value that is not an array of strings.\n   *\n   * @param snapId - The id of the snap whose SES endowments to get.\n   * @returns An array of the names of the endowments.\n   */\n  async #getEndowments(snapId: string): Promise<string[]> {\n    let allEndowments: string[] = [];\n\n    for (const permissionName of this.#environmentEndowmentPermissions) {\n      if (\n        this.messagingSystem.call(\n          'PermissionController:hasPermission',\n          snapId,\n          permissionName,\n        )\n      ) {\n        const endowments = await this.messagingSystem.call(\n          'PermissionController:getEndowments',\n          snapId,\n          permissionName,\n        );\n\n        if (endowments) {\n          // We don't have any guarantees about the type of the endowments\n          // value, so we have to guard at runtime.\n          if (\n            !Array.isArray(endowments) ||\n            endowments.some((value) => typeof value !== 'string')\n          ) {\n            throw new Error('Expected an array of string endowment names.');\n          }\n\n          allEndowments = allEndowments.concat(endowments as string[]);\n        }\n      }\n    }\n\n    const dedupedEndowments = [\n      ...new Set([...DEFAULT_ENDOWMENTS, ...allEndowments]),\n    ];\n\n    if (\n      dedupedEndowments.length <\n      // This is a bug in TypeScript: https://github.com/microsoft/TypeScript/issues/48313\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      DEFAULT_ENDOWMENTS.length + allEndowments.length\n    ) {\n      console.error(\n        'Duplicate endowments found. Default endowments should not be requested.',\n        allEndowments,\n      );\n    }\n    return dedupedEndowments;\n  }\n\n  /**\n   * Sets a snap in state. Called when a snap is installed or updated. Performs\n   * various validation checks on the received arguments, and will throw if\n   * validation fails.\n   *\n   * The snap will be enabled and unblocked by the time this method returns,\n   * regardless of its previous state.\n   *\n   * See {@link SnapController.add} and {@link SnapController.updateSnap} for\n   * usage.\n   *\n   * @param args - The add snap args.\n   * @returns The resulting snap object.\n   */\n  #set(args: SetSnapArgs): PersistedSnap {\n    const {\n      id: snapId,\n      origin,\n      manifest,\n      files,\n      versionRange = DEFAULT_REQUESTED_SNAP_VERSION,\n      isUpdate = false,\n    } = args;\n\n    assertIsSnapManifest(manifest.result);\n    const { version } = manifest.result;\n\n    if (!satisfiesVersionRange(version, versionRange)) {\n      throw new Error(\n        `Version mismatch. Manifest for \"${snapId}\" specifies version \"${version}\" which doesn't satisfy requested version range \"${versionRange}\"`,\n      );\n    }\n\n    const sourceCode = files\n      .find(\n        (file) => file.path === manifest.result.source.location.npm.filePath,\n      )\n      ?.toString();\n    const svgIcon = files.find(\n      (file) =>\n        manifest.result.source.location.npm.iconPath !== undefined &&\n        file.path === manifest.result.source.location.npm.iconPath,\n    );\n    assert(sourceCode !== undefined);\n    if (typeof sourceCode !== 'string' || sourceCode.length === 0) {\n      throw new Error(`Invalid source code for snap \"${snapId}\".`);\n    }\n\n    const snapsState = this.state.snaps;\n\n    const existingSnap = snapsState[snapId];\n\n    const previousVersionHistory = existingSnap?.versionHistory ?? [];\n    const versionHistory = [\n      ...previousVersionHistory,\n      {\n        version,\n        date: Date.now(),\n        origin,\n      },\n    ];\n\n    const snap: Snap = {\n      // Restore relevant snap state if it exists\n      ...existingSnap,\n\n      // Note that the snap will be unblocked and enabled, regardless of its\n      // previous state.\n      blocked: false,\n      enabled: true,\n\n      // So we can easily correlate the snap with its permission\n      permissionName: getSnapPermissionName(snapId),\n\n      id: snapId,\n      initialPermissions: manifest.result.initialPermissions,\n      manifest: manifest.result,\n      status: this.#statusMachine.config.initial as StatusStates['value'],\n      version,\n      versionHistory,\n    };\n    // If the snap was blocked, it isn't any longer\n    delete snap.blockInformation;\n\n    // store the snap back in state\n    const { inversePatches } = this.update((state: any) => {\n      state.snaps[snapId] = snap;\n    });\n\n    // checking for isUpdate here as this function is also used in\n    // the install flow, we do not care to create snapshots for installs\n    if (isUpdate) {\n      const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n      if (rollbackSnapshot !== undefined) {\n        rollbackSnapshot.statePatches = inversePatches;\n      }\n    }\n\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.sourceCode = sourceCode;\n\n    this.messagingSystem.publish(\n      `SnapController:snapAdded`,\n      snap,\n      svgIcon?.toString(),\n    );\n    return { ...snap, sourceCode };\n  }\n\n  /**\n   * Fetches the manifest and source code of a snap.\n   *\n   * This function is not hash private yet because of tests.\n   *\n   * @param snapId - The id of the Snap.\n   * @param location - Source from which snap will be fetched.\n   * @returns A tuple of the Snap manifest object and the Snap source code.\n   */\n  async #fetchSnap(\n    snapId: ValidatedSnapId,\n    location: SnapLocation,\n  ): Promise<FetchSnapResult> {\n    try {\n      const manifest = await location.manifest();\n      const sourceCode = await location.fetch(\n        manifest.result.source.location.npm.filePath,\n      );\n      validateSnapShasum(manifest.result, sourceCode.toString());\n      const { iconPath } = manifest.result.source.location.npm;\n\n      const files = [sourceCode];\n      if (iconPath) {\n        files.push(await location.fetch(iconPath));\n      }\n\n      return { manifest, files, location };\n    } catch (error) {\n      // TODO(ritave): Export `getErrorMessage()` from @metamask/utils and use it here\n      //               https://github.com/MetaMask/utils/blob/62d022ef83c91fa4d150e51913be4441508a0ab1/src/assert.ts\n      const message = error instanceof Error ? error.message : error.toString();\n      throw new Error(`Failed to fetch Snap \"${snapId}\": ${message}.`);\n    }\n  }\n\n  /**\n   * Map initial permissions as defined in a Snap manifest to something that can\n   * be processed by the PermissionsController. Each caveat mapping function\n   * should return a valid permission caveat value.\n   *\n   * This function does not validate the caveat values, since that is done by\n   * the PermissionsController itself, upon requesting the permissions.\n   *\n   * @param initialPermissions - The initial permissions to process.\n   * @returns The processed permissions.\n   * @private\n   */\n  #processSnapPermissions(\n    initialPermissions: SnapPermissions,\n  ): Record<string, Pick<PermissionConstraint, 'caveats'>> {\n    return fromEntries(\n      Object.entries(initialPermissions).map(([initialPermission, value]) => {\n        if (hasProperty(caveatMappers, initialPermission)) {\n          return [initialPermission, caveatMappers[initialPermission](value)];\n        } else if (hasProperty(endowmentCaveatMappers, initialPermission)) {\n          return [\n            initialPermission,\n            endowmentCaveatMappers[initialPermission](value),\n          ];\n        }\n\n        // If we have no mapping, this may be a non-snap permission, return as-is\n        return [\n          initialPermission,\n          value as Pick<PermissionConstraint, 'caveats'>,\n        ];\n      }),\n    );\n  }\n\n  /**\n   * Initiates a request for the given snap's initial permissions.\n   * Must be called in order. See processRequestedSnap.\n   *\n   * This function is not hash private yet because of tests.\n   *\n   * @param origin - The origin of the install request.\n   * @param snapId - The id of the Snap.\n   * @returns The snap's approvedPermissions.\n   */\n  private async authorize(origin: string, snapId: SnapId): Promise<void> {\n    console.info(`Authorizing snap: ${snapId}`);\n    const snapsState = this.state.snaps;\n    const snap = snapsState[snapId];\n    const { initialPermissions } = snap;\n\n    try {\n      const processedPermissions =\n        this.#processSnapPermissions(initialPermissions);\n      const id = nanoid();\n      const { permissions: approvedPermissions, ...requestData } =\n        (await this.messagingSystem.call(\n          'ApprovalController:addRequest',\n          {\n            origin,\n            id,\n            type: SNAP_APPROVAL_INSTALL,\n            requestData: {\n              // Mirror previous installation metadata\n              metadata: { id, origin: snapId, dappOrigin: origin },\n              permissions: processedPermissions,\n              snapId,\n            },\n          },\n          true,\n        )) as PermissionsRequest;\n\n      if (isNonEmptyArray(Object.keys(approvedPermissions))) {\n        this.messagingSystem.call('PermissionController:grantPermissions', {\n          approvedPermissions,\n          subject: { origin: snapId },\n          requestData,\n        });\n      }\n    } finally {\n      const runtime = this.#getRuntimeExpect(snapId);\n      runtime.installPromise = null;\n    }\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this.#timeoutForLastRequestStatus) {\n      clearTimeout(this.#timeoutForLastRequestStatus);\n    }\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n    /* eslint-enable @typescript-eslint/unbound-method */\n  }\n\n  /**\n   * Passes a JSON-RPC request object to the RPC handler function of a snap.\n   *\n   * @param options - A bag of options.\n   * @param options.snapId - The ID of the recipient snap.\n   * @param options.origin - The origin of the RPC request.\n   * @param options.handler - The handler to trigger on the snap for the request.\n   * @param options.request - The JSON-RPC request object.\n   * @returns The result of the JSON-RPC request.\n   */\n  async handleRequest({\n    snapId,\n    origin,\n    handler: handlerType,\n    request,\n  }: SnapRpcHookArgs & { snapId: SnapId }): Promise<unknown> {\n    const permissionName = handlerEndowments[handlerType];\n    const hasPermission = this.messagingSystem.call(\n      'PermissionController:hasPermission',\n      snapId,\n      permissionName,\n    );\n\n    if (!hasPermission) {\n      throw new Error(\n        `Snap \"${snapId}\" is not permitted to use \"${permissionName}\".`,\n      );\n    }\n\n    if (permissionName === SnapEndowments.Rpc) {\n      const subject = this.messagingSystem.call(\n        'SubjectMetadataController:getSubjectMetadata',\n        origin,\n      );\n      const isSnap = subject?.subjectType === SubjectType.Snap;\n\n      const permissions = this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        snapId,\n      );\n\n      const rpcPermission = permissions?.[SnapEndowments.Rpc];\n      assert(rpcPermission);\n\n      const origins = getRpcCaveatOrigins(rpcPermission);\n      assert(origins);\n\n      if ((isSnap && !origins.snaps) || (!isSnap && !origins.dapps)) {\n        throw new Error(\n          `Snap \"${snapId}\" is not permitted to handle JSON-RPC requests from \"${origin}\".`,\n        );\n      }\n    }\n\n    const handler = await this.#getRpcRequestHandler(snapId);\n    if (!handler) {\n      throw new Error(\n        `Snap RPC message handler not found for snap \"${snapId}\".`,\n      );\n    }\n\n    return handler({ origin, handler: handlerType, request });\n  }\n\n  /**\n   * Gets the RPC message handler for the given snap.\n   *\n   * @param snapId - The id of the Snap whose message handler to get.\n   * @returns The RPC handler for the given snap.\n   */\n  #getRpcRequestHandler(snapId: SnapId): SnapRpcHook {\n    const runtime = this.#getRuntimeExpect(snapId);\n    const existingHandler = runtime.rpcHandler;\n    if (existingHandler) {\n      return existingHandler;\n    }\n\n    const requestQueue = new RequestQueue(5);\n    // We need to set up this promise map to map snapIds to their respective startPromises,\n    // because otherwise we would lose context on the correct startPromise.\n    const startPromises = new Map<string, Promise<void>>();\n\n    const rpcHandler = async ({\n      origin,\n      handler: handlerType,\n      request,\n    }: SnapRpcHookArgs) => {\n      if (this.state.snaps[snapId].enabled === false) {\n        throw new Error(`Snap \"${snapId}\" is disabled.`);\n      }\n\n      if (this.state.snaps[snapId].status === SnapStatus.Installing) {\n        throw new Error(\n          `Snap \"${snapId}\" is currently being installed. Please try again later.`,\n        );\n      }\n\n      if (!this.isRunning(snapId)) {\n        let localStartPromise = startPromises.get(snapId);\n        if (!localStartPromise) {\n          localStartPromise = this.startSnap(snapId);\n          startPromises.set(snapId, localStartPromise);\n        } else if (requestQueue.get(origin) >= requestQueue.maxQueueSize) {\n          throw new Error(\n            'Exceeds maximum number of requests waiting to be resolved, please try again.',\n          );\n        }\n\n        requestQueue.increment(origin);\n        try {\n          await localStartPromise;\n        } finally {\n          requestQueue.decrement(origin);\n          // Only delete startPromise for a snap if its value hasn't changed\n          if (startPromises.get(snapId) === localStartPromise) {\n            startPromises.delete(snapId);\n          }\n        }\n      }\n\n      let _request = request;\n      if (!hasProperty(request, 'jsonrpc')) {\n        _request = { ...request, jsonrpc: '2.0' };\n      } else if (request.jsonrpc !== '2.0') {\n        throw ethErrors.rpc.invalidRequest({\n          message: 'Invalid \"jsonrpc\" property. Must be \"2.0\" if provided.',\n          data: request.jsonrpc,\n        });\n      }\n\n      const timer = new Timer(this.maxRequestTime);\n      this.#recordSnapRpcRequestStart(snapId, request.id, timer);\n\n      const handleRpcRequestPromise = this.messagingSystem.call(\n        'ExecutionService:handleRpcRequest',\n        snapId,\n        { origin, handler: handlerType, request: _request },\n      );\n\n      // This will either get the result or reject due to the timeout.\n      try {\n        const result = await this.#executeWithTimeout(\n          snapId,\n          handleRpcRequestPromise,\n          timer,\n        );\n        this.#recordSnapRpcRequestFinish(snapId, request.id);\n        return result;\n      } catch (error) {\n        await this.stopSnap(snapId, SnapStatusEvents.Crash);\n        throw error;\n      }\n    };\n\n    runtime.rpcHandler = rpcHandler;\n    return rpcHandler;\n  }\n\n  /**\n   * Awaits the specified promise and rejects if the promise doesn't resolve\n   * before the timeout.\n   *\n   * @param snapId - The snap id.\n   * @param promise - The promise to await.\n   * @param timer - An optional timer object to control the timeout.\n   * @returns The result of the promise or rejects if the promise times out.\n   * @template PromiseValue - The value of the Promise.\n   */\n  async #executeWithTimeout<PromiseValue>(\n    snapId: SnapId,\n    promise: Promise<PromiseValue>,\n    timer?: Timer,\n  ): Promise<PromiseValue> {\n    const isLongRunning = this.messagingSystem.call(\n      'PermissionController:hasPermission',\n      snapId,\n      SnapEndowments.LongRunning,\n    );\n\n    // Long running snaps have timeouts disabled\n    if (isLongRunning) {\n      return promise;\n    }\n\n    const result = await withTimeout(promise, timer ?? this.maxRequestTime);\n    if (result === hasTimedOut) {\n      throw new Error('The request timed out.');\n    }\n    return result;\n  }\n\n  #recordSnapRpcRequestStart(snapId: SnapId, requestId: unknown, timer: Timer) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests.push({ requestId, timer });\n    runtime.lastRequest = null;\n  }\n\n  #recordSnapRpcRequestFinish(snapId: SnapId, requestId: unknown) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests = runtime.pendingInboundRequests.filter(\n      (request) => request.requestId !== requestId,\n    );\n\n    if (runtime.pendingInboundRequests.length === 0) {\n      runtime.lastRequest = Date.now();\n    }\n  }\n\n  /**\n   * Retrieves the rollback snapshot of a snap.\n   *\n   * @param snapId - The snap id.\n   * @returns A `RollbackSnapshot` or `undefined` if one doesn't exist.\n   */\n  #getRollbackSnapshot(snapId: SnapId): RollbackSnapshot | undefined {\n    return this.#rollbackSnapshots.get(snapId);\n  }\n\n  /**\n   * Creates a `RollbackSnapshot` that is used to help ensure\n   * atomicity in multiple snap updates.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If the snap exists before creation or if creation fails.\n   * @returns A `RollbackSnapshot`.\n   */\n  #createRollbackSnapshot(snapId: SnapId): RollbackSnapshot {\n    assert(\n      this.#rollbackSnapshots.get(snapId) === undefined,\n      new Error(`Snap \"${snapId}\" rollback snapshot already exists.`),\n    );\n\n    this.#rollbackSnapshots.set(snapId, {\n      statePatches: [],\n      sourceCode: '',\n      permissions: { revoked: null, granted: [], requestData: null },\n      newVersion: '',\n    });\n\n    const newRollbackSnapshot = this.#rollbackSnapshots.get(snapId);\n\n    assert(\n      newRollbackSnapshot !== undefined,\n      new Error(`Snapshot creation failed for ${snapId}.`),\n    );\n    return newRollbackSnapshot;\n  }\n\n  /**\n   * Rolls back a snap to its previous state, permissions\n   * and source code based on the `RollbackSnapshot` that\n   * is captured during the update process. After rolling back,\n   * the function also emits an event indicating that the\n   * snap has been rolled back and it clears the snapshot\n   * for that snap.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If a snapshot does not exist.\n   */\n  async #rollbackSnap(snapId: SnapId) {\n    const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n    if (!rollbackSnapshot) {\n      throw new Error('A snapshot does not exist for this snap.');\n    }\n\n    await this.stopSnap(snapId, SnapStatusEvents.Stop);\n\n    const { statePatches, sourceCode, permissions } = rollbackSnapshot;\n\n    if (statePatches?.length) {\n      this.applyPatches(statePatches);\n    }\n\n    if (sourceCode) {\n      const runtime = this.#getRuntimeExpect(snapId);\n      runtime.sourceCode = sourceCode;\n    }\n\n    if (permissions.revoked && Object.keys(permissions.revoked).length) {\n      this.messagingSystem.call('PermissionController:grantPermissions', {\n        approvedPermissions: permissions.revoked as RequestedPermissions,\n        subject: { origin: snapId },\n        requestData: permissions.requestData as Record<string, unknown>,\n      });\n    }\n\n    if (permissions.granted?.length) {\n      this.messagingSystem.call('PermissionController:revokePermissions', {\n        [snapId]: permissions.granted as NonEmptyArray<string>,\n      });\n    }\n\n    const truncatedSnap = this.getTruncatedExpect(snapId);\n\n    this.messagingSystem.publish(\n      'SnapController:snapRolledback',\n      truncatedSnap,\n      rollbackSnapshot.newVersion,\n    );\n\n    this.#rollbackSnapshots.delete(snapId);\n  }\n\n  /**\n   * Iterates through an array of snap ids\n   * and calls `rollbackSnap` on them.\n   *\n   * @param snapIds - An array of snap ids.\n   */\n  async #rollbackSnaps(snapIds: SnapId[]) {\n    for (const snapId of snapIds) {\n      await this.#rollbackSnap(snapId);\n    }\n  }\n\n  #getRuntime(snapId: SnapId): SnapRuntimeData | undefined {\n    return this.snapsRuntimeData.get(snapId);\n  }\n\n  #getRuntimeExpect(snapId: SnapId): SnapRuntimeData {\n    const runtime = this.#getRuntime(snapId);\n    assert(\n      runtime !== undefined,\n      new Error(`Snap \"${snapId}\" runtime data not found`),\n    );\n    return runtime;\n  }\n\n  #setupRuntime(\n    snapId: SnapId,\n    data: { sourceCode: string | null; state: string | null },\n  ) {\n    if (this.snapsRuntimeData.has(snapId)) {\n      return;\n    }\n\n    const snap = this.get(snapId);\n    const interpreter = interpret(this.#statusMachine);\n    interpreter.start({\n      context: { snapId },\n      value:\n        snap?.status ??\n        (this.#statusMachine.config.initial as StatusStates['value']),\n    });\n\n    forceStrict(interpreter);\n\n    this.snapsRuntimeData.set(snapId, {\n      lastRequest: null,\n      rpcHandler: null,\n      installPromise: null,\n      activeReferences: 0,\n      pendingInboundRequests: [],\n      pendingOutboundRequests: 0,\n      interpreter,\n      ...data,\n    });\n  }\n\n  #calculatePermissionsChange(\n    snapId: SnapId,\n    desiredPermissionsSet: RequestedSnapPermissions,\n  ): {\n    newPermissions: RequestedSnapPermissions;\n    unusedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n    approvedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n  } {\n    const oldPermissions =\n      this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        snapId,\n      ) ?? {};\n\n    const newPermissions = setDiff(desiredPermissionsSet, oldPermissions);\n    // TODO(ritave): The assumption that these are unused only holds so long as we do not\n    //               permit dynamic permission requests.\n    const unusedPermissions = setDiff(oldPermissions, desiredPermissionsSet);\n\n    // It's a Set Intersection of oldPermissions and desiredPermissionsSet\n    // oldPermissions  (oldPermissions  desiredPermissionsSet)  oldPermissions  desiredPermissionsSet\n    const approvedPermissions = setDiff(oldPermissions, unusedPermissions);\n\n    return { newPermissions, unusedPermissions, approvedPermissions };\n  }\n\n  /**\n   * Checks if a snap will pass version validation checks\n   * with the new version range that is requested. The first\n   * check that is done is to check if the existing snap version\n   * falls inside the requested range. If it does, we want to return\n   * false because we do not care to create a rollback snapshot in\n   * that scenario. The second check is to ensure that the current\n   * snap version is not greater than all possible versions in\n   * the requested version range. If it is, then we also want\n   * to return false in that scenario.\n   *\n   * @param snapId - The snap id.\n   * @param newVersionRange - The new version range being requsted.\n   * @returns `true` if validation checks pass and `false` if they do not.\n   */\n  #isValidUpdate(snapId: SnapId, newVersionRange: SemVerRange): boolean {\n    const existingSnap = this.getExpect(snapId);\n\n    if (satisfiesVersionRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    if (gtRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    return true;\n  }\n}\n"]}
\ No newline at end of file
diff --git a/dist/snaps/index.d.ts b/dist/snaps/index.d.ts
index 8dd75a0e609de3eac1ac700ee052f8a27b757a09..83a71776890a88f8716d987e425aa62d5270991b 100644
--- a/dist/snaps/index.d.ts
+++ b/dist/snaps/index.d.ts
@@ -1,3 +1,4 @@
 export * from './SnapController';
 export * from './endowments';
 export * from './selectors';
+export * from './registry';
diff --git a/dist/snaps/index.js b/dist/snaps/index.js
index 3fc524f2b4a709aec6037e6445e9dbbe45a4746e..5e7f071c09d2c1d0094cbb51ded7d1e23bd9c5f4 100644
--- a/dist/snaps/index.js
+++ b/dist/snaps/index.js
@@ -17,4 +17,5 @@ Object.defineProperty(exports, "__esModule", { value: true });
 __exportStar(require("./SnapController"), exports);
 __exportStar(require("./endowments"), exports);
 __exportStar(require("./selectors"), exports);
+__exportStar(require("./registry"), exports);
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/snaps/index.js.map b/dist/snaps/index.js.map
index 4d3c632f12eb9a7d3443ce9e032b066370537f71..a2353d1fa48a50d44e94ece5c63cd89c73a2b2de 100644
--- a/dist/snaps/index.js.map
+++ b/dist/snaps/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/snaps/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,mDAAiC;AACjC,+CAA6B;AAC7B,8CAA4B","sourcesContent":["export * from './SnapController';\nexport * from './endowments';\nexport * from './selectors';\n"]}
\ No newline at end of file
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/snaps/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,mDAAiC;AACjC,+CAA6B;AAC7B,8CAA4B;AAC5B,6CAA2B","sourcesContent":["export * from './SnapController';\nexport * from './endowments';\nexport * from './selectors';\nexport * from './registry';\n"]}
\ No newline at end of file
diff --git a/dist/snaps/registry/index.d.ts b/dist/snaps/registry/index.d.ts
new file mode 100755
index 0000000000000000000000000000000000000000..7828ade84730fa19b9784131fd1daad743e0d587
--- /dev/null
+++ b/dist/snaps/registry/index.d.ts
@@ -0,0 +1 @@
+export * from './json';
diff --git a/dist/snaps/registry/index.js b/dist/snaps/registry/index.js
new file mode 100755
index 0000000000000000000000000000000000000000..2b40b473ddaf17481b21ffc9d438e271008c3459
--- /dev/null
+++ b/dist/snaps/registry/index.js
@@ -0,0 +1,18 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __exportStar = (this && this.__exportStar) || function(m, exports) {
+    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+__exportStar(require("./json"), exports);
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/snaps/registry/index.js.map b/dist/snaps/registry/index.js.map
new file mode 100755
index 0000000000000000000000000000000000000000..9cc6c62c98d3f593666b11dbaa783383c40d3523
--- /dev/null
+++ b/dist/snaps/registry/index.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/snaps/registry/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,yCAAuB","sourcesContent":["export * from './json';\n"]}
\ No newline at end of file
diff --git a/dist/snaps/registry/json.d.ts b/dist/snaps/registry/json.d.ts
new file mode 100755
index 0000000000000000000000000000000000000000..3f3b74fc60b3dfbc0820a116344c7099e4f8035a
--- /dev/null
+++ b/dist/snaps/registry/json.d.ts
@@ -0,0 +1,6 @@
+import { SnapId, SnapRegistry, SnapRegistryRequest, SnapRegistryResult } from '@metamask/snaps-utils';
+export declare class JsonSnapRegistry implements SnapRegistry {
+    #private;
+    constructor(fetchFn?: typeof fetch);
+    get(snaps: SnapRegistryRequest): Promise<Record<SnapId, SnapRegistryResult>>;
+}
diff --git a/dist/snaps/registry/json.js b/dist/snaps/registry/json.js
new file mode 100755
index 0000000000000000000000000000000000000000..28ad132ee02dfab9eea085ac1214d3c718b67270
--- /dev/null
+++ b/dist/snaps/registry/json.js
@@ -0,0 +1,67 @@
+"use strict";
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _JsonSnapRegistry_instances, _JsonSnapRegistry_db, _JsonSnapRegistry_fetchFn, _JsonSnapRegistry_getDatabase, _JsonSnapRegistry_getSingle;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.JsonSnapRegistry = void 0;
+const snaps_utils_1 = require("@metamask/snaps-utils");
+// TODO: Replace with a Codefi URL
+const SNAP_REGISTRY_URL = 'https://cdn.jsdelivr.net/gh/MetaMask/snaps-registry@main/src/registry.json';
+class JsonSnapRegistry {
+    constructor(fetchFn = globalThis.fetch.bind(globalThis)) {
+        _JsonSnapRegistry_instances.add(this);
+        _JsonSnapRegistry_db.set(this, null);
+        _JsonSnapRegistry_fetchFn.set(this, void 0);
+        __classPrivateFieldSet(this, _JsonSnapRegistry_fetchFn, fetchFn, "f");
+    }
+    async get(snaps) {
+        return Object.entries(snaps).reduce(async (previousPromise, [snapId, snapInfo]) => {
+            const result = await __classPrivateFieldGet(this, _JsonSnapRegistry_instances, "m", _JsonSnapRegistry_getSingle).call(this, snapId, snapInfo);
+            const acc = await previousPromise;
+            acc[snapId] = result;
+            return acc;
+        }, Promise.resolve({}));
+    }
+}
+exports.JsonSnapRegistry = JsonSnapRegistry;
+_JsonSnapRegistry_db = new WeakMap(), _JsonSnapRegistry_fetchFn = new WeakMap(), _JsonSnapRegistry_instances = new WeakSet(), _JsonSnapRegistry_getDatabase = async function _JsonSnapRegistry_getDatabase() {
+    if (__classPrivateFieldGet(this, _JsonSnapRegistry_db, "f") === null) {
+        // TODO: Decide if we should persist this between sessions
+        // TODO: Decide what happens if this fails
+        const response = await __classPrivateFieldGet(this, _JsonSnapRegistry_fetchFn, "f").call(this, SNAP_REGISTRY_URL);
+        __classPrivateFieldSet(this, _JsonSnapRegistry_db, await response.json(), "f");
+    }
+    return __classPrivateFieldGet(this, _JsonSnapRegistry_db, "f");
+}, _JsonSnapRegistry_getSingle = async function _JsonSnapRegistry_getSingle(snapId, snapInfo) {
+    var _a;
+    const db = await __classPrivateFieldGet(this, _JsonSnapRegistry_instances, "m", _JsonSnapRegistry_getDatabase).call(this);
+    const blockedEntry = db.blockedSnaps.find((blocked) => {
+        if ('id' in blocked) {
+            return (blocked.id === snapId &&
+                (0, snaps_utils_1.satisfiesVersionRange)(snapInfo.version, blocked.versionRange));
+        }
+        return blocked.checksum === snapInfo.checksum;
+    });
+    if (blockedEntry) {
+        return {
+            status: snaps_utils_1.SnapRegistryStatus.Blocked,
+            reason: blockedEntry.reason,
+        };
+    }
+    const verified = db.verifiedSnaps[snapId];
+    const version = (_a = verified === null || verified === void 0 ? void 0 : verified.versions) === null || _a === void 0 ? void 0 : _a[snapInfo.version];
+    if (version && version.checksum === snapInfo.checksum) {
+        return { status: snaps_utils_1.SnapRegistryStatus.Verified };
+    }
+    return { status: snaps_utils_1.SnapRegistryStatus.Unverified };
+};
+//# sourceMappingURL=json.js.map
\ No newline at end of file
diff --git a/dist/snaps/registry/json.js.map b/dist/snaps/registry/json.js.map
new file mode 100755
index 0000000000000000000000000000000000000000..88128dbb13c31b2c3435a4d7b570227b5aaf8110
--- /dev/null
+++ b/dist/snaps/registry/json.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"json.js","sourceRoot":"","sources":["../../../src/snaps/registry/json.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,uDAS+B;AAE/B,kCAAkC;AAClC,MAAM,iBAAiB,GACrB,4EAA4E,CAAC;AAE/E,MAAa,gBAAgB;IAK3B,YAAY,UAAwB,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC;;QAJrE,+BAAuC,IAAI,EAAC;QAE5C,4CAAuB;QAGrB,uBAAA,IAAI,6BAAY,OAAO,MAAA,CAAC;IAC1B,CAAC;IAyCM,KAAK,CAAC,GAAG,CACd,KAA0B;QAE1B,OAAO,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,MAAM,CAEjC,KAAK,EAAE,eAAe,EAAE,CAAC,MAAM,EAAE,QAAQ,CAAC,EAAE,EAAE;YAC9C,MAAM,MAAM,GAAG,MAAM,uBAAA,IAAI,gEAAW,MAAf,IAAI,EAAY,MAAM,EAAE,QAAQ,CAAC,CAAC;YACvD,MAAM,GAAG,GAAG,MAAM,eAAe,CAAC;YAClC,GAAG,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;YACrB,OAAO,GAAG,CAAC;QACb,CAAC,EAAE,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;IAC1B,CAAC;CACF;AA5DD,4CA4DC;8JAnDC,KAAK;IACH,IAAI,uBAAA,IAAI,4BAAI,KAAK,IAAI,EAAE;QACrB,0DAA0D;QAC1D,0CAA0C;QAC1C,MAAM,QAAQ,GAAG,MAAM,uBAAA,IAAI,iCAAS,MAAb,IAAI,EAAU,iBAAiB,CAAC,CAAC;QACxD,uBAAA,IAAI,wBAAO,MAAM,QAAQ,CAAC,IAAI,EAAE,MAAA,CAAC;KAClC;IACD,OAAO,uBAAA,IAAI,4BAAgC,CAAC;AAC9C,CAAC,gCAED,KAAK,sCAAY,MAAc,EAAE,QAA0B;;IACzD,MAAM,EAAE,GAAG,MAAM,uBAAA,IAAI,kEAAa,MAAjB,IAAI,CAAe,CAAC;IAErC,MAAM,YAAY,GAAG,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE;QACpD,IAAI,IAAI,IAAI,OAAO,EAAE;YACnB,OAAO,CACL,OAAO,CAAC,EAAE,KAAK,MAAM;gBACrB,IAAA,mCAAqB,EAAC,QAAQ,CAAC,OAAO,EAAE,OAAO,CAAC,YAAY,CAAC,CAC9D,CAAC;SACH;QAED,OAAO,OAAO,CAAC,QAAQ,KAAK,QAAQ,CAAC,QAAQ,CAAC;IAChD,CAAC,CAAC,CAAC;IAEH,IAAI,YAAY,EAAE;QAChB,OAAO;YACL,MAAM,EAAE,gCAAkB,CAAC,OAAO;YAClC,MAAM,EAAE,YAAY,CAAC,MAAM;SAC5B,CAAC;KACH;IAED,MAAM,QAAQ,GAAG,EAAE,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;IAC1C,MAAM,OAAO,GAAG,MAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,QAAQ,0CAAG,QAAQ,CAAC,OAAO,CAAC,CAAC;IACvD,IAAI,OAAO,IAAI,OAAO,CAAC,QAAQ,KAAK,QAAQ,CAAC,QAAQ,EAAE;QACrD,OAAO,EAAE,MAAM,EAAE,gCAAkB,CAAC,QAAQ,EAAE,CAAC;KAChD;IACD,OAAO,EAAE,MAAM,EAAE,gCAAkB,CAAC,UAAU,EAAE,CAAC;AACnD,CAAC","sourcesContent":["import {\n  satisfiesVersionRange,\n  SnapId,\n  SnapRegistry,\n  JsonSnapRegistryDatabase,\n  SnapRegistryInfo,\n  SnapRegistryRequest,\n  SnapRegistryResult,\n  SnapRegistryStatus,\n} from '@metamask/snaps-utils';\n\n// TODO: Replace with a Codefi URL\nconst SNAP_REGISTRY_URL =\n  'https://cdn.jsdelivr.net/gh/MetaMask/snaps-registry@main/src/registry.json';\n\nexport class JsonSnapRegistry implements SnapRegistry {\n  #db: JsonSnapRegistryDatabase | null = null;\n\n  #fetchFn: typeof fetch;\n\n  constructor(fetchFn: typeof fetch = globalThis.fetch.bind(globalThis)) {\n    this.#fetchFn = fetchFn;\n  }\n\n  async #getDatabase(): Promise<JsonSnapRegistryDatabase> {\n    if (this.#db === null) {\n      // TODO: Decide if we should persist this between sessions\n      // TODO: Decide what happens if this fails\n      const response = await this.#fetchFn(SNAP_REGISTRY_URL);\n      this.#db = await response.json();\n    }\n    return this.#db as JsonSnapRegistryDatabase;\n  }\n\n  async #getSingle(snapId: SnapId, snapInfo: SnapRegistryInfo) {\n    const db = await this.#getDatabase();\n\n    const blockedEntry = db.blockedSnaps.find((blocked) => {\n      if ('id' in blocked) {\n        return (\n          blocked.id === snapId &&\n          satisfiesVersionRange(snapInfo.version, blocked.versionRange)\n        );\n      }\n\n      return blocked.checksum === snapInfo.checksum;\n    });\n\n    if (blockedEntry) {\n      return {\n        status: SnapRegistryStatus.Blocked,\n        reason: blockedEntry.reason,\n      };\n    }\n\n    const verified = db.verifiedSnaps[snapId];\n    const version = verified?.versions?.[snapInfo.version];\n    if (version && version.checksum === snapInfo.checksum) {\n      return { status: SnapRegistryStatus.Verified };\n    }\n    return { status: SnapRegistryStatus.Unverified };\n  }\n\n  public async get(\n    snaps: SnapRegistryRequest,\n  ): Promise<Record<SnapId, SnapRegistryResult>> {\n    return Object.entries(snaps).reduce<\n      Promise<Record<SnapId, SnapRegistryResult>>\n    >(async (previousPromise, [snapId, snapInfo]) => {\n      const result = await this.#getSingle(snapId, snapInfo);\n      const acc = await previousPromise;\n      acc[snapId] = result;\n      return acc;\n    }, Promise.resolve({}));\n  }\n}\n"]}
\ No newline at end of file
