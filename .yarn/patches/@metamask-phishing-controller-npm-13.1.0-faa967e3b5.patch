diff --git a/dist/PathTrie.cjs b/dist/PathTrie.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..43bd502133dd01db03ca70556f9b5f47c3415c8c
--- /dev/null
+++ b/dist/PathTrie.cjs
@@ -0,0 +1,175 @@
+'use strict';
+Object.defineProperty(exports, '__esModule', { value: true });
+exports.deepCopyPathTrie =
+  exports.convertListToTrie =
+  exports.matchedPathPrefix =
+  exports.deleteFromTrie =
+  exports.insertToTrie =
+  exports.isTerminal =
+    void 0;
+const utils_1 = require('./utils.cjs');
+const isTerminal = (node) => {
+  if (!node || typeof node !== 'object') {
+    return false;
+  }
+  return Object.keys(node).length === 0;
+};
+exports.isTerminal = isTerminal;
+/**
+ * Insert a URL into the trie.
+ *
+ * @param url - The URL to insert into the trie.
+ * @param pathTrie - The trie to insert the URL into.
+ */
+const insertToTrie = (url, pathTrie) => {
+  const { hostname, pathComponents } = (0,
+  utils_1.getHostnameAndPathComponents)(url);
+  if (pathComponents.length === 0 || !hostname) {
+    return;
+  }
+  const lowerHostname = hostname.toLowerCase();
+  if (!pathTrie[lowerHostname]) {
+    pathTrie[lowerHostname] = {};
+  }
+  let curr = pathTrie[lowerHostname];
+  for (let i = 0; i < pathComponents.length; i++) {
+    const pathComponent = pathComponents[i];
+    const isLast = i === pathComponents.length - 1;
+    const exists = curr[pathComponent] !== undefined;
+    if (exists) {
+      if (!isLast && (0, exports.isTerminal)(curr[pathComponent])) {
+        return;
+      }
+      if (isLast) {
+        // Prune descendants if the current path component is not terminal
+        if (!(0, exports.isTerminal)(curr[pathComponent])) {
+          curr[pathComponent] = {};
+        }
+        return;
+      }
+      curr = curr[pathComponent];
+      continue;
+    }
+    if (isLast) {
+      curr[pathComponent] = {};
+      return;
+    }
+    const next = {};
+    curr[pathComponent] = next;
+    curr = next;
+  }
+};
+exports.insertToTrie = insertToTrie;
+/**
+ * Delete a URL from the trie.
+ *
+ * @param url - The URL to delete from the trie.
+ * @param pathTrie - The trie to delete the URL from.
+ */
+const deleteFromTrie = (url, pathTrie) => {
+  const { hostname, pathComponents } = (0,
+  utils_1.getHostnameAndPathComponents)(url);
+  const lowerHostname = hostname.toLowerCase();
+  if (pathComponents.length === 0 || !pathTrie[lowerHostname]) {
+    return;
+  }
+  const pathToNode = [{ node: pathTrie, key: lowerHostname }];
+  let curr = pathTrie[lowerHostname];
+  for (const pathComponent of pathComponents) {
+    if (!curr[pathComponent]) {
+      return;
+    }
+    pathToNode.push({ node: curr, key: pathComponent });
+    curr = curr[pathComponent];
+  }
+  const lastEntry = pathToNode[pathToNode.length - 1];
+  delete lastEntry.node[lastEntry.key];
+  for (let i = pathToNode.length - 2; i >= 0; i--) {
+    const { node, key } = pathToNode[i];
+    if ((0, exports.isTerminal)(node[key])) {
+      delete node[key];
+    } else {
+      break;
+    }
+  }
+};
+exports.deleteFromTrie = deleteFromTrie;
+/**
+ * Get the concatenated hostname and path components all the way down to the
+ * terminal node in the trie that is prefixed in the passed URL. It will only
+ * return a string if the terminal node in the trie is contained in the passed
+ * URL.
+ *
+ * @param url - The URL to check.
+ * @param pathTrie - The trie to check the URL in.
+ * @returns The matched path prefix, or null if no match is found.
+ */
+const matchedPathPrefix = (url, pathTrie) => {
+  const { hostname, pathComponents } = (0,
+  utils_1.getHostnameAndPathComponents)(url);
+  const lowerHostname = hostname.toLowerCase();
+  if (pathComponents.length === 0 || !hostname || !pathTrie[lowerHostname]) {
+    return null;
+  }
+  let matchedPath = `${hostname}/`;
+  let curr = pathTrie[lowerHostname];
+  for (const pathComponent of pathComponents) {
+    if (!curr[pathComponent]) {
+      return null;
+    }
+    curr = curr[pathComponent];
+    // If we've reached a terminal node, then we can return the matched path.
+    if ((0, exports.isTerminal)(curr)) {
+      matchedPath += pathComponent;
+      return matchedPath;
+    }
+    matchedPath += `${pathComponent}/`;
+  }
+  return null;
+};
+exports.matchedPathPrefix = matchedPathPrefix;
+/**
+ * Converts a list ofpaths into a PathTrie structure. This assumes that the
+ * entries are only hostname+pathname format.
+ *
+ * @param paths - Array of hostname+pathname
+ * @returns PathTrie structure for efficient path checking
+ */
+const convertListToTrie = (paths = []) => {
+  const pathTrie = {};
+  if (!paths || !Array.isArray(paths)) {
+    return pathTrie;
+  }
+  for (const path of paths) {
+    (0, exports.insertToTrie)(path, pathTrie);
+  }
+  return pathTrie;
+};
+exports.convertListToTrie = convertListToTrie;
+/**
+ * Creates a deep copy of a PathNode structure.
+ *
+ * @param original - The original PathNode to copy.
+ * @returns A deep copy of the PathNode.
+ */
+const deepCopyPathNode = (original) => {
+  const copy = {};
+  for (const [key, childNode] of Object.entries(original)) {
+    copy[key] = deepCopyPathNode(childNode);
+  }
+  return copy;
+};
+/**
+ * Creates a deep copy of a PathTrie structure.
+ *
+ * @param original - The original PathTrie to copy.
+ * @returns A deep copy of the PathTrie.
+ */
+const deepCopyPathTrie = (original) => {
+  if (!original) {
+    return {};
+  }
+  return deepCopyPathNode(original);
+};
+exports.deepCopyPathTrie = deepCopyPathTrie;
+//# sourceMappingURL=PathTrie.cjs.map
diff --git a/dist/PathTrie.mjs b/dist/PathTrie.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..ca466f9ee66877701d1ed831de36845cda8d7039
--- /dev/null
+++ b/dist/PathTrie.mjs
@@ -0,0 +1,160 @@
+import { getHostnameAndPathComponents } from "./utils.mjs";
+export const isTerminal = (node) => {
+    if (!node || typeof node !== 'object') {
+        return false;
+    }
+    return Object.keys(node).length === 0;
+};
+/**
+ * Insert a URL into the trie.
+ *
+ * @param url - The URL to insert into the trie.
+ * @param pathTrie - The trie to insert the URL into.
+ */
+export const insertToTrie = (url, pathTrie) => {
+    const { hostname, pathComponents } = getHostnameAndPathComponents(url);
+    if (pathComponents.length === 0 || !hostname) {
+        return;
+    }
+    const lowerHostname = hostname.toLowerCase();
+    if (!pathTrie[lowerHostname]) {
+        pathTrie[lowerHostname] = {};
+    }
+    let curr = pathTrie[lowerHostname];
+    for (let i = 0; i < pathComponents.length; i++) {
+        const pathComponent = pathComponents[i];
+        const isLast = i === pathComponents.length - 1;
+        const exists = curr[pathComponent] !== undefined;
+        if (exists) {
+            if (!isLast && isTerminal(curr[pathComponent])) {
+                return;
+            }
+            if (isLast) {
+                // Prune descendants if the current path component is not terminal
+                if (!isTerminal(curr[pathComponent])) {
+                    curr[pathComponent] = {};
+                }
+                return;
+            }
+            curr = curr[pathComponent];
+            continue;
+        }
+        if (isLast) {
+            curr[pathComponent] = {};
+            return;
+        }
+        const next = {};
+        curr[pathComponent] = next;
+        curr = next;
+    }
+};
+/**
+ * Delete a URL from the trie.
+ *
+ * @param url - The URL to delete from the trie.
+ * @param pathTrie - The trie to delete the URL from.
+ */
+export const deleteFromTrie = (url, pathTrie) => {
+    const { hostname, pathComponents } = getHostnameAndPathComponents(url);
+    const lowerHostname = hostname.toLowerCase();
+    if (pathComponents.length === 0 || !pathTrie[lowerHostname]) {
+        return;
+    }
+    const pathToNode = [
+        { node: pathTrie, key: lowerHostname },
+    ];
+    let curr = pathTrie[lowerHostname];
+    for (const pathComponent of pathComponents) {
+        if (!curr[pathComponent]) {
+            return;
+        }
+        pathToNode.push({ node: curr, key: pathComponent });
+        curr = curr[pathComponent];
+    }
+    const lastEntry = pathToNode[pathToNode.length - 1];
+    delete lastEntry.node[lastEntry.key];
+    for (let i = pathToNode.length - 2; i >= 0; i--) {
+        const { node, key } = pathToNode[i];
+        if (isTerminal(node[key])) {
+            delete node[key];
+        }
+        else {
+            break;
+        }
+    }
+};
+/**
+ * Get the concatenated hostname and path components all the way down to the
+ * terminal node in the trie that is prefixed in the passed URL. It will only
+ * return a string if the terminal node in the trie is contained in the passed
+ * URL.
+ *
+ * @param url - The URL to check.
+ * @param pathTrie - The trie to check the URL in.
+ * @returns The matched path prefix, or null if no match is found.
+ */
+export const matchedPathPrefix = (url, pathTrie) => {
+    const { hostname, pathComponents } = getHostnameAndPathComponents(url);
+    const lowerHostname = hostname.toLowerCase();
+    if (pathComponents.length === 0 || !hostname || !pathTrie[lowerHostname]) {
+        return null;
+    }
+    let matchedPath = `${hostname}/`;
+    let curr = pathTrie[lowerHostname];
+    for (const pathComponent of pathComponents) {
+        if (!curr[pathComponent]) {
+            return null;
+        }
+        curr = curr[pathComponent];
+        // If we've reached a terminal node, then we can return the matched path.
+        if (isTerminal(curr)) {
+            matchedPath += pathComponent;
+            return matchedPath;
+        }
+        matchedPath += `${pathComponent}/`;
+    }
+    return null;
+};
+/**
+ * Converts a list ofpaths into a PathTrie structure. This assumes that the
+ * entries are only hostname+pathname format.
+ *
+ * @param paths - Array of hostname+pathname
+ * @returns PathTrie structure for efficient path checking
+ */
+export const convertListToTrie = (paths = []) => {
+    const pathTrie = {};
+    if (!paths || !Array.isArray(paths)) {
+        return pathTrie;
+    }
+    for (const path of paths) {
+        insertToTrie(path, pathTrie);
+    }
+    return pathTrie;
+};
+/**
+ * Creates a deep copy of a PathNode structure.
+ *
+ * @param original - The original PathNode to copy.
+ * @returns A deep copy of the PathNode.
+ */
+const deepCopyPathNode = (original) => {
+    const copy = {};
+    for (const [key, childNode] of Object.entries(original)) {
+        copy[key] = deepCopyPathNode(childNode);
+    }
+    return copy;
+};
+/**
+ * Creates a deep copy of a PathTrie structure.
+ *
+ * @param original - The original PathTrie to copy.
+ * @returns A deep copy of the PathTrie.
+ */
+export const deepCopyPathTrie = (original) => {
+    if (!original) {
+        return {};
+    }
+    return deepCopyPathNode(original);
+};
+//# sourceMappingURL=PathTrie.mjs.map
\ No newline at end of file
diff --git a/dist/PhishingController.cjs b/dist/PhishingController.cjs
index eb660e86f4067babdc22a208a13a0c603301ecba..4faa539496dab9ee2d2c6cb3c8560bfb8eb6e381 100644
--- a/dist/PhishingController.cjs
+++ b/dist/PhishingController.cjs
@@ -1,33 +1,102 @@
 "use strict";
-var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+var __classPrivateFieldSet =
+  (this && this.__classPrivateFieldSet) ||
+  function (receiver, state, value, kind, f) {
     if (kind === "m") throw new TypeError("Private method is not writable");
-    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
-    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
-    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
-};
-var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
-    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
-    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
-    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
-};
-var _PhishingController_instances, _PhishingController_detector, _PhishingController_stalelistRefreshInterval, _PhishingController_hotlistRefreshInterval, _PhishingController_c2DomainBlocklistRefreshInterval, _PhishingController_urlScanCache, _PhishingController_inProgressHotlistUpdate, _PhishingController_inProgressStalelistUpdate, _PhishingController_isProgressC2DomainBlocklistUpdate, _PhishingController_registerMessageHandlers, _PhishingController_processBatch, _PhishingController_updateStalelist, _PhishingController_updateHotlist, _PhishingController_updateC2DomainBlocklist, _PhishingController_queryConfig;
+    if (kind === "a" && !f)
+      throw new TypeError("Private accessor was defined without a setter");
+    if (
+      typeof state === "function"
+        ? receiver !== state || !f
+        : !state.has(receiver)
+    )
+      throw new TypeError(
+        "Cannot write private member to an object whose class did not declare it"
+      );
+    return (
+      kind === "a"
+        ? f.call(receiver, value)
+        : f
+        ? (f.value = value)
+        : state.set(receiver, value),
+      value
+    );
+  };
+var __classPrivateFieldGet =
+  (this && this.__classPrivateFieldGet) ||
+  function (receiver, state, kind, f) {
+    if (kind === "a" && !f)
+      throw new TypeError("Private accessor was defined without a getter");
+    if (
+      typeof state === "function"
+        ? receiver !== state || !f
+        : !state.has(receiver)
+    )
+      throw new TypeError(
+        "Cannot read private member from an object whose class did not declare it"
+      );
+    return kind === "m"
+      ? f
+      : kind === "a"
+      ? f.call(receiver)
+      : f
+      ? f.value
+      : state.get(receiver);
+  };
+var _PhishingController_instances,
+  _PhishingController_detector,
+  _PhishingController_stalelistRefreshInterval,
+  _PhishingController_hotlistRefreshInterval,
+  _PhishingController_c2DomainBlocklistRefreshInterval,
+  _PhishingController_urlScanCache,
+  _PhishingController_inProgressHotlistUpdate,
+  _PhishingController_inProgressStalelistUpdate,
+  _PhishingController_isProgressC2DomainBlocklistUpdate,
+  _PhishingController_registerMessageHandlers,
+  _PhishingController_processBatch,
+  _PhishingController_updateStalelist,
+  _PhishingController_updateHotlist,
+  _PhishingController_updateC2DomainBlocklist,
+  _PhishingController_queryConfig;
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.PhishingController = exports.phishingListKeyNameMap = exports.ListNames = exports.ListKeys = exports.C2_DOMAIN_BLOCKLIST_URL = exports.METAMASK_HOTLIST_DIFF_URL = exports.METAMASK_STALELIST_URL = exports.STALELIST_REFRESH_INTERVAL = exports.HOTLIST_REFRESH_INTERVAL = exports.C2_DOMAIN_BLOCKLIST_REFRESH_INTERVAL = exports.PHISHING_DETECTION_BULK_SCAN_ENDPOINT = exports.PHISHING_DETECTION_SCAN_ENDPOINT = exports.PHISHING_DETECTION_BASE_URL = exports.C2_DOMAIN_BLOCKLIST_ENDPOINT = exports.CLIENT_SIDE_DETECION_BASE_URL = exports.METAMASK_HOTLIST_DIFF_FILE = exports.METAMASK_STALELIST_FILE = exports.PHISHING_CONFIG_BASE_URL = void 0;
+exports.PhishingController =
+  exports.phishingListKeyNameMap =
+  exports.ListNames =
+  exports.ListKeys =
+  exports.C2_DOMAIN_BLOCKLIST_URL =
+  exports.METAMASK_HOTLIST_DIFF_URL =
+  exports.METAMASK_STALELIST_URL =
+  exports.STALELIST_REFRESH_INTERVAL =
+  exports.HOTLIST_REFRESH_INTERVAL =
+  exports.C2_DOMAIN_BLOCKLIST_REFRESH_INTERVAL =
+  exports.PHISHING_DETECTION_BULK_SCAN_ENDPOINT =
+  exports.PHISHING_DETECTION_SCAN_ENDPOINT =
+  exports.PHISHING_DETECTION_BASE_URL =
+  exports.C2_DOMAIN_BLOCKLIST_ENDPOINT =
+  exports.CLIENT_SIDE_DETECION_BASE_URL =
+  exports.METAMASK_HOTLIST_DIFF_FILE =
+  exports.METAMASK_STALELIST_FILE =
+  exports.PHISHING_CONFIG_BASE_URL =
+    void 0;
 const base_controller_1 = require("@metamask/base-controller");
 const controller_utils_1 = require("@metamask/controller-utils");
 const punycode_js_1 = require("punycode/punycode.js");
+const PathTrie_1 = require("./PathTrie.cjs");
 const PhishingDetector_1 = require("./PhishingDetector.cjs");
 const types_1 = require("./types.cjs");
 const UrlScanCache_1 = require("./UrlScanCache.cjs");
 const utils_1 = require("./utils.cjs");
-exports.PHISHING_CONFIG_BASE_URL = 'https://phishing-detection.api.cx.metamask.io';
-exports.METAMASK_STALELIST_FILE = '/v1/stalelist';
-exports.METAMASK_HOTLIST_DIFF_FILE = '/v1/diffsSince';
-exports.CLIENT_SIDE_DETECION_BASE_URL = 'https://client-side-detection.api.cx.metamask.io';
-exports.C2_DOMAIN_BLOCKLIST_ENDPOINT = '/v1/request-blocklist';
-exports.PHISHING_DETECTION_BASE_URL = 'https://dapp-scanning.api.cx.metamask.io';
-exports.PHISHING_DETECTION_SCAN_ENDPOINT = 'v2/scan';
-exports.PHISHING_DETECTION_BULK_SCAN_ENDPOINT = 'bulk-scan';
+exports.PHISHING_CONFIG_BASE_URL =
+  "https://phishing-detection.api.cx.metamask.io";
+exports.METAMASK_STALELIST_FILE = "/v1/stalelist";
+exports.METAMASK_HOTLIST_DIFF_FILE = "/v2/diffsSince";
+exports.CLIENT_SIDE_DETECION_BASE_URL =
+  "https://client-side-detection.api.cx.metamask.io";
+exports.C2_DOMAIN_BLOCKLIST_ENDPOINT = "/v1/request-blocklist";
+exports.PHISHING_DETECTION_BASE_URL =
+  "https://dapp-scanning.api.cx.metamask.io";
+exports.PHISHING_DETECTION_SCAN_ENDPOINT = "v2/scan";
+exports.PHISHING_DETECTION_BULK_SCAN_ENDPOINT = "bulk-scan";
 exports.C2_DOMAIN_BLOCKLIST_REFRESH_INTERVAL = 5 * 60; // 5 mins in seconds
 exports.HOTLIST_REFRESH_INTERVAL = 5 * 60; // 5 mins in seconds
 exports.STALELIST_REFRESH_INTERVAL = 30 * 24 * 60 * 60; // 30 days in seconds
@@ -40,652 +109,978 @@ exports.C2_DOMAIN_BLOCKLIST_URL = `${exports.CLIENT_SIDE_DETECION_BASE_URL}${exp
  */
 var ListKeys;
 (function (ListKeys) {
-    ListKeys["EthPhishingDetectConfig"] = "eth_phishing_detect_config";
+  ListKeys["EthPhishingDetectConfig"] = "eth_phishing_detect_config";
 })(ListKeys || (exports.ListKeys = ListKeys = {}));
 /**
  * Enum containing downstream client attribution names.
  */
 var ListNames;
 (function (ListNames) {
-    ListNames["MetaMask"] = "MetaMask";
+  ListNames["MetaMask"] = "MetaMask";
 })(ListNames || (exports.ListNames = ListNames = {}));
 /**
  * Maps from downstream client attribution name
  * to list key sourced from upstream data provider.
  */
 const phishingListNameKeyMap = {
-    [ListNames.MetaMask]: ListKeys.EthPhishingDetectConfig,
+  [ListNames.MetaMask]: ListKeys.EthPhishingDetectConfig,
 };
 /**
  * Maps from list key sourced from upstream data
  * provider to downstream client attribution name.
  */
 exports.phishingListKeyNameMap = {
-    [ListKeys.EthPhishingDetectConfig]: ListNames.MetaMask,
+  [ListKeys.EthPhishingDetectConfig]: ListNames.MetaMask,
 };
-const controllerName = 'PhishingController';
+const controllerName = "PhishingController";
 const metadata = {
-    phishingLists: { persist: true, anonymous: false },
-    whitelist: { persist: true, anonymous: false },
-    hotlistLastFetched: { persist: true, anonymous: false },
-    stalelistLastFetched: { persist: true, anonymous: false },
-    c2DomainBlocklistLastFetched: { persist: true, anonymous: false },
-    urlScanCache: { persist: true, anonymous: false },
+  phishingLists: { persist: true, anonymous: false },
+  whitelist: { persist: true, anonymous: false },
+  whitelistPaths: { persist: true, anonymous: false },
+  hotlistLastFetched: { persist: true, anonymous: false },
+  stalelistLastFetched: { persist: true, anonymous: false },
+  c2DomainBlocklistLastFetched: { persist: true, anonymous: false },
+  urlScanCache: { persist: true, anonymous: false },
 };
 /**
  * Get a default empty state for the controller.
  * @returns The default empty state.
  */
 const getDefaultState = () => {
-    return {
-        phishingLists: [],
-        whitelist: [],
-        hotlistLastFetched: 0,
-        stalelistLastFetched: 0,
-        c2DomainBlocklistLastFetched: 0,
-        urlScanCache: {},
-    };
+  return {
+    phishingLists: [],
+    whitelist: [],
+    whitelistPaths: {},
+    hotlistLastFetched: 0,
+    stalelistLastFetched: 0,
+    c2DomainBlocklistLastFetched: 0,
+    urlScanCache: {},
+  };
 };
 /**
  * Controller that manages community-maintained lists of approved and unapproved website origins.
  */
 class PhishingController extends base_controller_1.BaseController {
+  /**
+   * Construct a Phishing Controller.
+   *
+   * @param config - Initial options used to configure this controller.
+   * @param config.stalelistRefreshInterval - Polling interval used to fetch stale list.
+   * @param config.hotlistRefreshInterval - Polling interval used to fetch hotlist diff list.
+   * @param config.c2DomainBlocklistRefreshInterval - Polling interval used to fetch c2 domain blocklist.
+   * @param config.urlScanCacheTTL - Time to live in seconds for cached scan results.
+   * @param config.urlScanCacheMaxSize - Maximum number of entries in the scan cache.
+   * @param config.messenger - The controller restricted messenger.
+   * @param config.state - Initial state to set on this controller.
+   */
+  constructor({
+    stalelistRefreshInterval = exports.STALELIST_REFRESH_INTERVAL,
+    hotlistRefreshInterval = exports.HOTLIST_REFRESH_INTERVAL,
+    c2DomainBlocklistRefreshInterval = exports.C2_DOMAIN_BLOCKLIST_REFRESH_INTERVAL,
+    urlScanCacheTTL = UrlScanCache_1.DEFAULT_URL_SCAN_CACHE_TTL,
+    urlScanCacheMaxSize = UrlScanCache_1.DEFAULT_URL_SCAN_CACHE_MAX_SIZE,
+    messenger,
+    state = {},
+  }) {
+    super({
+      name: controllerName,
+      metadata,
+      messenger,
+      state: {
+        ...getDefaultState(),
+        ...state,
+      },
+    });
+    _PhishingController_instances.add(this);
+    // TODO: Replace `any` with type
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    _PhishingController_detector.set(this, void 0);
+    _PhishingController_stalelistRefreshInterval.set(this, void 0);
+    _PhishingController_hotlistRefreshInterval.set(this, void 0);
+    _PhishingController_c2DomainBlocklistRefreshInterval.set(this, void 0);
+    _PhishingController_urlScanCache.set(this, void 0);
+    _PhishingController_inProgressHotlistUpdate.set(this, void 0);
+    _PhishingController_inProgressStalelistUpdate.set(this, void 0);
+    _PhishingController_isProgressC2DomainBlocklistUpdate.set(this, void 0);
     /**
-     * Construct a Phishing Controller.
+     * Scan a URL for phishing. It will only scan the hostname of the URL. It also only supports
+     * web URLs.
      *
-     * @param config - Initial options used to configure this controller.
-     * @param config.stalelistRefreshInterval - Polling interval used to fetch stale list.
-     * @param config.hotlistRefreshInterval - Polling interval used to fetch hotlist diff list.
-     * @param config.c2DomainBlocklistRefreshInterval - Polling interval used to fetch c2 domain blocklist.
-     * @param config.urlScanCacheTTL - Time to live in seconds for cached scan results.
-     * @param config.urlScanCacheMaxSize - Maximum number of entries in the scan cache.
-     * @param config.messenger - The controller restricted messenger.
-     * @param config.state - Initial state to set on this controller.
+     * @param url - The URL to scan.
+     * @returns The phishing detection scan result.
      */
-    constructor({ stalelistRefreshInterval = exports.STALELIST_REFRESH_INTERVAL, hotlistRefreshInterval = exports.HOTLIST_REFRESH_INTERVAL, c2DomainBlocklistRefreshInterval = exports.C2_DOMAIN_BLOCKLIST_REFRESH_INTERVAL, urlScanCacheTTL = UrlScanCache_1.DEFAULT_URL_SCAN_CACHE_TTL, urlScanCacheMaxSize = UrlScanCache_1.DEFAULT_URL_SCAN_CACHE_MAX_SIZE, messenger, state = {}, }) {
-        super({
-            name: controllerName,
-            metadata,
-            messenger,
-            state: {
-                ...getDefaultState(),
-                ...state,
-            },
-        });
-        _PhishingController_instances.add(this);
-        // TODO: Replace `any` with type
-        // eslint-disable-next-line @typescript-eslint/no-explicit-any
-        _PhishingController_detector.set(this, void 0);
-        _PhishingController_stalelistRefreshInterval.set(this, void 0);
-        _PhishingController_hotlistRefreshInterval.set(this, void 0);
-        _PhishingController_c2DomainBlocklistRefreshInterval.set(this, void 0);
-        _PhishingController_urlScanCache.set(this, void 0);
-        _PhishingController_inProgressHotlistUpdate.set(this, void 0);
-        _PhishingController_inProgressStalelistUpdate.set(this, void 0);
-        _PhishingController_isProgressC2DomainBlocklistUpdate.set(this, void 0);
-        /**
-         * Scan a URL for phishing. It will only scan the hostname of the URL. It also only supports
-         * web URLs.
-         *
-         * @param url - The URL to scan.
-         * @returns The phishing detection scan result.
-         */
-        this.scanUrl = async (url) => {
-            const [hostname, ok] = (0, utils_1.getHostnameFromWebUrl)(url);
-            if (!ok) {
-                return {
-                    hostname: '',
-                    recommendedAction: types_1.RecommendedAction.None,
-                    fetchError: 'url is not a valid web URL',
-                };
-            }
-            const cachedResult = __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").get(hostname);
-            if (cachedResult) {
-                return cachedResult;
-            }
-            const apiResponse = await (0, controller_utils_1.safelyExecuteWithTimeout)(async () => {
-                const res = await fetch(`${exports.PHISHING_DETECTION_BASE_URL}/${exports.PHISHING_DETECTION_SCAN_ENDPOINT}?url=${encodeURIComponent(hostname)}`, {
-                    method: 'GET',
-                    headers: {
-                        Accept: 'application/json',
-                    },
-                });
-                if (!res.ok) {
-                    return {
-                        error: `${res.status} ${res.statusText}`,
-                    };
-                }
-                const data = await res.json();
-                return data;
-            }, true, 8000);
-            // Need to do it this way because safelyExecuteWithTimeout returns undefined for both timeouts and errors.
-            if (!apiResponse) {
-                return {
-                    hostname: '',
-                    recommendedAction: types_1.RecommendedAction.None,
-                    fetchError: 'timeout of 8000ms exceeded',
-                };
-            }
-            else if ('error' in apiResponse) {
-                return {
-                    hostname: '',
-                    recommendedAction: types_1.RecommendedAction.None,
-                    fetchError: apiResponse.error,
-                };
-            }
-            const result = {
-                hostname,
-                recommendedAction: apiResponse.recommendedAction,
-            };
-            __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").add(hostname, result);
-            return result;
+    this.scanUrl = async (url) => {
+      const [hostname, ok] = (0, utils_1.getHostnameFromWebUrl)(url);
+      if (!ok) {
+        return {
+          hostname: "",
+          recommendedAction: types_1.RecommendedAction.None,
+          fetchError: "url is not a valid web URL",
         };
-        /**
-         * Scan multiple URLs for phishing in bulk. It will only scan the hostnames of the URLs.
-         * It also only supports web URLs.
-         *
-         * @param urls - The URLs to scan.
-         * @returns A mapping of URLs to their phishing detection scan results and errors.
-         */
-        this.bulkScanUrls = async (urls) => {
-            if (!urls || urls.length === 0) {
-                return {
-                    results: {},
-                    errors: {},
-                };
+      }
+      const cachedResult = __classPrivateFieldGet(
+        this,
+        _PhishingController_urlScanCache,
+        "f"
+      ).get(hostname);
+      if (cachedResult) {
+        return cachedResult;
+      }
+      const apiResponse = await (0,
+      controller_utils_1.safelyExecuteWithTimeout)(
+        async () => {
+          const res = await fetch(
+            `${exports.PHISHING_DETECTION_BASE_URL}/${
+              exports.PHISHING_DETECTION_SCAN_ENDPOINT
+            }?url=${encodeURIComponent(hostname)}`,
+            {
+              method: "GET",
+              headers: {
+                Accept: "application/json",
+              },
             }
-            // we are arbitrarily limiting the number of URLs to 250
-            const MAX_TOTAL_URLS = 250;
-            if (urls.length > MAX_TOTAL_URLS) {
-                return {
-                    results: {},
-                    errors: {
-                        too_many_urls: [
-                            `Maximum of ${MAX_TOTAL_URLS} URLs allowed per request`,
-                        ],
-                    },
-                };
-            }
-            const MAX_URL_LENGTH = 2048;
-            const combinedResponse = {
-                results: {},
-                errors: {},
+          );
+          if (!res.ok) {
+            return {
+              error: `${res.status} ${res.statusText}`,
             };
-            // Extract hostnames from URLs and check for validity and length constraints
-            const urlsToHostnames = {};
-            const urlsToFetch = [];
-            for (const url of urls) {
-                if (url.length > MAX_URL_LENGTH) {
-                    combinedResponse.errors[url] = [
-                        `URL length must not exceed ${MAX_URL_LENGTH} characters`,
-                    ];
-                    continue;
-                }
-                const [hostname, ok] = (0, utils_1.getHostnameFromWebUrl)(url);
-                if (!ok) {
-                    combinedResponse.errors[url] = ['url is not a valid web URL'];
-                    continue;
-                }
-                // Check if result is already in cache
-                const cachedResult = __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").get(hostname);
-                if (cachedResult) {
-                    // Use cached result
-                    combinedResponse.results[url] = cachedResult;
-                }
-                else {
-                    // Add to list of URLs to fetch
-                    urlsToHostnames[url] = hostname;
-                    urlsToFetch.push(url);
-                }
-            }
-            // If there are URLs to fetch, process them in batches
-            if (urlsToFetch.length > 0) {
-                // The API has a limit of 50 URLs per request, so we batch the requests
-                const MAX_URLS_PER_BATCH = 50;
-                const batches = [];
-                for (let i = 0; i < urlsToFetch.length; i += MAX_URLS_PER_BATCH) {
-                    batches.push(urlsToFetch.slice(i, i + MAX_URLS_PER_BATCH));
-                }
-                // Process each batch in parallel
-                const batchResults = await Promise.all(batches.map((batchUrls) => __classPrivateFieldGet(this, _PhishingController_processBatch, "f").call(this, batchUrls)));
-                // Merge results and errors from all batches
-                batchResults.forEach((batchResponse) => {
-                    // Add results to cache and combine with response
-                    Object.entries(batchResponse.results).forEach(([url, result]) => {
-                        const hostname = urlsToHostnames[url];
-                        if (hostname) {
-                            __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").add(hostname, result);
-                        }
-                        combinedResponse.results[url] = result;
-                    });
-                    // Combine errors
-                    Object.entries(batchResponse.errors).forEach(([key, messages]) => {
-                        combinedResponse.errors[key] = [
-                            ...(combinedResponse.errors[key] || []),
-                            ...messages,
-                        ];
-                    });
-                });
-            }
-            return combinedResponse;
+          }
+          const data = await res.json();
+          return data;
+        },
+        true,
+        8000
+      );
+      // Need to do it this way because safelyExecuteWithTimeout returns undefined for both timeouts and errors.
+      if (!apiResponse) {
+        return {
+          hostname: "",
+          recommendedAction: types_1.RecommendedAction.None,
+          fetchError: "timeout of 8000ms exceeded",
         };
-        /**
-         * Process a batch of URLs (up to 50) for phishing detection.
-         *
-         * @param urls - A batch of URLs to scan.
-         * @returns The scan results and errors for this batch.
-         */
-        _PhishingController_processBatch.set(this, async (urls) => {
-            const apiResponse = await (0, controller_utils_1.safelyExecuteWithTimeout)(async () => {
-                const res = await fetch(`${exports.PHISHING_DETECTION_BASE_URL}/${exports.PHISHING_DETECTION_BULK_SCAN_ENDPOINT}`, {
-                    method: 'POST',
-                    headers: {
-                        Accept: 'application/json',
-                        'Content-Type': 'application/json',
-                    },
-                    body: JSON.stringify({ urls }),
-                });
-                if (!res.ok) {
-                    return {
-                        error: `${res.status} ${res.statusText}`,
-                        status: res.status,
-                        statusText: res.statusText,
-                    };
-                }
-                const data = await res.json();
-                return data;
-            }, true, 15000);
-            // Handle timeout or network errors
-            if (!apiResponse) {
-                return {
-                    results: {},
-                    errors: {
-                        network_error: ['timeout of 15000ms exceeded'],
-                    },
-                };
-            }
-            // Handle HTTP error responses
-            if ('error' in apiResponse &&
-                'status' in apiResponse &&
-                'statusText' in apiResponse) {
-                return {
-                    results: {},
-                    errors: {
-                        api_error: [`${apiResponse.status} ${apiResponse.statusText}`],
-                    },
-                };
-            }
-            return apiResponse;
-        });
-        __classPrivateFieldSet(this, _PhishingController_stalelistRefreshInterval, stalelistRefreshInterval, "f");
-        __classPrivateFieldSet(this, _PhishingController_hotlistRefreshInterval, hotlistRefreshInterval, "f");
-        __classPrivateFieldSet(this, _PhishingController_c2DomainBlocklistRefreshInterval, c2DomainBlocklistRefreshInterval, "f");
-        __classPrivateFieldSet(this, _PhishingController_urlScanCache, new UrlScanCache_1.UrlScanCache({
-            cacheTTL: urlScanCacheTTL,
-            maxCacheSize: urlScanCacheMaxSize,
-            initialCache: this.state.urlScanCache,
-            updateState: (cache) => {
-                this.update((draftState) => {
-                    draftState.urlScanCache = cache;
-                });
-            },
-        }), "f");
-        __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_registerMessageHandlers).call(this);
-        this.updatePhishingDetector();
-    }
-    /**
-     * Updates this.detector with an instance of PhishingDetector using the current state.
-     */
-    updatePhishingDetector() {
-        __classPrivateFieldSet(this, _PhishingController_detector, new PhishingDetector_1.PhishingDetector(this.state.phishingLists), "f");
-    }
+      } else if ("error" in apiResponse) {
+        return {
+          hostname: "",
+          recommendedAction: types_1.RecommendedAction.None,
+          fetchError: apiResponse.error,
+        };
+      }
+      const result = {
+        hostname,
+        recommendedAction: apiResponse.recommendedAction,
+      };
+      __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").add(
+        hostname,
+        result
+      );
+      return result;
+    };
     /**
-     * Set the interval at which the stale phishing list will be refetched.
-     * Fetching will only occur on the next call to test/bypass.
-     * For immediate update to the phishing list, call {@link updateStalelist} directly.
+     * Scan multiple URLs for phishing in bulk. It will only scan the hostnames of the URLs.
+     * It also only supports web URLs.
      *
-     * @param interval - the new interval, in ms.
+     * @param urls - The URLs to scan.
+     * @returns A mapping of URLs to their phishing detection scan results and errors.
      */
-    setStalelistRefreshInterval(interval) {
-        __classPrivateFieldSet(this, _PhishingController_stalelistRefreshInterval, interval, "f");
-    }
+    this.bulkScanUrls = async (urls) => {
+      if (!urls || urls.length === 0) {
+        return {
+          results: {},
+          errors: {},
+        };
+      }
+      // we are arbitrarily limiting the number of URLs to 250
+      const MAX_TOTAL_URLS = 250;
+      if (urls.length > MAX_TOTAL_URLS) {
+        return {
+          results: {},
+          errors: {
+            too_many_urls: [
+              `Maximum of ${MAX_TOTAL_URLS} URLs allowed per request`,
+            ],
+          },
+        };
+      }
+      const MAX_URL_LENGTH = 2048;
+      const combinedResponse = {
+        results: {},
+        errors: {},
+      };
+      // Extract hostnames from URLs and check for validity and length constraints
+      const urlsToHostnames = {};
+      const urlsToFetch = [];
+      for (const url of urls) {
+        if (url.length > MAX_URL_LENGTH) {
+          combinedResponse.errors[url] = [
+            `URL length must not exceed ${MAX_URL_LENGTH} characters`,
+          ];
+          continue;
+        }
+        const [hostname, ok] = (0, utils_1.getHostnameFromWebUrl)(url);
+        if (!ok) {
+          combinedResponse.errors[url] = ["url is not a valid web URL"];
+          continue;
+        }
+        // Check if result is already in cache
+        const cachedResult = __classPrivateFieldGet(
+          this,
+          _PhishingController_urlScanCache,
+          "f"
+        ).get(hostname);
+        if (cachedResult) {
+          // Use cached result
+          combinedResponse.results[url] = cachedResult;
+        } else {
+          // Add to list of URLs to fetch
+          urlsToHostnames[url] = hostname;
+          urlsToFetch.push(url);
+        }
+      }
+      // If there are URLs to fetch, process them in batches
+      if (urlsToFetch.length > 0) {
+        // The API has a limit of 50 URLs per request, so we batch the requests
+        const MAX_URLS_PER_BATCH = 50;
+        const batches = [];
+        for (let i = 0; i < urlsToFetch.length; i += MAX_URLS_PER_BATCH) {
+          batches.push(urlsToFetch.slice(i, i + MAX_URLS_PER_BATCH));
+        }
+        // Process each batch in parallel
+        const batchResults = await Promise.all(
+          batches.map((batchUrls) =>
+            __classPrivateFieldGet(
+              this,
+              _PhishingController_processBatch,
+              "f"
+            ).call(this, batchUrls)
+          )
+        );
+        // Merge results and errors from all batches
+        batchResults.forEach((batchResponse) => {
+          // Add results to cache and combine with response
+          Object.entries(batchResponse.results).forEach(([url, result]) => {
+            const hostname = urlsToHostnames[url];
+            if (hostname) {
+              __classPrivateFieldGet(
+                this,
+                _PhishingController_urlScanCache,
+                "f"
+              ).add(hostname, result);
+            }
+            combinedResponse.results[url] = result;
+          });
+          // Combine errors
+          Object.entries(batchResponse.errors).forEach(([key, messages]) => {
+            combinedResponse.errors[key] = [
+              ...(combinedResponse.errors[key] || []),
+              ...messages,
+            ];
+          });
+        });
+      }
+      return combinedResponse;
+    };
     /**
-     * Set the interval at which the hot list will be refetched.
-     * Fetching will only occur on the next call to test/bypass.
-     * For immediate update to the phishing list, call {@link updateHotlist} directly.
+     * Process a batch of URLs (up to 50) for phishing detection.
      *
-     * @param interval - the new interval, in ms.
+     * @param urls - A batch of URLs to scan.
+     * @returns The scan results and errors for this batch.
      */
-    setHotlistRefreshInterval(interval) {
-        __classPrivateFieldSet(this, _PhishingController_hotlistRefreshInterval, interval, "f");
+    _PhishingController_processBatch.set(this, async (urls) => {
+      const apiResponse = await (0,
+      controller_utils_1.safelyExecuteWithTimeout)(
+        async () => {
+          const res = await fetch(
+            `${exports.PHISHING_DETECTION_BASE_URL}/${exports.PHISHING_DETECTION_BULK_SCAN_ENDPOINT}`,
+            {
+              method: "POST",
+              headers: {
+                Accept: "application/json",
+                "Content-Type": "application/json",
+              },
+              body: JSON.stringify({ urls }),
+            }
+          );
+          if (!res.ok) {
+            return {
+              error: `${res.status} ${res.statusText}`,
+              status: res.status,
+              statusText: res.statusText,
+            };
+          }
+          const data = await res.json();
+          return data;
+        },
+        true,
+        15000
+      );
+      // Handle timeout or network errors
+      if (!apiResponse) {
+        return {
+          results: {},
+          errors: {
+            network_error: ["timeout of 15000ms exceeded"],
+          },
+        };
+      }
+      // Handle HTTP error responses
+      if (
+        "error" in apiResponse &&
+        "status" in apiResponse &&
+        "statusText" in apiResponse
+      ) {
+        return {
+          results: {},
+          errors: {
+            api_error: [`${apiResponse.status} ${apiResponse.statusText}`],
+          },
+        };
+      }
+      return apiResponse;
+    });
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_stalelistRefreshInterval,
+      stalelistRefreshInterval,
+      "f"
+    );
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_hotlistRefreshInterval,
+      hotlistRefreshInterval,
+      "f"
+    );
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_c2DomainBlocklistRefreshInterval,
+      c2DomainBlocklistRefreshInterval,
+      "f"
+    );
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_urlScanCache,
+      new UrlScanCache_1.UrlScanCache({
+        cacheTTL: urlScanCacheTTL,
+        maxCacheSize: urlScanCacheMaxSize,
+        initialCache: this.state.urlScanCache,
+        updateState: (cache) => {
+          this.update((draftState) => {
+            draftState.urlScanCache = cache;
+          });
+        },
+      }),
+      "f"
+    );
+    __classPrivateFieldGet(
+      this,
+      _PhishingController_instances,
+      "m",
+      _PhishingController_registerMessageHandlers
+    ).call(this);
+    this.updatePhishingDetector();
+  }
+  /**
+   * Updates this.detector with an instance of PhishingDetector using the current state.
+   */
+  updatePhishingDetector() {
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_detector,
+      new PhishingDetector_1.PhishingDetector(this.state.phishingLists),
+      "f"
+    );
+  }
+  /**
+   * Set the interval at which the stale phishing list will be refetched.
+   * Fetching will only occur on the next call to test/bypass.
+   * For immediate update to the phishing list, call {@link updateStalelist} directly.
+   *
+   * @param interval - the new interval, in ms.
+   */
+  setStalelistRefreshInterval(interval) {
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_stalelistRefreshInterval,
+      interval,
+      "f"
+    );
+  }
+  /**
+   * Set the interval at which the hot list will be refetched.
+   * Fetching will only occur on the next call to test/bypass.
+   * For immediate update to the phishing list, call {@link updateHotlist} directly.
+   *
+   * @param interval - the new interval, in ms.
+   */
+  setHotlistRefreshInterval(interval) {
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_hotlistRefreshInterval,
+      interval,
+      "f"
+    );
+  }
+  /**
+   * Set the interval at which the C2 domain blocklist will be refetched.
+   * Fetching will only occur on the next call to test/bypass.
+   * For immediate update to the phishing list, call {@link updateHotlist} directly.
+   *
+   * @param interval - the new interval, in ms.
+   */
+  setC2DomainBlocklistRefreshInterval(interval) {
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_c2DomainBlocklistRefreshInterval,
+      interval,
+      "f"
+    );
+  }
+  /**
+   * Set the time-to-live for URL scan cache entries.
+   *
+   * @param ttl - The TTL in seconds.
+   */
+  setUrlScanCacheTTL(ttl) {
+    __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").setTTL(
+      ttl
+    );
+  }
+  /**
+   * Set the maximum number of entries in the URL scan cache.
+   *
+   * @param maxSize - The maximum cache size.
+   */
+  setUrlScanCacheMaxSize(maxSize) {
+    __classPrivateFieldGet(
+      this,
+      _PhishingController_urlScanCache,
+      "f"
+    ).setMaxSize(maxSize);
+  }
+  /**
+   * Clear the URL scan cache.
+   */
+  clearUrlScanCache() {
+    __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").clear();
+  }
+  /**
+   * Determine if an update to the stalelist configuration is needed.
+   *
+   * @returns Whether an update is needed
+   */
+  isStalelistOutOfDate() {
+    return (
+      (0, utils_1.fetchTimeNow)() - this.state.stalelistLastFetched >=
+      __classPrivateFieldGet(
+        this,
+        _PhishingController_stalelistRefreshInterval,
+        "f"
+      )
+    );
+  }
+  /**
+   * Determine if an update to the hotlist configuration is needed.
+   *
+   * @returns Whether an update is needed
+   */
+  isHotlistOutOfDate() {
+    return (
+      (0, utils_1.fetchTimeNow)() - this.state.hotlistLastFetched >=
+      __classPrivateFieldGet(
+        this,
+        _PhishingController_hotlistRefreshInterval,
+        "f"
+      )
+    );
+  }
+  /**
+   * Determine if an update to the C2 domain blocklist is needed.
+   *
+   * @returns Whether an update is needed
+   */
+  isC2DomainBlocklistOutOfDate() {
+    return (
+      (0, utils_1.fetchTimeNow)() - this.state.c2DomainBlocklistLastFetched >=
+      __classPrivateFieldGet(
+        this,
+        _PhishingController_c2DomainBlocklistRefreshInterval,
+        "f"
+      )
+    );
+  }
+  /**
+   * Conditionally update the phishing configuration.
+   *
+   * If the stalelist configuration is out of date, this function will call `updateStalelist`
+   * to update the configuration. This will automatically grab the hotlist,
+   * so it isn't necessary to continue on to download the hotlist and the c2 domain blocklist.
+   *
+   */
+  async maybeUpdateState() {
+    const staleListOutOfDate = this.isStalelistOutOfDate();
+    if (staleListOutOfDate) {
+      await this.updateStalelist();
+      return;
     }
-    /**
-     * Set the interval at which the C2 domain blocklist will be refetched.
-     * Fetching will only occur on the next call to test/bypass.
-     * For immediate update to the phishing list, call {@link updateHotlist} directly.
-     *
-     * @param interval - the new interval, in ms.
-     */
-    setC2DomainBlocklistRefreshInterval(interval) {
-        __classPrivateFieldSet(this, _PhishingController_c2DomainBlocklistRefreshInterval, interval, "f");
+    const hotlistOutOfDate = this.isHotlistOutOfDate();
+    if (hotlistOutOfDate) {
+      await this.updateHotlist();
     }
-    /**
-     * Set the time-to-live for URL scan cache entries.
-     *
-     * @param ttl - The TTL in seconds.
-     */
-    setUrlScanCacheTTL(ttl) {
-        __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").setTTL(ttl);
+    const c2DomainBlocklistOutOfDate = this.isC2DomainBlocklistOutOfDate();
+    if (c2DomainBlocklistOutOfDate) {
+      await this.updateC2DomainBlocklist();
     }
-    /**
-     * Set the maximum number of entries in the URL scan cache.
-     *
-     * @param maxSize - The maximum cache size.
-     */
-    setUrlScanCacheMaxSize(maxSize) {
-        __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").setMaxSize(maxSize);
+  }
+  /**
+   * Determines if a given origin is unapproved.
+   *
+   * It is strongly recommended that you call {@link maybeUpdateState} before calling this,
+   * to check whether the phishing configuration is up-to-date. It will be updated if necessary
+   * by calling {@link updateStalelist} or {@link updateHotlist}.
+   *
+   * @param origin - Domain origin of a website.
+   * @returns Whether the origin is an unapproved origin.
+   */
+  test(origin) {
+    const punycodeOrigin = (0, punycode_js_1.toASCII)(origin);
+    const hostname = (0, utils_1.getHostnameFromUrl)(punycodeOrigin);
+    const hostnameWithPaths =
+      hostname + (0, utils_1.getPathnameFromUrl)(origin);
+    if (
+      (0, PathTrie_1.matchedPathPrefix)(
+        hostnameWithPaths,
+        this.state.whitelistPaths
+      )
+    ) {
+      return { result: false, type: types_1.PhishingDetectorResultType.All };
     }
-    /**
-     * Clear the URL scan cache.
-     */
-    clearUrlScanCache() {
-        __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").clear();
+    if (this.state.whitelist.includes(hostname || punycodeOrigin)) {
+      return { result: false, type: types_1.PhishingDetectorResultType.All }; // Same as whitelisted match returned by detector.check(...).
     }
-    /**
-     * Determine if an update to the stalelist configuration is needed.
-     *
-     * @returns Whether an update is needed
-     */
-    isStalelistOutOfDate() {
-        return ((0, utils_1.fetchTimeNow)() - this.state.stalelistLastFetched >=
-            __classPrivateFieldGet(this, _PhishingController_stalelistRefreshInterval, "f"));
+    return __classPrivateFieldGet(
+      this,
+      _PhishingController_detector,
+      "f"
+    ).check(punycodeOrigin);
+  }
+  /**
+   * Checks if a request URL's domain is blocked against the request blocklist.
+   *
+   * This method is used to determine if a specific request URL is associated with a malicious
+   * command and control (C2) domain. The URL's hostname is hashed and checked against a configured
+   * blocklist of known malicious domains.
+   *
+   * @param origin - The full request URL to be checked.
+   * @returns An object indicating whether the URL's domain is blocked and relevant metadata.
+   */
+  isBlockedRequest(origin) {
+    const punycodeOrigin = (0, punycode_js_1.toASCII)(origin);
+    const hostname = (0, utils_1.getHostnameFromUrl)(punycodeOrigin);
+    if (this.state.whitelist.includes(hostname || punycodeOrigin)) {
+      return { result: false, type: types_1.PhishingDetectorResultType.All }; // Same as whitelisted match returned by detector.check(...).
     }
-    /**
-     * Determine if an update to the hotlist configuration is needed.
-     *
-     * @returns Whether an update is needed
-     */
-    isHotlistOutOfDate() {
-        return ((0, utils_1.fetchTimeNow)() - this.state.hotlistLastFetched >=
-            __classPrivateFieldGet(this, _PhishingController_hotlistRefreshInterval, "f"));
+    return __classPrivateFieldGet(
+      this,
+      _PhishingController_detector,
+      "f"
+    ).isMaliciousC2Domain(punycodeOrigin);
+  }
+  /**
+   * Temporarily marks a given origin as approved.
+   *
+   * @param origin - The origin to mark as approved.
+   */
+  bypass(origin) {
+    const punycodeOrigin = (0, punycode_js_1.toASCII)(origin);
+    const hostname = (0, utils_1.getHostnameFromUrl)(punycodeOrigin);
+    const hostnameWithPaths =
+      hostname + (0, utils_1.getPathnameFromUrl)(origin);
+    const { whitelist, whitelistPaths } = this.state;
+    const whitelistPath = (0, PathTrie_1.matchedPathPrefix)(
+      hostnameWithPaths,
+      whitelistPaths
+    );
+    if (whitelist.includes(hostname || punycodeOrigin) || whitelistPath) {
+      return;
     }
-    /**
-     * Determine if an update to the C2 domain blocklist is needed.
-     *
-     * @returns Whether an update is needed
-     */
-    isC2DomainBlocklistOutOfDate() {
-        return ((0, utils_1.fetchTimeNow)() - this.state.c2DomainBlocklistLastFetched >=
-            __classPrivateFieldGet(this, _PhishingController_c2DomainBlocklistRefreshInterval, "f"));
+    // If the origin was blocked by a path, then we only want to add it to the whitelistPaths since
+    // other paths with the same hostname may not be blocked.
+    const blockingPath = __classPrivateFieldGet(
+      this,
+      _PhishingController_detector,
+      "f"
+    ).blockingPath(origin);
+    if (blockingPath) {
+      this.update((draftState) => {
+        (0, PathTrie_1.insertToTrie)(blockingPath, draftState.whitelistPaths);
+      });
+      return;
     }
-    /**
-     * Conditionally update the phishing configuration.
-     *
-     * If the stalelist configuration is out of date, this function will call `updateStalelist`
-     * to update the configuration. This will automatically grab the hotlist,
-     * so it isn't necessary to continue on to download the hotlist and the c2 domain blocklist.
-     *
-     */
-    async maybeUpdateState() {
-        const staleListOutOfDate = this.isStalelistOutOfDate();
-        if (staleListOutOfDate) {
-            await this.updateStalelist();
-            return;
-        }
-        const hotlistOutOfDate = this.isHotlistOutOfDate();
-        if (hotlistOutOfDate) {
-            await this.updateHotlist();
-        }
-        const c2DomainBlocklistOutOfDate = this.isC2DomainBlocklistOutOfDate();
-        if (c2DomainBlocklistOutOfDate) {
-            await this.updateC2DomainBlocklist();
-        }
+    this.update((draftState) => {
+      draftState.whitelist.push(hostname || punycodeOrigin);
+    });
+  }
+  /**
+   * Update the C2 domain blocklist.
+   *
+   * If an update is in progress, no additional update will be made. Instead this will wait until
+   * the in-progress update has finished.
+   */
+  async updateC2DomainBlocklist() {
+    if (
+      __classPrivateFieldGet(
+        this,
+        _PhishingController_isProgressC2DomainBlocklistUpdate,
+        "f"
+      )
+    ) {
+      await __classPrivateFieldGet(
+        this,
+        _PhishingController_isProgressC2DomainBlocklistUpdate,
+        "f"
+      );
+      return;
     }
-    /**
-     * Determines if a given origin is unapproved.
-     *
-     * It is strongly recommended that you call {@link maybeUpdateState} before calling this,
-     * to check whether the phishing configuration is up-to-date. It will be updated if necessary
-     * by calling {@link updateStalelist} or {@link updateHotlist}.
-     *
-     * @param origin - Domain origin of a website.
-     * @returns Whether the origin is an unapproved origin.
-     */
-    test(origin) {
-        const punycodeOrigin = (0, punycode_js_1.toASCII)(origin);
-        const hostname = (0, utils_1.getHostnameFromUrl)(punycodeOrigin);
-        if (this.state.whitelist.includes(hostname || punycodeOrigin)) {
-            return { result: false, type: types_1.PhishingDetectorResultType.All }; // Same as whitelisted match returned by detector.check(...).
-        }
-        return __classPrivateFieldGet(this, _PhishingController_detector, "f").check(punycodeOrigin);
+    try {
+      __classPrivateFieldSet(
+        this,
+        _PhishingController_isProgressC2DomainBlocklistUpdate,
+        __classPrivateFieldGet(
+          this,
+          _PhishingController_instances,
+          "m",
+          _PhishingController_updateC2DomainBlocklist
+        ).call(this),
+        "f"
+      );
+      await __classPrivateFieldGet(
+        this,
+        _PhishingController_isProgressC2DomainBlocklistUpdate,
+        "f"
+      );
+    } finally {
+      __classPrivateFieldSet(
+        this,
+        _PhishingController_isProgressC2DomainBlocklistUpdate,
+        undefined,
+        "f"
+      );
     }
-    /**
-     * Checks if a request URL's domain is blocked against the request blocklist.
-     *
-     * This method is used to determine if a specific request URL is associated with a malicious
-     * command and control (C2) domain. The URL's hostname is hashed and checked against a configured
-     * blocklist of known malicious domains.
-     *
-     * @param origin - The full request URL to be checked.
-     * @returns An object indicating whether the URL's domain is blocked and relevant metadata.
-     */
-    isBlockedRequest(origin) {
-        const punycodeOrigin = (0, punycode_js_1.toASCII)(origin);
-        const hostname = (0, utils_1.getHostnameFromUrl)(punycodeOrigin);
-        if (this.state.whitelist.includes(hostname || punycodeOrigin)) {
-            return { result: false, type: types_1.PhishingDetectorResultType.All }; // Same as whitelisted match returned by detector.check(...).
-        }
-        return __classPrivateFieldGet(this, _PhishingController_detector, "f").isMaliciousC2Domain(punycodeOrigin);
+  }
+  /**
+   * Update the hotlist.
+   *
+   * If an update is in progress, no additional update will be made. Instead this will wait until
+   * the in-progress update has finished.
+   */
+  async updateHotlist() {
+    if (
+      __classPrivateFieldGet(
+        this,
+        _PhishingController_inProgressHotlistUpdate,
+        "f"
+      )
+    ) {
+      await __classPrivateFieldGet(
+        this,
+        _PhishingController_inProgressHotlistUpdate,
+        "f"
+      );
+      return;
     }
-    /**
-     * Temporarily marks a given origin as approved.
-     *
-     * @param origin - The origin to mark as approved.
-     */
-    bypass(origin) {
-        const punycodeOrigin = (0, punycode_js_1.toASCII)(origin);
-        const hostname = (0, utils_1.getHostnameFromUrl)(punycodeOrigin);
-        const { whitelist } = this.state;
-        if (whitelist.includes(hostname || punycodeOrigin)) {
-            return;
-        }
-        this.update((draftState) => {
-            draftState.whitelist.push(hostname || punycodeOrigin);
-        });
+    try {
+      __classPrivateFieldSet(
+        this,
+        _PhishingController_inProgressHotlistUpdate,
+        __classPrivateFieldGet(
+          this,
+          _PhishingController_instances,
+          "m",
+          _PhishingController_updateHotlist
+        ).call(this),
+        "f"
+      );
+      await __classPrivateFieldGet(
+        this,
+        _PhishingController_inProgressHotlistUpdate,
+        "f"
+      );
+    } finally {
+      __classPrivateFieldSet(
+        this,
+        _PhishingController_inProgressHotlistUpdate,
+        undefined,
+        "f"
+      );
     }
-    /**
-     * Update the C2 domain blocklist.
-     *
-     * If an update is in progress, no additional update will be made. Instead this will wait until
-     * the in-progress update has finished.
-     */
-    async updateC2DomainBlocklist() {
-        if (__classPrivateFieldGet(this, _PhishingController_isProgressC2DomainBlocklistUpdate, "f")) {
-            await __classPrivateFieldGet(this, _PhishingController_isProgressC2DomainBlocklistUpdate, "f");
-            return;
-        }
-        try {
-            __classPrivateFieldSet(this, _PhishingController_isProgressC2DomainBlocklistUpdate, __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_updateC2DomainBlocklist).call(this), "f");
-            await __classPrivateFieldGet(this, _PhishingController_isProgressC2DomainBlocklistUpdate, "f");
-        }
-        finally {
-            __classPrivateFieldSet(this, _PhishingController_isProgressC2DomainBlocklistUpdate, undefined, "f");
-        }
+  }
+  /**
+   * Update the stalelist.
+   *
+   * If an update is in progress, no additional update will be made. Instead this will wait until
+   * the in-progress update has finished.
+   */
+  async updateStalelist() {
+    if (
+      __classPrivateFieldGet(
+        this,
+        _PhishingController_inProgressStalelistUpdate,
+        "f"
+      )
+    ) {
+      await __classPrivateFieldGet(
+        this,
+        _PhishingController_inProgressStalelistUpdate,
+        "f"
+      );
+      return;
     }
-    /**
-     * Update the hotlist.
-     *
-     * If an update is in progress, no additional update will be made. Instead this will wait until
-     * the in-progress update has finished.
-     */
-    async updateHotlist() {
-        if (__classPrivateFieldGet(this, _PhishingController_inProgressHotlistUpdate, "f")) {
-            await __classPrivateFieldGet(this, _PhishingController_inProgressHotlistUpdate, "f");
-            return;
-        }
-        try {
-            __classPrivateFieldSet(this, _PhishingController_inProgressHotlistUpdate, __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_updateHotlist).call(this), "f");
-            await __classPrivateFieldGet(this, _PhishingController_inProgressHotlistUpdate, "f");
-        }
-        finally {
-            __classPrivateFieldSet(this, _PhishingController_inProgressHotlistUpdate, undefined, "f");
-        }
+    try {
+      __classPrivateFieldSet(
+        this,
+        _PhishingController_inProgressStalelistUpdate,
+        __classPrivateFieldGet(
+          this,
+          _PhishingController_instances,
+          "m",
+          _PhishingController_updateStalelist
+        ).call(this),
+        "f"
+      );
+      await __classPrivateFieldGet(
+        this,
+        _PhishingController_inProgressStalelistUpdate,
+        "f"
+      );
+    } finally {
+      __classPrivateFieldSet(
+        this,
+        _PhishingController_inProgressStalelistUpdate,
+        undefined,
+        "f"
+      );
     }
+  }
+}
+exports.PhishingController = PhishingController;
+(_PhishingController_detector = new WeakMap()),
+  (_PhishingController_stalelistRefreshInterval = new WeakMap()),
+  (_PhishingController_hotlistRefreshInterval = new WeakMap()),
+  (_PhishingController_c2DomainBlocklistRefreshInterval = new WeakMap()),
+  (_PhishingController_urlScanCache = new WeakMap()),
+  (_PhishingController_inProgressHotlistUpdate = new WeakMap()),
+  (_PhishingController_inProgressStalelistUpdate = new WeakMap()),
+  (_PhishingController_isProgressC2DomainBlocklistUpdate = new WeakMap()),
+  (_PhishingController_processBatch = new WeakMap()),
+  (_PhishingController_instances = new WeakSet()),
+  (_PhishingController_registerMessageHandlers =
+    function _PhishingController_registerMessageHandlers() {
+      this.messagingSystem.registerActionHandler(
+        `${controllerName}:maybeUpdateState`,
+        this.maybeUpdateState.bind(this)
+      );
+      this.messagingSystem.registerActionHandler(
+        `${controllerName}:testOrigin`,
+        this.test.bind(this)
+      );
+      this.messagingSystem.registerActionHandler(
+        `${controllerName}:bulkScanUrls`,
+        this.bulkScanUrls.bind(this)
+      );
+    }),
+  (_PhishingController_updateStalelist =
     /**
-     * Update the stalelist.
+     * Update the stalelist configuration.
      *
-     * If an update is in progress, no additional update will be made. Instead this will wait until
-     * the in-progress update has finished.
+     * This should only be called from the `updateStalelist` function, which is a wrapper around
+     * this function that prevents redundant configuration updates.
      */
-    async updateStalelist() {
-        if (__classPrivateFieldGet(this, _PhishingController_inProgressStalelistUpdate, "f")) {
-            await __classPrivateFieldGet(this, _PhishingController_inProgressStalelistUpdate, "f");
-            return;
-        }
-        try {
-            __classPrivateFieldSet(this, _PhishingController_inProgressStalelistUpdate, __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_updateStalelist).call(this), "f");
-            await __classPrivateFieldGet(this, _PhishingController_inProgressStalelistUpdate, "f");
-        }
-        finally {
-            __classPrivateFieldSet(this, _PhishingController_inProgressStalelistUpdate, undefined, "f");
-        }
-    }
-}
-exports.PhishingController = PhishingController;
-_PhishingController_detector = new WeakMap(), _PhishingController_stalelistRefreshInterval = new WeakMap(), _PhishingController_hotlistRefreshInterval = new WeakMap(), _PhishingController_c2DomainBlocklistRefreshInterval = new WeakMap(), _PhishingController_urlScanCache = new WeakMap(), _PhishingController_inProgressHotlistUpdate = new WeakMap(), _PhishingController_inProgressStalelistUpdate = new WeakMap(), _PhishingController_isProgressC2DomainBlocklistUpdate = new WeakMap(), _PhishingController_processBatch = new WeakMap(), _PhishingController_instances = new WeakSet(), _PhishingController_registerMessageHandlers = function _PhishingController_registerMessageHandlers() {
-    this.messagingSystem.registerActionHandler(`${controllerName}:maybeUpdateState`, this.maybeUpdateState.bind(this));
-    this.messagingSystem.registerActionHandler(`${controllerName}:testOrigin`, this.test.bind(this));
-    this.messagingSystem.registerActionHandler(`${controllerName}:bulkScanUrls`, this.bulkScanUrls.bind(this));
-}, _PhishingController_updateStalelist = 
-/**
- * Update the stalelist configuration.
- *
- * This should only be called from the `updateStalelist` function, which is a wrapper around
- * this function that prevents redundant configuration updates.
- */
-async function _PhishingController_updateStalelist() {
-    let stalelistResponse = null;
-    let hotlistDiffsResponse = null;
-    let c2DomainBlocklistResponse = null;
-    try {
-        const stalelistPromise = __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_queryConfig).call(this, exports.METAMASK_STALELIST_URL);
-        const c2DomainBlocklistPromise = __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_queryConfig).call(this, exports.C2_DOMAIN_BLOCKLIST_URL);
+    async function _PhishingController_updateStalelist() {
+      let stalelistResponse = null;
+      let hotlistDiffsResponse = null;
+      let c2DomainBlocklistResponse = null;
+      try {
+        const stalelistPromise = __classPrivateFieldGet(
+          this,
+          _PhishingController_instances,
+          "m",
+          _PhishingController_queryConfig
+        ).call(this, exports.METAMASK_STALELIST_URL);
+        const c2DomainBlocklistPromise = __classPrivateFieldGet(
+          this,
+          _PhishingController_instances,
+          "m",
+          _PhishingController_queryConfig
+        ).call(this, exports.C2_DOMAIN_BLOCKLIST_URL);
         [stalelistResponse, c2DomainBlocklistResponse] = await Promise.all([
-            stalelistPromise,
-            c2DomainBlocklistPromise,
+          stalelistPromise,
+          c2DomainBlocklistPromise,
         ]);
         // Fetching hotlist diffs relies on having a lastUpdated timestamp to do `GET /v1/diffsSince/:timestamp`,
         // so it doesn't make sense to call if there is not a timestamp to begin with.
         if (stalelistResponse?.data && stalelistResponse.data.lastUpdated > 0) {
-            hotlistDiffsResponse = await __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_queryConfig).call(this, `${exports.METAMASK_HOTLIST_DIFF_URL}/${stalelistResponse.data.lastUpdated}`);
+          hotlistDiffsResponse = await __classPrivateFieldGet(
+            this,
+            _PhishingController_instances,
+            "m",
+            _PhishingController_queryConfig
+          ).call(
+            this,
+            `${exports.METAMASK_HOTLIST_DIFF_URL}/${stalelistResponse.data.lastUpdated}`
+          );
         }
-    }
-    finally {
+      } finally {
         // Set `stalelistLastFetched` and `hotlistLastFetched` even for failed requests to prevent server
         // from being overwhelmed with traffic after a network disruption.
         const timeNow = (0, utils_1.fetchTimeNow)();
         this.update((draftState) => {
-            draftState.stalelistLastFetched = timeNow;
-            draftState.hotlistLastFetched = timeNow;
-            draftState.c2DomainBlocklistLastFetched = timeNow;
+          draftState.stalelistLastFetched = timeNow;
+          draftState.hotlistLastFetched = timeNow;
+          draftState.c2DomainBlocklistLastFetched = timeNow;
         });
-    }
-    if (!stalelistResponse || !hotlistDiffsResponse) {
+      }
+      if (!stalelistResponse || !hotlistDiffsResponse) {
         return;
-    }
-    // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-    const { eth_phishing_detect_config, ...partialState } = stalelistResponse.data;
-    const metamaskListState = {
-        ...eth_phishing_detect_config,
-        ...partialState,
+      }
+      const metamaskListState = {
+        allowlist: stalelistResponse.data.allowlist,
+        fuzzylist: stalelistResponse.data.fuzzylist,
+        tolerance: stalelistResponse.data.tolerance,
+        version: stalelistResponse.data.version,
+        lastUpdated: stalelistResponse.data.lastUpdated,
+        blocklist: stalelistResponse.data.blocklist,
+        blocklistPaths: (0, PathTrie_1.convertListToTrie)(
+          stalelistResponse.data.blocklistPaths
+        ),
         c2DomainBlocklist: c2DomainBlocklistResponse
-            ? c2DomainBlocklistResponse.recentlyAdded
-            : [],
+          ? c2DomainBlocklistResponse.recentlyAdded
+          : [],
         name: exports.phishingListKeyNameMap.eth_phishing_detect_config,
-    };
-    const newMetaMaskListState = (0, utils_1.applyDiffs)(metamaskListState, hotlistDiffsResponse.data, ListKeys.EthPhishingDetectConfig);
-    this.update((draftState) => {
+      };
+      const newMetaMaskListState = (0, utils_1.applyDiffs)(
+        metamaskListState,
+        hotlistDiffsResponse.data,
+        ListKeys.EthPhishingDetectConfig
+      );
+      this.update((draftState) => {
         draftState.phishingLists = [newMetaMaskListState];
-    });
-    this.updatePhishingDetector();
-}, _PhishingController_updateHotlist = 
-/**
- * Update the stalelist configuration.
- *
- * This should only be called from the `updateStalelist` function, which is a wrapper around
- * this function that prevents redundant configuration updates.
- */
-async function _PhishingController_updateHotlist() {
-    let hotlistResponse;
-    try {
+      });
+      this.updatePhishingDetector();
+    }),
+  (_PhishingController_updateHotlist =
+    /**
+     * Update the stalelist configuration.
+     *
+     * This should only be called from the `updateStalelist` function, which is a wrapper around
+     * this function that prevents redundant configuration updates.
+     */
+    async function _PhishingController_updateHotlist() {
+      let hotlistResponse;
+      try {
         if (this.state.phishingLists.length === 0) {
-            return;
+          return;
         }
-        const lastDiffTimestamp = Math.max(...this.state.phishingLists.map(({ lastUpdated }) => lastUpdated));
-        hotlistResponse = await __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_queryConfig).call(this, `${exports.METAMASK_HOTLIST_DIFF_URL}/${lastDiffTimestamp}`);
-    }
-    finally {
+        const lastDiffTimestamp = Math.max(
+          ...this.state.phishingLists.map(({ lastUpdated }) => lastUpdated)
+        );
+        hotlistResponse = await __classPrivateFieldGet(
+          this,
+          _PhishingController_instances,
+          "m",
+          _PhishingController_queryConfig
+        ).call(
+          this,
+          `${exports.METAMASK_HOTLIST_DIFF_URL}/${lastDiffTimestamp}`
+        );
+      } finally {
         // Set `hotlistLastFetched` even for failed requests to prevent server from being overwhelmed with
         // traffic after a network disruption.
         this.update((draftState) => {
-            draftState.hotlistLastFetched = (0, utils_1.fetchTimeNow)();
+          draftState.hotlistLastFetched = (0, utils_1.fetchTimeNow)();
         });
-    }
-    if (!hotlistResponse?.data) {
+      }
+      if (!hotlistResponse?.data) {
         return;
-    }
-    const hotlist = hotlistResponse.data;
-    const newPhishingLists = this.state.phishingLists.map((phishingList) => {
-        const updatedList = (0, utils_1.applyDiffs)(phishingList, hotlist, phishingListNameKeyMap[phishingList.name], [], []);
+      }
+      const hotlist = hotlistResponse.data;
+      const newPhishingLists = this.state.phishingLists.map((phishingList) => {
+        const updatedList = (0, utils_1.applyDiffs)(
+          phishingList,
+          hotlist,
+          phishingListNameKeyMap[phishingList.name],
+          [],
+          []
+        );
         return updatedList;
-    });
-    this.update((draftState) => {
+      });
+      this.update((draftState) => {
         draftState.phishingLists = newPhishingLists;
-    });
-    this.updatePhishingDetector();
-}, _PhishingController_updateC2DomainBlocklist = 
-/**
- * Update the C2 domain blocklist.
- *
- * This should only be called from the `updateC2DomainBlocklist` function, which is a wrapper around
- * this function that prevents redundant configuration updates.
- */
-async function _PhishingController_updateC2DomainBlocklist() {
-    let c2DomainBlocklistResponse = null;
-    try {
-        c2DomainBlocklistResponse =
-            await __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_queryConfig).call(this, `${exports.C2_DOMAIN_BLOCKLIST_URL}?timestamp=${(0, utils_1.roundToNearestMinute)(this.state.c2DomainBlocklistLastFetched)}`);
-    }
-    finally {
+      });
+      this.updatePhishingDetector();
+    }),
+  (_PhishingController_updateC2DomainBlocklist =
+    /**
+     * Update the C2 domain blocklist.
+     *
+     * This should only be called from the `updateC2DomainBlocklist` function, which is a wrapper around
+     * this function that prevents redundant configuration updates.
+     */
+    async function _PhishingController_updateC2DomainBlocklist() {
+      let c2DomainBlocklistResponse = null;
+      try {
+        c2DomainBlocklistResponse = await __classPrivateFieldGet(
+          this,
+          _PhishingController_instances,
+          "m",
+          _PhishingController_queryConfig
+        ).call(
+          this,
+          `${exports.C2_DOMAIN_BLOCKLIST_URL}?timestamp=${(0,
+          utils_1.roundToNearestMinute)(
+            this.state.c2DomainBlocklistLastFetched
+          )}`
+        );
+      } finally {
         // Set `c2DomainBlocklistLastFetched` even for failed requests to prevent server from being overwhelmed with
         // traffic after a network disruption.
         this.update((draftState) => {
-            draftState.c2DomainBlocklistLastFetched = (0, utils_1.fetchTimeNow)();
+          draftState.c2DomainBlocklistLastFetched = (0, utils_1.fetchTimeNow)();
         });
-    }
-    if (!c2DomainBlocklistResponse) {
+      }
+      if (!c2DomainBlocklistResponse) {
         return;
-    }
-    const recentlyAddedC2Domains = c2DomainBlocklistResponse.recentlyAdded;
-    const recentlyRemovedC2Domains = c2DomainBlocklistResponse.recentlyRemoved;
-    const newPhishingLists = this.state.phishingLists.map((phishingList) => {
-        const updatedList = (0, utils_1.applyDiffs)(phishingList, [], phishingListNameKeyMap[phishingList.name], recentlyAddedC2Domains, recentlyRemovedC2Domains);
+      }
+      const recentlyAddedC2Domains = c2DomainBlocklistResponse.recentlyAdded;
+      const recentlyRemovedC2Domains =
+        c2DomainBlocklistResponse.recentlyRemoved;
+      const newPhishingLists = this.state.phishingLists.map((phishingList) => {
+        const updatedList = (0, utils_1.applyDiffs)(
+          phishingList,
+          [],
+          phishingListNameKeyMap[phishingList.name],
+          recentlyAddedC2Domains,
+          recentlyRemovedC2Domains
+        );
         return updatedList;
-    });
-    this.update((draftState) => {
+      });
+      this.update((draftState) => {
         draftState.phishingLists = newPhishingLists;
-    });
-    this.updatePhishingDetector();
-}, _PhishingController_queryConfig = async function _PhishingController_queryConfig(input) {
-    const response = await (0, controller_utils_1.safelyExecute)(() => fetch(input, { cache: 'no-cache' }), true);
-    switch (response?.status) {
+      });
+      this.updatePhishingDetector();
+    }),
+  (_PhishingController_queryConfig =
+    async function _PhishingController_queryConfig(input) {
+      const response = await (0, controller_utils_1.safelyExecute)(
+        () => fetch(input, { cache: "no-cache" }),
+        true
+      );
+      switch (response?.status) {
         case 200: {
-            return await response.json();
+          return await response.json();
         }
         default: {
-            return null;
+          return null;
         }
-    }
-};
+      }
+    });
 exports.default = PhishingController;
 //# sourceMappingURL=PhishingController.cjs.map
diff --git a/dist/PhishingController.mjs b/dist/PhishingController.mjs
index e4bb6908a916af4b01341928a3bf3b4bd5366120..9619b991917c89d4b6326db22b130c4020b110f9 100644
--- a/dist/PhishingController.mjs
+++ b/dist/PhishingController.mjs
@@ -1,31 +1,100 @@
-var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+var __classPrivateFieldSet =
+  (this && this.__classPrivateFieldSet) ||
+  function (receiver, state, value, kind, f) {
     if (kind === "m") throw new TypeError("Private method is not writable");
-    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
-    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
-    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
-};
-var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
-    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
-    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
-    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
-};
-var _PhishingController_instances, _PhishingController_detector, _PhishingController_stalelistRefreshInterval, _PhishingController_hotlistRefreshInterval, _PhishingController_c2DomainBlocklistRefreshInterval, _PhishingController_urlScanCache, _PhishingController_inProgressHotlistUpdate, _PhishingController_inProgressStalelistUpdate, _PhishingController_isProgressC2DomainBlocklistUpdate, _PhishingController_registerMessageHandlers, _PhishingController_processBatch, _PhishingController_updateStalelist, _PhishingController_updateHotlist, _PhishingController_updateC2DomainBlocklist, _PhishingController_queryConfig;
+    if (kind === "a" && !f)
+      throw new TypeError("Private accessor was defined without a setter");
+    if (
+      typeof state === "function"
+        ? receiver !== state || !f
+        : !state.has(receiver)
+    )
+      throw new TypeError(
+        "Cannot write private member to an object whose class did not declare it"
+      );
+    return (
+      kind === "a"
+        ? f.call(receiver, value)
+        : f
+        ? (f.value = value)
+        : state.set(receiver, value),
+      value
+    );
+  };
+var __classPrivateFieldGet =
+  (this && this.__classPrivateFieldGet) ||
+  function (receiver, state, kind, f) {
+    if (kind === "a" && !f)
+      throw new TypeError("Private accessor was defined without a getter");
+    if (
+      typeof state === "function"
+        ? receiver !== state || !f
+        : !state.has(receiver)
+    )
+      throw new TypeError(
+        "Cannot read private member from an object whose class did not declare it"
+      );
+    return kind === "m"
+      ? f
+      : kind === "a"
+      ? f.call(receiver)
+      : f
+      ? f.value
+      : state.get(receiver);
+  };
+var _PhishingController_instances,
+  _PhishingController_detector,
+  _PhishingController_stalelistRefreshInterval,
+  _PhishingController_hotlistRefreshInterval,
+  _PhishingController_c2DomainBlocklistRefreshInterval,
+  _PhishingController_urlScanCache,
+  _PhishingController_inProgressHotlistUpdate,
+  _PhishingController_inProgressStalelistUpdate,
+  _PhishingController_isProgressC2DomainBlocklistUpdate,
+  _PhishingController_registerMessageHandlers,
+  _PhishingController_processBatch,
+  _PhishingController_updateStalelist,
+  _PhishingController_updateHotlist,
+  _PhishingController_updateC2DomainBlocklist,
+  _PhishingController_queryConfig;
 import { BaseController } from "@metamask/base-controller";
-import { safelyExecute, safelyExecuteWithTimeout } from "@metamask/controller-utils";
+import {
+  safelyExecute,
+  safelyExecuteWithTimeout,
+} from "@metamask/controller-utils";
 import $punycodepunycodejs from "punycode/punycode.js";
 const { toASCII } = $punycodepunycodejs;
+import {
+  convertListToTrie,
+  insertToTrie,
+  matchedPathPrefix,
+} from "./PathTrie.mjs";
 import { PhishingDetector } from "./PhishingDetector.mjs";
 import { PhishingDetectorResultType, RecommendedAction } from "./types.mjs";
-import { DEFAULT_URL_SCAN_CACHE_MAX_SIZE, DEFAULT_URL_SCAN_CACHE_TTL, UrlScanCache } from "./UrlScanCache.mjs";
-import { applyDiffs, fetchTimeNow, getHostnameFromUrl, roundToNearestMinute, getHostnameFromWebUrl } from "./utils.mjs";
-export const PHISHING_CONFIG_BASE_URL = 'https://phishing-detection.api.cx.metamask.io';
-export const METAMASK_STALELIST_FILE = '/v1/stalelist';
-export const METAMASK_HOTLIST_DIFF_FILE = '/v1/diffsSince';
-export const CLIENT_SIDE_DETECION_BASE_URL = 'https://client-side-detection.api.cx.metamask.io';
-export const C2_DOMAIN_BLOCKLIST_ENDPOINT = '/v1/request-blocklist';
-export const PHISHING_DETECTION_BASE_URL = 'https://dapp-scanning.api.cx.metamask.io';
-export const PHISHING_DETECTION_SCAN_ENDPOINT = 'v2/scan';
-export const PHISHING_DETECTION_BULK_SCAN_ENDPOINT = 'bulk-scan';
+import {
+  DEFAULT_URL_SCAN_CACHE_MAX_SIZE,
+  DEFAULT_URL_SCAN_CACHE_TTL,
+  UrlScanCache,
+} from "./UrlScanCache.mjs";
+import {
+  applyDiffs,
+  fetchTimeNow,
+  getHostnameFromUrl,
+  roundToNearestMinute,
+  getHostnameFromWebUrl,
+  getPathnameFromUrl,
+} from "./utils.mjs";
+export const PHISHING_CONFIG_BASE_URL =
+  "https://phishing-detection.api.cx.metamask.io";
+export const METAMASK_STALELIST_FILE = "/v1/stalelist";
+export const METAMASK_HOTLIST_DIFF_FILE = "/v1/diffsSince";
+export const CLIENT_SIDE_DETECION_BASE_URL =
+  "https://client-side-detection.api.cx.metamask.io";
+export const C2_DOMAIN_BLOCKLIST_ENDPOINT = "/v1/request-blocklist";
+export const PHISHING_DETECTION_BASE_URL =
+  "https://dapp-scanning.api.cx.metamask.io";
+export const PHISHING_DETECTION_SCAN_ENDPOINT = "v2/scan";
+export const PHISHING_DETECTION_BULK_SCAN_ENDPOINT = "bulk-scan";
 export const C2_DOMAIN_BLOCKLIST_REFRESH_INTERVAL = 5 * 60; // 5 mins in seconds
 export const HOTLIST_REFRESH_INTERVAL = 5 * 60; // 5 mins in seconds
 export const STALELIST_REFRESH_INTERVAL = 30 * 24 * 60 * 60; // 30 days in seconds
@@ -38,651 +107,961 @@ export const C2_DOMAIN_BLOCKLIST_URL = `${CLIENT_SIDE_DETECION_BASE_URL}${C2_DOM
  */
 export var ListKeys;
 (function (ListKeys) {
-    ListKeys["EthPhishingDetectConfig"] = "eth_phishing_detect_config";
+  ListKeys["EthPhishingDetectConfig"] = "eth_phishing_detect_config";
 })(ListKeys || (ListKeys = {}));
 /**
  * Enum containing downstream client attribution names.
  */
 export var ListNames;
 (function (ListNames) {
-    ListNames["MetaMask"] = "MetaMask";
+  ListNames["MetaMask"] = "MetaMask";
 })(ListNames || (ListNames = {}));
 /**
  * Maps from downstream client attribution name
  * to list key sourced from upstream data provider.
  */
 const phishingListNameKeyMap = {
-    [ListNames.MetaMask]: ListKeys.EthPhishingDetectConfig,
+  [ListNames.MetaMask]: ListKeys.EthPhishingDetectConfig,
 };
 /**
  * Maps from list key sourced from upstream data
  * provider to downstream client attribution name.
  */
 export const phishingListKeyNameMap = {
-    [ListKeys.EthPhishingDetectConfig]: ListNames.MetaMask,
+  [ListKeys.EthPhishingDetectConfig]: ListNames.MetaMask,
 };
-const controllerName = 'PhishingController';
+const controllerName = "PhishingController";
 const metadata = {
-    phishingLists: { persist: true, anonymous: false },
-    whitelist: { persist: true, anonymous: false },
-    hotlistLastFetched: { persist: true, anonymous: false },
-    stalelistLastFetched: { persist: true, anonymous: false },
-    c2DomainBlocklistLastFetched: { persist: true, anonymous: false },
-    urlScanCache: { persist: true, anonymous: false },
+  phishingLists: { persist: true, anonymous: false },
+  whitelist: { persist: true, anonymous: false },
+  whitelistPaths: { persist: true, anonymous: false },
+  hotlistLastFetched: { persist: true, anonymous: false },
+  stalelistLastFetched: { persist: true, anonymous: false },
+  c2DomainBlocklistLastFetched: { persist: true, anonymous: false },
+  urlScanCache: { persist: true, anonymous: false },
 };
 /**
  * Get a default empty state for the controller.
  * @returns The default empty state.
  */
 const getDefaultState = () => {
-    return {
-        phishingLists: [],
-        whitelist: [],
-        hotlistLastFetched: 0,
-        stalelistLastFetched: 0,
-        c2DomainBlocklistLastFetched: 0,
-        urlScanCache: {},
-    };
+  return {
+    phishingLists: [],
+    whitelist: [],
+    whitelistPaths: {},
+    hotlistLastFetched: 0,
+    stalelistLastFetched: 0,
+    c2DomainBlocklistLastFetched: 0,
+    urlScanCache: {},
+  };
 };
 /**
  * Controller that manages community-maintained lists of approved and unapproved website origins.
  */
 export class PhishingController extends BaseController {
+  /**
+   * Construct a Phishing Controller.
+   *
+   * @param config - Initial options used to configure this controller.
+   * @param config.stalelistRefreshInterval - Polling interval used to fetch stale list.
+   * @param config.hotlistRefreshInterval - Polling interval used to fetch hotlist diff list.
+   * @param config.c2DomainBlocklistRefreshInterval - Polling interval used to fetch c2 domain blocklist.
+   * @param config.urlScanCacheTTL - Time to live in seconds for cached scan results.
+   * @param config.urlScanCacheMaxSize - Maximum number of entries in the scan cache.
+   * @param config.messenger - The controller restricted messenger.
+   * @param config.state - Initial state to set on this controller.
+   */
+  constructor({
+    stalelistRefreshInterval = STALELIST_REFRESH_INTERVAL,
+    hotlistRefreshInterval = HOTLIST_REFRESH_INTERVAL,
+    c2DomainBlocklistRefreshInterval = C2_DOMAIN_BLOCKLIST_REFRESH_INTERVAL,
+    urlScanCacheTTL = DEFAULT_URL_SCAN_CACHE_TTL,
+    urlScanCacheMaxSize = DEFAULT_URL_SCAN_CACHE_MAX_SIZE,
+    messenger,
+    state = {},
+  }) {
+    super({
+      name: controllerName,
+      metadata,
+      messenger,
+      state: {
+        ...getDefaultState(),
+        ...state,
+      },
+    });
+    _PhishingController_instances.add(this);
+    // TODO: Replace `any` with type
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    _PhishingController_detector.set(this, void 0);
+    _PhishingController_stalelistRefreshInterval.set(this, void 0);
+    _PhishingController_hotlistRefreshInterval.set(this, void 0);
+    _PhishingController_c2DomainBlocklistRefreshInterval.set(this, void 0);
+    _PhishingController_urlScanCache.set(this, void 0);
+    _PhishingController_inProgressHotlistUpdate.set(this, void 0);
+    _PhishingController_inProgressStalelistUpdate.set(this, void 0);
+    _PhishingController_isProgressC2DomainBlocklistUpdate.set(this, void 0);
     /**
-     * Construct a Phishing Controller.
+     * Scan a URL for phishing. It will only scan the hostname of the URL. It also only supports
+     * web URLs.
      *
-     * @param config - Initial options used to configure this controller.
-     * @param config.stalelistRefreshInterval - Polling interval used to fetch stale list.
-     * @param config.hotlistRefreshInterval - Polling interval used to fetch hotlist diff list.
-     * @param config.c2DomainBlocklistRefreshInterval - Polling interval used to fetch c2 domain blocklist.
-     * @param config.urlScanCacheTTL - Time to live in seconds for cached scan results.
-     * @param config.urlScanCacheMaxSize - Maximum number of entries in the scan cache.
-     * @param config.messenger - The controller restricted messenger.
-     * @param config.state - Initial state to set on this controller.
+     * @param url - The URL to scan.
+     * @returns The phishing detection scan result.
      */
-    constructor({ stalelistRefreshInterval = STALELIST_REFRESH_INTERVAL, hotlistRefreshInterval = HOTLIST_REFRESH_INTERVAL, c2DomainBlocklistRefreshInterval = C2_DOMAIN_BLOCKLIST_REFRESH_INTERVAL, urlScanCacheTTL = DEFAULT_URL_SCAN_CACHE_TTL, urlScanCacheMaxSize = DEFAULT_URL_SCAN_CACHE_MAX_SIZE, messenger, state = {}, }) {
-        super({
-            name: controllerName,
-            metadata,
-            messenger,
-            state: {
-                ...getDefaultState(),
-                ...state,
-            },
-        });
-        _PhishingController_instances.add(this);
-        // TODO: Replace `any` with type
-        // eslint-disable-next-line @typescript-eslint/no-explicit-any
-        _PhishingController_detector.set(this, void 0);
-        _PhishingController_stalelistRefreshInterval.set(this, void 0);
-        _PhishingController_hotlistRefreshInterval.set(this, void 0);
-        _PhishingController_c2DomainBlocklistRefreshInterval.set(this, void 0);
-        _PhishingController_urlScanCache.set(this, void 0);
-        _PhishingController_inProgressHotlistUpdate.set(this, void 0);
-        _PhishingController_inProgressStalelistUpdate.set(this, void 0);
-        _PhishingController_isProgressC2DomainBlocklistUpdate.set(this, void 0);
-        /**
-         * Scan a URL for phishing. It will only scan the hostname of the URL. It also only supports
-         * web URLs.
-         *
-         * @param url - The URL to scan.
-         * @returns The phishing detection scan result.
-         */
-        this.scanUrl = async (url) => {
-            const [hostname, ok] = getHostnameFromWebUrl(url);
-            if (!ok) {
-                return {
-                    hostname: '',
-                    recommendedAction: RecommendedAction.None,
-                    fetchError: 'url is not a valid web URL',
-                };
-            }
-            const cachedResult = __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").get(hostname);
-            if (cachedResult) {
-                return cachedResult;
-            }
-            const apiResponse = await safelyExecuteWithTimeout(async () => {
-                const res = await fetch(`${PHISHING_DETECTION_BASE_URL}/${PHISHING_DETECTION_SCAN_ENDPOINT}?url=${encodeURIComponent(hostname)}`, {
-                    method: 'GET',
-                    headers: {
-                        Accept: 'application/json',
-                    },
-                });
-                if (!res.ok) {
-                    return {
-                        error: `${res.status} ${res.statusText}`,
-                    };
-                }
-                const data = await res.json();
-                return data;
-            }, true, 8000);
-            // Need to do it this way because safelyExecuteWithTimeout returns undefined for both timeouts and errors.
-            if (!apiResponse) {
-                return {
-                    hostname: '',
-                    recommendedAction: RecommendedAction.None,
-                    fetchError: 'timeout of 8000ms exceeded',
-                };
-            }
-            else if ('error' in apiResponse) {
-                return {
-                    hostname: '',
-                    recommendedAction: RecommendedAction.None,
-                    fetchError: apiResponse.error,
-                };
-            }
-            const result = {
-                hostname,
-                recommendedAction: apiResponse.recommendedAction,
-            };
-            __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").add(hostname, result);
-            return result;
+    this.scanUrl = async (url) => {
+      const [hostname, ok] = getHostnameFromWebUrl(url);
+      if (!ok) {
+        return {
+          hostname: "",
+          recommendedAction: RecommendedAction.None,
+          fetchError: "url is not a valid web URL",
         };
-        /**
-         * Scan multiple URLs for phishing in bulk. It will only scan the hostnames of the URLs.
-         * It also only supports web URLs.
-         *
-         * @param urls - The URLs to scan.
-         * @returns A mapping of URLs to their phishing detection scan results and errors.
-         */
-        this.bulkScanUrls = async (urls) => {
-            if (!urls || urls.length === 0) {
-                return {
-                    results: {},
-                    errors: {},
-                };
+      }
+      const cachedResult = __classPrivateFieldGet(
+        this,
+        _PhishingController_urlScanCache,
+        "f"
+      ).get(hostname);
+      if (cachedResult) {
+        return cachedResult;
+      }
+      const apiResponse = await safelyExecuteWithTimeout(
+        async () => {
+          const res = await fetch(
+            `${PHISHING_DETECTION_BASE_URL}/${PHISHING_DETECTION_SCAN_ENDPOINT}?url=${encodeURIComponent(
+              hostname
+            )}`,
+            {
+              method: "GET",
+              headers: {
+                Accept: "application/json",
+              },
             }
-            // we are arbitrarily limiting the number of URLs to 250
-            const MAX_TOTAL_URLS = 250;
-            if (urls.length > MAX_TOTAL_URLS) {
-                return {
-                    results: {},
-                    errors: {
-                        too_many_urls: [
-                            `Maximum of ${MAX_TOTAL_URLS} URLs allowed per request`,
-                        ],
-                    },
-                };
-            }
-            const MAX_URL_LENGTH = 2048;
-            const combinedResponse = {
-                results: {},
-                errors: {},
+          );
+          if (!res.ok) {
+            return {
+              error: `${res.status} ${res.statusText}`,
             };
-            // Extract hostnames from URLs and check for validity and length constraints
-            const urlsToHostnames = {};
-            const urlsToFetch = [];
-            for (const url of urls) {
-                if (url.length > MAX_URL_LENGTH) {
-                    combinedResponse.errors[url] = [
-                        `URL length must not exceed ${MAX_URL_LENGTH} characters`,
-                    ];
-                    continue;
-                }
-                const [hostname, ok] = getHostnameFromWebUrl(url);
-                if (!ok) {
-                    combinedResponse.errors[url] = ['url is not a valid web URL'];
-                    continue;
-                }
-                // Check if result is already in cache
-                const cachedResult = __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").get(hostname);
-                if (cachedResult) {
-                    // Use cached result
-                    combinedResponse.results[url] = cachedResult;
-                }
-                else {
-                    // Add to list of URLs to fetch
-                    urlsToHostnames[url] = hostname;
-                    urlsToFetch.push(url);
-                }
-            }
-            // If there are URLs to fetch, process them in batches
-            if (urlsToFetch.length > 0) {
-                // The API has a limit of 50 URLs per request, so we batch the requests
-                const MAX_URLS_PER_BATCH = 50;
-                const batches = [];
-                for (let i = 0; i < urlsToFetch.length; i += MAX_URLS_PER_BATCH) {
-                    batches.push(urlsToFetch.slice(i, i + MAX_URLS_PER_BATCH));
-                }
-                // Process each batch in parallel
-                const batchResults = await Promise.all(batches.map((batchUrls) => __classPrivateFieldGet(this, _PhishingController_processBatch, "f").call(this, batchUrls)));
-                // Merge results and errors from all batches
-                batchResults.forEach((batchResponse) => {
-                    // Add results to cache and combine with response
-                    Object.entries(batchResponse.results).forEach(([url, result]) => {
-                        const hostname = urlsToHostnames[url];
-                        if (hostname) {
-                            __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").add(hostname, result);
-                        }
-                        combinedResponse.results[url] = result;
-                    });
-                    // Combine errors
-                    Object.entries(batchResponse.errors).forEach(([key, messages]) => {
-                        combinedResponse.errors[key] = [
-                            ...(combinedResponse.errors[key] || []),
-                            ...messages,
-                        ];
-                    });
-                });
-            }
-            return combinedResponse;
+          }
+          const data = await res.json();
+          return data;
+        },
+        true,
+        8000
+      );
+      // Need to do it this way because safelyExecuteWithTimeout returns undefined for both timeouts and errors.
+      if (!apiResponse) {
+        return {
+          hostname: "",
+          recommendedAction: RecommendedAction.None,
+          fetchError: "timeout of 8000ms exceeded",
         };
-        /**
-         * Process a batch of URLs (up to 50) for phishing detection.
-         *
-         * @param urls - A batch of URLs to scan.
-         * @returns The scan results and errors for this batch.
-         */
-        _PhishingController_processBatch.set(this, async (urls) => {
-            const apiResponse = await safelyExecuteWithTimeout(async () => {
-                const res = await fetch(`${PHISHING_DETECTION_BASE_URL}/${PHISHING_DETECTION_BULK_SCAN_ENDPOINT}`, {
-                    method: 'POST',
-                    headers: {
-                        Accept: 'application/json',
-                        'Content-Type': 'application/json',
-                    },
-                    body: JSON.stringify({ urls }),
-                });
-                if (!res.ok) {
-                    return {
-                        error: `${res.status} ${res.statusText}`,
-                        status: res.status,
-                        statusText: res.statusText,
-                    };
-                }
-                const data = await res.json();
-                return data;
-            }, true, 15000);
-            // Handle timeout or network errors
-            if (!apiResponse) {
-                return {
-                    results: {},
-                    errors: {
-                        network_error: ['timeout of 15000ms exceeded'],
-                    },
-                };
-            }
-            // Handle HTTP error responses
-            if ('error' in apiResponse &&
-                'status' in apiResponse &&
-                'statusText' in apiResponse) {
-                return {
-                    results: {},
-                    errors: {
-                        api_error: [`${apiResponse.status} ${apiResponse.statusText}`],
-                    },
-                };
-            }
-            return apiResponse;
-        });
-        __classPrivateFieldSet(this, _PhishingController_stalelistRefreshInterval, stalelistRefreshInterval, "f");
-        __classPrivateFieldSet(this, _PhishingController_hotlistRefreshInterval, hotlistRefreshInterval, "f");
-        __classPrivateFieldSet(this, _PhishingController_c2DomainBlocklistRefreshInterval, c2DomainBlocklistRefreshInterval, "f");
-        __classPrivateFieldSet(this, _PhishingController_urlScanCache, new UrlScanCache({
-            cacheTTL: urlScanCacheTTL,
-            maxCacheSize: urlScanCacheMaxSize,
-            initialCache: this.state.urlScanCache,
-            updateState: (cache) => {
-                this.update((draftState) => {
-                    draftState.urlScanCache = cache;
-                });
-            },
-        }), "f");
-        __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_registerMessageHandlers).call(this);
-        this.updatePhishingDetector();
-    }
-    /**
-     * Updates this.detector with an instance of PhishingDetector using the current state.
-     */
-    updatePhishingDetector() {
-        __classPrivateFieldSet(this, _PhishingController_detector, new PhishingDetector(this.state.phishingLists), "f");
-    }
+      } else if ("error" in apiResponse) {
+        return {
+          hostname: "",
+          recommendedAction: RecommendedAction.None,
+          fetchError: apiResponse.error,
+        };
+      }
+      const result = {
+        hostname,
+        recommendedAction: apiResponse.recommendedAction,
+      };
+      __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").add(
+        hostname,
+        result
+      );
+      return result;
+    };
     /**
-     * Set the interval at which the stale phishing list will be refetched.
-     * Fetching will only occur on the next call to test/bypass.
-     * For immediate update to the phishing list, call {@link updateStalelist} directly.
+     * Scan multiple URLs for phishing in bulk. It will only scan the hostnames of the URLs.
+     * It also only supports web URLs.
      *
-     * @param interval - the new interval, in ms.
+     * @param urls - The URLs to scan.
+     * @returns A mapping of URLs to their phishing detection scan results and errors.
      */
-    setStalelistRefreshInterval(interval) {
-        __classPrivateFieldSet(this, _PhishingController_stalelistRefreshInterval, interval, "f");
-    }
+    this.bulkScanUrls = async (urls) => {
+      if (!urls || urls.length === 0) {
+        return {
+          results: {},
+          errors: {},
+        };
+      }
+      // we are arbitrarily limiting the number of URLs to 250
+      const MAX_TOTAL_URLS = 250;
+      if (urls.length > MAX_TOTAL_URLS) {
+        return {
+          results: {},
+          errors: {
+            too_many_urls: [
+              `Maximum of ${MAX_TOTAL_URLS} URLs allowed per request`,
+            ],
+          },
+        };
+      }
+      const MAX_URL_LENGTH = 2048;
+      const combinedResponse = {
+        results: {},
+        errors: {},
+      };
+      // Extract hostnames from URLs and check for validity and length constraints
+      const urlsToHostnames = {};
+      const urlsToFetch = [];
+      for (const url of urls) {
+        if (url.length > MAX_URL_LENGTH) {
+          combinedResponse.errors[url] = [
+            `URL length must not exceed ${MAX_URL_LENGTH} characters`,
+          ];
+          continue;
+        }
+        const [hostname, ok] = getHostnameFromWebUrl(url);
+        if (!ok) {
+          combinedResponse.errors[url] = ["url is not a valid web URL"];
+          continue;
+        }
+        // Check if result is already in cache
+        const cachedResult = __classPrivateFieldGet(
+          this,
+          _PhishingController_urlScanCache,
+          "f"
+        ).get(hostname);
+        if (cachedResult) {
+          // Use cached result
+          combinedResponse.results[url] = cachedResult;
+        } else {
+          // Add to list of URLs to fetch
+          urlsToHostnames[url] = hostname;
+          urlsToFetch.push(url);
+        }
+      }
+      // If there are URLs to fetch, process them in batches
+      if (urlsToFetch.length > 0) {
+        // The API has a limit of 50 URLs per request, so we batch the requests
+        const MAX_URLS_PER_BATCH = 50;
+        const batches = [];
+        for (let i = 0; i < urlsToFetch.length; i += MAX_URLS_PER_BATCH) {
+          batches.push(urlsToFetch.slice(i, i + MAX_URLS_PER_BATCH));
+        }
+        // Process each batch in parallel
+        const batchResults = await Promise.all(
+          batches.map((batchUrls) =>
+            __classPrivateFieldGet(
+              this,
+              _PhishingController_processBatch,
+              "f"
+            ).call(this, batchUrls)
+          )
+        );
+        // Merge results and errors from all batches
+        batchResults.forEach((batchResponse) => {
+          // Add results to cache and combine with response
+          Object.entries(batchResponse.results).forEach(([url, result]) => {
+            const hostname = urlsToHostnames[url];
+            if (hostname) {
+              __classPrivateFieldGet(
+                this,
+                _PhishingController_urlScanCache,
+                "f"
+              ).add(hostname, result);
+            }
+            combinedResponse.results[url] = result;
+          });
+          // Combine errors
+          Object.entries(batchResponse.errors).forEach(([key, messages]) => {
+            combinedResponse.errors[key] = [
+              ...(combinedResponse.errors[key] || []),
+              ...messages,
+            ];
+          });
+        });
+      }
+      return combinedResponse;
+    };
     /**
-     * Set the interval at which the hot list will be refetched.
-     * Fetching will only occur on the next call to test/bypass.
-     * For immediate update to the phishing list, call {@link updateHotlist} directly.
+     * Process a batch of URLs (up to 50) for phishing detection.
      *
-     * @param interval - the new interval, in ms.
+     * @param urls - A batch of URLs to scan.
+     * @returns The scan results and errors for this batch.
      */
-    setHotlistRefreshInterval(interval) {
-        __classPrivateFieldSet(this, _PhishingController_hotlistRefreshInterval, interval, "f");
+    _PhishingController_processBatch.set(this, async (urls) => {
+      const apiResponse = await safelyExecuteWithTimeout(
+        async () => {
+          const res = await fetch(
+            `${PHISHING_DETECTION_BASE_URL}/${PHISHING_DETECTION_BULK_SCAN_ENDPOINT}`,
+            {
+              method: "POST",
+              headers: {
+                Accept: "application/json",
+                "Content-Type": "application/json",
+              },
+              body: JSON.stringify({ urls }),
+            }
+          );
+          if (!res.ok) {
+            return {
+              error: `${res.status} ${res.statusText}`,
+              status: res.status,
+              statusText: res.statusText,
+            };
+          }
+          const data = await res.json();
+          return data;
+        },
+        true,
+        15000
+      );
+      // Handle timeout or network errors
+      if (!apiResponse) {
+        return {
+          results: {},
+          errors: {
+            network_error: ["timeout of 15000ms exceeded"],
+          },
+        };
+      }
+      // Handle HTTP error responses
+      if (
+        "error" in apiResponse &&
+        "status" in apiResponse &&
+        "statusText" in apiResponse
+      ) {
+        return {
+          results: {},
+          errors: {
+            api_error: [`${apiResponse.status} ${apiResponse.statusText}`],
+          },
+        };
+      }
+      return apiResponse;
+    });
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_stalelistRefreshInterval,
+      stalelistRefreshInterval,
+      "f"
+    );
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_hotlistRefreshInterval,
+      hotlistRefreshInterval,
+      "f"
+    );
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_c2DomainBlocklistRefreshInterval,
+      c2DomainBlocklistRefreshInterval,
+      "f"
+    );
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_urlScanCache,
+      new UrlScanCache({
+        cacheTTL: urlScanCacheTTL,
+        maxCacheSize: urlScanCacheMaxSize,
+        initialCache: this.state.urlScanCache,
+        updateState: (cache) => {
+          this.update((draftState) => {
+            draftState.urlScanCache = cache;
+          });
+        },
+      }),
+      "f"
+    );
+    __classPrivateFieldGet(
+      this,
+      _PhishingController_instances,
+      "m",
+      _PhishingController_registerMessageHandlers
+    ).call(this);
+    this.updatePhishingDetector();
+  }
+  /**
+   * Updates this.detector with an instance of PhishingDetector using the current state.
+   */
+  updatePhishingDetector() {
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_detector,
+      new PhishingDetector(this.state.phishingLists),
+      "f"
+    );
+  }
+  /**
+   * Set the interval at which the stale phishing list will be refetched.
+   * Fetching will only occur on the next call to test/bypass.
+   * For immediate update to the phishing list, call {@link updateStalelist} directly.
+   *
+   * @param interval - the new interval, in ms.
+   */
+  setStalelistRefreshInterval(interval) {
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_stalelistRefreshInterval,
+      interval,
+      "f"
+    );
+  }
+  /**
+   * Set the interval at which the hot list will be refetched.
+   * Fetching will only occur on the next call to test/bypass.
+   * For immediate update to the phishing list, call {@link updateHotlist} directly.
+   *
+   * @param interval - the new interval, in ms.
+   */
+  setHotlistRefreshInterval(interval) {
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_hotlistRefreshInterval,
+      interval,
+      "f"
+    );
+  }
+  /**
+   * Set the interval at which the C2 domain blocklist will be refetched.
+   * Fetching will only occur on the next call to test/bypass.
+   * For immediate update to the phishing list, call {@link updateHotlist} directly.
+   *
+   * @param interval - the new interval, in ms.
+   */
+  setC2DomainBlocklistRefreshInterval(interval) {
+    __classPrivateFieldSet(
+      this,
+      _PhishingController_c2DomainBlocklistRefreshInterval,
+      interval,
+      "f"
+    );
+  }
+  /**
+   * Set the time-to-live for URL scan cache entries.
+   *
+   * @param ttl - The TTL in seconds.
+   */
+  setUrlScanCacheTTL(ttl) {
+    __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").setTTL(
+      ttl
+    );
+  }
+  /**
+   * Set the maximum number of entries in the URL scan cache.
+   *
+   * @param maxSize - The maximum cache size.
+   */
+  setUrlScanCacheMaxSize(maxSize) {
+    __classPrivateFieldGet(
+      this,
+      _PhishingController_urlScanCache,
+      "f"
+    ).setMaxSize(maxSize);
+  }
+  /**
+   * Clear the URL scan cache.
+   */
+  clearUrlScanCache() {
+    __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").clear();
+  }
+  /**
+   * Determine if an update to the stalelist configuration is needed.
+   *
+   * @returns Whether an update is needed
+   */
+  isStalelistOutOfDate() {
+    return (
+      fetchTimeNow() - this.state.stalelistLastFetched >=
+      __classPrivateFieldGet(
+        this,
+        _PhishingController_stalelistRefreshInterval,
+        "f"
+      )
+    );
+  }
+  /**
+   * Determine if an update to the hotlist configuration is needed.
+   *
+   * @returns Whether an update is needed
+   */
+  isHotlistOutOfDate() {
+    return (
+      fetchTimeNow() - this.state.hotlistLastFetched >=
+      __classPrivateFieldGet(
+        this,
+        _PhishingController_hotlistRefreshInterval,
+        "f"
+      )
+    );
+  }
+  /**
+   * Determine if an update to the C2 domain blocklist is needed.
+   *
+   * @returns Whether an update is needed
+   */
+  isC2DomainBlocklistOutOfDate() {
+    return (
+      fetchTimeNow() - this.state.c2DomainBlocklistLastFetched >=
+      __classPrivateFieldGet(
+        this,
+        _PhishingController_c2DomainBlocklistRefreshInterval,
+        "f"
+      )
+    );
+  }
+  /**
+   * Conditionally update the phishing configuration.
+   *
+   * If the stalelist configuration is out of date, this function will call `updateStalelist`
+   * to update the configuration. This will automatically grab the hotlist,
+   * so it isn't necessary to continue on to download the hotlist and the c2 domain blocklist.
+   *
+   */
+  async maybeUpdateState() {
+    const staleListOutOfDate = this.isStalelistOutOfDate();
+    if (staleListOutOfDate) {
+      await this.updateStalelist();
+      return;
     }
-    /**
-     * Set the interval at which the C2 domain blocklist will be refetched.
-     * Fetching will only occur on the next call to test/bypass.
-     * For immediate update to the phishing list, call {@link updateHotlist} directly.
-     *
-     * @param interval - the new interval, in ms.
-     */
-    setC2DomainBlocklistRefreshInterval(interval) {
-        __classPrivateFieldSet(this, _PhishingController_c2DomainBlocklistRefreshInterval, interval, "f");
+    const hotlistOutOfDate = this.isHotlistOutOfDate();
+    if (hotlistOutOfDate) {
+      await this.updateHotlist();
     }
-    /**
-     * Set the time-to-live for URL scan cache entries.
-     *
-     * @param ttl - The TTL in seconds.
-     */
-    setUrlScanCacheTTL(ttl) {
-        __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").setTTL(ttl);
+    const c2DomainBlocklistOutOfDate = this.isC2DomainBlocklistOutOfDate();
+    if (c2DomainBlocklistOutOfDate) {
+      await this.updateC2DomainBlocklist();
     }
-    /**
-     * Set the maximum number of entries in the URL scan cache.
-     *
-     * @param maxSize - The maximum cache size.
-     */
-    setUrlScanCacheMaxSize(maxSize) {
-        __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").setMaxSize(maxSize);
+  }
+  /**
+   * Determines if a given origin is unapproved.
+   *
+   * It is strongly recommended that you call {@link maybeUpdateState} before calling this,
+   * to check whether the phishing configuration is up-to-date. It will be updated if necessary
+   * by calling {@link updateStalelist} or {@link updateHotlist}.
+   *
+   * @param origin - Domain origin of a website.
+   * @returns Whether the origin is an unapproved origin.
+   */
+  test(origin) {
+    const punycodeOrigin = toASCII(origin);
+    const hostname = getHostnameFromUrl(punycodeOrigin);
+    const hostnameWithPaths = hostname + getPathnameFromUrl(origin);
+    if (matchedPathPrefix(hostnameWithPaths, this.state.whitelistPaths)) {
+      return { result: false, type: PhishingDetectorResultType.All };
     }
-    /**
-     * Clear the URL scan cache.
-     */
-    clearUrlScanCache() {
-        __classPrivateFieldGet(this, _PhishingController_urlScanCache, "f").clear();
+    if (this.state.whitelist.includes(hostname || punycodeOrigin)) {
+      return { result: false, type: PhishingDetectorResultType.All }; // Same as whitelisted match returned by detector.check(...).
     }
-    /**
-     * Determine if an update to the stalelist configuration is needed.
-     *
-     * @returns Whether an update is needed
-     */
-    isStalelistOutOfDate() {
-        return (fetchTimeNow() - this.state.stalelistLastFetched >=
-            __classPrivateFieldGet(this, _PhishingController_stalelistRefreshInterval, "f"));
+    return __classPrivateFieldGet(
+      this,
+      _PhishingController_detector,
+      "f"
+    ).check(punycodeOrigin);
+  }
+  /**
+   * Checks if a request URL's domain is blocked against the request blocklist.
+   *
+   * This method is used to determine if a specific request URL is associated with a malicious
+   * command and control (C2) domain. The URL's hostname is hashed and checked against a configured
+   * blocklist of known malicious domains.
+   *
+   * @param origin - The full request URL to be checked.
+   * @returns An object indicating whether the URL's domain is blocked and relevant metadata.
+   */
+  isBlockedRequest(origin) {
+    const punycodeOrigin = toASCII(origin);
+    const hostname = getHostnameFromUrl(punycodeOrigin);
+    if (this.state.whitelist.includes(hostname || punycodeOrigin)) {
+      return { result: false, type: PhishingDetectorResultType.All }; // Same as whitelisted match returned by detector.check(...).
     }
-    /**
-     * Determine if an update to the hotlist configuration is needed.
-     *
-     * @returns Whether an update is needed
-     */
-    isHotlistOutOfDate() {
-        return (fetchTimeNow() - this.state.hotlistLastFetched >=
-            __classPrivateFieldGet(this, _PhishingController_hotlistRefreshInterval, "f"));
+    return __classPrivateFieldGet(
+      this,
+      _PhishingController_detector,
+      "f"
+    ).isMaliciousC2Domain(punycodeOrigin);
+  }
+  /**
+   * Temporarily marks a given origin as approved.
+   *
+   * @param origin - The origin to mark as approved.
+   */
+  bypass(origin) {
+    const punycodeOrigin = toASCII(origin);
+    const hostname = getHostnameFromUrl(punycodeOrigin);
+    const hostnameWithPaths = hostname + getPathnameFromUrl(origin);
+    const { whitelist, whitelistPaths } = this.state;
+    const whitelistPath = matchedPathPrefix(hostnameWithPaths, whitelistPaths);
+    if (whitelist.includes(hostname || punycodeOrigin) || whitelistPath) {
+      return;
     }
-    /**
-     * Determine if an update to the C2 domain blocklist is needed.
-     *
-     * @returns Whether an update is needed
-     */
-    isC2DomainBlocklistOutOfDate() {
-        return (fetchTimeNow() - this.state.c2DomainBlocklistLastFetched >=
-            __classPrivateFieldGet(this, _PhishingController_c2DomainBlocklistRefreshInterval, "f"));
+    // If the origin was blocked by a path, then we only want to add it to the whitelistPaths since
+    // other paths with the same hostname may not be blocked.
+    const blockingPath = __classPrivateFieldGet(
+      this,
+      _PhishingController_detector,
+      "f"
+    ).blockingPath(origin);
+    if (blockingPath) {
+      this.update((draftState) => {
+        insertToTrie(blockingPath, draftState.whitelistPaths);
+      });
+      return;
     }
-    /**
-     * Conditionally update the phishing configuration.
-     *
-     * If the stalelist configuration is out of date, this function will call `updateStalelist`
-     * to update the configuration. This will automatically grab the hotlist,
-     * so it isn't necessary to continue on to download the hotlist and the c2 domain blocklist.
-     *
-     */
-    async maybeUpdateState() {
-        const staleListOutOfDate = this.isStalelistOutOfDate();
-        if (staleListOutOfDate) {
-            await this.updateStalelist();
-            return;
-        }
-        const hotlistOutOfDate = this.isHotlistOutOfDate();
-        if (hotlistOutOfDate) {
-            await this.updateHotlist();
-        }
-        const c2DomainBlocklistOutOfDate = this.isC2DomainBlocklistOutOfDate();
-        if (c2DomainBlocklistOutOfDate) {
-            await this.updateC2DomainBlocklist();
-        }
+    this.update((draftState) => {
+      draftState.whitelist.push(hostname || punycodeOrigin);
+    });
+  }
+  /**
+   * Update the C2 domain blocklist.
+   *
+   * If an update is in progress, no additional update will be made. Instead this will wait until
+   * the in-progress update has finished.
+   */
+  async updateC2DomainBlocklist() {
+    if (
+      __classPrivateFieldGet(
+        this,
+        _PhishingController_isProgressC2DomainBlocklistUpdate,
+        "f"
+      )
+    ) {
+      await __classPrivateFieldGet(
+        this,
+        _PhishingController_isProgressC2DomainBlocklistUpdate,
+        "f"
+      );
+      return;
     }
-    /**
-     * Determines if a given origin is unapproved.
-     *
-     * It is strongly recommended that you call {@link maybeUpdateState} before calling this,
-     * to check whether the phishing configuration is up-to-date. It will be updated if necessary
-     * by calling {@link updateStalelist} or {@link updateHotlist}.
-     *
-     * @param origin - Domain origin of a website.
-     * @returns Whether the origin is an unapproved origin.
-     */
-    test(origin) {
-        const punycodeOrigin = toASCII(origin);
-        const hostname = getHostnameFromUrl(punycodeOrigin);
-        if (this.state.whitelist.includes(hostname || punycodeOrigin)) {
-            return { result: false, type: PhishingDetectorResultType.All }; // Same as whitelisted match returned by detector.check(...).
-        }
-        return __classPrivateFieldGet(this, _PhishingController_detector, "f").check(punycodeOrigin);
+    try {
+      __classPrivateFieldSet(
+        this,
+        _PhishingController_isProgressC2DomainBlocklistUpdate,
+        __classPrivateFieldGet(
+          this,
+          _PhishingController_instances,
+          "m",
+          _PhishingController_updateC2DomainBlocklist
+        ).call(this),
+        "f"
+      );
+      await __classPrivateFieldGet(
+        this,
+        _PhishingController_isProgressC2DomainBlocklistUpdate,
+        "f"
+      );
+    } finally {
+      __classPrivateFieldSet(
+        this,
+        _PhishingController_isProgressC2DomainBlocklistUpdate,
+        undefined,
+        "f"
+      );
     }
-    /**
-     * Checks if a request URL's domain is blocked against the request blocklist.
-     *
-     * This method is used to determine if a specific request URL is associated with a malicious
-     * command and control (C2) domain. The URL's hostname is hashed and checked against a configured
-     * blocklist of known malicious domains.
-     *
-     * @param origin - The full request URL to be checked.
-     * @returns An object indicating whether the URL's domain is blocked and relevant metadata.
-     */
-    isBlockedRequest(origin) {
-        const punycodeOrigin = toASCII(origin);
-        const hostname = getHostnameFromUrl(punycodeOrigin);
-        if (this.state.whitelist.includes(hostname || punycodeOrigin)) {
-            return { result: false, type: PhishingDetectorResultType.All }; // Same as whitelisted match returned by detector.check(...).
-        }
-        return __classPrivateFieldGet(this, _PhishingController_detector, "f").isMaliciousC2Domain(punycodeOrigin);
+  }
+  /**
+   * Update the hotlist.
+   *
+   * If an update is in progress, no additional update will be made. Instead this will wait until
+   * the in-progress update has finished.
+   */
+  async updateHotlist() {
+    if (
+      __classPrivateFieldGet(
+        this,
+        _PhishingController_inProgressHotlistUpdate,
+        "f"
+      )
+    ) {
+      await __classPrivateFieldGet(
+        this,
+        _PhishingController_inProgressHotlistUpdate,
+        "f"
+      );
+      return;
     }
-    /**
-     * Temporarily marks a given origin as approved.
-     *
-     * @param origin - The origin to mark as approved.
-     */
-    bypass(origin) {
-        const punycodeOrigin = toASCII(origin);
-        const hostname = getHostnameFromUrl(punycodeOrigin);
-        const { whitelist } = this.state;
-        if (whitelist.includes(hostname || punycodeOrigin)) {
-            return;
-        }
-        this.update((draftState) => {
-            draftState.whitelist.push(hostname || punycodeOrigin);
-        });
+    try {
+      __classPrivateFieldSet(
+        this,
+        _PhishingController_inProgressHotlistUpdate,
+        __classPrivateFieldGet(
+          this,
+          _PhishingController_instances,
+          "m",
+          _PhishingController_updateHotlist
+        ).call(this),
+        "f"
+      );
+      await __classPrivateFieldGet(
+        this,
+        _PhishingController_inProgressHotlistUpdate,
+        "f"
+      );
+    } finally {
+      __classPrivateFieldSet(
+        this,
+        _PhishingController_inProgressHotlistUpdate,
+        undefined,
+        "f"
+      );
     }
-    /**
-     * Update the C2 domain blocklist.
-     *
-     * If an update is in progress, no additional update will be made. Instead this will wait until
-     * the in-progress update has finished.
-     */
-    async updateC2DomainBlocklist() {
-        if (__classPrivateFieldGet(this, _PhishingController_isProgressC2DomainBlocklistUpdate, "f")) {
-            await __classPrivateFieldGet(this, _PhishingController_isProgressC2DomainBlocklistUpdate, "f");
-            return;
-        }
-        try {
-            __classPrivateFieldSet(this, _PhishingController_isProgressC2DomainBlocklistUpdate, __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_updateC2DomainBlocklist).call(this), "f");
-            await __classPrivateFieldGet(this, _PhishingController_isProgressC2DomainBlocklistUpdate, "f");
-        }
-        finally {
-            __classPrivateFieldSet(this, _PhishingController_isProgressC2DomainBlocklistUpdate, undefined, "f");
-        }
+  }
+  /**
+   * Update the stalelist.
+   *
+   * If an update is in progress, no additional update will be made. Instead this will wait until
+   * the in-progress update has finished.
+   */
+  async updateStalelist() {
+    if (
+      __classPrivateFieldGet(
+        this,
+        _PhishingController_inProgressStalelistUpdate,
+        "f"
+      )
+    ) {
+      await __classPrivateFieldGet(
+        this,
+        _PhishingController_inProgressStalelistUpdate,
+        "f"
+      );
+      return;
     }
-    /**
-     * Update the hotlist.
-     *
-     * If an update is in progress, no additional update will be made. Instead this will wait until
-     * the in-progress update has finished.
-     */
-    async updateHotlist() {
-        if (__classPrivateFieldGet(this, _PhishingController_inProgressHotlistUpdate, "f")) {
-            await __classPrivateFieldGet(this, _PhishingController_inProgressHotlistUpdate, "f");
-            return;
-        }
-        try {
-            __classPrivateFieldSet(this, _PhishingController_inProgressHotlistUpdate, __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_updateHotlist).call(this), "f");
-            await __classPrivateFieldGet(this, _PhishingController_inProgressHotlistUpdate, "f");
-        }
-        finally {
-            __classPrivateFieldSet(this, _PhishingController_inProgressHotlistUpdate, undefined, "f");
-        }
+    try {
+      __classPrivateFieldSet(
+        this,
+        _PhishingController_inProgressStalelistUpdate,
+        __classPrivateFieldGet(
+          this,
+          _PhishingController_instances,
+          "m",
+          _PhishingController_updateStalelist
+        ).call(this),
+        "f"
+      );
+      await __classPrivateFieldGet(
+        this,
+        _PhishingController_inProgressStalelistUpdate,
+        "f"
+      );
+    } finally {
+      __classPrivateFieldSet(
+        this,
+        _PhishingController_inProgressStalelistUpdate,
+        undefined,
+        "f"
+      );
     }
+  }
+}
+(_PhishingController_detector = new WeakMap()),
+  (_PhishingController_stalelistRefreshInterval = new WeakMap()),
+  (_PhishingController_hotlistRefreshInterval = new WeakMap()),
+  (_PhishingController_c2DomainBlocklistRefreshInterval = new WeakMap()),
+  (_PhishingController_urlScanCache = new WeakMap()),
+  (_PhishingController_inProgressHotlistUpdate = new WeakMap()),
+  (_PhishingController_inProgressStalelistUpdate = new WeakMap()),
+  (_PhishingController_isProgressC2DomainBlocklistUpdate = new WeakMap()),
+  (_PhishingController_processBatch = new WeakMap()),
+  (_PhishingController_instances = new WeakSet()),
+  (_PhishingController_registerMessageHandlers =
+    function _PhishingController_registerMessageHandlers() {
+      this.messagingSystem.registerActionHandler(
+        `${controllerName}:maybeUpdateState`,
+        this.maybeUpdateState.bind(this)
+      );
+      this.messagingSystem.registerActionHandler(
+        `${controllerName}:testOrigin`,
+        this.test.bind(this)
+      );
+      this.messagingSystem.registerActionHandler(
+        `${controllerName}:bulkScanUrls`,
+        this.bulkScanUrls.bind(this)
+      );
+    }),
+  (_PhishingController_updateStalelist =
     /**
-     * Update the stalelist.
+     * Update the stalelist configuration.
      *
-     * If an update is in progress, no additional update will be made. Instead this will wait until
-     * the in-progress update has finished.
+     * This should only be called from the `updateStalelist` function, which is a wrapper around
+     * this function that prevents redundant configuration updates.
      */
-    async updateStalelist() {
-        if (__classPrivateFieldGet(this, _PhishingController_inProgressStalelistUpdate, "f")) {
-            await __classPrivateFieldGet(this, _PhishingController_inProgressStalelistUpdate, "f");
-            return;
-        }
-        try {
-            __classPrivateFieldSet(this, _PhishingController_inProgressStalelistUpdate, __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_updateStalelist).call(this), "f");
-            await __classPrivateFieldGet(this, _PhishingController_inProgressStalelistUpdate, "f");
-        }
-        finally {
-            __classPrivateFieldSet(this, _PhishingController_inProgressStalelistUpdate, undefined, "f");
-        }
-    }
-}
-_PhishingController_detector = new WeakMap(), _PhishingController_stalelistRefreshInterval = new WeakMap(), _PhishingController_hotlistRefreshInterval = new WeakMap(), _PhishingController_c2DomainBlocklistRefreshInterval = new WeakMap(), _PhishingController_urlScanCache = new WeakMap(), _PhishingController_inProgressHotlistUpdate = new WeakMap(), _PhishingController_inProgressStalelistUpdate = new WeakMap(), _PhishingController_isProgressC2DomainBlocklistUpdate = new WeakMap(), _PhishingController_processBatch = new WeakMap(), _PhishingController_instances = new WeakSet(), _PhishingController_registerMessageHandlers = function _PhishingController_registerMessageHandlers() {
-    this.messagingSystem.registerActionHandler(`${controllerName}:maybeUpdateState`, this.maybeUpdateState.bind(this));
-    this.messagingSystem.registerActionHandler(`${controllerName}:testOrigin`, this.test.bind(this));
-    this.messagingSystem.registerActionHandler(`${controllerName}:bulkScanUrls`, this.bulkScanUrls.bind(this));
-}, _PhishingController_updateStalelist = 
-/**
- * Update the stalelist configuration.
- *
- * This should only be called from the `updateStalelist` function, which is a wrapper around
- * this function that prevents redundant configuration updates.
- */
-async function _PhishingController_updateStalelist() {
-    let stalelistResponse = null;
-    let hotlistDiffsResponse = null;
-    let c2DomainBlocklistResponse = null;
-    try {
-        const stalelistPromise = __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_queryConfig).call(this, METAMASK_STALELIST_URL);
-        const c2DomainBlocklistPromise = __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_queryConfig).call(this, C2_DOMAIN_BLOCKLIST_URL);
+    async function _PhishingController_updateStalelist() {
+      let stalelistResponse = null;
+      let hotlistDiffsResponse = null;
+      let c2DomainBlocklistResponse = null;
+      try {
+        const stalelistPromise = __classPrivateFieldGet(
+          this,
+          _PhishingController_instances,
+          "m",
+          _PhishingController_queryConfig
+        ).call(this, METAMASK_STALELIST_URL);
+        const c2DomainBlocklistPromise = __classPrivateFieldGet(
+          this,
+          _PhishingController_instances,
+          "m",
+          _PhishingController_queryConfig
+        ).call(this, C2_DOMAIN_BLOCKLIST_URL);
         [stalelistResponse, c2DomainBlocklistResponse] = await Promise.all([
-            stalelistPromise,
-            c2DomainBlocklistPromise,
+          stalelistPromise,
+          c2DomainBlocklistPromise,
         ]);
         // Fetching hotlist diffs relies on having a lastUpdated timestamp to do `GET /v1/diffsSince/:timestamp`,
         // so it doesn't make sense to call if there is not a timestamp to begin with.
         if (stalelistResponse?.data && stalelistResponse.data.lastUpdated > 0) {
-            hotlistDiffsResponse = await __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_queryConfig).call(this, `${METAMASK_HOTLIST_DIFF_URL}/${stalelistResponse.data.lastUpdated}`);
+          hotlistDiffsResponse = await __classPrivateFieldGet(
+            this,
+            _PhishingController_instances,
+            "m",
+            _PhishingController_queryConfig
+          ).call(
+            this,
+            `${METAMASK_HOTLIST_DIFF_URL}/${stalelistResponse.data.lastUpdated}`
+          );
         }
-    }
-    finally {
+      } finally {
         // Set `stalelistLastFetched` and `hotlistLastFetched` even for failed requests to prevent server
         // from being overwhelmed with traffic after a network disruption.
         const timeNow = fetchTimeNow();
         this.update((draftState) => {
-            draftState.stalelistLastFetched = timeNow;
-            draftState.hotlistLastFetched = timeNow;
-            draftState.c2DomainBlocklistLastFetched = timeNow;
+          draftState.stalelistLastFetched = timeNow;
+          draftState.hotlistLastFetched = timeNow;
+          draftState.c2DomainBlocklistLastFetched = timeNow;
         });
-    }
-    if (!stalelistResponse || !hotlistDiffsResponse) {
+      }
+      if (!stalelistResponse || !hotlistDiffsResponse) {
         return;
-    }
-    // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-    const { eth_phishing_detect_config, ...partialState } = stalelistResponse.data;
-    const metamaskListState = {
-        ...eth_phishing_detect_config,
-        ...partialState,
+      }
+      const metamaskListState = {
+        allowlist: stalelistResponse.data.allowlist,
+        fuzzylist: stalelistResponse.data.fuzzylist,
+        tolerance: stalelistResponse.data.tolerance,
+        version: stalelistResponse.data.version,
+        lastUpdated: stalelistResponse.data.lastUpdated,
+        blocklist: stalelistResponse.data.blocklist,
+        blocklistPaths: convertListToTrie(
+          stalelistResponse.data.blocklistPaths
+        ),
         c2DomainBlocklist: c2DomainBlocklistResponse
-            ? c2DomainBlocklistResponse.recentlyAdded
-            : [],
+          ? c2DomainBlocklistResponse.recentlyAdded
+          : [],
         name: phishingListKeyNameMap.eth_phishing_detect_config,
-    };
-    const newMetaMaskListState = applyDiffs(metamaskListState, hotlistDiffsResponse.data, ListKeys.EthPhishingDetectConfig);
-    this.update((draftState) => {
+      };
+      const newMetaMaskListState = applyDiffs(
+        metamaskListState,
+        hotlistDiffsResponse.data,
+        ListKeys.EthPhishingDetectConfig
+      );
+      this.update((draftState) => {
         draftState.phishingLists = [newMetaMaskListState];
-    });
-    this.updatePhishingDetector();
-}, _PhishingController_updateHotlist = 
-/**
- * Update the stalelist configuration.
- *
- * This should only be called from the `updateStalelist` function, which is a wrapper around
- * this function that prevents redundant configuration updates.
- */
-async function _PhishingController_updateHotlist() {
-    let hotlistResponse;
-    try {
+      });
+      this.updatePhishingDetector();
+    }),
+  (_PhishingController_updateHotlist =
+    /**
+     * Update the stalelist configuration.
+     *
+     * This should only be called from the `updateStalelist` function, which is a wrapper around
+     * this function that prevents redundant configuration updates.
+     */
+    async function _PhishingController_updateHotlist() {
+      let hotlistResponse;
+      try {
         if (this.state.phishingLists.length === 0) {
-            return;
+          return;
         }
-        const lastDiffTimestamp = Math.max(...this.state.phishingLists.map(({ lastUpdated }) => lastUpdated));
-        hotlistResponse = await __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_queryConfig).call(this, `${METAMASK_HOTLIST_DIFF_URL}/${lastDiffTimestamp}`);
-    }
-    finally {
+        const lastDiffTimestamp = Math.max(
+          ...this.state.phishingLists.map(({ lastUpdated }) => lastUpdated)
+        );
+        hotlistResponse = await __classPrivateFieldGet(
+          this,
+          _PhishingController_instances,
+          "m",
+          _PhishingController_queryConfig
+        ).call(this, `${METAMASK_HOTLIST_DIFF_URL}/${lastDiffTimestamp}`);
+      } finally {
         // Set `hotlistLastFetched` even for failed requests to prevent server from being overwhelmed with
         // traffic after a network disruption.
         this.update((draftState) => {
-            draftState.hotlistLastFetched = fetchTimeNow();
+          draftState.hotlistLastFetched = fetchTimeNow();
         });
-    }
-    if (!hotlistResponse?.data) {
+      }
+      if (!hotlistResponse?.data) {
         return;
-    }
-    const hotlist = hotlistResponse.data;
-    const newPhishingLists = this.state.phishingLists.map((phishingList) => {
-        const updatedList = applyDiffs(phishingList, hotlist, phishingListNameKeyMap[phishingList.name], [], []);
+      }
+      const hotlist = hotlistResponse.data;
+      const newPhishingLists = this.state.phishingLists.map((phishingList) => {
+        const updatedList = applyDiffs(
+          phishingList,
+          hotlist,
+          phishingListNameKeyMap[phishingList.name],
+          [],
+          []
+        );
         return updatedList;
-    });
-    this.update((draftState) => {
+      });
+      this.update((draftState) => {
         draftState.phishingLists = newPhishingLists;
-    });
-    this.updatePhishingDetector();
-}, _PhishingController_updateC2DomainBlocklist = 
-/**
- * Update the C2 domain blocklist.
- *
- * This should only be called from the `updateC2DomainBlocklist` function, which is a wrapper around
- * this function that prevents redundant configuration updates.
- */
-async function _PhishingController_updateC2DomainBlocklist() {
-    let c2DomainBlocklistResponse = null;
-    try {
-        c2DomainBlocklistResponse =
-            await __classPrivateFieldGet(this, _PhishingController_instances, "m", _PhishingController_queryConfig).call(this, `${C2_DOMAIN_BLOCKLIST_URL}?timestamp=${roundToNearestMinute(this.state.c2DomainBlocklistLastFetched)}`);
-    }
-    finally {
+      });
+      this.updatePhishingDetector();
+    }),
+  (_PhishingController_updateC2DomainBlocklist =
+    /**
+     * Update the C2 domain blocklist.
+     *
+     * This should only be called from the `updateC2DomainBlocklist` function, which is a wrapper around
+     * this function that prevents redundant configuration updates.
+     */
+    async function _PhishingController_updateC2DomainBlocklist() {
+      let c2DomainBlocklistResponse = null;
+      try {
+        c2DomainBlocklistResponse = await __classPrivateFieldGet(
+          this,
+          _PhishingController_instances,
+          "m",
+          _PhishingController_queryConfig
+        ).call(
+          this,
+          `${C2_DOMAIN_BLOCKLIST_URL}?timestamp=${roundToNearestMinute(
+            this.state.c2DomainBlocklistLastFetched
+          )}`
+        );
+      } finally {
         // Set `c2DomainBlocklistLastFetched` even for failed requests to prevent server from being overwhelmed with
         // traffic after a network disruption.
         this.update((draftState) => {
-            draftState.c2DomainBlocklistLastFetched = fetchTimeNow();
+          draftState.c2DomainBlocklistLastFetched = fetchTimeNow();
         });
-    }
-    if (!c2DomainBlocklistResponse) {
+      }
+      if (!c2DomainBlocklistResponse) {
         return;
-    }
-    const recentlyAddedC2Domains = c2DomainBlocklistResponse.recentlyAdded;
-    const recentlyRemovedC2Domains = c2DomainBlocklistResponse.recentlyRemoved;
-    const newPhishingLists = this.state.phishingLists.map((phishingList) => {
-        const updatedList = applyDiffs(phishingList, [], phishingListNameKeyMap[phishingList.name], recentlyAddedC2Domains, recentlyRemovedC2Domains);
+      }
+      const recentlyAddedC2Domains = c2DomainBlocklistResponse.recentlyAdded;
+      const recentlyRemovedC2Domains =
+        c2DomainBlocklistResponse.recentlyRemoved;
+      const newPhishingLists = this.state.phishingLists.map((phishingList) => {
+        const updatedList = applyDiffs(
+          phishingList,
+          [],
+          phishingListNameKeyMap[phishingList.name],
+          recentlyAddedC2Domains,
+          recentlyRemovedC2Domains
+        );
         return updatedList;
-    });
-    this.update((draftState) => {
+      });
+      this.update((draftState) => {
         draftState.phishingLists = newPhishingLists;
-    });
-    this.updatePhishingDetector();
-}, _PhishingController_queryConfig = async function _PhishingController_queryConfig(input) {
-    const response = await safelyExecute(() => fetch(input, { cache: 'no-cache' }), true);
-    switch (response?.status) {
+      });
+      this.updatePhishingDetector();
+    }),
+  (_PhishingController_queryConfig =
+    async function _PhishingController_queryConfig(input) {
+      const response = await safelyExecute(
+        () => fetch(input, { cache: "no-cache" }),
+        true
+      );
+      switch (response?.status) {
         case 200: {
-            return await response.json();
+          return await response.json();
         }
         default: {
-            return null;
+          return null;
         }
-    }
-};
+      }
+    });
 export default PhishingController;
 //# sourceMappingURL=PhishingController.mjs.map
diff --git a/dist/PhishingDetector.cjs b/dist/PhishingDetector.cjs
index ef3873125d6a7884e5365abfda6e01fdbea98140..e87cfc46aa7163efd04018e79f3a7c315320e288 100644
--- a/dist/PhishingDetector.cjs
+++ b/dist/PhishingDetector.cjs
@@ -1,244 +1,357 @@
 "use strict";
-var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+var __classPrivateFieldSet =
+  (this && this.__classPrivateFieldSet) ||
+  function (receiver, state, value, kind, f) {
     if (kind === "m") throw new TypeError("Private method is not writable");
-    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
-    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
-    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
-};
-var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
-    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
-    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
-    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
-};
-var _PhishingDetector_instances, _PhishingDetector_configs, _PhishingDetector_legacyConfig, _PhishingDetector_check;
+    if (kind === "a" && !f)
+      throw new TypeError("Private accessor was defined without a setter");
+    if (
+      typeof state === "function"
+        ? receiver !== state || !f
+        : !state.has(receiver)
+    )
+      throw new TypeError(
+        "Cannot write private member to an object whose class did not declare it"
+      );
+    return (
+      kind === "a"
+        ? f.call(receiver, value)
+        : f
+        ? (f.value = value)
+        : state.set(receiver, value),
+      value
+    );
+  };
+var __classPrivateFieldGet =
+  (this && this.__classPrivateFieldGet) ||
+  function (receiver, state, kind, f) {
+    if (kind === "a" && !f)
+      throw new TypeError("Private accessor was defined without a getter");
+    if (
+      typeof state === "function"
+        ? receiver !== state || !f
+        : !state.has(receiver)
+    )
+      throw new TypeError(
+        "Cannot read private member from an object whose class did not declare it"
+      );
+    return kind === "m"
+      ? f
+      : kind === "a"
+      ? f.call(receiver)
+      : f
+      ? f.value
+      : state.get(receiver);
+  };
+var _PhishingDetector_instances,
+  _PhishingDetector_configs,
+  _PhishingDetector_legacyConfig,
+  _PhishingDetector_check;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.PhishingDetector = void 0;
 const fastest_levenshtein_1 = require("fastest-levenshtein");
 const types_1 = require("./types.cjs");
 const utils_1 = require("./utils.cjs");
 class PhishingDetector {
-    /**
-     * Construct a phishing detector, which can check whether origins are known
-     * to be malicious or similar to common phishing targets.
-     *
-     * A list of configurations is accepted. Each origin checked is processed
-     * using each configuration in sequence, so the order defines which
-     * configurations take precedence.
-     *
-     * @param opts - Phishing detection options
-     */
-    constructor(opts) {
-        _PhishingDetector_instances.add(this);
-        _PhishingDetector_configs.set(this, void 0);
-        _PhishingDetector_legacyConfig.set(this, void 0);
-        // recommended configuration
-        if (Array.isArray(opts)) {
-            __classPrivateFieldSet(this, _PhishingDetector_configs, (0, utils_1.processConfigs)(opts), "f");
-            __classPrivateFieldSet(this, _PhishingDetector_legacyConfig, false, "f");
-            // legacy configuration
-        }
-        else {
-            __classPrivateFieldSet(this, _PhishingDetector_configs, [
-                (0, utils_1.getDefaultPhishingDetectorConfig)({
-                    allowlist: opts.whitelist,
-                    blocklist: opts.blacklist,
-                    c2DomainBlocklist: opts.c2DomainBlocklist,
-                    fuzzylist: opts.fuzzylist,
-                    tolerance: opts.tolerance,
-                }),
-            ], "f");
-            __classPrivateFieldSet(this, _PhishingDetector_legacyConfig, true, "f");
-        }
+  /**
+   * Construct a phishing detector, which can check whether origins are known
+   * to be malicious or similar to common phishing targets.
+   *
+   * A list of configurations is accepted. Each origin checked is processed
+   * using each configuration in sequence, so the order defines which
+   * configurations take precedence.
+   *
+   * @param opts - Phishing detection options
+   */
+  constructor(opts) {
+    _PhishingDetector_instances.add(this);
+    _PhishingDetector_configs.set(this, void 0);
+    _PhishingDetector_legacyConfig.set(this, void 0);
+    // recommended configuration
+    if (Array.isArray(opts)) {
+      __classPrivateFieldSet(
+        this,
+        _PhishingDetector_configs,
+        (0, utils_1.processConfigs)(opts),
+        "f"
+      );
+      __classPrivateFieldSet(this, _PhishingDetector_legacyConfig, false, "f");
+      // legacy configuration
+    } else {
+      __classPrivateFieldSet(
+        this,
+        _PhishingDetector_configs,
+        [
+          (0, utils_1.getDefaultPhishingDetectorConfig)({
+            allowlist: opts.whitelist,
+            blocklist: opts.blacklist,
+            fuzzylist: opts.fuzzylist,
+            tolerance: opts.tolerance,
+          }),
+        ],
+        "f"
+      );
+      __classPrivateFieldSet(this, _PhishingDetector_legacyConfig, true, "f");
     }
-    /**
-     * Check if a url is known to be malicious or similar to a common phishing
-     * target. This will check the hostname and IPFS CID that is sometimes
-     * located in the path.
-     *
-     * @param url - The url to check.
-     * @returns The result of the check.
-     */
-    check(url) {
-        const result = __classPrivateFieldGet(this, _PhishingDetector_instances, "m", _PhishingDetector_check).call(this, url);
-        if (__classPrivateFieldGet(this, _PhishingDetector_legacyConfig, "f")) {
-            let legacyType = result.type;
-            if (legacyType === types_1.PhishingDetectorResultType.Allowlist) {
-                legacyType = types_1.PhishingDetectorResultType.Whitelist;
-            }
-            else if (legacyType === types_1.PhishingDetectorResultType.Blocklist) {
-                legacyType = types_1.PhishingDetectorResultType.Blacklist;
-            }
-            return {
-                match: result.match,
-                result: result.result,
-                type: legacyType,
-            };
-        }
-        return result;
+  }
+  /**
+   * Check if a url is known to be malicious or similar to a common phishing
+   * target. This will check the hostname and IPFS CID that is sometimes
+   * located in the path.
+   *
+   * @param url - The url to check.
+   * @returns The result of the check.
+   */
+  check(url) {
+    const result = __classPrivateFieldGet(
+      this,
+      _PhishingDetector_instances,
+      "m",
+      _PhishingDetector_check
+    ).call(this, url);
+    if (__classPrivateFieldGet(this, _PhishingDetector_legacyConfig, "f")) {
+      let legacyType = result.type;
+      if (legacyType === types_1.PhishingDetectorResultType.Allowlist) {
+        legacyType = types_1.PhishingDetectorResultType.Whitelist;
+      } else if (legacyType === types_1.PhishingDetectorResultType.Blocklist) {
+        legacyType = types_1.PhishingDetectorResultType.Blacklist;
+      }
+      return {
+        match: result.match,
+        result: result.result,
+        type: legacyType,
+      };
     }
-    /**
-     * Checks if a URL is blocked against the hashed request blocklist.
-     * This is done by hashing the URL's hostname and checking it against the hashed request blocklist.
-     *
-     *
-     * @param urlString - The URL to check.
-     * @returns An object indicating if the URL is blocked and relevant metadata.
-     */
-    isMaliciousC2Domain(urlString) {
-        const hostname = (0, utils_1.getHostnameFromUrl)(urlString);
-        if (!hostname) {
-            return {
-                result: false,
-                type: types_1.PhishingDetectorResultType.C2DomainBlocklist,
-            };
-        }
-        const fqdn = hostname.endsWith('.') ? hostname.slice(0, -1) : hostname;
-        const sourceParts = (0, utils_1.domainToParts)(fqdn);
-        for (const { allowlist, name, version } of __classPrivateFieldGet(this, _PhishingDetector_configs, "f")) {
-            // if source matches allowlist hostname (or subdomain thereof), PASS
-            const allowlistMatch = (0, utils_1.matchPartsAgainstList)(sourceParts, allowlist);
-            if (allowlistMatch) {
-                const match = (0, utils_1.domainPartsToDomain)(allowlistMatch);
-                return {
-                    match,
-                    name,
-                    result: false,
-                    type: types_1.PhishingDetectorResultType.Allowlist,
-                    version: version === undefined ? version : String(version),
-                };
-            }
-        }
-        const hostnameHash = (0, utils_1.sha256Hash)(hostname.toLowerCase());
-        const domainsToCheck = (0, utils_1.generateParentDomains)(sourceParts.reverse(), 5);
-        for (const { c2DomainBlocklist, name, version } of __classPrivateFieldGet(this, _PhishingDetector_configs, "f")) {
-            if (!c2DomainBlocklist || c2DomainBlocklist.length === 0) {
-                continue;
-            }
-            if (c2DomainBlocklist.includes(hostnameHash)) {
-                return {
-                    name,
-                    result: true,
-                    type: types_1.PhishingDetectorResultType.C2DomainBlocklist,
-                    version: version === undefined ? version : String(version),
-                };
-            }
-            for (const domain of domainsToCheck) {
-                const domainHash = (0, utils_1.sha256Hash)(domain);
-                if (c2DomainBlocklist.includes(domainHash)) {
-                    return {
-                        name,
-                        result: true,
-                        type: types_1.PhishingDetectorResultType.C2DomainBlocklist,
-                        version: version === undefined ? version : String(version),
-                    };
-                }
-            }
-        }
-        // did not match, PASS
+    return result;
+  }
+  /**
+   * Gets the specific terminal path from blocklistPaths that is blocking a URL.
+   *
+   * @param url - The URL to check.
+   * @returns The terminal path that is blocking the URL, or null if not blocked.
+   */
+  blockingPath(url) {
+    for (const { blocklistPaths } of __classPrivateFieldGet(
+      this,
+      _PhishingDetector_configs,
+      "f"
+    )) {
+      if (!blocklistPaths || Object.keys(blocklistPaths).length === 0) {
+        continue;
+      }
+      const matchedPath = (0, PathTrie_1.matchedPathPrefix)(
+        url,
+        blocklistPaths
+      );
+      if (matchedPath) {
+        return matchedPath;
+      }
+    }
+    return null;
+  }
+  /**
+   * Checks if a URL is blocked against the hashed request blocklist.
+   * This is done by hashing the URL's hostname and checking it against the hashed request blocklist.
+   *
+   *
+   * @param urlString - The URL to check.
+   * @returns An object indicating if the URL is blocked and relevant metadata.
+   */
+  isMaliciousC2Domain(urlString) {
+    const hostname = (0, utils_1.getHostnameFromUrl)(urlString);
+    if (!hostname) {
+      return {
+        result: false,
+        type: types_1.PhishingDetectorResultType.C2DomainBlocklist,
+      };
+    }
+    const fqdn = hostname.endsWith(".") ? hostname.slice(0, -1) : hostname;
+    const sourceParts = (0, utils_1.domainToParts)(fqdn);
+    for (const { allowlist, name, version } of __classPrivateFieldGet(
+      this,
+      _PhishingDetector_configs,
+      "f"
+    )) {
+      // if source matches allowlist hostname (or subdomain thereof), PASS
+      const allowlistMatch = (0, utils_1.matchPartsAgainstList)(
+        sourceParts,
+        allowlist
+      );
+      if (allowlistMatch) {
+        const match = (0, utils_1.domainPartsToDomain)(allowlistMatch);
         return {
-            result: false,
-            type: types_1.PhishingDetectorResultType.C2DomainBlocklist,
+          match,
+          name,
+          result: false,
+          type: types_1.PhishingDetectorResultType.Allowlist,
+          version: version === undefined ? version : String(version),
         };
+      }
     }
+    const hostnameHash = (0, utils_1.sha256Hash)(hostname.toLowerCase());
+    const domainsToCheck = (0, utils_1.generateParentDomains)(
+      sourceParts.reverse(),
+      5
+    );
+    for (const { c2DomainBlocklist, name, version } of __classPrivateFieldGet(
+      this,
+      _PhishingDetector_configs,
+      "f"
+    )) {
+      if (!c2DomainBlocklist || c2DomainBlocklist.length === 0) {
+        continue;
+      }
+      if (c2DomainBlocklist.includes(hostnameHash)) {
+        return {
+          name,
+          result: true,
+          type: types_1.PhishingDetectorResultType.C2DomainBlocklist,
+          version: version === undefined ? version : String(version),
+        };
+      }
+      for (const domain of domainsToCheck) {
+        const domainHash = (0, utils_1.sha256Hash)(domain);
+        if (c2DomainBlocklist.includes(domainHash)) {
+          return {
+            name,
+            result: true,
+            type: types_1.PhishingDetectorResultType.C2DomainBlocklist,
+            version: version === undefined ? version : String(version),
+          };
+        }
+      }
+    }
+    // did not match, PASS
+    return {
+      result: false,
+      type: types_1.PhishingDetectorResultType.C2DomainBlocklist,
+    };
+  }
 }
 exports.PhishingDetector = PhishingDetector;
-_PhishingDetector_configs = new WeakMap(), _PhishingDetector_legacyConfig = new WeakMap(), _PhishingDetector_instances = new WeakSet(), _PhishingDetector_check = function _PhishingDetector_check(url) {
+(_PhishingDetector_configs = new WeakMap()),
+  (_PhishingDetector_legacyConfig = new WeakMap()),
+  (_PhishingDetector_instances = new WeakSet()),
+  (_PhishingDetector_check = function _PhishingDetector_check(url) {
     const ipfsCidMatch = url.match(ipfsCidRegex());
     // Check for IPFS CID related blocklist entries
     if (ipfsCidMatch !== null) {
-        // there is a cID string somewhere
-        // Determine if any of the entries are ipfs cids
-        // Depending on the gateway, the CID is in the path OR a subdomain, so we do a regex match on it all
-        const cID = ipfsCidMatch[0];
-        for (const { blocklist, name, version } of __classPrivateFieldGet(this, _PhishingDetector_configs, "f")) {
-            const blocklistMatch = blocklist
-                .filter((entries) => entries.length === 1)
-                .find((entries) => {
-                return entries[0] === cID;
-            });
-            if (blocklistMatch) {
-                return {
-                    name,
-                    match: cID,
-                    result: true,
-                    type: types_1.PhishingDetectorResultType.Blocklist,
-                    version: version === undefined ? version : String(version),
-                };
-            }
+      // there is a cID string somewhere
+      // Determine if any of the entries are ipfs cids
+      // Depending on the gateway, the CID is in the path OR a subdomain, so we do a regex match on it all
+      const cID = ipfsCidMatch[0];
+      for (const { blocklist, name, version } of __classPrivateFieldGet(
+        this,
+        _PhishingDetector_configs,
+        "f"
+      )) {
+        const blocklistMatch = blocklist
+          .filter((entries) => entries.length === 1)
+          .find((entries) => {
+            return entries[0] === cID;
+          });
+        if (blocklistMatch) {
+          return {
+            name,
+            match: cID,
+            result: true,
+            type: types_1.PhishingDetectorResultType.Blocklist,
+            version: version === undefined ? version : String(version),
+          };
         }
+      }
     }
     let domain;
     try {
-        domain = new URL(url).hostname;
+      domain = new URL(url).hostname;
+    } catch (error) {
+      return {
+        result: false,
+        type: types_1.PhishingDetectorResultType.All,
+      };
     }
-    catch (error) {
+    const fqdn = domain.endsWith(".") ? domain.slice(0, -1) : domain;
+    const source = (0, utils_1.domainToParts)(fqdn);
+    for (const { allowlist, name, version } of __classPrivateFieldGet(
+      this,
+      _PhishingDetector_configs,
+      "f"
+    )) {
+      // if source matches allowlist hostname (or subdomain thereof), PASS
+      const allowlistMatch = (0, utils_1.matchPartsAgainstList)(
+        source,
+        allowlist
+      );
+      if (allowlistMatch) {
+        const match = (0, utils_1.domainPartsToDomain)(allowlistMatch);
         return {
-            result: false,
-            type: types_1.PhishingDetectorResultType.All,
+          match,
+          name,
+          result: false,
+          type: types_1.PhishingDetectorResultType.Allowlist,
+          version: version === undefined ? version : String(version),
         };
+      }
     }
-    const fqdn = domain.endsWith('.') ? domain.slice(0, -1) : domain;
-    const source = (0, utils_1.domainToParts)(fqdn);
-    for (const { allowlist, name, version } of __classPrivateFieldGet(this, _PhishingDetector_configs, "f")) {
-        // if source matches allowlist hostname (or subdomain thereof), PASS
-        const allowlistMatch = (0, utils_1.matchPartsAgainstList)(source, allowlist);
-        if (allowlistMatch) {
-            const match = (0, utils_1.domainPartsToDomain)(allowlistMatch);
-            return {
-                match,
-                name,
-                result: false,
-                type: types_1.PhishingDetectorResultType.Allowlist,
-                version: version === undefined ? version : String(version),
-            };
-        }
-    }
-    for (const { blocklist, fuzzylist, name, tolerance, version } of __classPrivateFieldGet(this, _PhishingDetector_configs, "f")) {
-        // if source matches blocklist hostname (or subdomain thereof), FAIL
-        const blocklistMatch = (0, utils_1.matchPartsAgainstList)(source, blocklist);
-        if (blocklistMatch) {
-            const match = (0, utils_1.domainPartsToDomain)(blocklistMatch);
-            return {
-                match,
-                name,
-                result: true,
-                type: types_1.PhishingDetectorResultType.Blocklist,
-                version: version === undefined ? version : String(version),
-            };
-        }
-        if (tolerance > 0) {
-            // check if near-match of whitelist domain, FAIL
-            let fuzzyForm = (0, utils_1.domainPartsToFuzzyForm)(source);
-            // strip www
-            fuzzyForm = fuzzyForm.replace(/^www\./u, '');
-            // check against fuzzylist
-            const levenshteinMatched = fuzzylist.find((targetParts) => {
-                const fuzzyTarget = (0, utils_1.domainPartsToFuzzyForm)(targetParts);
-                const dist = (0, fastest_levenshtein_1.distance)(fuzzyForm, fuzzyTarget);
-                return dist <= tolerance;
-            });
-            if (levenshteinMatched) {
-                const match = (0, utils_1.domainPartsToDomain)(levenshteinMatched);
-                return {
-                    name,
-                    match,
-                    result: true,
-                    type: types_1.PhishingDetectorResultType.Fuzzy,
-                    version: version === undefined ? version : String(version),
-                };
-            }
+    for (const {
+      blocklist,
+      fuzzylist,
+      name,
+      tolerance,
+      version,
+    } of __classPrivateFieldGet(this, _PhishingDetector_configs, "f")) {
+      // if source matches blocklist hostname (or subdomain thereof), FAIL
+      const blocklistMatch = (0, utils_1.matchPartsAgainstList)(
+        source,
+        blocklist
+      );
+      if (blocklistMatch) {
+        const match = (0, utils_1.domainPartsToDomain)(blocklistMatch);
+        return {
+          match,
+          name,
+          result: true,
+          type: types_1.PhishingDetectorResultType.Blocklist,
+          version: version === undefined ? version : String(version),
+        };
+      }
+      if (tolerance > 0) {
+        // check if near-match of whitelist domain, FAIL
+        let fuzzyForm = (0, utils_1.domainPartsToFuzzyForm)(source);
+        // strip www
+        fuzzyForm = fuzzyForm.replace(/^www\./u, "");
+        // check against fuzzylist
+        const levenshteinMatched = fuzzylist.find((targetParts) => {
+          const fuzzyTarget = (0, utils_1.domainPartsToFuzzyForm)(targetParts);
+          const dist = (0, fastest_levenshtein_1.distance)(
+            fuzzyForm,
+            fuzzyTarget
+          );
+          return dist <= tolerance;
+        });
+        if (levenshteinMatched) {
+          const match = (0, utils_1.domainPartsToDomain)(levenshteinMatched);
+          return {
+            name,
+            match,
+            result: true,
+            type: types_1.PhishingDetectorResultType.Fuzzy,
+            version: version === undefined ? version : String(version),
+          };
         }
+      }
     }
     // matched nothing, PASS
     return { result: false, type: types_1.PhishingDetectorResultType.All };
-};
+  });
 /**
  * Runs a regex match to determine if a string is a IPFS CID
  * @returns Regex string for IPFS CID
  */
 function ipfsCidRegex() {
-    // regex from https://stackoverflow.com/a/67176726
-    const reg = 'Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,}';
-    return new RegExp(reg, 'u');
+  // regex from https://stackoverflow.com/a/67176726
+  const reg =
+    "Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,}";
+  return new RegExp(reg, "u");
 }
 //# sourceMappingURL=PhishingDetector.cjs.map
diff --git a/dist/PhishingDetector.mjs b/dist/PhishingDetector.mjs
index 3421038a19779ae403ebdd6ece83917cdc3f75f0..a7f2fea35a4f1c879a5151823d62e85070f9c396 100644
--- a/dist/PhishingDetector.mjs
+++ b/dist/PhishingDetector.mjs
@@ -1,240 +1,345 @@
-var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+var __classPrivateFieldSet =
+  (this && this.__classPrivateFieldSet) ||
+  function (receiver, state, value, kind, f) {
     if (kind === "m") throw new TypeError("Private method is not writable");
-    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
-    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
-    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
-};
-var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
-    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
-    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
-    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
-};
-var _PhishingDetector_instances, _PhishingDetector_configs, _PhishingDetector_legacyConfig, _PhishingDetector_check;
+    if (kind === "a" && !f)
+      throw new TypeError("Private accessor was defined without a setter");
+    if (
+      typeof state === "function"
+        ? receiver !== state || !f
+        : !state.has(receiver)
+    )
+      throw new TypeError(
+        "Cannot write private member to an object whose class did not declare it"
+      );
+    return (
+      kind === "a"
+        ? f.call(receiver, value)
+        : f
+        ? (f.value = value)
+        : state.set(receiver, value),
+      value
+    );
+  };
+var __classPrivateFieldGet =
+  (this && this.__classPrivateFieldGet) ||
+  function (receiver, state, kind, f) {
+    if (kind === "a" && !f)
+      throw new TypeError("Private accessor was defined without a getter");
+    if (
+      typeof state === "function"
+        ? receiver !== state || !f
+        : !state.has(receiver)
+    )
+      throw new TypeError(
+        "Cannot read private member from an object whose class did not declare it"
+      );
+    return kind === "m"
+      ? f
+      : kind === "a"
+      ? f.call(receiver)
+      : f
+      ? f.value
+      : state.get(receiver);
+  };
+var _PhishingDetector_instances,
+  _PhishingDetector_configs,
+  _PhishingDetector_legacyConfig,
+  _PhishingDetector_check;
 import { distance } from "fastest-levenshtein";
 import { PhishingDetectorResultType } from "./types.mjs";
-import { domainPartsToDomain, domainPartsToFuzzyForm, domainToParts, generateParentDomains, getDefaultPhishingDetectorConfig, getHostnameFromUrl, matchPartsAgainstList, processConfigs, sha256Hash } from "./utils.mjs";
+import {
+  domainPartsToDomain,
+  domainPartsToFuzzyForm,
+  domainToParts,
+  generateParentDomains,
+  getDefaultPhishingDetectorConfig,
+  getHostnameFromUrl,
+  matchPartsAgainstList,
+  processConfigs,
+  sha256Hash,
+} from "./utils.mjs";
 export class PhishingDetector {
-    /**
-     * Construct a phishing detector, which can check whether origins are known
-     * to be malicious or similar to common phishing targets.
-     *
-     * A list of configurations is accepted. Each origin checked is processed
-     * using each configuration in sequence, so the order defines which
-     * configurations take precedence.
-     *
-     * @param opts - Phishing detection options
-     */
-    constructor(opts) {
-        _PhishingDetector_instances.add(this);
-        _PhishingDetector_configs.set(this, void 0);
-        _PhishingDetector_legacyConfig.set(this, void 0);
-        // recommended configuration
-        if (Array.isArray(opts)) {
-            __classPrivateFieldSet(this, _PhishingDetector_configs, processConfigs(opts), "f");
-            __classPrivateFieldSet(this, _PhishingDetector_legacyConfig, false, "f");
-            // legacy configuration
-        }
-        else {
-            __classPrivateFieldSet(this, _PhishingDetector_configs, [
-                getDefaultPhishingDetectorConfig({
-                    allowlist: opts.whitelist,
-                    blocklist: opts.blacklist,
-                    c2DomainBlocklist: opts.c2DomainBlocklist,
-                    fuzzylist: opts.fuzzylist,
-                    tolerance: opts.tolerance,
-                }),
-            ], "f");
-            __classPrivateFieldSet(this, _PhishingDetector_legacyConfig, true, "f");
-        }
+  /**
+   * Construct a phishing detector, which can check whether origins are known
+   * to be malicious or similar to common phishing targets.
+   *
+   * A list of configurations is accepted. Each origin checked is processed
+   * using each configuration in sequence, so the order defines which
+   * configurations take precedence.
+   *
+   * @param opts - Phishing detection options
+   */
+  constructor(opts) {
+    _PhishingDetector_instances.add(this);
+    _PhishingDetector_configs.set(this, void 0);
+    _PhishingDetector_legacyConfig.set(this, void 0);
+    // recommended configuration
+    if (Array.isArray(opts)) {
+      __classPrivateFieldSet(
+        this,
+        _PhishingDetector_configs,
+        processConfigs(opts),
+        "f"
+      );
+      __classPrivateFieldSet(this, _PhishingDetector_legacyConfig, false, "f");
+      // legacy configuration
+    } else {
+      __classPrivateFieldSet(
+        this,
+        _PhishingDetector_configs,
+        [
+          getDefaultPhishingDetectorConfig({
+            allowlist: opts.whitelist,
+            blocklist: opts.blacklist,
+            fuzzylist: opts.fuzzylist,
+            tolerance: opts.tolerance,
+          }),
+        ],
+        "f"
+      );
+      __classPrivateFieldSet(this, _PhishingDetector_legacyConfig, true, "f");
     }
-    /**
-     * Check if a url is known to be malicious or similar to a common phishing
-     * target. This will check the hostname and IPFS CID that is sometimes
-     * located in the path.
-     *
-     * @param url - The url to check.
-     * @returns The result of the check.
-     */
-    check(url) {
-        const result = __classPrivateFieldGet(this, _PhishingDetector_instances, "m", _PhishingDetector_check).call(this, url);
-        if (__classPrivateFieldGet(this, _PhishingDetector_legacyConfig, "f")) {
-            let legacyType = result.type;
-            if (legacyType === PhishingDetectorResultType.Allowlist) {
-                legacyType = PhishingDetectorResultType.Whitelist;
-            }
-            else if (legacyType === PhishingDetectorResultType.Blocklist) {
-                legacyType = PhishingDetectorResultType.Blacklist;
-            }
-            return {
-                match: result.match,
-                result: result.result,
-                type: legacyType,
-            };
-        }
-        return result;
+  }
+  /**
+   * Check if a url is known to be malicious or similar to a common phishing
+   * target. This will check the hostname and IPFS CID that is sometimes
+   * located in the path.
+   *
+   * @param url - The url to check.
+   * @returns The result of the check.
+   */
+  check(url) {
+    const result = __classPrivateFieldGet(
+      this,
+      _PhishingDetector_instances,
+      "m",
+      _PhishingDetector_check
+    ).call(this, url);
+    if (__classPrivateFieldGet(this, _PhishingDetector_legacyConfig, "f")) {
+      let legacyType = result.type;
+      if (legacyType === PhishingDetectorResultType.Allowlist) {
+        legacyType = PhishingDetectorResultType.Whitelist;
+      } else if (legacyType === PhishingDetectorResultType.Blocklist) {
+        legacyType = PhishingDetectorResultType.Blacklist;
+      }
+      return {
+        match: result.match,
+        result: result.result,
+        type: legacyType,
+      };
     }
-    /**
-     * Checks if a URL is blocked against the hashed request blocklist.
-     * This is done by hashing the URL's hostname and checking it against the hashed request blocklist.
-     *
-     *
-     * @param urlString - The URL to check.
-     * @returns An object indicating if the URL is blocked and relevant metadata.
-     */
-    isMaliciousC2Domain(urlString) {
-        const hostname = getHostnameFromUrl(urlString);
-        if (!hostname) {
-            return {
-                result: false,
-                type: PhishingDetectorResultType.C2DomainBlocklist,
-            };
-        }
-        const fqdn = hostname.endsWith('.') ? hostname.slice(0, -1) : hostname;
-        const sourceParts = domainToParts(fqdn);
-        for (const { allowlist, name, version } of __classPrivateFieldGet(this, _PhishingDetector_configs, "f")) {
-            // if source matches allowlist hostname (or subdomain thereof), PASS
-            const allowlistMatch = matchPartsAgainstList(sourceParts, allowlist);
-            if (allowlistMatch) {
-                const match = domainPartsToDomain(allowlistMatch);
-                return {
-                    match,
-                    name,
-                    result: false,
-                    type: PhishingDetectorResultType.Allowlist,
-                    version: version === undefined ? version : String(version),
-                };
-            }
-        }
-        const hostnameHash = sha256Hash(hostname.toLowerCase());
-        const domainsToCheck = generateParentDomains(sourceParts.reverse(), 5);
-        for (const { c2DomainBlocklist, name, version } of __classPrivateFieldGet(this, _PhishingDetector_configs, "f")) {
-            if (!c2DomainBlocklist || c2DomainBlocklist.length === 0) {
-                continue;
-            }
-            if (c2DomainBlocklist.includes(hostnameHash)) {
-                return {
-                    name,
-                    result: true,
-                    type: PhishingDetectorResultType.C2DomainBlocklist,
-                    version: version === undefined ? version : String(version),
-                };
-            }
-            for (const domain of domainsToCheck) {
-                const domainHash = sha256Hash(domain);
-                if (c2DomainBlocklist.includes(domainHash)) {
-                    return {
-                        name,
-                        result: true,
-                        type: PhishingDetectorResultType.C2DomainBlocklist,
-                        version: version === undefined ? version : String(version),
-                    };
-                }
-            }
-        }
-        // did not match, PASS
+    return result;
+  }
+  /**
+   * Gets the specific terminal path from blocklistPaths that is blocking a URL.
+   *
+   * @param url - The URL to check.
+   * @returns The terminal path that is blocking the URL, or null if not blocked.
+   */
+  blockingPath(url) {
+    for (const { blocklistPaths } of __classPrivateFieldGet(
+      this,
+      _PhishingDetector_configs,
+      "f"
+    )) {
+      if (!blocklistPaths || Object.keys(blocklistPaths).length === 0) {
+        continue;
+      }
+      const matchedPath = matchedPathPrefix(url, blocklistPaths);
+      if (matchedPath) {
+        return matchedPath;
+      }
+    }
+    return null;
+  }
+  /**
+   * Checks if a URL is blocked against the hashed request blocklist.
+   * This is done by hashing the URL's hostname and checking it against the hashed request blocklist.
+   *
+   *
+   * @param urlString - The URL to check.
+   * @returns An object indicating if the URL is blocked and relevant metadata.
+   */
+  isMaliciousC2Domain(urlString) {
+    const hostname = getHostnameFromUrl(urlString);
+    if (!hostname) {
+      return {
+        result: false,
+        type: PhishingDetectorResultType.C2DomainBlocklist,
+      };
+    }
+    const fqdn = hostname.endsWith(".") ? hostname.slice(0, -1) : hostname;
+    const sourceParts = domainToParts(fqdn);
+    for (const { allowlist, name, version } of __classPrivateFieldGet(
+      this,
+      _PhishingDetector_configs,
+      "f"
+    )) {
+      // if source matches allowlist hostname (or subdomain thereof), PASS
+      const allowlistMatch = matchPartsAgainstList(sourceParts, allowlist);
+      if (allowlistMatch) {
+        const match = domainPartsToDomain(allowlistMatch);
         return {
-            result: false,
-            type: PhishingDetectorResultType.C2DomainBlocklist,
+          match,
+          name,
+          result: false,
+          type: PhishingDetectorResultType.Allowlist,
+          version: version === undefined ? version : String(version),
         };
+      }
     }
+    const hostnameHash = sha256Hash(hostname.toLowerCase());
+    const domainsToCheck = generateParentDomains(sourceParts.reverse(), 5);
+    for (const { c2DomainBlocklist, name, version } of __classPrivateFieldGet(
+      this,
+      _PhishingDetector_configs,
+      "f"
+    )) {
+      if (!c2DomainBlocklist || c2DomainBlocklist.length === 0) {
+        continue;
+      }
+      if (c2DomainBlocklist.includes(hostnameHash)) {
+        return {
+          name,
+          result: true,
+          type: PhishingDetectorResultType.C2DomainBlocklist,
+          version: version === undefined ? version : String(version),
+        };
+      }
+      for (const domain of domainsToCheck) {
+        const domainHash = sha256Hash(domain);
+        if (c2DomainBlocklist.includes(domainHash)) {
+          return {
+            name,
+            result: true,
+            type: PhishingDetectorResultType.C2DomainBlocklist,
+            version: version === undefined ? version : String(version),
+          };
+        }
+      }
+    }
+    // did not match, PASS
+    return {
+      result: false,
+      type: PhishingDetectorResultType.C2DomainBlocklist,
+    };
+  }
 }
-_PhishingDetector_configs = new WeakMap(), _PhishingDetector_legacyConfig = new WeakMap(), _PhishingDetector_instances = new WeakSet(), _PhishingDetector_check = function _PhishingDetector_check(url) {
+(_PhishingDetector_configs = new WeakMap()),
+  (_PhishingDetector_legacyConfig = new WeakMap()),
+  (_PhishingDetector_instances = new WeakSet()),
+  (_PhishingDetector_check = function _PhishingDetector_check(url) {
     const ipfsCidMatch = url.match(ipfsCidRegex());
     // Check for IPFS CID related blocklist entries
     if (ipfsCidMatch !== null) {
-        // there is a cID string somewhere
-        // Determine if any of the entries are ipfs cids
-        // Depending on the gateway, the CID is in the path OR a subdomain, so we do a regex match on it all
-        const cID = ipfsCidMatch[0];
-        for (const { blocklist, name, version } of __classPrivateFieldGet(this, _PhishingDetector_configs, "f")) {
-            const blocklistMatch = blocklist
-                .filter((entries) => entries.length === 1)
-                .find((entries) => {
-                return entries[0] === cID;
-            });
-            if (blocklistMatch) {
-                return {
-                    name,
-                    match: cID,
-                    result: true,
-                    type: PhishingDetectorResultType.Blocklist,
-                    version: version === undefined ? version : String(version),
-                };
-            }
+      // there is a cID string somewhere
+      // Determine if any of the entries are ipfs cids
+      // Depending on the gateway, the CID is in the path OR a subdomain, so we do a regex match on it all
+      const cID = ipfsCidMatch[0];
+      for (const { blocklist, name, version } of __classPrivateFieldGet(
+        this,
+        _PhishingDetector_configs,
+        "f"
+      )) {
+        const blocklistMatch = blocklist
+          .filter((entries) => entries.length === 1)
+          .find((entries) => {
+            return entries[0] === cID;
+          });
+        if (blocklistMatch) {
+          return {
+            name,
+            match: cID,
+            result: true,
+            type: PhishingDetectorResultType.Blocklist,
+            version: version === undefined ? version : String(version),
+          };
         }
+      }
     }
     let domain;
     try {
-        domain = new URL(url).hostname;
+      domain = new URL(url).hostname;
+    } catch (error) {
+      return {
+        result: false,
+        type: PhishingDetectorResultType.All,
+      };
     }
-    catch (error) {
+    const fqdn = domain.endsWith(".") ? domain.slice(0, -1) : domain;
+    const source = domainToParts(fqdn);
+    for (const { allowlist, name, version } of __classPrivateFieldGet(
+      this,
+      _PhishingDetector_configs,
+      "f"
+    )) {
+      // if source matches allowlist hostname (or subdomain thereof), PASS
+      const allowlistMatch = matchPartsAgainstList(source, allowlist);
+      if (allowlistMatch) {
+        const match = domainPartsToDomain(allowlistMatch);
         return {
-            result: false,
-            type: PhishingDetectorResultType.All,
+          match,
+          name,
+          result: false,
+          type: PhishingDetectorResultType.Allowlist,
+          version: version === undefined ? version : String(version),
         };
+      }
     }
-    const fqdn = domain.endsWith('.') ? domain.slice(0, -1) : domain;
-    const source = domainToParts(fqdn);
-    for (const { allowlist, name, version } of __classPrivateFieldGet(this, _PhishingDetector_configs, "f")) {
-        // if source matches allowlist hostname (or subdomain thereof), PASS
-        const allowlistMatch = matchPartsAgainstList(source, allowlist);
-        if (allowlistMatch) {
-            const match = domainPartsToDomain(allowlistMatch);
-            return {
-                match,
-                name,
-                result: false,
-                type: PhishingDetectorResultType.Allowlist,
-                version: version === undefined ? version : String(version),
-            };
-        }
-    }
-    for (const { blocklist, fuzzylist, name, tolerance, version } of __classPrivateFieldGet(this, _PhishingDetector_configs, "f")) {
-        // if source matches blocklist hostname (or subdomain thereof), FAIL
-        const blocklistMatch = matchPartsAgainstList(source, blocklist);
-        if (blocklistMatch) {
-            const match = domainPartsToDomain(blocklistMatch);
-            return {
-                match,
-                name,
-                result: true,
-                type: PhishingDetectorResultType.Blocklist,
-                version: version === undefined ? version : String(version),
-            };
-        }
-        if (tolerance > 0) {
-            // check if near-match of whitelist domain, FAIL
-            let fuzzyForm = domainPartsToFuzzyForm(source);
-            // strip www
-            fuzzyForm = fuzzyForm.replace(/^www\./u, '');
-            // check against fuzzylist
-            const levenshteinMatched = fuzzylist.find((targetParts) => {
-                const fuzzyTarget = domainPartsToFuzzyForm(targetParts);
-                const dist = distance(fuzzyForm, fuzzyTarget);
-                return dist <= tolerance;
-            });
-            if (levenshteinMatched) {
-                const match = domainPartsToDomain(levenshteinMatched);
-                return {
-                    name,
-                    match,
-                    result: true,
-                    type: PhishingDetectorResultType.Fuzzy,
-                    version: version === undefined ? version : String(version),
-                };
-            }
+    for (const {
+      blocklist,
+      fuzzylist,
+      name,
+      tolerance,
+      version,
+    } of __classPrivateFieldGet(this, _PhishingDetector_configs, "f")) {
+      // if source matches blocklist hostname (or subdomain thereof), FAIL
+      const blocklistMatch = matchPartsAgainstList(source, blocklist);
+      if (blocklistMatch) {
+        const match = domainPartsToDomain(blocklistMatch);
+        return {
+          match,
+          name,
+          result: true,
+          type: PhishingDetectorResultType.Blocklist,
+          version: version === undefined ? version : String(version),
+        };
+      }
+      if (tolerance > 0) {
+        // check if near-match of whitelist domain, FAIL
+        let fuzzyForm = domainPartsToFuzzyForm(source);
+        // strip www
+        fuzzyForm = fuzzyForm.replace(/^www\./u, "");
+        // check against fuzzylist
+        const levenshteinMatched = fuzzylist.find((targetParts) => {
+          const fuzzyTarget = domainPartsToFuzzyForm(targetParts);
+          const dist = distance(fuzzyForm, fuzzyTarget);
+          return dist <= tolerance;
+        });
+        if (levenshteinMatched) {
+          const match = domainPartsToDomain(levenshteinMatched);
+          return {
+            name,
+            match,
+            result: true,
+            type: PhishingDetectorResultType.Fuzzy,
+            version: version === undefined ? version : String(version),
+          };
         }
+      }
     }
     // matched nothing, PASS
     return { result: false, type: PhishingDetectorResultType.All };
-};
+  });
 /**
  * Runs a regex match to determine if a string is a IPFS CID
  * @returns Regex string for IPFS CID
  */
 function ipfsCidRegex() {
-    // regex from https://stackoverflow.com/a/67176726
-    const reg = 'Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,}';
-    return new RegExp(reg, 'u');
+  // regex from https://stackoverflow.com/a/67176726
+  const reg =
+    "Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,}";
+  return new RegExp(reg, "u");
 }
 //# sourceMappingURL=PhishingDetector.mjs.map
diff --git a/dist/utils.cjs b/dist/utils.cjs
index aec18d0178cdd810d219695cbee9a6420b2ac75f..7bd08640c31d5edba8d7e0a22ff0f200bdeb172d 100644
--- a/dist/utils.cjs
+++ b/dist/utils.cjs
@@ -1,8 +1,26 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.generateParentDomains = exports.getHostnameFromWebUrl = exports.getHostnameFromUrl = exports.sha256Hash = exports.matchPartsAgainstList = exports.domainPartsToFuzzyForm = exports.domainPartsToDomain = exports.processConfigs = exports.getDefaultPhishingDetectorConfig = exports.processDomainList = exports.domainToParts = exports.validateConfig = exports.applyDiffs = exports.roundToNearestMinute = exports.fetchTimeNow = void 0;
+exports.generateParentDomains =
+  exports.getPathnameFromUrl =
+  exports.getHostnameFromWebUrl =
+  exports.getHostnameFromUrl =
+  exports.sha256Hash =
+  exports.matchPartsAgainstList =
+  exports.domainPartsToFuzzyForm =
+  exports.domainPartsToDomain =
+  exports.processConfigs =
+  exports.getDefaultPhishingDetectorConfig =
+  exports.processDomainList =
+  exports.domainToParts =
+  exports.validateConfig =
+  exports.applyDiffs =
+  exports.getHostnameAndPathComponents =
+  exports.roundToNearestMinute =
+  exports.fetchTimeNow =
+    void 0;
 const utils_1 = require("@noble/hashes/utils");
 const sha256_1 = require("ethereum-cryptography/sha256");
+const PathTrie_1 = require("./PathTrie.cjs");
 const PhishingController_1 = require("./PhishingController.cjs");
 const DEFAULT_TOLERANCE = 3;
 /**
@@ -19,7 +37,7 @@ exports.fetchTimeNow = fetchTimeNow;
  * @returns The rounded Unix timestamp.
  */
 function roundToNearestMinute(unixTimestamp) {
-    return Math.floor(unixTimestamp / 60) * 60;
+  return Math.floor(unixTimestamp / 60) * 60;
 }
 exports.roundToNearestMinute = roundToNearestMinute;
 /**
@@ -29,12 +47,31 @@ exports.roundToNearestMinute = roundToNearestMinute;
  * @returns An array of length two containing the beginning and end of the string.
  */
 const splitStringByPeriod = (stringToSplit) => {
-    const periodIndex = stringToSplit.indexOf('.');
-    return [
-        stringToSplit.slice(0, periodIndex),
-        stringToSplit.slice(periodIndex + 1),
-    ];
+  const periodIndex = stringToSplit.indexOf(".");
+  return [
+    stringToSplit.slice(0, periodIndex),
+    stringToSplit.slice(periodIndex + 1),
+  ];
 };
+const getHostnameAndPathComponents = (url) => {
+  const urlWithProtocol = url.startsWith("http") ? url : `https://${url}`;
+  try {
+    const { hostname, pathname } = new URL(urlWithProtocol);
+    return {
+      hostname: hostname.toLowerCase(),
+      pathComponents: pathname
+        .split("/")
+        .filter(Boolean)
+        .map((component) => decodeURIComponent(component)),
+    };
+  } catch {
+    return {
+      hostname: "",
+      pathComponents: [],
+    };
+  }
+};
+exports.getHostnameAndPathComponents = getHostnameAndPathComponents;
 /**
  * Determines which diffs are applicable to the listState, then applies those diffs.
  *
@@ -45,52 +82,73 @@ const splitStringByPeriod = (stringToSplit) => {
  * @param recentlyRemovedC2Domains - list of hashed C2 domains to remove from the local c2 domain blocklist
  * @returns the new list state
  */
-const applyDiffs = (listState, hotlistDiffs, listKey, recentlyAddedC2Domains = [], recentlyRemovedC2Domains = []) => {
-    // filter to remove diffs that were added before the lastUpdate time.
-    // filter to remove diffs that aren't applicable to the specified list (by listKey).
-    const diffsToApply = hotlistDiffs.filter(({ timestamp, targetList }) => timestamp > listState.lastUpdated &&
-        splitStringByPeriod(targetList)[0] === listKey);
-    // the reason behind using latestDiffTimestamp as the lastUpdated time
-    // is so that we can benefit server-side from memoization due to end client's
-    // `GET /v1/diffSince/:timestamp` requests lining up with
-    // our periodic updates (which create diffs at specific timestamps).
-    let latestDiffTimestamp = listState.lastUpdated;
-    const listSets = {
-        allowlist: new Set(listState.allowlist),
-        blocklist: new Set(listState.blocklist),
-        fuzzylist: new Set(listState.fuzzylist),
-        c2DomainBlocklist: new Set(listState.c2DomainBlocklist),
-    };
-    for (const { isRemoval, targetList, url, timestamp } of diffsToApply) {
-        const targetListType = splitStringByPeriod(targetList)[1];
-        if (timestamp > latestDiffTimestamp) {
-            latestDiffTimestamp = timestamp;
-        }
-        if (isRemoval) {
-            listSets[targetListType].delete(url);
-        }
-        else {
-            listSets[targetListType].add(url);
-        }
+const applyDiffs = (
+  listState,
+  hotlistDiffs,
+  listKey,
+  recentlyAddedC2Domains = [],
+  recentlyRemovedC2Domains = []
+) => {
+  // filter to remove diffs that were added before the lastUpdate time.
+  // filter to remove diffs that aren't applicable to the specified list (by listKey).
+  const diffsToApply = hotlistDiffs.filter(
+    ({ timestamp, targetList }) =>
+      timestamp > listState.lastUpdated &&
+      splitStringByPeriod(targetList)[0] === listKey
+  );
+  // the reason behind using latestDiffTimestamp as the lastUpdated time
+  // is so that we can benefit server-side from memoization due to end client's
+  // `GET /v1/diffSince/:timestamp` requests lining up with
+  // our periodic updates (which create diffs at specific timestamps).
+  let latestDiffTimestamp = listState.lastUpdated;
+  const listSets = {
+    allowlist: new Set(listState.allowlist),
+    blocklist: new Set(listState.blocklist),
+    fuzzylist: new Set(listState.fuzzylist),
+    c2DomainBlocklist: new Set(listState.c2DomainBlocklist),
+  };
+  // deep copy of blocklistPaths to avoid mutating the original
+  const newBlocklistPaths = (0, PathTrie_1.deepCopyPathTrie)(
+    listState.blocklistPaths
+  );
+  for (const { isRemoval, targetList, url, timestamp } of diffsToApply) {
+    const targetListType = splitStringByPeriod(targetList)[1];
+    if (timestamp > latestDiffTimestamp) {
+      latestDiffTimestamp = timestamp;
     }
-    if (listKey === PhishingController_1.ListKeys.EthPhishingDetectConfig) {
-        for (const hash of recentlyAddedC2Domains) {
-            listSets.c2DomainBlocklist.add(hash);
-        }
-        for (const hash of recentlyRemovedC2Domains) {
-            listSets.c2DomainBlocklist.delete(hash);
-        }
+    if (isRemoval) {
+      if (targetListType === "blocklistPaths") {
+        (0, PathTrie_1.deleteFromTrie)(url, newBlocklistPaths);
+      } else {
+        listSets[targetListType].delete(url);
+      }
+      continue;
     }
-    return {
-        c2DomainBlocklist: Array.from(listSets.c2DomainBlocklist),
-        allowlist: Array.from(listSets.allowlist),
-        blocklist: Array.from(listSets.blocklist),
-        fuzzylist: Array.from(listSets.fuzzylist),
-        version: listState.version,
-        name: PhishingController_1.phishingListKeyNameMap[listKey],
-        tolerance: listState.tolerance,
-        lastUpdated: latestDiffTimestamp,
-    };
+    if (targetListType === "blocklistPaths") {
+      (0, PathTrie_1.insertToTrie)(url, newBlocklistPaths);
+    } else {
+      listSets[targetListType].add(url);
+    }
+  }
+  if (listKey === PhishingController_1.ListKeys.EthPhishingDetectConfig) {
+    for (const hash of recentlyAddedC2Domains) {
+      listSets.c2DomainBlocklist.add(hash);
+    }
+    for (const hash of recentlyRemovedC2Domains) {
+      listSets.c2DomainBlocklist.delete(hash);
+    }
+  }
+  return {
+    c2DomainBlocklist: Array.from(listSets.c2DomainBlocklist),
+    allowlist: Array.from(listSets.allowlist),
+    blocklist: Array.from(listSets.blocklist),
+    fuzzylist: Array.from(listSets.fuzzylist),
+    blocklistPaths: newBlocklistPaths,
+    version: listState.version,
+    name: PhishingController_1.phishingListKeyNameMap[listKey],
+    tolerance: listState.tolerance,
+    lastUpdated: latestDiffTimestamp,
+  };
 };
 exports.applyDiffs = applyDiffs;
 /**
@@ -100,21 +158,25 @@ exports.applyDiffs = applyDiffs;
  * @throws an error if the configuration is invalid.
  */
 function validateConfig(config) {
-    if (config === null || typeof config !== 'object') {
-        throw new Error('Invalid config');
-    }
-    if ('tolerance' in config && !('fuzzylist' in config)) {
-        throw new Error('Fuzzylist tolerance provided without fuzzylist');
-    }
-    if ('name' in config &&
-        (typeof config.name !== 'string' || config.name === '')) {
-        throw new Error("Invalid config parameter: 'name'");
-    }
-    if ('version' in config &&
-        (!['number', 'string'].includes(typeof config.version) ||
-            config.version === '')) {
-        throw new Error("Invalid config parameter: 'version'");
-    }
+  if (config === null || typeof config !== "object") {
+    throw new Error("Invalid config");
+  }
+  if ("tolerance" in config && !("fuzzylist" in config)) {
+    throw new Error("Fuzzylist tolerance provided without fuzzylist");
+  }
+  if (
+    "name" in config &&
+    (typeof config.name !== "string" || config.name === "")
+  ) {
+    throw new Error("Invalid config parameter: 'name'");
+  }
+  if (
+    "version" in config &&
+    (!["number", "string"].includes(typeof config.version) ||
+      config.version === "")
+  ) {
+    throw new Error("Invalid config parameter: 'version'");
+  }
 }
 exports.validateConfig = validateConfig;
 /**
@@ -124,12 +186,11 @@ exports.validateConfig = validateConfig;
  * @returns the list of domain parts.
  */
 const domainToParts = (domain) => {
-    try {
-        return domain.split('.').reverse();
-    }
-    catch (e) {
-        throw new Error(JSON.stringify(domain));
-    }
+  try {
+    return domain.split(".").reverse();
+  } catch (e) {
+    throw new Error(JSON.stringify(domain));
+  }
 };
 exports.domainToParts = domainToParts;
 /**
@@ -139,7 +200,7 @@ exports.domainToParts = domainToParts;
  * @returns the list of domain parts.
  */
 const processDomainList = (list) => {
-    return list.map(exports.domainToParts);
+  return list.map(exports.domainToParts);
 };
 exports.processDomainList = processDomainList;
 /**
@@ -153,11 +214,16 @@ exports.processDomainList = processDomainList;
  * @param override.tolerance - the optional tolerance to override.
  * @returns the default phishing detector configuration.
  */
-const getDefaultPhishingDetectorConfig = ({ allowlist = [], blocklist = [], fuzzylist = [], tolerance = DEFAULT_TOLERANCE, }) => ({
-    allowlist: (0, exports.processDomainList)(allowlist),
-    blocklist: (0, exports.processDomainList)(blocklist),
-    fuzzylist: (0, exports.processDomainList)(fuzzylist),
-    tolerance,
+const getDefaultPhishingDetectorConfig = ({
+  allowlist = [],
+  blocklist = [],
+  fuzzylist = [],
+  tolerance = DEFAULT_TOLERANCE,
+}) => ({
+  allowlist: (0, exports.processDomainList)(allowlist),
+  blocklist: (0, exports.processDomainList)(blocklist),
+  fuzzylist: (0, exports.processDomainList)(fuzzylist),
+  tolerance,
 });
 exports.getDefaultPhishingDetectorConfig = getDefaultPhishingDetectorConfig;
 /**
@@ -167,20 +233,19 @@ exports.getDefaultPhishingDetectorConfig = getDefaultPhishingDetectorConfig;
  * @returns An array of processed and valid configurations.
  */
 const processConfigs = (configs = []) => {
-    return configs
-        .filter((config) => {
-        try {
-            validateConfig(config);
-            return true;
-        }
-        catch (error) {
-            console.error(error);
-            return false;
-        }
+  return configs
+    .filter((config) => {
+      try {
+        validateConfig(config);
+        return true;
+      } catch (error) {
+        console.error(error);
+        return false;
+      }
     })
-        .map((config) => ({
-        ...config,
-        ...(0, exports.getDefaultPhishingDetectorConfig)(config),
+    .map((config) => ({
+      ...config,
+      ...(0, exports.getDefaultPhishingDetectorConfig)(config),
     }));
 };
 exports.processConfigs = processConfigs;
@@ -191,7 +256,7 @@ exports.processConfigs = processConfigs;
  * @returns the domain string.
  */
 const domainPartsToDomain = (domainParts) => {
-    return domainParts.slice().reverse().join('.');
+  return domainParts.slice().reverse().join(".");
 };
 exports.domainPartsToDomain = domainPartsToDomain;
 /**
@@ -201,7 +266,7 @@ exports.domainPartsToDomain = domainPartsToDomain;
  * @returns the fuzzy form of the domain.
  */
 const domainPartsToFuzzyForm = (domainParts) => {
-    return domainParts.slice(1).reverse().join('.');
+  return domainParts.slice(1).reverse().join(".");
 };
 exports.domainPartsToFuzzyForm = domainPartsToFuzzyForm;
 /**
@@ -212,14 +277,14 @@ exports.domainPartsToFuzzyForm = domainPartsToFuzzyForm;
  * @returns the parts for the first found matching entry.
  */
 const matchPartsAgainstList = (source, list) => {
-    return list.find((target) => {
-        // target domain has more parts than source, fail
-        if (target.length > source.length) {
-            return false;
-        }
-        // source matches target or (is deeper subdomain)
-        return target.every((part, index) => source[index] === part);
-    });
+  return list.find((target) => {
+    // target domain has more parts than source, fail
+    if (target.length > source.length) {
+      return false;
+    }
+    // source matches target or (is deeper subdomain)
+    return target.every((part, index) => source[index] === part);
+  });
 };
 exports.matchPartsAgainstList = matchPartsAgainstList;
 /**
@@ -229,8 +294,10 @@ exports.matchPartsAgainstList = matchPartsAgainstList;
  * @returns The SHA-256 hash of the hostname.
  */
 const sha256Hash = (hostname) => {
-    const hashBuffer = (0, sha256_1.sha256)(new TextEncoder().encode(hostname.toLowerCase()));
-    return (0, utils_1.bytesToHex)(hashBuffer);
+  const hashBuffer = (0, sha256_1.sha256)(
+    new TextEncoder().encode(hostname.toLowerCase())
+  );
+  return (0, utils_1.bytesToHex)(hashBuffer);
 };
 exports.sha256Hash = sha256Hash;
 /**
@@ -240,18 +307,17 @@ exports.sha256Hash = sha256Hash;
  * @returns The hostname extracted from the URL, or null if the URL is invalid.
  */
 const getHostnameFromUrl = (url) => {
-    let hostname;
-    try {
-        hostname = new URL(url).hostname;
-        // above will not throw if 'http://.' is passed. in fact, any string with a dot will pass.
-        if (!hostname || hostname.split('.').join('') === '') {
-            return null;
-        }
-    }
-    catch {
-        return null;
+  let hostname;
+  try {
+    hostname = new URL(url).hostname;
+    // above will not throw if 'http://.' is passed. in fact, any string with a dot will pass.
+    if (!hostname || hostname.split(".").join("") === "") {
+      return null;
     }
-    return hostname;
+  } catch {
+    return null;
+  }
+  return hostname;
 };
 exports.getHostnameFromUrl = getHostnameFromUrl;
 /**
@@ -267,14 +333,25 @@ exports.getHostnameFromUrl = getHostnameFromUrl;
  * getHostnameFromWebUrl('') // Returns: ['', false]
  */
 const getHostnameFromWebUrl = (url) => {
-    if (!url.toLowerCase().startsWith('http://') &&
-        !url.toLowerCase().startsWith('https://')) {
-        return ['', false];
-    }
-    const hostname = (0, exports.getHostnameFromUrl)(url);
-    return [hostname || '', Boolean(hostname)];
+  if (
+    !url.toLowerCase().startsWith("http://") &&
+    !url.toLowerCase().startsWith("https://")
+  ) {
+    return ["", false];
+  }
+  const hostname = (0, exports.getHostnameFromUrl)(url);
+  return [hostname || "", Boolean(hostname)];
 };
 exports.getHostnameFromWebUrl = getHostnameFromWebUrl;
+const getPathnameFromUrl = (url) => {
+  try {
+    const { pathname } = new URL(url);
+    return pathname;
+  } catch {
+    return "";
+  }
+};
+exports.getPathnameFromUrl = getPathnameFromUrl;
 /**
  * Generates all possible parent domains up to a specified limit.
  *
@@ -292,25 +369,28 @@ exports.getHostnameFromWebUrl = getHostnameFromWebUrl;
  * // Returns: ['example.com', 'sub.example.com']
  */
 const generateParentDomains = (sourceParts, limit = 5) => {
-    const domains = [];
-    if (sourceParts.length === 0) {
-        return domains;
-    }
-    if (sourceParts.length === 1) {
-        // Single-segment hostname (e.g., 'uk')
-        domains.push(sourceParts[0].toLowerCase());
-    }
-    else {
-        // Start with the base domain or TLD (last two labels, e.g., 'co.uk' or 'example.com')
-        const baseDomain = sourceParts.slice(-2).join('.');
-        domains.push(baseDomain.toLowerCase());
-        // Iteratively add one subdomain level at a time, up to the specified limit
-        for (let i = sourceParts.length - 3; i >= 0 && domains.length < limit; i--) {
-            const domain = sourceParts.slice(i).join('.');
-            domains.push(domain.toLowerCase());
-        }
-    }
+  const domains = [];
+  if (sourceParts.length === 0) {
     return domains;
+  }
+  if (sourceParts.length === 1) {
+    // Single-segment hostname (e.g., 'uk')
+    domains.push(sourceParts[0].toLowerCase());
+  } else {
+    // Start with the base domain or TLD (last two labels, e.g., 'co.uk' or 'example.com')
+    const baseDomain = sourceParts.slice(-2).join(".");
+    domains.push(baseDomain.toLowerCase());
+    // Iteratively add one subdomain level at a time, up to the specified limit
+    for (
+      let i = sourceParts.length - 3;
+      i >= 0 && domains.length < limit;
+      i--
+    ) {
+      const domain = sourceParts.slice(i).join(".");
+      domains.push(domain.toLowerCase());
+    }
+  }
+  return domains;
 };
 exports.generateParentDomains = generateParentDomains;
 //# sourceMappingURL=utils.cjs.map
diff --git a/dist/utils.mjs b/dist/utils.mjs
index e6fdc66cac65ccc610c8a886081729e4b35e3fec..149066f03e4b88f8c851fe58d120dbd338e95eb5 100644
--- a/dist/utils.mjs
+++ b/dist/utils.mjs
@@ -1,5 +1,6 @@
 import { bytesToHex } from "@noble/hashes/utils";
 import { sha256 } from "ethereum-cryptography/sha256";
+import { deleteFromTrie, insertToTrie, deepCopyPathTrie } from "./PathTrie.mjs";
 import { ListKeys, phishingListKeyNameMap } from "./PhishingController.mjs";
 const DEFAULT_TOLERANCE = 3;
 /**
@@ -15,7 +16,7 @@ export const fetchTimeNow = () => Math.round(Date.now() / 1000);
  * @returns The rounded Unix timestamp.
  */
 export function roundToNearestMinute(unixTimestamp) {
-    return Math.floor(unixTimestamp / 60) * 60;
+  return Math.floor(unixTimestamp / 60) * 60;
 }
 /**
  * Split a string into two pieces, using the first period as the delimiter.
@@ -24,11 +25,29 @@ export function roundToNearestMinute(unixTimestamp) {
  * @returns An array of length two containing the beginning and end of the string.
  */
 const splitStringByPeriod = (stringToSplit) => {
-    const periodIndex = stringToSplit.indexOf('.');
-    return [
-        stringToSplit.slice(0, periodIndex),
-        stringToSplit.slice(periodIndex + 1),
-    ];
+  const periodIndex = stringToSplit.indexOf(".");
+  return [
+    stringToSplit.slice(0, periodIndex),
+    stringToSplit.slice(periodIndex + 1),
+  ];
+};
+export const getHostnameAndPathComponents = (url) => {
+  const urlWithProtocol = url.startsWith("http") ? url : `https://${url}`;
+  try {
+    const { hostname, pathname } = new URL(urlWithProtocol);
+    return {
+      hostname: hostname.toLowerCase(),
+      pathComponents: pathname
+        .split("/")
+        .filter(Boolean)
+        .map((component) => decodeURIComponent(component)),
+    };
+  } catch {
+    return {
+      hostname: "",
+      pathComponents: [],
+    };
+  }
 };
 /**
  * Determines which diffs are applicable to the listState, then applies those diffs.
@@ -40,52 +59,60 @@ const splitStringByPeriod = (stringToSplit) => {
  * @param recentlyRemovedC2Domains - list of hashed C2 domains to remove from the local c2 domain blocklist
  * @returns the new list state
  */
-export const applyDiffs = (listState, hotlistDiffs, listKey, recentlyAddedC2Domains = [], recentlyRemovedC2Domains = []) => {
-    // filter to remove diffs that were added before the lastUpdate time.
-    // filter to remove diffs that aren't applicable to the specified list (by listKey).
-    const diffsToApply = hotlistDiffs.filter(({ timestamp, targetList }) => timestamp > listState.lastUpdated &&
-        splitStringByPeriod(targetList)[0] === listKey);
-    // the reason behind using latestDiffTimestamp as the lastUpdated time
-    // is so that we can benefit server-side from memoization due to end client's
-    // `GET /v1/diffSince/:timestamp` requests lining up with
-    // our periodic updates (which create diffs at specific timestamps).
-    let latestDiffTimestamp = listState.lastUpdated;
-    const listSets = {
-        allowlist: new Set(listState.allowlist),
-        blocklist: new Set(listState.blocklist),
-        fuzzylist: new Set(listState.fuzzylist),
-        c2DomainBlocklist: new Set(listState.c2DomainBlocklist),
-    };
-    for (const { isRemoval, targetList, url, timestamp } of diffsToApply) {
-        const targetListType = splitStringByPeriod(targetList)[1];
-        if (timestamp > latestDiffTimestamp) {
-            latestDiffTimestamp = timestamp;
-        }
-        if (isRemoval) {
-            listSets[targetListType].delete(url);
-        }
-        else {
-            listSets[targetListType].add(url);
-        }
+export const applyDiffs = (
+  listState,
+  hotlistDiffs,
+  listKey,
+  recentlyAddedC2Domains = [],
+  recentlyRemovedC2Domains = []
+) => {
+  // filter to remove diffs that were added before the lastUpdate time.
+  // filter to remove diffs that aren't applicable to the specified list (by listKey).
+  const diffsToApply = hotlistDiffs.filter(
+    ({ timestamp, targetList }) =>
+      timestamp > listState.lastUpdated &&
+      splitStringByPeriod(targetList)[0] === listKey
+  );
+  // the reason behind using latestDiffTimestamp as the lastUpdated time
+  // is so that we can benefit server-side from memoization due to end client's
+  // `GET /v1/diffSince/:timestamp` requests lining up with
+  // our periodic updates (which create diffs at specific timestamps).
+  let latestDiffTimestamp = listState.lastUpdated;
+  const listSets = {
+    allowlist: new Set(listState.allowlist),
+    blocklist: new Set(listState.blocklist),
+    fuzzylist: new Set(listState.fuzzylist),
+    c2DomainBlocklist: new Set(listState.c2DomainBlocklist),
+  };
+  for (const { isRemoval, targetList, url, timestamp } of diffsToApply) {
+    const targetListType = splitStringByPeriod(targetList)[1];
+    if (timestamp > latestDiffTimestamp) {
+      latestDiffTimestamp = timestamp;
     }
-    if (listKey === ListKeys.EthPhishingDetectConfig) {
-        for (const hash of recentlyAddedC2Domains) {
-            listSets.c2DomainBlocklist.add(hash);
-        }
-        for (const hash of recentlyRemovedC2Domains) {
-            listSets.c2DomainBlocklist.delete(hash);
-        }
+    if (isRemoval) {
+      listSets[targetListType].delete(url);
+    } else {
+      listSets[targetListType].add(url);
     }
-    return {
-        c2DomainBlocklist: Array.from(listSets.c2DomainBlocklist),
-        allowlist: Array.from(listSets.allowlist),
-        blocklist: Array.from(listSets.blocklist),
-        fuzzylist: Array.from(listSets.fuzzylist),
-        version: listState.version,
-        name: phishingListKeyNameMap[listKey],
-        tolerance: listState.tolerance,
-        lastUpdated: latestDiffTimestamp,
-    };
+  }
+  if (listKey === ListKeys.EthPhishingDetectConfig) {
+    for (const hash of recentlyAddedC2Domains) {
+      listSets.c2DomainBlocklist.add(hash);
+    }
+    for (const hash of recentlyRemovedC2Domains) {
+      listSets.c2DomainBlocklist.delete(hash);
+    }
+  }
+  return {
+    c2DomainBlocklist: Array.from(listSets.c2DomainBlocklist),
+    allowlist: Array.from(listSets.allowlist),
+    blocklist: Array.from(listSets.blocklist),
+    fuzzylist: Array.from(listSets.fuzzylist),
+    version: listState.version,
+    name: phishingListKeyNameMap[listKey],
+    tolerance: listState.tolerance,
+    lastUpdated: latestDiffTimestamp,
+  };
 };
 /**
  * Validates the configuration object for the phishing detector.
@@ -94,21 +121,25 @@ export const applyDiffs = (listState, hotlistDiffs, listKey, recentlyAddedC2Doma
  * @throws an error if the configuration is invalid.
  */
 export function validateConfig(config) {
-    if (config === null || typeof config !== 'object') {
-        throw new Error('Invalid config');
-    }
-    if ('tolerance' in config && !('fuzzylist' in config)) {
-        throw new Error('Fuzzylist tolerance provided without fuzzylist');
-    }
-    if ('name' in config &&
-        (typeof config.name !== 'string' || config.name === '')) {
-        throw new Error("Invalid config parameter: 'name'");
-    }
-    if ('version' in config &&
-        (!['number', 'string'].includes(typeof config.version) ||
-            config.version === '')) {
-        throw new Error("Invalid config parameter: 'version'");
-    }
+  if (config === null || typeof config !== "object") {
+    throw new Error("Invalid config");
+  }
+  if ("tolerance" in config && !("fuzzylist" in config)) {
+    throw new Error("Fuzzylist tolerance provided without fuzzylist");
+  }
+  if (
+    "name" in config &&
+    (typeof config.name !== "string" || config.name === "")
+  ) {
+    throw new Error("Invalid config parameter: 'name'");
+  }
+  if (
+    "version" in config &&
+    (!["number", "string"].includes(typeof config.version) ||
+      config.version === "")
+  ) {
+    throw new Error("Invalid config parameter: 'version'");
+  }
 }
 /**
  * Converts a domain string to a list of domain parts.
@@ -117,12 +148,11 @@ export function validateConfig(config) {
  * @returns the list of domain parts.
  */
 export const domainToParts = (domain) => {
-    try {
-        return domain.split('.').reverse();
-    }
-    catch (e) {
-        throw new Error(JSON.stringify(domain));
-    }
+  try {
+    return domain.split(".").reverse();
+  } catch (e) {
+    throw new Error(JSON.stringify(domain));
+  }
 };
 /**
  * Converts a list of domain strings to a list of domain parts.
@@ -131,7 +161,7 @@ export const domainToParts = (domain) => {
  * @returns the list of domain parts.
  */
 export const processDomainList = (list) => {
-    return list.map(domainToParts);
+  return list.map(domainToParts);
 };
 /**
  * Gets the default phishing detector configuration.
@@ -144,11 +174,16 @@ export const processDomainList = (list) => {
  * @param override.tolerance - the optional tolerance to override.
  * @returns the default phishing detector configuration.
  */
-export const getDefaultPhishingDetectorConfig = ({ allowlist = [], blocklist = [], fuzzylist = [], tolerance = DEFAULT_TOLERANCE, }) => ({
-    allowlist: processDomainList(allowlist),
-    blocklist: processDomainList(blocklist),
-    fuzzylist: processDomainList(fuzzylist),
-    tolerance,
+export const getDefaultPhishingDetectorConfig = ({
+  allowlist = [],
+  blocklist = [],
+  fuzzylist = [],
+  tolerance = DEFAULT_TOLERANCE,
+}) => ({
+  allowlist: processDomainList(allowlist),
+  blocklist: processDomainList(blocklist),
+  fuzzylist: processDomainList(fuzzylist),
+  tolerance,
 });
 /**
  * Processes the configurations for the phishing detector, filtering out any invalid configs.
@@ -157,20 +192,19 @@ export const getDefaultPhishingDetectorConfig = ({ allowlist = [], blocklist = [
  * @returns An array of processed and valid configurations.
  */
 export const processConfigs = (configs = []) => {
-    return configs
-        .filter((config) => {
-        try {
-            validateConfig(config);
-            return true;
-        }
-        catch (error) {
-            console.error(error);
-            return false;
-        }
+  return configs
+    .filter((config) => {
+      try {
+        validateConfig(config);
+        return true;
+      } catch (error) {
+        console.error(error);
+        return false;
+      }
     })
-        .map((config) => ({
-        ...config,
-        ...getDefaultPhishingDetectorConfig(config),
+    .map((config) => ({
+      ...config,
+      ...getDefaultPhishingDetectorConfig(config),
     }));
 };
 /**
@@ -180,7 +214,7 @@ export const processConfigs = (configs = []) => {
  * @returns the domain string.
  */
 export const domainPartsToDomain = (domainParts) => {
-    return domainParts.slice().reverse().join('.');
+  return domainParts.slice().reverse().join(".");
 };
 /**
  * Converts a list of domain parts to a fuzzy form.
@@ -189,7 +223,7 @@ export const domainPartsToDomain = (domainParts) => {
  * @returns the fuzzy form of the domain.
  */
 export const domainPartsToFuzzyForm = (domainParts) => {
-    return domainParts.slice(1).reverse().join('.');
+  return domainParts.slice(1).reverse().join(".");
 };
 /**
  * Matches the target parts, ignoring extra subdomains on source.
@@ -199,14 +233,14 @@ export const domainPartsToFuzzyForm = (domainParts) => {
  * @returns the parts for the first found matching entry.
  */
 export const matchPartsAgainstList = (source, list) => {
-    return list.find((target) => {
-        // target domain has more parts than source, fail
-        if (target.length > source.length) {
-            return false;
-        }
-        // source matches target or (is deeper subdomain)
-        return target.every((part, index) => source[index] === part);
-    });
+  return list.find((target) => {
+    // target domain has more parts than source, fail
+    if (target.length > source.length) {
+      return false;
+    }
+    // source matches target or (is deeper subdomain)
+    return target.every((part, index) => source[index] === part);
+  });
 };
 /**
  * Generate the SHA-256 hash of a hostname.
@@ -215,8 +249,8 @@ export const matchPartsAgainstList = (source, list) => {
  * @returns The SHA-256 hash of the hostname.
  */
 export const sha256Hash = (hostname) => {
-    const hashBuffer = sha256(new TextEncoder().encode(hostname.toLowerCase()));
-    return bytesToHex(hashBuffer);
+  const hashBuffer = sha256(new TextEncoder().encode(hostname.toLowerCase()));
+  return bytesToHex(hashBuffer);
 };
 /**
  * Extracts the hostname from a URL.
@@ -225,18 +259,17 @@ export const sha256Hash = (hostname) => {
  * @returns The hostname extracted from the URL, or null if the URL is invalid.
  */
 export const getHostnameFromUrl = (url) => {
-    let hostname;
-    try {
-        hostname = new URL(url).hostname;
-        // above will not throw if 'http://.' is passed. in fact, any string with a dot will pass.
-        if (!hostname || hostname.split('.').join('') === '') {
-            return null;
-        }
-    }
-    catch {
-        return null;
+  let hostname;
+  try {
+    hostname = new URL(url).hostname;
+    // above will not throw if 'http://.' is passed. in fact, any string with a dot will pass.
+    if (!hostname || hostname.split(".").join("") === "") {
+      return null;
     }
-    return hostname;
+  } catch {
+    return null;
+  }
+  return hostname;
 };
 /**
  * getHostnameFromWebUrl returns the hostname from a web URL.
@@ -251,12 +284,22 @@ export const getHostnameFromUrl = (url) => {
  * getHostnameFromWebUrl('') // Returns: ['', false]
  */
 export const getHostnameFromWebUrl = (url) => {
-    if (!url.toLowerCase().startsWith('http://') &&
-        !url.toLowerCase().startsWith('https://')) {
-        return ['', false];
-    }
-    const hostname = getHostnameFromUrl(url);
-    return [hostname || '', Boolean(hostname)];
+  if (
+    !url.toLowerCase().startsWith("http://") &&
+    !url.toLowerCase().startsWith("https://")
+  ) {
+    return ["", false];
+  }
+  const hostname = getHostnameFromUrl(url);
+  return [hostname || "", Boolean(hostname)];
+};
+export const getPathnameFromUrl = (url) => {
+  try {
+    const { pathname } = new URL(url);
+    return pathname;
+  } catch {
+    return "";
+  }
 };
 /**
  * Generates all possible parent domains up to a specified limit.
@@ -275,24 +318,27 @@ export const getHostnameFromWebUrl = (url) => {
  * // Returns: ['example.com', 'sub.example.com']
  */
 export const generateParentDomains = (sourceParts, limit = 5) => {
-    const domains = [];
-    if (sourceParts.length === 0) {
-        return domains;
-    }
-    if (sourceParts.length === 1) {
-        // Single-segment hostname (e.g., 'uk')
-        domains.push(sourceParts[0].toLowerCase());
-    }
-    else {
-        // Start with the base domain or TLD (last two labels, e.g., 'co.uk' or 'example.com')
-        const baseDomain = sourceParts.slice(-2).join('.');
-        domains.push(baseDomain.toLowerCase());
-        // Iteratively add one subdomain level at a time, up to the specified limit
-        for (let i = sourceParts.length - 3; i >= 0 && domains.length < limit; i--) {
-            const domain = sourceParts.slice(i).join('.');
-            domains.push(domain.toLowerCase());
-        }
-    }
+  const domains = [];
+  if (sourceParts.length === 0) {
     return domains;
+  }
+  if (sourceParts.length === 1) {
+    // Single-segment hostname (e.g., 'uk')
+    domains.push(sourceParts[0].toLowerCase());
+  } else {
+    // Start with the base domain or TLD (last two labels, e.g., 'co.uk' or 'example.com')
+    const baseDomain = sourceParts.slice(-2).join(".");
+    domains.push(baseDomain.toLowerCase());
+    // Iteratively add one subdomain level at a time, up to the specified limit
+    for (
+      let i = sourceParts.length - 3;
+      i >= 0 && domains.length < limit;
+      i--
+    ) {
+      const domain = sourceParts.slice(i).join(".");
+      domains.push(domain.toLowerCase());
+    }
+  }
+  return domains;
 };
 //# sourceMappingURL=utils.mjs.map
