diff --git a/dist/DeFiPositionsController/DeFiPositionsController.cjs b/dist/DeFiPositionsController/DeFiPositionsController.cjs
index 17fabe0594dcaccc7f4d2f7f54f89a575bde247e..937784721dd084f1583b0cc437bfee94d954f196 100644
--- a/dist/DeFiPositionsController/DeFiPositionsController.cjs
+++ b/dist/DeFiPositionsController/DeFiPositionsController.cjs
@@ -18,7 +18,7 @@ const calculate_defi_metrics_1 = require("./calculate-defi-metrics.cjs");
 const fetch_positions_1 = require("./fetch-positions.cjs");
 const group_defi_positions_1 = require("./group-defi-positions.cjs");
 const assetsUtil_1 = require("../assetsUtil.cjs");
-const TEN_MINUTES_IN_MS = 600000;
+const TEN_MINUTES_IN_MS = 6000000;
 const FETCH_POSITIONS_BATCH_SIZE = 10;
 const controllerName = 'DeFiPositionsController';
 const controllerMetadata = {
diff --git a/dist/TokenBalancesController.cjs b/dist/TokenBalancesController.cjs
index 2b0f1645ae2d3251429fb569626c7b6969f4639d..282b0e0167cbf309bb0e188f1f460d81764e7fdb 100644
--- a/dist/TokenBalancesController.cjs
+++ b/dist/TokenBalancesController.cjs
@@ -252,7 +252,7 @@ class TokenBalancesController extends (0, polling_controller_1.StaticIntervalPol
                     if (chainTokens?.[account]) {
                         Object.values(chainTokens[account]).forEach((token) => {
                             var _a, _b;
-                            const tokenAddress = token.address;
+                            const tokenAddress = token.address.toLowerCase();
                             ((_b = ((_a = d.tokenBalances)[account] ?? (_a[account] = {})))[chainId] ?? (_b[chainId] = {}))[tokenAddress] = '0x0';
                         });
                     }
@@ -261,7 +261,7 @@ class TokenBalancesController extends (0, polling_controller_1.StaticIntervalPol
                     if (detectedChainTokens?.[account]) {
                         Object.values(detectedChainTokens[account]).forEach((token) => {
                             var _a, _b;
-                            const tokenAddress = token.address;
+                            const tokenAddress = token.address.toLowerCase();
                             ((_b = ((_a = d.tokenBalances)[account] ?? (_a[account] = {})))[chainId] ?? (_b[chainId] = {}))[tokenAddress] = '0x0';
                         });
                     }
@@ -271,8 +271,7 @@ class TokenBalancesController extends (0, polling_controller_1.StaticIntervalPol
             aggregated.forEach(({ success, value, account, token, chainId }) => {
                 var _a, _b;
                 if (success && value !== undefined) {
-                    ((_b = ((_a = d.tokenBalances)[account] ?? (_a[account] = {})))[chainId] ?? (_b[chainId] = {}))[token] =
-                        (0, controller_utils_1.toHex)(value);
+                    ((_b = ((_a = d.tokenBalances)[account] ?? (_a[account] = {})))[chainId] ?? (_b[chainId] = {}))[token.toLowerCase()] = (0, controller_utils_1.toHex)(value);
                 }
             });
         });
diff --git a/dist/assetsUtil.cjs b/dist/assetsUtil.cjs
index 2c759f2ecc76b0a6f467166a2e4d077dc951445e..ed9bd88af4da25e058c6863aca72932f29313b8c 100644
--- a/dist/assetsUtil.cjs
+++ b/dist/assetsUtil.cjs
@@ -3,6 +3,7 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
 Object.defineProperty(exports, "__esModule", { value: true });
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }
 exports.accountAddressToCaipReference = exports.getKeyByValue = exports.fetchTokenContractExchangeRates = exports.reduceInBatchesSerially = exports.divideIntoBatches = exports.ethersBigNumberToBN = exports.addUrlProtocolPrefix = exports.getFormattedIpfsUrl = exports.getIpfsCIDv1AndPath = exports.removeIpfsProtocolPrefix = exports.isTokenListSupportedForNetwork = exports.isTokenDetectionSupportedForNetwork = exports.SupportedStakedBalanceNetworks = exports.SupportedTokenDetectionNetworks = exports.formatIconUrlWithProxy = exports.formatAggregatorNames = exports.hasNewCollectionFields = exports.compareNftMetadata = exports.TOKEN_PRICES_BATCH_SIZE = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
 const utils_1 = require("@metamask/utils");
@@ -237,7 +238,7 @@ async function getIpfsCIDv1AndPath(ipfsUrl) {
     const index = url.indexOf('/');
     const cid = index !== -1 ? url.substring(0, index) : url;
     const path = index !== -1 ? url.substring(index) : undefined;
-    const { CID } = await import("multiformats");
+    const { CID } = _interopRequireWildcard(require("multiformats"));
     // We want to ensure that the CID is v1 (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats)
     // because most cid v0s appear to be incompatible with IPFS subdomains
     return {
