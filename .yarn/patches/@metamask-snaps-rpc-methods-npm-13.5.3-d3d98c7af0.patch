diff --git a/dist/restricted/invokeSnap.cjs b/dist/restricted/invokeSnap.cjs
index 1c1c0f15f3c9a6d70c756f969758471935648b26..2a01ec50724afd6a491875b42d5fb0212730880d 100644
--- a/dist/restricted/invokeSnap.cjs
+++ b/dist/restricted/invokeSnap.cjs
@@ -10,20 +10,20 @@ exports.WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';
  *
  * @param params - The side-effect params.
  * @param params.requestData - The request data associated to the requested permission.
- * @param params.messagingSystem - The messenger to call an action.
+ * @param params.messenger - The messenger to call an action.
  * @returns The result of the Snap installation.
  */
-const handleSnapInstall = async ({ requestData, messagingSystem }) => {
+const handleSnapInstall = async ({ requestData, messenger }) => {
     const snaps = requestData.permissions[exports.WALLET_SNAP_PERMISSION_KEY].caveats?.[0]
         .value;
-    const permittedSnaps = messagingSystem.call(`SnapController:getPermitted`, requestData.metadata.origin);
+    const permittedSnaps = messenger.call(`SnapController:getPermitted`, requestData.metadata.origin);
     const dedupedSnaps = Object.keys(snaps).reduce((filteredSnaps, snap) => {
         if (!permittedSnaps[snap]) {
             filteredSnaps[snap] = snaps[snap];
         }
         return filteredSnaps;
     }, {});
-    return messagingSystem.call(`SnapController:install`, requestData.metadata.origin, dedupedSnaps);
+    return messenger.call(`SnapController:install`, requestData.metadata.origin, dedupedSnaps);
 };
 exports.handleSnapInstall = handleSnapInstall;
 /**
diff --git a/dist/restricted/invokeSnap.cjs.map b/dist/restricted/invokeSnap.cjs.map
index 22a55c6887d4ed0e8c30e8af75e914eb1eb41523..a7e79b5c95cf3d28540ca2ed39a00dd84a6078a3 100644
--- a/dist/restricted/invokeSnap.cjs.map
+++ b/dist/restricted/invokeSnap.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"invokeSnap.cjs","sourceRoot":"","sources":["../../src/restricted/invokeSnap.ts"],"names":[],"mappings":";;;AAOA,2EAAiE;AACjE,qDAAiD;AAOjD,uDAAoE;AAKvD,QAAA,0BAA0B,GAAG,aAAa,CAAC;AAgDxD;;;;;;;GAOG;AACI,MAAM,iBAAiB,GAGX,KAAK,EAAE,EAAE,WAAW,EAAE,eAAe,EAAE,EAAE,EAAE;IAC5D,MAAM,KAAK,GAAG,WAAW,CAAC,WAAW,CAAC,kCAA0B,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;SAC3E,KAA2B,CAAC;IAE/B,MAAM,cAAc,GAAG,eAAe,CAAC,IAAI,CACzC,6BAA6B,EAC7B,WAAW,CAAC,QAAQ,CAAC,MAAM,CAC5B,CAAC;IAEF,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,CAC5C,CAAC,aAAa,EAAE,IAAI,EAAE,EAAE;QACtB,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC;YAC1B,aAAa,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;QACpC,CAAC;QACD,OAAO,aAAa,CAAC;IACvB,CAAC,EACD,EAAE,CACH,CAAC;IAEF,OAAO,eAAe,CAAC,IAAI,CACzB,wBAAwB,EACxB,WAAW,CAAC,QAAQ,CAAC,MAAM,EAC3B,YAAY,CACb,CAAC;AACJ,CAAC,CAAC;AA3BW,QAAA,iBAAiB,qBA2B5B;AACF;;;;;;;;;;;GAWG;AACH,MAAM,oBAAoB,GAItB,CAAC,EAAE,WAAW,EAAyC,EAAE,EAAE;IAC7D,OAAO;QACL,cAAc,EAAE,sCAAc,CAAC,gBAAgB;QAC/C,UAAU,EAAE,kCAA0B;QACtC,cAAc,EAAE,CAAC,4BAAc,CAAC,OAAO,CAAC;QACxC,oBAAoB,EAAE,2BAA2B,CAAC,WAAW,CAAC;QAC9D,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE;YACzB,IAAI,OAAO,EAAE,MAAM,KAAK,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,4BAAc,CAAC,OAAO,EAAE,CAAC;gBACxE,MAAM,sBAAS,CAAC,aAAa,CAAC;oBAC5B,OAAO,EAAE,sBAAsB,4BAAc,CAAC,OAAO,WAAW;iBACjE,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QACD,UAAU,EAAE;YACV,WAAW,EAAE,yBAAiB;SAC/B;KACF,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,WAAW,GAA6C;IAC5D,oBAAoB,EAAE,IAAI;CAC3B,CAAC;AAEW,QAAA,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC;IAC7C,UAAU,EAAE,kCAA0B;IACtC,oBAAoB;IACpB,WAAW;CACH,CAAC,CAAC;AAEZ;;;;;;;GAOG;AACH,SAAgB,2BAA2B,CAAC,EAC1C,oBAAoB,GACE;IACtB,OAAO,KAAK,UAAU,UAAU,CAC9B,OAAkD;QAElD,MAAM,EAAE,MAAM,GAAG,EAAE,EAAE,OAAO,EAAE,GAAG,OAAO,CAAC;QAEzC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,MAA0B,CAAC;QAEvD,MAAM,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC;QAE3B,OAAO,CAAC,MAAM,oBAAoB,CAAC;YACjC,MAAM;YACN,MAAM;YACN,OAAO;YACP,OAAO,EAAE,yBAAW,CAAC,YAAY;SAClC,CAAC,CAAS,CAAC;IACd,CAAC,CAAC;AACJ,CAAC;AAnBD,kEAmBC","sourcesContent":["import type {\n  PermissionSpecificationBuilder,\n  RestrictedMethodOptions,\n  ValidPermissionSpecification,\n  PermissionValidatorConstraint,\n  PermissionSideEffect,\n} from '@metamask/permission-controller';\nimport { PermissionType } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type {\n  InvokeSnapResult,\n  RequestSnapsParams,\n  RequestSnapsResult,\n} from '@metamask/snaps-sdk';\nimport type { SnapRpcHookArgs } from '@metamask/snaps-utils';\nimport { HandlerType, SnapCaveatType } from '@metamask/snaps-utils';\nimport type { Json, NonEmptyArray } from '@metamask/utils';\n\nimport type { MethodHooksObject } from '../utils';\n\nexport const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';\n\n// Redeclare installSnaps action type to avoid circular dependencies\nexport type InstallSnaps = {\n  type: `SnapController:install`;\n  handler: (\n    origin: string,\n    requestedSnaps: RequestSnapsParams,\n  ) => Promise<RequestSnapsResult>;\n};\n\nexport type GetPermittedSnaps = {\n  type: `SnapController:getPermitted`;\n  handler: (origin: string) => RequestSnapsResult;\n};\n\ntype AllowedActions = InstallSnaps | GetPermittedSnaps;\n\nexport type InvokeSnapMethodHooks = {\n  handleSnapRpcRequest: ({\n    snapId,\n    origin,\n    handler,\n    request,\n  }: SnapRpcHookArgs & { snapId: string }) => Promise<unknown>;\n};\n\ntype InvokeSnapSpecificationBuilderOptions = {\n  allowedCaveats?: Readonly<NonEmptyArray<string>> | null;\n  methodHooks: InvokeSnapMethodHooks;\n};\n\ntype InvokeSnapSpecification = ValidPermissionSpecification<{\n  permissionType: PermissionType.RestrictedMethod;\n  targetName: typeof WALLET_SNAP_PERMISSION_KEY;\n  methodImplementation: ReturnType<typeof getInvokeSnapImplementation>;\n  allowedCaveats: Readonly<NonEmptyArray<string>> | null;\n  validator: PermissionValidatorConstraint;\n  sideEffect: {\n    onPermitted: PermissionSideEffect<AllowedActions, never>['onPermitted'];\n  };\n}>;\n\nexport type InvokeSnapParams = {\n  snapId: string;\n  request: Record<string, Json>;\n};\n\n/**\n * The side-effect method to handle the snap install.\n *\n * @param params - The side-effect params.\n * @param params.requestData - The request data associated to the requested permission.\n * @param params.messagingSystem - The messenger to call an action.\n * @returns The result of the Snap installation.\n */\nexport const handleSnapInstall: PermissionSideEffect<\n  AllowedActions,\n  never\n>['onPermitted'] = async ({ requestData, messagingSystem }) => {\n  const snaps = requestData.permissions[WALLET_SNAP_PERMISSION_KEY].caveats?.[0]\n    .value as RequestSnapsParams;\n\n  const permittedSnaps = messagingSystem.call(\n    `SnapController:getPermitted`,\n    requestData.metadata.origin,\n  );\n\n  const dedupedSnaps = Object.keys(snaps).reduce<RequestSnapsParams>(\n    (filteredSnaps, snap) => {\n      if (!permittedSnaps[snap]) {\n        filteredSnaps[snap] = snaps[snap];\n      }\n      return filteredSnaps;\n    },\n    {},\n  );\n\n  return messagingSystem.call(\n    `SnapController:install`,\n    requestData.metadata.origin,\n    dedupedSnaps,\n  );\n};\n/**\n * The specification builder for the `wallet_snap_*` permission.\n *\n * `wallet_snap_*` attempts to invoke an RPC method of the specified Snap.\n *\n * Requesting its corresponding permission will attempt to connect to the Snap,\n * and install it if it's not available yet.\n *\n * @param options - The specification builder options.\n * @param options.methodHooks - The RPC method hooks needed by the method implementation.\n * @returns The specification for the `wallet_snap_*` permission.\n */\nconst specificationBuilder: PermissionSpecificationBuilder<\n  PermissionType.RestrictedMethod,\n  InvokeSnapSpecificationBuilderOptions,\n  InvokeSnapSpecification\n> = ({ methodHooks }: InvokeSnapSpecificationBuilderOptions) => {\n  return {\n    permissionType: PermissionType.RestrictedMethod,\n    targetName: WALLET_SNAP_PERMISSION_KEY,\n    allowedCaveats: [SnapCaveatType.SnapIds],\n    methodImplementation: getInvokeSnapImplementation(methodHooks),\n    validator: ({ caveats }) => {\n      if (caveats?.length !== 1 || caveats[0].type !== SnapCaveatType.SnapIds) {\n        throw rpcErrors.invalidParams({\n          message: `Expected a single \"${SnapCaveatType.SnapIds}\" caveat.`,\n        });\n      }\n    },\n    sideEffect: {\n      onPermitted: handleSnapInstall,\n    },\n  };\n};\n\nconst methodHooks: MethodHooksObject<InvokeSnapMethodHooks> = {\n  handleSnapRpcRequest: true,\n};\n\nexport const invokeSnapBuilder = Object.freeze({\n  targetName: WALLET_SNAP_PERMISSION_KEY,\n  specificationBuilder,\n  methodHooks,\n} as const);\n\n/**\n * Builds the method implementation for `wallet_snap_*`.\n *\n * @param hooks - The RPC method hooks.\n * @param hooks.handleSnapRpcRequest - A function that sends an RPC request to a snap's RPC handler or throws if that fails.\n * @returns The method implementation which returns the result of `handleSnapRpcRequest`.\n * @throws If the params are invalid.\n */\nexport function getInvokeSnapImplementation({\n  handleSnapRpcRequest,\n}: InvokeSnapMethodHooks) {\n  return async function invokeSnap(\n    options: RestrictedMethodOptions<InvokeSnapParams>,\n  ): Promise<InvokeSnapResult> {\n    const { params = {}, context } = options;\n\n    const { snapId, request } = params as InvokeSnapParams;\n\n    const { origin } = context;\n\n    return (await handleSnapRpcRequest({\n      snapId,\n      origin,\n      request,\n      handler: HandlerType.OnRpcRequest,\n    })) as Json;\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"invokeSnap.cjs","sourceRoot":"","sources":["../../src/restricted/invokeSnap.ts"],"names":[],"mappings":";;;AAOA,2EAAiE;AACjE,qDAAiD;AAOjD,uDAAoE;AAKvD,QAAA,0BAA0B,GAAG,aAAa,CAAC;AAgDxD;;;;;;;GAOG;AACI,MAAM,iBAAiB,GAGX,KAAK,EAAE,EAAE,WAAW,EAAE,SAAS,EAAE,EAAE,EAAE;IACtD,MAAM,KAAK,GAAG,WAAW,CAAC,WAAW,CAAC,kCAA0B,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;SAC3E,KAA2B,CAAC;IAE/B,MAAM,cAAc,GAAG,SAAS,CAAC,IAAI,CACnC,6BAA6B,EAC7B,WAAW,CAAC,QAAQ,CAAC,MAAM,CAC5B,CAAC;IAEF,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,CAC5C,CAAC,aAAa,EAAE,IAAI,EAAE,EAAE;QACtB,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC;YAC1B,aAAa,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;QACpC,CAAC;QACD,OAAO,aAAa,CAAC;IACvB,CAAC,EACD,EAAE,CACH,CAAC;IAEF,OAAO,SAAS,CAAC,IAAI,CACnB,wBAAwB,EACxB,WAAW,CAAC,QAAQ,CAAC,MAAM,EAC3B,YAAY,CACb,CAAC;AACJ,CAAC,CAAC;AA3BW,QAAA,iBAAiB,qBA2B5B;AACF;;;;;;;;;;;GAWG;AACH,MAAM,oBAAoB,GAItB,CAAC,EAAE,WAAW,EAAyC,EAAE,EAAE;IAC7D,OAAO;QACL,cAAc,EAAE,sCAAc,CAAC,gBAAgB;QAC/C,UAAU,EAAE,kCAA0B;QACtC,cAAc,EAAE,CAAC,4BAAc,CAAC,OAAO,CAAC;QACxC,oBAAoB,EAAE,2BAA2B,CAAC,WAAW,CAAC;QAC9D,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE;YACzB,IAAI,OAAO,EAAE,MAAM,KAAK,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,4BAAc,CAAC,OAAO,EAAE,CAAC;gBACxE,MAAM,sBAAS,CAAC,aAAa,CAAC;oBAC5B,OAAO,EAAE,sBAAsB,4BAAc,CAAC,OAAO,WAAW;iBACjE,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QACD,UAAU,EAAE;YACV,WAAW,EAAE,yBAAiB;SAC/B;KACF,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,WAAW,GAA6C;IAC5D,oBAAoB,EAAE,IAAI;CAC3B,CAAC;AAEW,QAAA,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC;IAC7C,UAAU,EAAE,kCAA0B;IACtC,oBAAoB;IACpB,WAAW;CACH,CAAC,CAAC;AAEZ;;;;;;;GAOG;AACH,SAAgB,2BAA2B,CAAC,EAC1C,oBAAoB,GACE;IACtB,OAAO,KAAK,UAAU,UAAU,CAC9B,OAAkD;QAElD,MAAM,EAAE,MAAM,GAAG,EAAE,EAAE,OAAO,EAAE,GAAG,OAAO,CAAC;QAEzC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,MAA0B,CAAC;QAEvD,MAAM,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC;QAE3B,OAAO,CAAC,MAAM,oBAAoB,CAAC;YACjC,MAAM;YACN,MAAM;YACN,OAAO;YACP,OAAO,EAAE,yBAAW,CAAC,YAAY;SAClC,CAAC,CAAS,CAAC;IACd,CAAC,CAAC;AACJ,CAAC;AAnBD,kEAmBC","sourcesContent":["import type {\n  PermissionSpecificationBuilder,\n  RestrictedMethodOptions,\n  ValidPermissionSpecification,\n  PermissionValidatorConstraint,\n  PermissionSideEffect,\n} from '@metamask/permission-controller';\nimport { PermissionType } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type {\n  InvokeSnapResult,\n  RequestSnapsParams,\n  RequestSnapsResult,\n} from '@metamask/snaps-sdk';\nimport type { SnapRpcHookArgs } from '@metamask/snaps-utils';\nimport { HandlerType, SnapCaveatType } from '@metamask/snaps-utils';\nimport type { Json, NonEmptyArray } from '@metamask/utils';\n\nimport type { MethodHooksObject } from '../utils';\n\nexport const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';\n\n// Redeclare installSnaps action type to avoid circular dependencies\nexport type InstallSnaps = {\n  type: `SnapController:install`;\n  handler: (\n    origin: string,\n    requestedSnaps: RequestSnapsParams,\n  ) => Promise<RequestSnapsResult>;\n};\n\nexport type GetPermittedSnaps = {\n  type: `SnapController:getPermitted`;\n  handler: (origin: string) => RequestSnapsResult;\n};\n\ntype AllowedActions = InstallSnaps | GetPermittedSnaps;\n\nexport type InvokeSnapMethodHooks = {\n  handleSnapRpcRequest: ({\n    snapId,\n    origin,\n    handler,\n    request,\n  }: SnapRpcHookArgs & { snapId: string }) => Promise<unknown>;\n};\n\ntype InvokeSnapSpecificationBuilderOptions = {\n  allowedCaveats?: Readonly<NonEmptyArray<string>> | null;\n  methodHooks: InvokeSnapMethodHooks;\n};\n\ntype InvokeSnapSpecification = ValidPermissionSpecification<{\n  permissionType: PermissionType.RestrictedMethod;\n  targetName: typeof WALLET_SNAP_PERMISSION_KEY;\n  methodImplementation: ReturnType<typeof getInvokeSnapImplementation>;\n  allowedCaveats: Readonly<NonEmptyArray<string>> | null;\n  validator: PermissionValidatorConstraint;\n  sideEffect: {\n    onPermitted: PermissionSideEffect<AllowedActions, never>['onPermitted'];\n  };\n}>;\n\nexport type InvokeSnapParams = {\n  snapId: string;\n  request: Record<string, Json>;\n};\n\n/**\n * The side-effect method to handle the snap install.\n *\n * @param params - The side-effect params.\n * @param params.requestData - The request data associated to the requested permission.\n * @param params.messenger - The messenger to call an action.\n * @returns The result of the Snap installation.\n */\nexport const handleSnapInstall: PermissionSideEffect<\n  AllowedActions,\n  never\n>['onPermitted'] = async ({ requestData, messenger }) => {\n  const snaps = requestData.permissions[WALLET_SNAP_PERMISSION_KEY].caveats?.[0]\n    .value as RequestSnapsParams;\n\n  const permittedSnaps = messenger.call(\n    `SnapController:getPermitted`,\n    requestData.metadata.origin,\n  );\n\n  const dedupedSnaps = Object.keys(snaps).reduce<RequestSnapsParams>(\n    (filteredSnaps, snap) => {\n      if (!permittedSnaps[snap]) {\n        filteredSnaps[snap] = snaps[snap];\n      }\n      return filteredSnaps;\n    },\n    {},\n  );\n\n  return messenger.call(\n    `SnapController:install`,\n    requestData.metadata.origin,\n    dedupedSnaps,\n  );\n};\n/**\n * The specification builder for the `wallet_snap_*` permission.\n *\n * `wallet_snap_*` attempts to invoke an RPC method of the specified Snap.\n *\n * Requesting its corresponding permission will attempt to connect to the Snap,\n * and install it if it's not available yet.\n *\n * @param options - The specification builder options.\n * @param options.methodHooks - The RPC method hooks needed by the method implementation.\n * @returns The specification for the `wallet_snap_*` permission.\n */\nconst specificationBuilder: PermissionSpecificationBuilder<\n  PermissionType.RestrictedMethod,\n  InvokeSnapSpecificationBuilderOptions,\n  InvokeSnapSpecification\n> = ({ methodHooks }: InvokeSnapSpecificationBuilderOptions) => {\n  return {\n    permissionType: PermissionType.RestrictedMethod,\n    targetName: WALLET_SNAP_PERMISSION_KEY,\n    allowedCaveats: [SnapCaveatType.SnapIds],\n    methodImplementation: getInvokeSnapImplementation(methodHooks),\n    validator: ({ caveats }) => {\n      if (caveats?.length !== 1 || caveats[0].type !== SnapCaveatType.SnapIds) {\n        throw rpcErrors.invalidParams({\n          message: `Expected a single \"${SnapCaveatType.SnapIds}\" caveat.`,\n        });\n      }\n    },\n    sideEffect: {\n      onPermitted: handleSnapInstall,\n    },\n  };\n};\n\nconst methodHooks: MethodHooksObject<InvokeSnapMethodHooks> = {\n  handleSnapRpcRequest: true,\n};\n\nexport const invokeSnapBuilder = Object.freeze({\n  targetName: WALLET_SNAP_PERMISSION_KEY,\n  specificationBuilder,\n  methodHooks,\n} as const);\n\n/**\n * Builds the method implementation for `wallet_snap_*`.\n *\n * @param hooks - The RPC method hooks.\n * @param hooks.handleSnapRpcRequest - A function that sends an RPC request to a snap's RPC handler or throws if that fails.\n * @returns The method implementation which returns the result of `handleSnapRpcRequest`.\n * @throws If the params are invalid.\n */\nexport function getInvokeSnapImplementation({\n  handleSnapRpcRequest,\n}: InvokeSnapMethodHooks) {\n  return async function invokeSnap(\n    options: RestrictedMethodOptions<InvokeSnapParams>,\n  ): Promise<InvokeSnapResult> {\n    const { params = {}, context } = options;\n\n    const { snapId, request } = params as InvokeSnapParams;\n\n    const { origin } = context;\n\n    return (await handleSnapRpcRequest({\n      snapId,\n      origin,\n      request,\n      handler: HandlerType.OnRpcRequest,\n    })) as Json;\n  };\n}\n"]}
\ No newline at end of file
diff --git a/dist/restricted/invokeSnap.d.cts b/dist/restricted/invokeSnap.d.cts
index f8b71b39e285c456f8459db99fcf4107c1028c40..990325c83b80e46ee5b70cb638c09de5721e9055 100644
--- a/dist/restricted/invokeSnap.d.cts
+++ b/dist/restricted/invokeSnap.d.cts
@@ -32,7 +32,7 @@ export type InvokeSnapParams = {
  *
  * @param params - The side-effect params.
  * @param params.requestData - The request data associated to the requested permission.
- * @param params.messagingSystem - The messenger to call an action.
+ * @param params.messenger - The messenger to call an action.
  * @returns The result of the Snap installation.
  */
 export declare const handleSnapInstall: PermissionSideEffect<AllowedActions, never>['onPermitted'];
diff --git a/dist/restricted/invokeSnap.d.mts b/dist/restricted/invokeSnap.d.mts
index 2ef68ddabc9db791d31b7ce10b95538197ec970e..00660869d3c565cdbe7c2389c140d76f777d5e1c 100644
--- a/dist/restricted/invokeSnap.d.mts
+++ b/dist/restricted/invokeSnap.d.mts
@@ -32,7 +32,7 @@ export type InvokeSnapParams = {
  *
  * @param params - The side-effect params.
  * @param params.requestData - The request data associated to the requested permission.
- * @param params.messagingSystem - The messenger to call an action.
+ * @param params.messenger - The messenger to call an action.
  * @returns The result of the Snap installation.
  */
 export declare const handleSnapInstall: PermissionSideEffect<AllowedActions, never>['onPermitted'];
diff --git a/dist/restricted/invokeSnap.mjs b/dist/restricted/invokeSnap.mjs
index 909c31267777c9b8be53f10164e2eee9d1d61e34..1798604391dd658b941be7baecb47eccf51e6c6d 100644
--- a/dist/restricted/invokeSnap.mjs
+++ b/dist/restricted/invokeSnap.mjs
@@ -7,20 +7,20 @@ export const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';
  *
  * @param params - The side-effect params.
  * @param params.requestData - The request data associated to the requested permission.
- * @param params.messagingSystem - The messenger to call an action.
+ * @param params.messenger - The messenger to call an action.
  * @returns The result of the Snap installation.
  */
-export const handleSnapInstall = async ({ requestData, messagingSystem }) => {
+export const handleSnapInstall = async ({ requestData, messenger }) => {
     const snaps = requestData.permissions[WALLET_SNAP_PERMISSION_KEY].caveats?.[0]
         .value;
-    const permittedSnaps = messagingSystem.call(`SnapController:getPermitted`, requestData.metadata.origin);
+    const permittedSnaps = messenger.call(`SnapController:getPermitted`, requestData.metadata.origin);
     const dedupedSnaps = Object.keys(snaps).reduce((filteredSnaps, snap) => {
         if (!permittedSnaps[snap]) {
             filteredSnaps[snap] = snaps[snap];
         }
         return filteredSnaps;
     }, {});
-    return messagingSystem.call(`SnapController:install`, requestData.metadata.origin, dedupedSnaps);
+    return messenger.call(`SnapController:install`, requestData.metadata.origin, dedupedSnaps);
 };
 /**
  * The specification builder for the `wallet_snap_*` permission.
diff --git a/dist/restricted/invokeSnap.mjs.map b/dist/restricted/invokeSnap.mjs.map
index 5194717fa9f07590d79c31de0e5dfe1d1033fa8c..a005e047c89fe82865801c74fb16168bc7e38851 100644
--- a/dist/restricted/invokeSnap.mjs.map
+++ b/dist/restricted/invokeSnap.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"invokeSnap.mjs","sourceRoot":"","sources":["../../src/restricted/invokeSnap.ts"],"names":[],"mappings":"AAOA,OAAO,EAAE,cAAc,EAAE,wCAAwC;AACjE,OAAO,EAAE,SAAS,EAAE,6BAA6B;AAOjD,OAAO,EAAE,WAAW,EAAE,cAAc,EAAE,8BAA8B;AAKpE,MAAM,CAAC,MAAM,0BAA0B,GAAG,aAAa,CAAC;AAgDxD;;;;;;;GAOG;AACH,MAAM,CAAC,MAAM,iBAAiB,GAGX,KAAK,EAAE,EAAE,WAAW,EAAE,eAAe,EAAE,EAAE,EAAE;IAC5D,MAAM,KAAK,GAAG,WAAW,CAAC,WAAW,CAAC,0BAA0B,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;SAC3E,KAA2B,CAAC;IAE/B,MAAM,cAAc,GAAG,eAAe,CAAC,IAAI,CACzC,6BAA6B,EAC7B,WAAW,CAAC,QAAQ,CAAC,MAAM,CAC5B,CAAC;IAEF,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,CAC5C,CAAC,aAAa,EAAE,IAAI,EAAE,EAAE;QACtB,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC;YAC1B,aAAa,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;QACpC,CAAC;QACD,OAAO,aAAa,CAAC;IACvB,CAAC,EACD,EAAE,CACH,CAAC;IAEF,OAAO,eAAe,CAAC,IAAI,CACzB,wBAAwB,EACxB,WAAW,CAAC,QAAQ,CAAC,MAAM,EAC3B,YAAY,CACb,CAAC;AACJ,CAAC,CAAC;AACF;;;;;;;;;;;GAWG;AACH,MAAM,oBAAoB,GAItB,CAAC,EAAE,WAAW,EAAyC,EAAE,EAAE;IAC7D,OAAO;QACL,cAAc,EAAE,cAAc,CAAC,gBAAgB;QAC/C,UAAU,EAAE,0BAA0B;QACtC,cAAc,EAAE,CAAC,cAAc,CAAC,OAAO,CAAC;QACxC,oBAAoB,EAAE,2BAA2B,CAAC,WAAW,CAAC;QAC9D,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE;YACzB,IAAI,OAAO,EAAE,MAAM,KAAK,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,cAAc,CAAC,OAAO,EAAE,CAAC;gBACxE,MAAM,SAAS,CAAC,aAAa,CAAC;oBAC5B,OAAO,EAAE,sBAAsB,cAAc,CAAC,OAAO,WAAW;iBACjE,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QACD,UAAU,EAAE;YACV,WAAW,EAAE,iBAAiB;SAC/B;KACF,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,WAAW,GAA6C;IAC5D,oBAAoB,EAAE,IAAI;CAC3B,CAAC;AAEF,MAAM,CAAC,MAAM,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC;IAC7C,UAAU,EAAE,0BAA0B;IACtC,oBAAoB;IACpB,WAAW;CACH,CAAC,CAAC;AAEZ;;;;;;;GAOG;AACH,MAAM,UAAU,2BAA2B,CAAC,EAC1C,oBAAoB,GACE;IACtB,OAAO,KAAK,UAAU,UAAU,CAC9B,OAAkD;QAElD,MAAM,EAAE,MAAM,GAAG,EAAE,EAAE,OAAO,EAAE,GAAG,OAAO,CAAC;QAEzC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,MAA0B,CAAC;QAEvD,MAAM,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC;QAE3B,OAAO,CAAC,MAAM,oBAAoB,CAAC;YACjC,MAAM;YACN,MAAM;YACN,OAAO;YACP,OAAO,EAAE,WAAW,CAAC,YAAY;SAClC,CAAC,CAAS,CAAC;IACd,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import type {\n  PermissionSpecificationBuilder,\n  RestrictedMethodOptions,\n  ValidPermissionSpecification,\n  PermissionValidatorConstraint,\n  PermissionSideEffect,\n} from '@metamask/permission-controller';\nimport { PermissionType } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type {\n  InvokeSnapResult,\n  RequestSnapsParams,\n  RequestSnapsResult,\n} from '@metamask/snaps-sdk';\nimport type { SnapRpcHookArgs } from '@metamask/snaps-utils';\nimport { HandlerType, SnapCaveatType } from '@metamask/snaps-utils';\nimport type { Json, NonEmptyArray } from '@metamask/utils';\n\nimport type { MethodHooksObject } from '../utils';\n\nexport const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';\n\n// Redeclare installSnaps action type to avoid circular dependencies\nexport type InstallSnaps = {\n  type: `SnapController:install`;\n  handler: (\n    origin: string,\n    requestedSnaps: RequestSnapsParams,\n  ) => Promise<RequestSnapsResult>;\n};\n\nexport type GetPermittedSnaps = {\n  type: `SnapController:getPermitted`;\n  handler: (origin: string) => RequestSnapsResult;\n};\n\ntype AllowedActions = InstallSnaps | GetPermittedSnaps;\n\nexport type InvokeSnapMethodHooks = {\n  handleSnapRpcRequest: ({\n    snapId,\n    origin,\n    handler,\n    request,\n  }: SnapRpcHookArgs & { snapId: string }) => Promise<unknown>;\n};\n\ntype InvokeSnapSpecificationBuilderOptions = {\n  allowedCaveats?: Readonly<NonEmptyArray<string>> | null;\n  methodHooks: InvokeSnapMethodHooks;\n};\n\ntype InvokeSnapSpecification = ValidPermissionSpecification<{\n  permissionType: PermissionType.RestrictedMethod;\n  targetName: typeof WALLET_SNAP_PERMISSION_KEY;\n  methodImplementation: ReturnType<typeof getInvokeSnapImplementation>;\n  allowedCaveats: Readonly<NonEmptyArray<string>> | null;\n  validator: PermissionValidatorConstraint;\n  sideEffect: {\n    onPermitted: PermissionSideEffect<AllowedActions, never>['onPermitted'];\n  };\n}>;\n\nexport type InvokeSnapParams = {\n  snapId: string;\n  request: Record<string, Json>;\n};\n\n/**\n * The side-effect method to handle the snap install.\n *\n * @param params - The side-effect params.\n * @param params.requestData - The request data associated to the requested permission.\n * @param params.messagingSystem - The messenger to call an action.\n * @returns The result of the Snap installation.\n */\nexport const handleSnapInstall: PermissionSideEffect<\n  AllowedActions,\n  never\n>['onPermitted'] = async ({ requestData, messagingSystem }) => {\n  const snaps = requestData.permissions[WALLET_SNAP_PERMISSION_KEY].caveats?.[0]\n    .value as RequestSnapsParams;\n\n  const permittedSnaps = messagingSystem.call(\n    `SnapController:getPermitted`,\n    requestData.metadata.origin,\n  );\n\n  const dedupedSnaps = Object.keys(snaps).reduce<RequestSnapsParams>(\n    (filteredSnaps, snap) => {\n      if (!permittedSnaps[snap]) {\n        filteredSnaps[snap] = snaps[snap];\n      }\n      return filteredSnaps;\n    },\n    {},\n  );\n\n  return messagingSystem.call(\n    `SnapController:install`,\n    requestData.metadata.origin,\n    dedupedSnaps,\n  );\n};\n/**\n * The specification builder for the `wallet_snap_*` permission.\n *\n * `wallet_snap_*` attempts to invoke an RPC method of the specified Snap.\n *\n * Requesting its corresponding permission will attempt to connect to the Snap,\n * and install it if it's not available yet.\n *\n * @param options - The specification builder options.\n * @param options.methodHooks - The RPC method hooks needed by the method implementation.\n * @returns The specification for the `wallet_snap_*` permission.\n */\nconst specificationBuilder: PermissionSpecificationBuilder<\n  PermissionType.RestrictedMethod,\n  InvokeSnapSpecificationBuilderOptions,\n  InvokeSnapSpecification\n> = ({ methodHooks }: InvokeSnapSpecificationBuilderOptions) => {\n  return {\n    permissionType: PermissionType.RestrictedMethod,\n    targetName: WALLET_SNAP_PERMISSION_KEY,\n    allowedCaveats: [SnapCaveatType.SnapIds],\n    methodImplementation: getInvokeSnapImplementation(methodHooks),\n    validator: ({ caveats }) => {\n      if (caveats?.length !== 1 || caveats[0].type !== SnapCaveatType.SnapIds) {\n        throw rpcErrors.invalidParams({\n          message: `Expected a single \"${SnapCaveatType.SnapIds}\" caveat.`,\n        });\n      }\n    },\n    sideEffect: {\n      onPermitted: handleSnapInstall,\n    },\n  };\n};\n\nconst methodHooks: MethodHooksObject<InvokeSnapMethodHooks> = {\n  handleSnapRpcRequest: true,\n};\n\nexport const invokeSnapBuilder = Object.freeze({\n  targetName: WALLET_SNAP_PERMISSION_KEY,\n  specificationBuilder,\n  methodHooks,\n} as const);\n\n/**\n * Builds the method implementation for `wallet_snap_*`.\n *\n * @param hooks - The RPC method hooks.\n * @param hooks.handleSnapRpcRequest - A function that sends an RPC request to a snap's RPC handler or throws if that fails.\n * @returns The method implementation which returns the result of `handleSnapRpcRequest`.\n * @throws If the params are invalid.\n */\nexport function getInvokeSnapImplementation({\n  handleSnapRpcRequest,\n}: InvokeSnapMethodHooks) {\n  return async function invokeSnap(\n    options: RestrictedMethodOptions<InvokeSnapParams>,\n  ): Promise<InvokeSnapResult> {\n    const { params = {}, context } = options;\n\n    const { snapId, request } = params as InvokeSnapParams;\n\n    const { origin } = context;\n\n    return (await handleSnapRpcRequest({\n      snapId,\n      origin,\n      request,\n      handler: HandlerType.OnRpcRequest,\n    })) as Json;\n  };\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"invokeSnap.mjs","sourceRoot":"","sources":["../../src/restricted/invokeSnap.ts"],"names":[],"mappings":"AAOA,OAAO,EAAE,cAAc,EAAE,wCAAwC;AACjE,OAAO,EAAE,SAAS,EAAE,6BAA6B;AAOjD,OAAO,EAAE,WAAW,EAAE,cAAc,EAAE,8BAA8B;AAKpE,MAAM,CAAC,MAAM,0BAA0B,GAAG,aAAa,CAAC;AAgDxD;;;;;;;GAOG;AACH,MAAM,CAAC,MAAM,iBAAiB,GAGX,KAAK,EAAE,EAAE,WAAW,EAAE,SAAS,EAAE,EAAE,EAAE;IACtD,MAAM,KAAK,GAAG,WAAW,CAAC,WAAW,CAAC,0BAA0B,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;SAC3E,KAA2B,CAAC;IAE/B,MAAM,cAAc,GAAG,SAAS,CAAC,IAAI,CACnC,6BAA6B,EAC7B,WAAW,CAAC,QAAQ,CAAC,MAAM,CAC5B,CAAC;IAEF,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,CAC5C,CAAC,aAAa,EAAE,IAAI,EAAE,EAAE;QACtB,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC;YAC1B,aAAa,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;QACpC,CAAC;QACD,OAAO,aAAa,CAAC;IACvB,CAAC,EACD,EAAE,CACH,CAAC;IAEF,OAAO,SAAS,CAAC,IAAI,CACnB,wBAAwB,EACxB,WAAW,CAAC,QAAQ,CAAC,MAAM,EAC3B,YAAY,CACb,CAAC;AACJ,CAAC,CAAC;AACF;;;;;;;;;;;GAWG;AACH,MAAM,oBAAoB,GAItB,CAAC,EAAE,WAAW,EAAyC,EAAE,EAAE;IAC7D,OAAO;QACL,cAAc,EAAE,cAAc,CAAC,gBAAgB;QAC/C,UAAU,EAAE,0BAA0B;QACtC,cAAc,EAAE,CAAC,cAAc,CAAC,OAAO,CAAC;QACxC,oBAAoB,EAAE,2BAA2B,CAAC,WAAW,CAAC;QAC9D,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE;YACzB,IAAI,OAAO,EAAE,MAAM,KAAK,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,cAAc,CAAC,OAAO,EAAE,CAAC;gBACxE,MAAM,SAAS,CAAC,aAAa,CAAC;oBAC5B,OAAO,EAAE,sBAAsB,cAAc,CAAC,OAAO,WAAW;iBACjE,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QACD,UAAU,EAAE;YACV,WAAW,EAAE,iBAAiB;SAC/B;KACF,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,WAAW,GAA6C;IAC5D,oBAAoB,EAAE,IAAI;CAC3B,CAAC;AAEF,MAAM,CAAC,MAAM,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC;IAC7C,UAAU,EAAE,0BAA0B;IACtC,oBAAoB;IACpB,WAAW;CACH,CAAC,CAAC;AAEZ;;;;;;;GAOG;AACH,MAAM,UAAU,2BAA2B,CAAC,EAC1C,oBAAoB,GACE;IACtB,OAAO,KAAK,UAAU,UAAU,CAC9B,OAAkD;QAElD,MAAM,EAAE,MAAM,GAAG,EAAE,EAAE,OAAO,EAAE,GAAG,OAAO,CAAC;QAEzC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,MAA0B,CAAC;QAEvD,MAAM,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC;QAE3B,OAAO,CAAC,MAAM,oBAAoB,CAAC;YACjC,MAAM;YACN,MAAM;YACN,OAAO;YACP,OAAO,EAAE,WAAW,CAAC,YAAY;SAClC,CAAC,CAAS,CAAC;IACd,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import type {\n  PermissionSpecificationBuilder,\n  RestrictedMethodOptions,\n  ValidPermissionSpecification,\n  PermissionValidatorConstraint,\n  PermissionSideEffect,\n} from '@metamask/permission-controller';\nimport { PermissionType } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type {\n  InvokeSnapResult,\n  RequestSnapsParams,\n  RequestSnapsResult,\n} from '@metamask/snaps-sdk';\nimport type { SnapRpcHookArgs } from '@metamask/snaps-utils';\nimport { HandlerType, SnapCaveatType } from '@metamask/snaps-utils';\nimport type { Json, NonEmptyArray } from '@metamask/utils';\n\nimport type { MethodHooksObject } from '../utils';\n\nexport const WALLET_SNAP_PERMISSION_KEY = 'wallet_snap';\n\n// Redeclare installSnaps action type to avoid circular dependencies\nexport type InstallSnaps = {\n  type: `SnapController:install`;\n  handler: (\n    origin: string,\n    requestedSnaps: RequestSnapsParams,\n  ) => Promise<RequestSnapsResult>;\n};\n\nexport type GetPermittedSnaps = {\n  type: `SnapController:getPermitted`;\n  handler: (origin: string) => RequestSnapsResult;\n};\n\ntype AllowedActions = InstallSnaps | GetPermittedSnaps;\n\nexport type InvokeSnapMethodHooks = {\n  handleSnapRpcRequest: ({\n    snapId,\n    origin,\n    handler,\n    request,\n  }: SnapRpcHookArgs & { snapId: string }) => Promise<unknown>;\n};\n\ntype InvokeSnapSpecificationBuilderOptions = {\n  allowedCaveats?: Readonly<NonEmptyArray<string>> | null;\n  methodHooks: InvokeSnapMethodHooks;\n};\n\ntype InvokeSnapSpecification = ValidPermissionSpecification<{\n  permissionType: PermissionType.RestrictedMethod;\n  targetName: typeof WALLET_SNAP_PERMISSION_KEY;\n  methodImplementation: ReturnType<typeof getInvokeSnapImplementation>;\n  allowedCaveats: Readonly<NonEmptyArray<string>> | null;\n  validator: PermissionValidatorConstraint;\n  sideEffect: {\n    onPermitted: PermissionSideEffect<AllowedActions, never>['onPermitted'];\n  };\n}>;\n\nexport type InvokeSnapParams = {\n  snapId: string;\n  request: Record<string, Json>;\n};\n\n/**\n * The side-effect method to handle the snap install.\n *\n * @param params - The side-effect params.\n * @param params.requestData - The request data associated to the requested permission.\n * @param params.messenger - The messenger to call an action.\n * @returns The result of the Snap installation.\n */\nexport const handleSnapInstall: PermissionSideEffect<\n  AllowedActions,\n  never\n>['onPermitted'] = async ({ requestData, messenger }) => {\n  const snaps = requestData.permissions[WALLET_SNAP_PERMISSION_KEY].caveats?.[0]\n    .value as RequestSnapsParams;\n\n  const permittedSnaps = messenger.call(\n    `SnapController:getPermitted`,\n    requestData.metadata.origin,\n  );\n\n  const dedupedSnaps = Object.keys(snaps).reduce<RequestSnapsParams>(\n    (filteredSnaps, snap) => {\n      if (!permittedSnaps[snap]) {\n        filteredSnaps[snap] = snaps[snap];\n      }\n      return filteredSnaps;\n    },\n    {},\n  );\n\n  return messenger.call(\n    `SnapController:install`,\n    requestData.metadata.origin,\n    dedupedSnaps,\n  );\n};\n/**\n * The specification builder for the `wallet_snap_*` permission.\n *\n * `wallet_snap_*` attempts to invoke an RPC method of the specified Snap.\n *\n * Requesting its corresponding permission will attempt to connect to the Snap,\n * and install it if it's not available yet.\n *\n * @param options - The specification builder options.\n * @param options.methodHooks - The RPC method hooks needed by the method implementation.\n * @returns The specification for the `wallet_snap_*` permission.\n */\nconst specificationBuilder: PermissionSpecificationBuilder<\n  PermissionType.RestrictedMethod,\n  InvokeSnapSpecificationBuilderOptions,\n  InvokeSnapSpecification\n> = ({ methodHooks }: InvokeSnapSpecificationBuilderOptions) => {\n  return {\n    permissionType: PermissionType.RestrictedMethod,\n    targetName: WALLET_SNAP_PERMISSION_KEY,\n    allowedCaveats: [SnapCaveatType.SnapIds],\n    methodImplementation: getInvokeSnapImplementation(methodHooks),\n    validator: ({ caveats }) => {\n      if (caveats?.length !== 1 || caveats[0].type !== SnapCaveatType.SnapIds) {\n        throw rpcErrors.invalidParams({\n          message: `Expected a single \"${SnapCaveatType.SnapIds}\" caveat.`,\n        });\n      }\n    },\n    sideEffect: {\n      onPermitted: handleSnapInstall,\n    },\n  };\n};\n\nconst methodHooks: MethodHooksObject<InvokeSnapMethodHooks> = {\n  handleSnapRpcRequest: true,\n};\n\nexport const invokeSnapBuilder = Object.freeze({\n  targetName: WALLET_SNAP_PERMISSION_KEY,\n  specificationBuilder,\n  methodHooks,\n} as const);\n\n/**\n * Builds the method implementation for `wallet_snap_*`.\n *\n * @param hooks - The RPC method hooks.\n * @param hooks.handleSnapRpcRequest - A function that sends an RPC request to a snap's RPC handler or throws if that fails.\n * @returns The method implementation which returns the result of `handleSnapRpcRequest`.\n * @throws If the params are invalid.\n */\nexport function getInvokeSnapImplementation({\n  handleSnapRpcRequest,\n}: InvokeSnapMethodHooks) {\n  return async function invokeSnap(\n    options: RestrictedMethodOptions<InvokeSnapParams>,\n  ): Promise<InvokeSnapResult> {\n    const { params = {}, context } = options;\n\n    const { snapId, request } = params as InvokeSnapParams;\n\n    const { origin } = context;\n\n    return (await handleSnapRpcRequest({\n      snapId,\n      origin,\n      request,\n      handler: HandlerType.OnRpcRequest,\n    })) as Json;\n  };\n}\n"]}
\ No newline at end of file
