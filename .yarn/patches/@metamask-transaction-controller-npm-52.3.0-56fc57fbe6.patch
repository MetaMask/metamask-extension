diff --git a/dist/TransactionController.cjs b/dist/TransactionController.cjs
index c46bd8463907268ac5e2a762a04615d5c1371c20..817b21293437f055249e76cbb75ff4e348606a8c 100644
--- a/dist/TransactionController.cjs
+++ b/dist/TransactionController.cjs
@@ -334,12 +334,12 @@ class TransactionController extends base_controller_1.BaseController {
     /**
      * Determine which chains support atomic batch transactions with the given account address.
      *
-     * @param address - The address of the account to check.
-     * @returns  The supported chain IDs.
+     * @param request - Request object containing the account address and other parameters.
+     * @returns  Result object containing the supported chains and related information.
      */
-    async isAtomicBatchSupported(address) {
+    async isAtomicBatchSupported(request) {
         return (0, batch_1.isAtomicBatchSupported)({
-            address,
+            ...request,
             getEthQuery: (chainId) => __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_getEthQuery).call(this, { chainId }),
             messenger: this.messagingSystem,
             publicKeyEIP7702: __classPrivateFieldGet(this, _TransactionController_publicKeyEIP7702, "f"),
@@ -399,7 +399,7 @@ class TransactionController extends base_controller_1.BaseController {
         });
         const delegationAddressPromise = (0, eip7702_1.getDelegationAddress)(txParams.from, ethQuery).catch(() => undefined);
         const isEIP1559Compatible = await this.getEIP1559Compatibility(networkClientId);
-        (0, validation_1.validateTxParams)(txParams, isEIP1559Compatible);
+        (0, validation_1.validateTxParams)(txParams, isEIP1559Compatible, chainId);
         if (!txParams.type) {
             // Determine transaction type based on transaction parameters and network compatibility
             (0, utils_2.setEnvelopeType)(txParams, isEIP1559Compatible);
@@ -407,7 +407,7 @@ class TransactionController extends base_controller_1.BaseController {
         const isDuplicateBatchId = batchId?.length &&
             this.state.transactions.some((tx) => tx.batchId?.toLowerCase() === batchId?.toLowerCase());
         if (isDuplicateBatchId && origin && origin !== controller_utils_1.ORIGIN_METAMASK) {
-            throw rpc_errors_1.rpcErrors.invalidInput('Batch ID already exists');
+            throw new rpc_errors_1.JsonRpcError(validation_1.ErrorCode.DuplicateBundleId, 'Batch ID already exists');
         }
         const dappSuggestedGasFees = this.generateDappSuggestedGasFees(txParams, origin);
         const transactionType = type ?? (await (0, transaction_type_1.determineTransactionType)(txParams, ethQuery)).type;
@@ -2182,6 +2182,7 @@ _TransactionController_internalEvents = new WeakMap(), _TransactionController_me
         ethQuery,
         isCustomNetwork,
         isSimulationEnabled: __classPrivateFieldGet(this, _TransactionController_isSimulationEnabled, "f").call(this),
+        messenger: this.messagingSystem,
         txMeta: transactionMeta,
     });
 }, _TransactionController_deleteTransaction = function _TransactionController_deleteTransaction(transactionId) {
diff --git a/dist/TransactionController.d.cts b/dist/TransactionController.d.cts
index 713414992d9086fd5ac53856a75619c7ea797452..af58af2e81a2aaeb7b19ebea0ed233c23aac63d2 100644
--- a/dist/TransactionController.d.cts
+++ b/dist/TransactionController.d.cts
@@ -11,7 +11,7 @@ import type { NonceLock, Transaction as NonceTrackerTransaction } from "@metamas
 import type { RemoteFeatureFlagControllerGetStateAction } from "@metamask/remote-feature-flag-controller";
 import type { Hex } from "@metamask/utils";
 import type { IncomingTransactionOptions } from "./helpers/IncomingTransactionHelper.cjs";
-import type { SavedGasFees, SecurityProviderRequest, SendFlowHistoryEntry, TransactionParams, TransactionMeta, TransactionReceipt, WalletDevice, SecurityAlertResponse, GasFeeFlowResponse, GasPriceValue, FeeMarketEIP1559Values, SubmitHistoryEntry, TransactionBatchRequest, TransactionBatchResult, BatchTransactionParams, PublishHook, PublishBatchHook } from "./types.cjs";
+import type { SavedGasFees, SecurityProviderRequest, SendFlowHistoryEntry, TransactionParams, TransactionMeta, TransactionReceipt, WalletDevice, SecurityAlertResponse, GasFeeFlowResponse, GasPriceValue, FeeMarketEIP1559Values, SubmitHistoryEntry, TransactionBatchRequest, TransactionBatchResult, BatchTransactionParams, PublishHook, PublishBatchHook, IsAtomicBatchSupportedResult, IsAtomicBatchSupportedRequest } from "./types.cjs";
 import { TransactionType, TransactionStatus } from "./types.cjs";
 /**
  * Object with new transaction's meta and a promise resolving to the
@@ -393,10 +393,10 @@ export declare class TransactionController extends BaseController<typeof control
     /**
      * Determine which chains support atomic batch transactions with the given account address.
      *
-     * @param address - The address of the account to check.
-     * @returns  The supported chain IDs.
+     * @param request - Request object containing the account address and other parameters.
+     * @returns  Result object containing the supported chains and related information.
      */
-    isAtomicBatchSupported(address: Hex): Promise<Hex[]>;
+    isAtomicBatchSupported(request: IsAtomicBatchSupportedRequest): Promise<IsAtomicBatchSupportedResult>;
     /**
      * Add a new unapproved transaction to state. Parameters will be validated, a
      * unique transaction id will be generated, and gas and gasPrice will be calculated
diff --git a/dist/TransactionController.d.mts b/dist/TransactionController.d.mts
index c0f1dd6c6ba188a86a41a5c9af8de6474ad2c6ee..066a0b2646f523df4259eb1d080faef3fbcc3785 100644
--- a/dist/TransactionController.d.mts
+++ b/dist/TransactionController.d.mts
@@ -11,7 +11,7 @@ import type { NonceLock, Transaction as NonceTrackerTransaction } from "@metamas
 import type { RemoteFeatureFlagControllerGetStateAction } from "@metamask/remote-feature-flag-controller";
 import type { Hex } from "@metamask/utils";
 import type { IncomingTransactionOptions } from "./helpers/IncomingTransactionHelper.mjs";
-import type { SavedGasFees, SecurityProviderRequest, SendFlowHistoryEntry, TransactionParams, TransactionMeta, TransactionReceipt, WalletDevice, SecurityAlertResponse, GasFeeFlowResponse, GasPriceValue, FeeMarketEIP1559Values, SubmitHistoryEntry, TransactionBatchRequest, TransactionBatchResult, BatchTransactionParams, PublishHook, PublishBatchHook } from "./types.mjs";
+import type { SavedGasFees, SecurityProviderRequest, SendFlowHistoryEntry, TransactionParams, TransactionMeta, TransactionReceipt, WalletDevice, SecurityAlertResponse, GasFeeFlowResponse, GasPriceValue, FeeMarketEIP1559Values, SubmitHistoryEntry, TransactionBatchRequest, TransactionBatchResult, BatchTransactionParams, PublishHook, PublishBatchHook, IsAtomicBatchSupportedResult, IsAtomicBatchSupportedRequest } from "./types.mjs";
 import { TransactionType, TransactionStatus } from "./types.mjs";
 /**
  * Object with new transaction's meta and a promise resolving to the
@@ -393,10 +393,10 @@ export declare class TransactionController extends BaseController<typeof control
     /**
      * Determine which chains support atomic batch transactions with the given account address.
      *
-     * @param address - The address of the account to check.
-     * @returns  The supported chain IDs.
+     * @param request - Request object containing the account address and other parameters.
+     * @returns  Result object containing the supported chains and related information.
      */
-    isAtomicBatchSupported(address: Hex): Promise<Hex[]>;
+    isAtomicBatchSupported(request: IsAtomicBatchSupportedRequest): Promise<IsAtomicBatchSupportedResult>;
     /**
      * Add a new unapproved transaction to state. Parameters will be validated, a
      * unique transaction id will be generated, and gas and gasPrice will be calculated
diff --git a/dist/TransactionController.mjs b/dist/TransactionController.mjs
index 866bce89ab3c39ed2dc389b53a4fd220d014d8fb..186864d535d8a5feb98a5c2817896c351b37c7ba 100644
--- a/dist/TransactionController.mjs
+++ b/dist/TransactionController.mjs
@@ -22,7 +22,7 @@ import $EthQuery from "@metamask/eth-query";
 const EthQuery = $importDefault($EthQuery);
 import { NetworkClientType } from "@metamask/network-controller";
 import { NonceTracker } from "@metamask/nonce-tracker";
-import { errorCodes, rpcErrors, providerErrors } from "@metamask/rpc-errors";
+import { errorCodes, rpcErrors, providerErrors, JsonRpcError } from "@metamask/rpc-errors";
 import { add0x, hexToNumber, remove0x } from "@metamask/utils";
 // This package purposefully relies on Node's EventEmitter module.
 // eslint-disable-next-line import-x/no-nodejs-modules
@@ -62,7 +62,7 @@ import { getSimulationData } from "./utils/simulation.mjs";
 import { updatePostTransactionBalance, updateSwapsTransaction } from "./utils/swaps.mjs";
 import { determineTransactionType } from "./utils/transaction-type.mjs";
 import { normalizeTransactionParams, isEIP1559Transaction, validateGasValues, validateIfTransactionUnapproved, normalizeTxError, normalizeGasFeeValues, setEnvelopeType } from "./utils/utils.mjs";
-import { validateParamTo, validateTransactionOrigin, validateTxParams } from "./utils/validation.mjs";
+import { ErrorCode, validateParamTo, validateTransactionOrigin, validateTxParams } from "./utils/validation.mjs";
 /**
  * Metadata for the TransactionController state, describing how to "anonymize"
  * the state and which parts should be persisted.
@@ -336,12 +336,12 @@ export class TransactionController extends BaseController {
     /**
      * Determine which chains support atomic batch transactions with the given account address.
      *
-     * @param address - The address of the account to check.
-     * @returns  The supported chain IDs.
+     * @param request - Request object containing the account address and other parameters.
+     * @returns  Result object containing the supported chains and related information.
      */
-    async isAtomicBatchSupported(address) {
+    async isAtomicBatchSupported(request) {
         return isAtomicBatchSupported({
-            address,
+            ...request,
             getEthQuery: (chainId) => __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_getEthQuery).call(this, { chainId }),
             messenger: this.messagingSystem,
             publicKeyEIP7702: __classPrivateFieldGet(this, _TransactionController_publicKeyEIP7702, "f"),
@@ -401,7 +401,7 @@ export class TransactionController extends BaseController {
         });
         const delegationAddressPromise = getDelegationAddress(txParams.from, ethQuery).catch(() => undefined);
         const isEIP1559Compatible = await this.getEIP1559Compatibility(networkClientId);
-        validateTxParams(txParams, isEIP1559Compatible);
+        validateTxParams(txParams, isEIP1559Compatible, chainId);
         if (!txParams.type) {
             // Determine transaction type based on transaction parameters and network compatibility
             setEnvelopeType(txParams, isEIP1559Compatible);
@@ -409,7 +409,7 @@ export class TransactionController extends BaseController {
         const isDuplicateBatchId = batchId?.length &&
             this.state.transactions.some((tx) => tx.batchId?.toLowerCase() === batchId?.toLowerCase());
         if (isDuplicateBatchId && origin && origin !== ORIGIN_METAMASK) {
-            throw rpcErrors.invalidInput('Batch ID already exists');
+            throw new JsonRpcError(ErrorCode.DuplicateBundleId, 'Batch ID already exists');
         }
         const dappSuggestedGasFees = this.generateDappSuggestedGasFees(txParams, origin);
         const transactionType = type ?? (await determineTransactionType(txParams, ethQuery)).type;
@@ -2183,6 +2183,7 @@ _TransactionController_internalEvents = new WeakMap(), _TransactionController_me
         ethQuery,
         isCustomNetwork,
         isSimulationEnabled: __classPrivateFieldGet(this, _TransactionController_isSimulationEnabled, "f").call(this),
+        messenger: this.messagingSystem,
         txMeta: transactionMeta,
     });
 }, _TransactionController_deleteTransaction = function _TransactionController_deleteTransaction(transactionId) {
diff --git a/dist/constants.cjs b/dist/constants.cjs
index f98509f3bdb8243fc649e312d5442d54b28f05a6..7628bb1ee798a3922921b8ef452d4bb5cbd09bd9 100644
--- a/dist/constants.cjs
+++ b/dist/constants.cjs
@@ -1,6 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.ABI_IERC7821 = exports.ABI_SIMULATION_ERC721_LEGACY = exports.ABI_SIMULATION_ERC20_WRAPPED = exports.GAS_BUFFER_CHAIN_OVERRIDES = exports.CHAIN_IDS = void 0;
+exports.ABI_IERC7821 = exports.ABI_SIMULATION_ERC721_LEGACY = exports.ABI_SIMULATION_ERC20_WRAPPED = exports.CHAIN_IDS = void 0;
 exports.CHAIN_IDS = {
     MAINNET: '0x1',
     GOERLI: '0x5',
@@ -34,10 +34,6 @@ exports.CHAIN_IDS = {
     SCROLL_SEPOLIA: '0x8274f',
     MEGAETH_TESTNET: '0x18c6',
 };
-exports.GAS_BUFFER_CHAIN_OVERRIDES = {
-    [exports.CHAIN_IDS.OPTIMISM]: 1,
-    [exports.CHAIN_IDS.OPTIMISM_SEPOLIA]: 1,
-};
 /** Extract of the Wrapped ERC-20 ABI required for simulation. */
 exports.ABI_SIMULATION_ERC20_WRAPPED = [
     {
diff --git a/dist/constants.d.cts b/dist/constants.d.cts
index 8082d6dd26e39d31fcd8142a2033c2b76ee22932..47abbec964b6cf2ecfe2a8ad6a8a059eaa288aa0 100644
--- a/dist/constants.d.cts
+++ b/dist/constants.d.cts
@@ -31,10 +31,6 @@ export declare const CHAIN_IDS: {
     readonly SCROLL_SEPOLIA: "0x8274f";
     readonly MEGAETH_TESTNET: "0x18c6";
 };
-export declare const GAS_BUFFER_CHAIN_OVERRIDES: {
-    "0xa": number;
-    "0xaa37dc": number;
-};
 /** Extract of the Wrapped ERC-20 ABI required for simulation. */
 export declare const ABI_SIMULATION_ERC20_WRAPPED: {
     anonymous: boolean;
diff --git a/dist/constants.d.mts b/dist/constants.d.mts
index b62f188479dd6ea181b395286f78d5e9eb501c0e..ab649b7848acf6addc5670f1868ddf349c2f2c40 100644
--- a/dist/constants.d.mts
+++ b/dist/constants.d.mts
@@ -31,10 +31,6 @@ export declare const CHAIN_IDS: {
     readonly SCROLL_SEPOLIA: "0x8274f";
     readonly MEGAETH_TESTNET: "0x18c6";
 };
-export declare const GAS_BUFFER_CHAIN_OVERRIDES: {
-    "0xa": number;
-    "0xaa37dc": number;
-};
 /** Extract of the Wrapped ERC-20 ABI required for simulation. */
 export declare const ABI_SIMULATION_ERC20_WRAPPED: {
     anonymous: boolean;
diff --git a/dist/constants.mjs b/dist/constants.mjs
index 21c0af4e0d88942c47d22b74b5ac07377751bb6a..bfb1144959d3f356eba690384b87cccf5af17259 100644
--- a/dist/constants.mjs
+++ b/dist/constants.mjs
@@ -31,10 +31,6 @@ export const CHAIN_IDS = {
     SCROLL_SEPOLIA: '0x8274f',
     MEGAETH_TESTNET: '0x18c6',
 };
-export const GAS_BUFFER_CHAIN_OVERRIDES = {
-    [CHAIN_IDS.OPTIMISM]: 1,
-    [CHAIN_IDS.OPTIMISM_SEPOLIA]: 1,
-};
 /** Extract of the Wrapped ERC-20 ABI required for simulation. */
 export const ABI_SIMULATION_ERC20_WRAPPED = [
     {
diff --git a/dist/index.d.cts b/dist/index.d.cts
index dd5d172984cffb39bbde3d49aa72a23d85676e2a..577ff30dccd17738f867439bd52f9d2bdfbcd92b 100644
--- a/dist/index.d.cts
+++ b/dist/index.d.cts
@@ -1,6 +1,6 @@
 export type { MethodData, Result, TransactionControllerActions, TransactionControllerEvents, TransactionControllerGetStateAction, TransactionControllerIncomingTransactionsReceivedEvent, TransactionControllerPostTransactionBalanceUpdatedEvent, TransactionControllerSpeedupTransactionAddedEvent, TransactionControllerState, TransactionControllerStateChangeEvent, TransactionControllerTransactionApprovedEvent, TransactionControllerTransactionConfirmedEvent, TransactionControllerTransactionDroppedEvent, TransactionControllerTransactionFailedEvent, TransactionControllerTransactionFinishedEvent, TransactionControllerTransactionNewSwapApprovalEvent, TransactionControllerTransactionNewSwapEvent, TransactionControllerTransactionPublishingSkipped, TransactionControllerTransactionRejectedEvent, TransactionControllerTransactionStatusUpdatedEvent, TransactionControllerTransactionSubmittedEvent, TransactionControllerUnapprovedTransactionAddedEvent, TransactionControllerMessenger, TransactionControllerOptions, } from "./TransactionController.cjs";
 export { CANCEL_RATE, SPEED_UP_RATE, TransactionController, } from "./TransactionController.cjs";
-export type { Authorization, AuthorizationList, BatchTransactionParams, DappSuggestedGasFees, DefaultGasEstimates, FeeMarketEIP1559Values, FeeMarketGasFeeEstimateForLevel, FeeMarketGasFeeEstimates, GasFeeEstimates, GasFeeToken, GasPriceGasFeeEstimates, GasPriceValue, InferTransactionTypeResult, LegacyGasFeeEstimates, Log, NestedTransactionMetadata, PublishBatchHook, PublishBatchHookRequest, PublishBatchHookResult, PublishBatchHookTransaction, PublishHook, PublishHookResult, SavedGasFees, SecurityAlertResponse, SecurityProviderRequest, SendFlowHistoryEntry, SimulationBalanceChange, SimulationData, SimulationError, SimulationToken, SimulationTokenBalanceChange, TransactionBatchRequest, TransactionBatchResult, TransactionError, TransactionHistory, TransactionHistoryEntry, TransactionMeta, TransactionParams, TransactionReceipt, ValidateSecurityRequest, } from "./types.cjs";
+export type { Authorization, AuthorizationList, BatchTransactionParams, DappSuggestedGasFees, DefaultGasEstimates, FeeMarketEIP1559Values, FeeMarketGasFeeEstimateForLevel, FeeMarketGasFeeEstimates, GasFeeEstimates, GasFeeToken, GasPriceGasFeeEstimates, GasPriceValue, InferTransactionTypeResult, IsAtomicBatchSupportedRequest, IsAtomicBatchSupportedResult, IsAtomicBatchSupportedResultEntry, LegacyGasFeeEstimates, Log, NestedTransactionMetadata, PublishBatchHook, PublishBatchHookRequest, PublishBatchHookResult, PublishBatchHookTransaction, PublishHook, PublishHookResult, SavedGasFees, SecurityAlertResponse, SecurityProviderRequest, SendFlowHistoryEntry, SimulationBalanceChange, SimulationData, SimulationError, SimulationToken, SimulationTokenBalanceChange, TransactionBatchRequest, TransactionBatchResult, TransactionError, TransactionHistory, TransactionHistoryEntry, TransactionMeta, TransactionParams, TransactionReceipt, ValidateSecurityRequest, } from "./types.cjs";
 export { GasFeeEstimateLevel, GasFeeEstimateType, SimulationErrorCode, SimulationTokenStandard, TransactionEnvelopeType, TransactionStatus, TransactionType, UserFeeLevel, WalletDevice, } from "./types.cjs";
 export { DISPLAYED_TRANSACTION_HISTORY_PATHS, MAX_TRANSACTION_HISTORY_LENGTH, } from "./utils/history.cjs";
 export { determineTransactionType } from "./utils/transaction-type.cjs";
diff --git a/dist/index.d.mts b/dist/index.d.mts
index 5c295f0f6a0c137befbc86d7fe7e4fff7586b2b7..24ce4cdde5f76029496b5f36bee37f9fc471543d 100644
--- a/dist/index.d.mts
+++ b/dist/index.d.mts
@@ -1,6 +1,6 @@
 export type { MethodData, Result, TransactionControllerActions, TransactionControllerEvents, TransactionControllerGetStateAction, TransactionControllerIncomingTransactionsReceivedEvent, TransactionControllerPostTransactionBalanceUpdatedEvent, TransactionControllerSpeedupTransactionAddedEvent, TransactionControllerState, TransactionControllerStateChangeEvent, TransactionControllerTransactionApprovedEvent, TransactionControllerTransactionConfirmedEvent, TransactionControllerTransactionDroppedEvent, TransactionControllerTransactionFailedEvent, TransactionControllerTransactionFinishedEvent, TransactionControllerTransactionNewSwapApprovalEvent, TransactionControllerTransactionNewSwapEvent, TransactionControllerTransactionPublishingSkipped, TransactionControllerTransactionRejectedEvent, TransactionControllerTransactionStatusUpdatedEvent, TransactionControllerTransactionSubmittedEvent, TransactionControllerUnapprovedTransactionAddedEvent, TransactionControllerMessenger, TransactionControllerOptions, } from "./TransactionController.mjs";
 export { CANCEL_RATE, SPEED_UP_RATE, TransactionController, } from "./TransactionController.mjs";
-export type { Authorization, AuthorizationList, BatchTransactionParams, DappSuggestedGasFees, DefaultGasEstimates, FeeMarketEIP1559Values, FeeMarketGasFeeEstimateForLevel, FeeMarketGasFeeEstimates, GasFeeEstimates, GasFeeToken, GasPriceGasFeeEstimates, GasPriceValue, InferTransactionTypeResult, LegacyGasFeeEstimates, Log, NestedTransactionMetadata, PublishBatchHook, PublishBatchHookRequest, PublishBatchHookResult, PublishBatchHookTransaction, PublishHook, PublishHookResult, SavedGasFees, SecurityAlertResponse, SecurityProviderRequest, SendFlowHistoryEntry, SimulationBalanceChange, SimulationData, SimulationError, SimulationToken, SimulationTokenBalanceChange, TransactionBatchRequest, TransactionBatchResult, TransactionError, TransactionHistory, TransactionHistoryEntry, TransactionMeta, TransactionParams, TransactionReceipt, ValidateSecurityRequest, } from "./types.mjs";
+export type { Authorization, AuthorizationList, BatchTransactionParams, DappSuggestedGasFees, DefaultGasEstimates, FeeMarketEIP1559Values, FeeMarketGasFeeEstimateForLevel, FeeMarketGasFeeEstimates, GasFeeEstimates, GasFeeToken, GasPriceGasFeeEstimates, GasPriceValue, InferTransactionTypeResult, IsAtomicBatchSupportedRequest, IsAtomicBatchSupportedResult, IsAtomicBatchSupportedResultEntry, LegacyGasFeeEstimates, Log, NestedTransactionMetadata, PublishBatchHook, PublishBatchHookRequest, PublishBatchHookResult, PublishBatchHookTransaction, PublishHook, PublishHookResult, SavedGasFees, SecurityAlertResponse, SecurityProviderRequest, SendFlowHistoryEntry, SimulationBalanceChange, SimulationData, SimulationError, SimulationToken, SimulationTokenBalanceChange, TransactionBatchRequest, TransactionBatchResult, TransactionError, TransactionHistory, TransactionHistoryEntry, TransactionMeta, TransactionParams, TransactionReceipt, ValidateSecurityRequest, } from "./types.mjs";
 export { GasFeeEstimateLevel, GasFeeEstimateType, SimulationErrorCode, SimulationTokenStandard, TransactionEnvelopeType, TransactionStatus, TransactionType, UserFeeLevel, WalletDevice, } from "./types.mjs";
 export { DISPLAYED_TRANSACTION_HISTORY_PATHS, MAX_TRANSACTION_HISTORY_LENGTH, } from "./utils/history.mjs";
 export { determineTransactionType } from "./utils/transaction-type.mjs";
diff --git a/dist/types.d.cts b/dist/types.d.cts
index 0b709a5f4e5a941ab770ea2ced7fce96e7d9abd3..94c5504d22bca3131be24fbdb29fab635364da9c 100644
--- a/dist/types.d.cts
+++ b/dist/types.d.cts
@@ -613,6 +613,9 @@ export type TransactionParams = {
     authorizationList?: AuthorizationList;
     /**
      * Network ID as per EIP-155.
+     *
+     * @deprecated Ignored.
+     * Use `networkClientId` when calling `addTransaction`.
      */
     chainId?: Hex;
     /**
@@ -1345,5 +1348,28 @@ export type GasFeeToken = {
     /** Address of the token contract. */
     tokenAddress: Hex;
 };
+/** Request to check if atomic batch is supported for an account. */
+export type IsAtomicBatchSupportedRequest = {
+    /** Address of the account to check. */
+    address: Hex;
+    /**
+     * IDs of specific chains to check.
+     * If not provided, all supported chains will be checked.
+     */
+    chainIds?: Hex[];
+};
+/** Result of checking if atomic batch is supported for an account. */
+export type IsAtomicBatchSupportedResult = IsAtomicBatchSupportedResultEntry[];
+/** Info about atomic batch support for a single chain. */
+export type IsAtomicBatchSupportedResultEntry = {
+    /** ID of the chain. */
+    chainId: Hex;
+    /** Address of the contract that the account was upgraded to. */
+    delegationAddress?: Hex;
+    /** Whether the upgraded contract is supported. */
+    isSupported: boolean;
+    /** Address of the contract that the account would be upgraded to. */
+    upgradeContractAddress?: Hex;
+};
 export {};
 //# sourceMappingURL=types.d.cts.map
\ No newline at end of file
diff --git a/dist/types.d.mts b/dist/types.d.mts
index 17f5366caba8fa9a388b79ee46d617425a9c2728..e43adcecc7d406e4203ee998163f9c2b31b7e6f8 100644
--- a/dist/types.d.mts
+++ b/dist/types.d.mts
@@ -613,6 +613,9 @@ export type TransactionParams = {
     authorizationList?: AuthorizationList;
     /**
      * Network ID as per EIP-155.
+     *
+     * @deprecated Ignored.
+     * Use `networkClientId` when calling `addTransaction`.
      */
     chainId?: Hex;
     /**
@@ -1345,5 +1348,28 @@ export type GasFeeToken = {
     /** Address of the token contract. */
     tokenAddress: Hex;
 };
+/** Request to check if atomic batch is supported for an account. */
+export type IsAtomicBatchSupportedRequest = {
+    /** Address of the account to check. */
+    address: Hex;
+    /**
+     * IDs of specific chains to check.
+     * If not provided, all supported chains will be checked.
+     */
+    chainIds?: Hex[];
+};
+/** Result of checking if atomic batch is supported for an account. */
+export type IsAtomicBatchSupportedResult = IsAtomicBatchSupportedResultEntry[];
+/** Info about atomic batch support for a single chain. */
+export type IsAtomicBatchSupportedResultEntry = {
+    /** ID of the chain. */
+    chainId: Hex;
+    /** Address of the contract that the account was upgraded to. */
+    delegationAddress?: Hex;
+    /** Whether the upgraded contract is supported. */
+    isSupported: boolean;
+    /** Address of the contract that the account would be upgraded to. */
+    upgradeContractAddress?: Hex;
+};
 export {};
 //# sourceMappingURL=types.d.mts.map
\ No newline at end of file
diff --git a/dist/utils/batch.cjs b/dist/utils/batch.cjs
index ac9ea2743fb008b11821967a93ec62c266294e97..e8a4232f60e47942182a9275f96e92ce286dd245 100644
--- a/dist/utils/batch.cjs
+++ b/dist/utils/batch.cjs
@@ -105,21 +105,25 @@ exports.addTransactionBatch = addTransactionBatch;
  * @returns The chain IDs that support atomic batch transactions.
  */
 async function isAtomicBatchSupported(request) {
-    const { address, getEthQuery, messenger, publicKeyEIP7702: publicKey, } = request;
+    const { address, chainIds, getEthQuery, messenger, publicKeyEIP7702: publicKey, } = request;
     if (!publicKey) {
         throw rpc_errors_1.rpcErrors.internal('EIP-7702 public key not specified');
     }
     const chainIds7702 = (0, feature_flags_1.getEIP7702SupportedChains)(messenger);
-    const chainIds = [];
-    for (const chainId of chainIds7702) {
+    const filteredChainIds = chainIds7702.filter((chainId) => !chainIds || chainIds.includes(chainId));
+    const results = await Promise.all(filteredChainIds.map(async (chainId) => {
         const ethQuery = getEthQuery(chainId);
         const { isSupported, delegationAddress } = await (0, eip7702_1.isAccountUpgradedToEIP7702)(address, chainId, publicKey, messenger, ethQuery);
-        if (!delegationAddress || isSupported) {
-            chainIds.push(chainId);
-        }
-    }
-    log('Atomic batch supported chains', chainIds);
-    return chainIds;
+        const upgradeContractAddress = (0, feature_flags_1.getEIP7702UpgradeContractAddress)(chainId, messenger, publicKey);
+        return {
+            chainId,
+            delegationAddress,
+            isSupported,
+            upgradeContractAddress,
+        };
+    }));
+    log('Atomic batch supported results', results);
+    return results;
 }
 exports.isAtomicBatchSupported = isAtomicBatchSupported;
 /**
diff --git a/dist/utils/batch.d.cts b/dist/utils/batch.d.cts
index f7fcbecc94c9ab99d8ceecf79dae44014830ad0b..211870434058047b2a2a6f5c6718680498a2ec77 100644
--- a/dist/utils/batch.d.cts
+++ b/dist/utils/batch.d.cts
@@ -1,7 +1,7 @@
 import type EthQuery from "@metamask/eth-query";
 import type { Hex } from "@metamask/utils";
 import { type TransactionController, type TransactionControllerMessenger, type TransactionMeta } from "../index.cjs";
-import type { PublishBatchHook, TransactionBatchRequest } from "../types.cjs";
+import type { PublishBatchHook, TransactionBatchRequest, IsAtomicBatchSupportedResult } from "../types.cjs";
 import { type TransactionBatchResult } from "../types.cjs";
 type AddTransactionBatchRequest = {
     addTransaction: TransactionController['addTransaction'];
@@ -17,8 +17,9 @@ type AddTransactionBatchRequest = {
         transactionId: string;
     }, callback: (transactionMeta: TransactionMeta) => void) => void;
 };
-type IsAtomicBatchSupportedRequest = {
+type IsAtomicBatchSupportedRequestInternal = {
     address: Hex;
+    chainIds?: Hex[];
     getEthQuery: (chainId: Hex) => EthQuery;
     messenger: TransactionControllerMessenger;
     publicKeyEIP7702?: Hex;
@@ -36,6 +37,6 @@ export declare function addTransactionBatch(request: AddTransactionBatchRequest)
  * @param request - The request object including the account address and necessary callbacks.
  * @returns The chain IDs that support atomic batch transactions.
  */
-export declare function isAtomicBatchSupported(request: IsAtomicBatchSupportedRequest): Promise<Hex[]>;
+export declare function isAtomicBatchSupported(request: IsAtomicBatchSupportedRequestInternal): Promise<IsAtomicBatchSupportedResult>;
 export {};
 //# sourceMappingURL=batch.d.cts.map
\ No newline at end of file
diff --git a/dist/utils/batch.d.mts b/dist/utils/batch.d.mts
index db1e8ff8b906acfd7eea6d73e66693efeacdc2d1..6829f6b09f9b7629d5203da5662aa7ab4ae3d3fb 100644
--- a/dist/utils/batch.d.mts
+++ b/dist/utils/batch.d.mts
@@ -1,7 +1,7 @@
 import type EthQuery from "@metamask/eth-query";
 import type { Hex } from "@metamask/utils";
 import { type TransactionController, type TransactionControllerMessenger, type TransactionMeta } from "../index.mjs";
-import type { PublishBatchHook, TransactionBatchRequest } from "../types.mjs";
+import type { PublishBatchHook, TransactionBatchRequest, IsAtomicBatchSupportedResult } from "../types.mjs";
 import { type TransactionBatchResult } from "../types.mjs";
 type AddTransactionBatchRequest = {
     addTransaction: TransactionController['addTransaction'];
@@ -17,8 +17,9 @@ type AddTransactionBatchRequest = {
         transactionId: string;
     }, callback: (transactionMeta: TransactionMeta) => void) => void;
 };
-type IsAtomicBatchSupportedRequest = {
+type IsAtomicBatchSupportedRequestInternal = {
     address: Hex;
+    chainIds?: Hex[];
     getEthQuery: (chainId: Hex) => EthQuery;
     messenger: TransactionControllerMessenger;
     publicKeyEIP7702?: Hex;
@@ -36,6 +37,6 @@ export declare function addTransactionBatch(request: AddTransactionBatchRequest)
  * @param request - The request object including the account address and necessary callbacks.
  * @returns The chain IDs that support atomic batch transactions.
  */
-export declare function isAtomicBatchSupported(request: IsAtomicBatchSupportedRequest): Promise<Hex[]>;
+export declare function isAtomicBatchSupported(request: IsAtomicBatchSupportedRequestInternal): Promise<IsAtomicBatchSupportedResult>;
 export {};
 //# sourceMappingURL=batch.d.mts.map
\ No newline at end of file
diff --git a/dist/utils/batch.mjs b/dist/utils/batch.mjs
index a98e695fe5671da4deff8d7620462acd73f2a451..03809bc22f70210fac114c0d372a8df850cf1d47 100644
--- a/dist/utils/batch.mjs
+++ b/dist/utils/batch.mjs
@@ -101,21 +101,25 @@ export async function addTransactionBatch(request) {
  * @returns The chain IDs that support atomic batch transactions.
  */
 export async function isAtomicBatchSupported(request) {
-    const { address, getEthQuery, messenger, publicKeyEIP7702: publicKey, } = request;
+    const { address, chainIds, getEthQuery, messenger, publicKeyEIP7702: publicKey, } = request;
     if (!publicKey) {
         throw rpcErrors.internal('EIP-7702 public key not specified');
     }
     const chainIds7702 = getEIP7702SupportedChains(messenger);
-    const chainIds = [];
-    for (const chainId of chainIds7702) {
+    const filteredChainIds = chainIds7702.filter((chainId) => !chainIds || chainIds.includes(chainId));
+    const results = await Promise.all(filteredChainIds.map(async (chainId) => {
         const ethQuery = getEthQuery(chainId);
         const { isSupported, delegationAddress } = await isAccountUpgradedToEIP7702(address, chainId, publicKey, messenger, ethQuery);
-        if (!delegationAddress || isSupported) {
-            chainIds.push(chainId);
-        }
-    }
-    log('Atomic batch supported chains', chainIds);
-    return chainIds;
+        const upgradeContractAddress = getEIP7702UpgradeContractAddress(chainId, messenger, publicKey);
+        return {
+            chainId,
+            delegationAddress,
+            isSupported,
+            upgradeContractAddress,
+        };
+    }));
+    log('Atomic batch supported results', results);
+    return results;
 }
 /**
  * Generate a tranasction batch ID.
diff --git a/dist/utils/feature-flags.cjs b/dist/utils/feature-flags.cjs
index 1df8d0899cf69070528ab89756730913e9c4b2bb..248d5dc622fbbe0b23163bc0caa8fdedd7afbca9 100644
--- a/dist/utils/feature-flags.cjs
+++ b/dist/utils/feature-flags.cjs
@@ -1,15 +1,23 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.getGasFeeRandomisation = exports.getAcceleratedPollingParams = exports.getBatchSizeLimit = exports.getEIP7702UpgradeContractAddress = exports.getEIP7702ContractAddresses = exports.getEIP7702SupportedChains = exports.FEATURE_FLAG_EIP_7702 = exports.FEATURE_FLAG_TRANSACTIONS = void 0;
+exports.getGasEstimateBuffer = exports.getGasFeeRandomisation = exports.getAcceleratedPollingParams = exports.getBatchSizeLimit = exports.getEIP7702UpgradeContractAddress = exports.getEIP7702ContractAddresses = exports.getEIP7702SupportedChains = exports.FeatureFlag = void 0;
 const utils_1 = require("@metamask/utils");
 const signature_1 = require("./signature.cjs");
 const utils_2 = require("./utils.cjs");
 const logger_1 = require("../logger.cjs");
-exports.FEATURE_FLAG_TRANSACTIONS = 'confirmations_transactions';
-exports.FEATURE_FLAG_EIP_7702 = 'confirmations_eip_7702';
 const DEFAULT_BATCH_SIZE_LIMIT = 10;
 const DEFAULT_ACCELERATED_POLLING_COUNT_MAX = 10;
 const DEFAULT_ACCELERATED_POLLING_INTERVAL_MS = 3 * 1000;
+const DEFAULT_GAS_ESTIMATE_BUFFER = 1;
+/**
+ * Feature flags supporting the transaction controller.
+ */
+var FeatureFlag;
+(function (FeatureFlag) {
+    FeatureFlag["EIP7702"] = "confirmations_eip_7702";
+    FeatureFlag["GasBuffer"] = "confirmations_gas_buffer";
+    FeatureFlag["Transactions"] = "confirmations_transactions";
+})(FeatureFlag || (exports.FeatureFlag = FeatureFlag = {}));
 const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'feature-flags');
 /**
  * Retrieves the supported EIP-7702 chains.
@@ -19,7 +27,7 @@ const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'feature-fla
  */
 function getEIP7702SupportedChains(messenger) {
     const featureFlags = getFeatureFlags(messenger);
-    return featureFlags?.[exports.FEATURE_FLAG_EIP_7702]?.supportedChains ?? [];
+    return featureFlags?.[FeatureFlag.EIP7702]?.supportedChains ?? [];
 }
 exports.getEIP7702SupportedChains = getEIP7702SupportedChains;
 /**
@@ -32,7 +40,7 @@ exports.getEIP7702SupportedChains = getEIP7702SupportedChains;
  */
 function getEIP7702ContractAddresses(chainId, messenger, publicKey) {
     const featureFlags = getFeatureFlags(messenger);
-    const contracts = featureFlags?.[exports.FEATURE_FLAG_EIP_7702]?.contracts?.[chainId.toLowerCase()] ?? [];
+    const contracts = featureFlags?.[FeatureFlag.EIP7702]?.contracts?.[chainId.toLowerCase()] ?? [];
     return contracts
         .filter((contract) => (0, signature_1.isValidSignature)([contract.address, (0, utils_2.padHexToEvenLength)(chainId)], contract.signature, publicKey))
         .map((contract) => contract.address);
@@ -59,7 +67,7 @@ exports.getEIP7702UpgradeContractAddress = getEIP7702UpgradeContractAddress;
  */
 function getBatchSizeLimit(messenger) {
     const featureFlags = getFeatureFlags(messenger);
-    return (featureFlags?.[exports.FEATURE_FLAG_TRANSACTIONS]?.batchSizeLimit ??
+    return (featureFlags?.[FeatureFlag.Transactions]?.batchSizeLimit ??
         DEFAULT_BATCH_SIZE_LIMIT);
 }
 exports.getBatchSizeLimit = getBatchSizeLimit;
@@ -72,7 +80,7 @@ exports.getBatchSizeLimit = getBatchSizeLimit;
  */
 function getAcceleratedPollingParams(chainId, messenger) {
     const featureFlags = getFeatureFlags(messenger);
-    const acceleratedPollingParams = featureFlags?.[exports.FEATURE_FLAG_TRANSACTIONS]?.acceleratedPolling;
+    const acceleratedPollingParams = featureFlags?.[FeatureFlag.Transactions]?.acceleratedPolling;
     const countMax = acceleratedPollingParams?.perChainConfig?.[chainId]?.countMax ||
         acceleratedPollingParams?.defaultCountMax ||
         DEFAULT_ACCELERATED_POLLING_COUNT_MAX;
@@ -90,13 +98,42 @@ exports.getAcceleratedPollingParams = getAcceleratedPollingParams;
  */
 function getGasFeeRandomisation(messenger) {
     const featureFlags = getFeatureFlags(messenger);
-    const gasFeeRandomisation = featureFlags?.[exports.FEATURE_FLAG_TRANSACTIONS]?.gasFeeRandomisation || {};
+    const gasFeeRandomisation = featureFlags?.[FeatureFlag.Transactions]?.gasFeeRandomisation || {};
     return {
         randomisedGasFeeDigits: gasFeeRandomisation.randomisedGasFeeDigits || {},
         preservedNumberOfDigits: gasFeeRandomisation.preservedNumberOfDigits,
     };
 }
 exports.getGasFeeRandomisation = getGasFeeRandomisation;
+/**
+ * Retrieves the gas buffers for a given chain ID.
+ *
+ * @param request - The request object.
+ * @param request.chainId - The chain ID.
+ * @param request.isCustomRPC - Whether the network RPC is added by the user.
+ * @param request.isUpgradeWithDataToSelf - Whether the transaction is an EIP-7702 upgrade with data to self.
+ * @param request.messenger - The controller messenger instance.
+ * @returns The gas buffers.
+ */
+function getGasEstimateBuffer({ chainId, isCustomRPC, isUpgradeWithDataToSelf, messenger, }) {
+    const featureFlags = getFeatureFlags(messenger);
+    const gasBufferFlags = featureFlags?.[FeatureFlag.GasBuffer];
+    const chainFlags = gasBufferFlags?.perChainConfig?.[chainId];
+    const chainIncludedRPCBuffer = isCustomRPC ? undefined : chainFlags?.included;
+    const defaultIncludedRPCBuffer = isCustomRPC
+        ? undefined
+        : gasBufferFlags?.included;
+    const upgradeBuffer = isUpgradeWithDataToSelf
+        ? chainFlags?.eip7702
+        : undefined;
+    return (upgradeBuffer ??
+        chainIncludedRPCBuffer ??
+        chainFlags?.base ??
+        defaultIncludedRPCBuffer ??
+        gasBufferFlags?.default ??
+        DEFAULT_GAS_ESTIMATE_BUFFER);
+}
+exports.getGasEstimateBuffer = getGasEstimateBuffer;
 /**
  * Retrieves the relevant feature flags from the remote feature flag controller.
  *
diff --git a/dist/utils/feature-flags.d.cts b/dist/utils/feature-flags.d.cts
index 0964f4bacccc02872d5bd942f59e91cf0ffbf709..d99fb63156e793980f484e890510aa47c3030bd8 100644
--- a/dist/utils/feature-flags.d.cts
+++ b/dist/utils/feature-flags.d.cts
@@ -1,9 +1,16 @@
 import { type Hex } from "@metamask/utils";
 import type { TransactionControllerMessenger } from "../TransactionController.cjs";
-export declare const FEATURE_FLAG_TRANSACTIONS = "confirmations_transactions";
-export declare const FEATURE_FLAG_EIP_7702 = "confirmations_eip_7702";
+/**
+ * Feature flags supporting the transaction controller.
+ */
+export declare enum FeatureFlag {
+    EIP7702 = "confirmations_eip_7702",
+    GasBuffer = "confirmations_gas_buffer",
+    Transactions = "confirmations_transactions"
+}
 export type TransactionControllerFeatureFlags = {
-    [FEATURE_FLAG_EIP_7702]?: {
+    /** Feature flags to support EIP-7702 / type-4 transactions. */
+    [FeatureFlag.EIP7702]?: {
         /**
          * All contracts that support EIP-7702 batch transactions.
          * Keyed by chain ID.
@@ -18,16 +25,51 @@ export type TransactionControllerFeatureFlags = {
         /** Chains enabled for EIP-7702 batch transactions. */
         supportedChains?: Hex[];
     };
-    [FEATURE_FLAG_TRANSACTIONS]?: {
+    /**
+     * Buffers added to gas limit estimations.
+     * Values are multipliers such as `1.5` meaning 150% of the original gas limit.
+     */
+    [FeatureFlag.GasBuffer]?: {
+        /** Fallback buffer for all chains and transactions. */
+        default?: number;
+        /**
+         * Buffer for included network RPCs only and not those added by user.
+         * Takes priority over `default`.
+         */
+        included?: number;
+        /** Buffers for specific chains. */
+        perChainConfig?: {
+            [chainId: Hex]: {
+                /**
+                 * Buffer for the chain for all transactions.
+                 * Takes priority over non-chain `included`.
+                 */
+                base?: number;
+                /**
+                 * Buffer if network RPC is included and not added by user.
+                 * Takes priority over `base`.
+                 */
+                included?: number;
+                /**
+                 * Buffer for the chain for EIP-7702 / type 4 transactions only.
+                 * Only if `data` included and `to` matches `from`.
+                 * Takes priority over `included` and `base`.
+                 */
+                eip7702?: number;
+            };
+        };
+    };
+    /** Miscellaneous feature flags to support the transaction controller. */
+    [FeatureFlag.Transactions]?: {
         /** Maximum number of transactions that can be in an external batch. */
         batchSizeLimit?: number;
+        /**
+         * Accelerated polling is used to speed up the polling process for
+         * transactions that are not yet confirmed.
+         */
         acceleratedPolling?: {
-            /**
-             * Accelerated polling is used to speed up the polling process for
-             * transactions that are not yet confirmed.
-             */
+            /** Accelerated polling parameters on a per-chain basis. */
             perChainConfig?: {
-                /** Accelerated polling parameters on a per-chain basis. */
                 [chainId: Hex]: {
                     /**
                      * Maximum number of polling requests that can be made in a row, before
@@ -105,4 +147,20 @@ export declare function getGasFeeRandomisation(messenger: TransactionControllerM
     randomisedGasFeeDigits: Record<Hex, number>;
     preservedNumberOfDigits: number | undefined;
 };
+/**
+ * Retrieves the gas buffers for a given chain ID.
+ *
+ * @param request - The request object.
+ * @param request.chainId - The chain ID.
+ * @param request.isCustomRPC - Whether the network RPC is added by the user.
+ * @param request.isUpgradeWithDataToSelf - Whether the transaction is an EIP-7702 upgrade with data to self.
+ * @param request.messenger - The controller messenger instance.
+ * @returns The gas buffers.
+ */
+export declare function getGasEstimateBuffer({ chainId, isCustomRPC, isUpgradeWithDataToSelf, messenger, }: {
+    chainId: Hex;
+    isCustomRPC: boolean;
+    isUpgradeWithDataToSelf: boolean;
+    messenger: TransactionControllerMessenger;
+}): number;
 //# sourceMappingURL=feature-flags.d.cts.map
\ No newline at end of file
diff --git a/dist/utils/feature-flags.d.mts b/dist/utils/feature-flags.d.mts
index 2b197afd66708162e463abb34031061f3bb18f5c..531c758dc6a90627468670b45361d3a85428e822 100644
--- a/dist/utils/feature-flags.d.mts
+++ b/dist/utils/feature-flags.d.mts
@@ -1,9 +1,16 @@
 import { type Hex } from "@metamask/utils";
 import type { TransactionControllerMessenger } from "../TransactionController.mjs";
-export declare const FEATURE_FLAG_TRANSACTIONS = "confirmations_transactions";
-export declare const FEATURE_FLAG_EIP_7702 = "confirmations_eip_7702";
+/**
+ * Feature flags supporting the transaction controller.
+ */
+export declare enum FeatureFlag {
+    EIP7702 = "confirmations_eip_7702",
+    GasBuffer = "confirmations_gas_buffer",
+    Transactions = "confirmations_transactions"
+}
 export type TransactionControllerFeatureFlags = {
-    [FEATURE_FLAG_EIP_7702]?: {
+    /** Feature flags to support EIP-7702 / type-4 transactions. */
+    [FeatureFlag.EIP7702]?: {
         /**
          * All contracts that support EIP-7702 batch transactions.
          * Keyed by chain ID.
@@ -18,16 +25,51 @@ export type TransactionControllerFeatureFlags = {
         /** Chains enabled for EIP-7702 batch transactions. */
         supportedChains?: Hex[];
     };
-    [FEATURE_FLAG_TRANSACTIONS]?: {
+    /**
+     * Buffers added to gas limit estimations.
+     * Values are multipliers such as `1.5` meaning 150% of the original gas limit.
+     */
+    [FeatureFlag.GasBuffer]?: {
+        /** Fallback buffer for all chains and transactions. */
+        default?: number;
+        /**
+         * Buffer for included network RPCs only and not those added by user.
+         * Takes priority over `default`.
+         */
+        included?: number;
+        /** Buffers for specific chains. */
+        perChainConfig?: {
+            [chainId: Hex]: {
+                /**
+                 * Buffer for the chain for all transactions.
+                 * Takes priority over non-chain `included`.
+                 */
+                base?: number;
+                /**
+                 * Buffer if network RPC is included and not added by user.
+                 * Takes priority over `base`.
+                 */
+                included?: number;
+                /**
+                 * Buffer for the chain for EIP-7702 / type 4 transactions only.
+                 * Only if `data` included and `to` matches `from`.
+                 * Takes priority over `included` and `base`.
+                 */
+                eip7702?: number;
+            };
+        };
+    };
+    /** Miscellaneous feature flags to support the transaction controller. */
+    [FeatureFlag.Transactions]?: {
         /** Maximum number of transactions that can be in an external batch. */
         batchSizeLimit?: number;
+        /**
+         * Accelerated polling is used to speed up the polling process for
+         * transactions that are not yet confirmed.
+         */
         acceleratedPolling?: {
-            /**
-             * Accelerated polling is used to speed up the polling process for
-             * transactions that are not yet confirmed.
-             */
+            /** Accelerated polling parameters on a per-chain basis. */
             perChainConfig?: {
-                /** Accelerated polling parameters on a per-chain basis. */
                 [chainId: Hex]: {
                     /**
                      * Maximum number of polling requests that can be made in a row, before
@@ -105,4 +147,20 @@ export declare function getGasFeeRandomisation(messenger: TransactionControllerM
     randomisedGasFeeDigits: Record<Hex, number>;
     preservedNumberOfDigits: number | undefined;
 };
+/**
+ * Retrieves the gas buffers for a given chain ID.
+ *
+ * @param request - The request object.
+ * @param request.chainId - The chain ID.
+ * @param request.isCustomRPC - Whether the network RPC is added by the user.
+ * @param request.isUpgradeWithDataToSelf - Whether the transaction is an EIP-7702 upgrade with data to self.
+ * @param request.messenger - The controller messenger instance.
+ * @returns The gas buffers.
+ */
+export declare function getGasEstimateBuffer({ chainId, isCustomRPC, isUpgradeWithDataToSelf, messenger, }: {
+    chainId: Hex;
+    isCustomRPC: boolean;
+    isUpgradeWithDataToSelf: boolean;
+    messenger: TransactionControllerMessenger;
+}): number;
 //# sourceMappingURL=feature-flags.d.mts.map
\ No newline at end of file
diff --git a/dist/utils/feature-flags.mjs b/dist/utils/feature-flags.mjs
index 2b50654f117bdbe06337036b1f31d1400ca12f62..e1a4ceb62e906632c4de3346cee394b781941fec 100644
--- a/dist/utils/feature-flags.mjs
+++ b/dist/utils/feature-flags.mjs
@@ -2,11 +2,19 @@ import { createModuleLogger } from "@metamask/utils";
 import { isValidSignature } from "./signature.mjs";
 import { padHexToEvenLength } from "./utils.mjs";
 import { projectLogger } from "../logger.mjs";
-export const FEATURE_FLAG_TRANSACTIONS = 'confirmations_transactions';
-export const FEATURE_FLAG_EIP_7702 = 'confirmations_eip_7702';
 const DEFAULT_BATCH_SIZE_LIMIT = 10;
 const DEFAULT_ACCELERATED_POLLING_COUNT_MAX = 10;
 const DEFAULT_ACCELERATED_POLLING_INTERVAL_MS = 3 * 1000;
+const DEFAULT_GAS_ESTIMATE_BUFFER = 1;
+/**
+ * Feature flags supporting the transaction controller.
+ */
+export var FeatureFlag;
+(function (FeatureFlag) {
+    FeatureFlag["EIP7702"] = "confirmations_eip_7702";
+    FeatureFlag["GasBuffer"] = "confirmations_gas_buffer";
+    FeatureFlag["Transactions"] = "confirmations_transactions";
+})(FeatureFlag || (FeatureFlag = {}));
 const log = createModuleLogger(projectLogger, 'feature-flags');
 /**
  * Retrieves the supported EIP-7702 chains.
@@ -16,7 +24,7 @@ const log = createModuleLogger(projectLogger, 'feature-flags');
  */
 export function getEIP7702SupportedChains(messenger) {
     const featureFlags = getFeatureFlags(messenger);
-    return featureFlags?.[FEATURE_FLAG_EIP_7702]?.supportedChains ?? [];
+    return featureFlags?.[FeatureFlag.EIP7702]?.supportedChains ?? [];
 }
 /**
  * Retrieves the supported EIP-7702 contract addresses for a given chain ID.
@@ -28,7 +36,7 @@ export function getEIP7702SupportedChains(messenger) {
  */
 export function getEIP7702ContractAddresses(chainId, messenger, publicKey) {
     const featureFlags = getFeatureFlags(messenger);
-    const contracts = featureFlags?.[FEATURE_FLAG_EIP_7702]?.contracts?.[chainId.toLowerCase()] ?? [];
+    const contracts = featureFlags?.[FeatureFlag.EIP7702]?.contracts?.[chainId.toLowerCase()] ?? [];
     return contracts
         .filter((contract) => isValidSignature([contract.address, padHexToEvenLength(chainId)], contract.signature, publicKey))
         .map((contract) => contract.address);
@@ -53,7 +61,7 @@ export function getEIP7702UpgradeContractAddress(chainId, messenger, publicKey)
  */
 export function getBatchSizeLimit(messenger) {
     const featureFlags = getFeatureFlags(messenger);
-    return (featureFlags?.[FEATURE_FLAG_TRANSACTIONS]?.batchSizeLimit ??
+    return (featureFlags?.[FeatureFlag.Transactions]?.batchSizeLimit ??
         DEFAULT_BATCH_SIZE_LIMIT);
 }
 /**
@@ -65,7 +73,7 @@ export function getBatchSizeLimit(messenger) {
  */
 export function getAcceleratedPollingParams(chainId, messenger) {
     const featureFlags = getFeatureFlags(messenger);
-    const acceleratedPollingParams = featureFlags?.[FEATURE_FLAG_TRANSACTIONS]?.acceleratedPolling;
+    const acceleratedPollingParams = featureFlags?.[FeatureFlag.Transactions]?.acceleratedPolling;
     const countMax = acceleratedPollingParams?.perChainConfig?.[chainId]?.countMax ||
         acceleratedPollingParams?.defaultCountMax ||
         DEFAULT_ACCELERATED_POLLING_COUNT_MAX;
@@ -82,12 +90,40 @@ export function getAcceleratedPollingParams(chainId, messenger) {
  */
 export function getGasFeeRandomisation(messenger) {
     const featureFlags = getFeatureFlags(messenger);
-    const gasFeeRandomisation = featureFlags?.[FEATURE_FLAG_TRANSACTIONS]?.gasFeeRandomisation || {};
+    const gasFeeRandomisation = featureFlags?.[FeatureFlag.Transactions]?.gasFeeRandomisation || {};
     return {
         randomisedGasFeeDigits: gasFeeRandomisation.randomisedGasFeeDigits || {},
         preservedNumberOfDigits: gasFeeRandomisation.preservedNumberOfDigits,
     };
 }
+/**
+ * Retrieves the gas buffers for a given chain ID.
+ *
+ * @param request - The request object.
+ * @param request.chainId - The chain ID.
+ * @param request.isCustomRPC - Whether the network RPC is added by the user.
+ * @param request.isUpgradeWithDataToSelf - Whether the transaction is an EIP-7702 upgrade with data to self.
+ * @param request.messenger - The controller messenger instance.
+ * @returns The gas buffers.
+ */
+export function getGasEstimateBuffer({ chainId, isCustomRPC, isUpgradeWithDataToSelf, messenger, }) {
+    const featureFlags = getFeatureFlags(messenger);
+    const gasBufferFlags = featureFlags?.[FeatureFlag.GasBuffer];
+    const chainFlags = gasBufferFlags?.perChainConfig?.[chainId];
+    const chainIncludedRPCBuffer = isCustomRPC ? undefined : chainFlags?.included;
+    const defaultIncludedRPCBuffer = isCustomRPC
+        ? undefined
+        : gasBufferFlags?.included;
+    const upgradeBuffer = isUpgradeWithDataToSelf
+        ? chainFlags?.eip7702
+        : undefined;
+    return (upgradeBuffer ??
+        chainIncludedRPCBuffer ??
+        chainFlags?.base ??
+        defaultIncludedRPCBuffer ??
+        gasBufferFlags?.default ??
+        DEFAULT_GAS_ESTIMATE_BUFFER);
+}
 /**
  * Retrieves the relevant feature flags from the remote feature flag controller.
  *
diff --git a/dist/utils/gas.cjs b/dist/utils/gas.cjs
index 9f9d9999911032d40db5be615cd181c07ecabeab..89fd87e9c36f00428b41daf22cb192c975fe2a7b 100644
--- a/dist/utils/gas.cjs
+++ b/dist/utils/gas.cjs
@@ -4,8 +4,8 @@ exports.addGasBuffer = exports.estimateGas = exports.updateGas = exports.DUMMY_A
 const controller_utils_1 = require("@metamask/controller-utils");
 const utils_1 = require("@metamask/utils");
 const eip7702_1 = require("./eip7702.cjs");
+const feature_flags_1 = require("./feature-flags.cjs");
 const simulation_api_1 = require("./simulation-api.cjs");
-const constants_1 = require("../constants.cjs");
 const logger_1 = require("../logger.cjs");
 const types_1 = require("../types.cjs");
 exports.log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas');
@@ -62,8 +62,8 @@ async function estimateGas({ chainId, ethQuery, isSimulationEnabled, txParams, }
     let estimatedGas = fallback;
     let simulationFails;
     const isUpgradeWithDataToSelf = txParams.type === types_1.TransactionEnvelopeType.setCode &&
-        authorizationList?.length &&
-        data &&
+        Boolean(authorizationList?.length) &&
+        Boolean(data) &&
         data !== '0x' &&
         from?.toLowerCase() === to?.toLowerCase();
     try {
@@ -89,6 +89,7 @@ async function estimateGas({ chainId, ethQuery, isSimulationEnabled, txParams, }
     return {
         blockGasLimit,
         estimatedGas,
+        isUpgradeWithDataToSelf,
         simulationFails,
     };
 }
@@ -128,7 +129,7 @@ exports.addGasBuffer = addGasBuffer;
  * @returns The final gas value and the estimate used.
  */
 async function getGas(request) {
-    const { chainId, isCustomNetwork, isSimulationEnabled, txMeta } = request;
+    const { chainId, isCustomNetwork, isSimulationEnabled, messenger, txMeta } = request;
     const { disableGasBuffer } = txMeta;
     if (txMeta.txParams.gas) {
         (0, exports.log)('Using value from request', txMeta.txParams.gas);
@@ -138,24 +139,32 @@ async function getGas(request) {
         (0, exports.log)('Using fixed value', exports.FIXED_GAS);
         return [exports.FIXED_GAS, undefined, exports.FIXED_GAS];
     }
-    const { blockGasLimit, estimatedGas, simulationFails } = await estimateGas({
+    const { blockGasLimit, estimatedGas, isUpgradeWithDataToSelf, simulationFails, } = await estimateGas({
         chainId: request.chainId,
         ethQuery: request.ethQuery,
         isSimulationEnabled,
         txParams: txMeta.txParams,
     });
-    if (isCustomNetwork || simulationFails) {
-        (0, exports.log)(isCustomNetwork
-            ? 'Using original estimate as custom network'
-            : 'Using original fallback estimate as simulation failed');
-        return [estimatedGas, simulationFails, estimatedGas];
+    (0, exports.log)('Original estimated gas', estimatedGas);
+    if (simulationFails) {
+        (0, exports.log)('Using original fallback estimate as simulation failed');
+    }
+    if (disableGasBuffer) {
+        (0, exports.log)('Gas buffer disabled');
     }
-    let finalGas = estimatedGas;
-    if (!disableGasBuffer) {
-        const bufferMultiplier = constants_1.GAS_BUFFER_CHAIN_OVERRIDES[chainId] ?? exports.DEFAULT_GAS_MULTIPLIER;
-        finalGas = addGasBuffer(estimatedGas, blockGasLimit, bufferMultiplier);
+    if (simulationFails || disableGasBuffer) {
+        return [estimatedGas, simulationFails, estimatedGas];
     }
-    return [finalGas, simulationFails, estimatedGas];
+    const bufferMultiplier = (0, feature_flags_1.getGasEstimateBuffer)({
+        chainId,
+        isCustomRPC: isCustomNetwork,
+        isUpgradeWithDataToSelf,
+        messenger,
+    });
+    (0, exports.log)('Buffer', bufferMultiplier);
+    const bufferedGas = addGasBuffer(estimatedGas, blockGasLimit, bufferMultiplier);
+    (0, exports.log)('Buffered gas', bufferedGas);
+    return [bufferedGas, simulationFails, estimatedGas];
 }
 /**
  * Determine if the gas for the provided request should be fixed.
diff --git a/dist/utils/gas.d.cts b/dist/utils/gas.d.cts
index d11f4d0e125386892ee2238ae19245cfe9272474..96e41882a167564b8d01f1951503a3b8765021e5 100644
--- a/dist/utils/gas.d.cts
+++ b/dist/utils/gas.d.cts
@@ -1,12 +1,14 @@
 /// <reference types="debug" />
 import type EthQuery from "@metamask/eth-query";
 import type { Hex } from "@metamask/utils";
+import type { TransactionControllerMessenger } from "../index.cjs";
 import { type TransactionMeta, type TransactionParams } from "../types.cjs";
 export type UpdateGasRequest = {
     chainId: Hex;
     ethQuery: EthQuery;
     isCustomNetwork: boolean;
     isSimulationEnabled: boolean;
+    messenger: TransactionControllerMessenger;
     txMeta: TransactionMeta;
 };
 export declare const log: import("debug").Debugger;
@@ -41,6 +43,7 @@ export declare function estimateGas({ chainId, ethQuery, isSimulationEnabled, tx
 }): Promise<{
     blockGasLimit: string;
     estimatedGas: `0x${string}`;
+    isUpgradeWithDataToSelf: boolean;
     simulationFails: {
         reason?: string | undefined;
         errorKey?: string | undefined;
diff --git a/dist/utils/gas.d.mts b/dist/utils/gas.d.mts
index 8b16db19489c7407a2f6f8cbba26f21587c8db11..0e34913db5efd07351ec2c4417e2ed90a2d2d8da 100644
--- a/dist/utils/gas.d.mts
+++ b/dist/utils/gas.d.mts
@@ -1,12 +1,14 @@
 /// <reference types="debug" />
 import type EthQuery from "@metamask/eth-query";
 import type { Hex } from "@metamask/utils";
+import type { TransactionControllerMessenger } from "../index.mjs";
 import { type TransactionMeta, type TransactionParams } from "../types.mjs";
 export type UpdateGasRequest = {
     chainId: Hex;
     ethQuery: EthQuery;
     isCustomNetwork: boolean;
     isSimulationEnabled: boolean;
+    messenger: TransactionControllerMessenger;
     txMeta: TransactionMeta;
 };
 export declare const log: import("debug").Debugger;
@@ -41,6 +43,7 @@ export declare function estimateGas({ chainId, ethQuery, isSimulationEnabled, tx
 }): Promise<{
     blockGasLimit: string;
     estimatedGas: `0x${string}`;
+    isUpgradeWithDataToSelf: boolean;
     simulationFails: {
         reason?: string | undefined;
         errorKey?: string | undefined;
diff --git a/dist/utils/gas.mjs b/dist/utils/gas.mjs
index 697fd3a0321be16f88c4ec2733f6975b9304538e..fe023e79e0de0c3422da8eced6ecdd98619e9a9e 100644
--- a/dist/utils/gas.mjs
+++ b/dist/utils/gas.mjs
@@ -1,8 +1,8 @@
 import { BNToHex, fractionBN, hexToBN, query } from "@metamask/controller-utils";
 import { add0x, createModuleLogger, remove0x } from "@metamask/utils";
 import { DELEGATION_PREFIX } from "./eip7702.mjs";
+import { getGasEstimateBuffer } from "./feature-flags.mjs";
 import { simulateTransactions } from "./simulation-api.mjs";
-import { GAS_BUFFER_CHAIN_OVERRIDES } from "../constants.mjs";
 import { projectLogger } from "../logger.mjs";
 import { TransactionEnvelopeType } from "../types.mjs";
 export const log = createModuleLogger(projectLogger, 'gas');
@@ -58,8 +58,8 @@ export async function estimateGas({ chainId, ethQuery, isSimulationEnabled, txPa
     let estimatedGas = fallback;
     let simulationFails;
     const isUpgradeWithDataToSelf = txParams.type === TransactionEnvelopeType.setCode &&
-        authorizationList?.length &&
-        data &&
+        Boolean(authorizationList?.length) &&
+        Boolean(data) &&
         data !== '0x' &&
         from?.toLowerCase() === to?.toLowerCase();
     try {
@@ -85,6 +85,7 @@ export async function estimateGas({ chainId, ethQuery, isSimulationEnabled, txPa
     return {
         blockGasLimit,
         estimatedGas,
+        isUpgradeWithDataToSelf,
         simulationFails,
     };
 }
@@ -122,7 +123,7 @@ export function addGasBuffer(estimatedGas, blockGasLimit, multiplier) {
  * @returns The final gas value and the estimate used.
  */
 async function getGas(request) {
-    const { chainId, isCustomNetwork, isSimulationEnabled, txMeta } = request;
+    const { chainId, isCustomNetwork, isSimulationEnabled, messenger, txMeta } = request;
     const { disableGasBuffer } = txMeta;
     if (txMeta.txParams.gas) {
         log('Using value from request', txMeta.txParams.gas);
@@ -132,24 +133,32 @@ async function getGas(request) {
         log('Using fixed value', FIXED_GAS);
         return [FIXED_GAS, undefined, FIXED_GAS];
     }
-    const { blockGasLimit, estimatedGas, simulationFails } = await estimateGas({
+    const { blockGasLimit, estimatedGas, isUpgradeWithDataToSelf, simulationFails, } = await estimateGas({
         chainId: request.chainId,
         ethQuery: request.ethQuery,
         isSimulationEnabled,
         txParams: txMeta.txParams,
     });
-    if (isCustomNetwork || simulationFails) {
-        log(isCustomNetwork
-            ? 'Using original estimate as custom network'
-            : 'Using original fallback estimate as simulation failed');
-        return [estimatedGas, simulationFails, estimatedGas];
+    log('Original estimated gas', estimatedGas);
+    if (simulationFails) {
+        log('Using original fallback estimate as simulation failed');
+    }
+    if (disableGasBuffer) {
+        log('Gas buffer disabled');
     }
-    let finalGas = estimatedGas;
-    if (!disableGasBuffer) {
-        const bufferMultiplier = GAS_BUFFER_CHAIN_OVERRIDES[chainId] ?? DEFAULT_GAS_MULTIPLIER;
-        finalGas = addGasBuffer(estimatedGas, blockGasLimit, bufferMultiplier);
+    if (simulationFails || disableGasBuffer) {
+        return [estimatedGas, simulationFails, estimatedGas];
     }
-    return [finalGas, simulationFails, estimatedGas];
+    const bufferMultiplier = getGasEstimateBuffer({
+        chainId,
+        isCustomRPC: isCustomNetwork,
+        isUpgradeWithDataToSelf,
+        messenger,
+    });
+    log('Buffer', bufferMultiplier);
+    const bufferedGas = addGasBuffer(estimatedGas, blockGasLimit, bufferMultiplier);
+    log('Buffered gas', bufferedGas);
+    return [bufferedGas, simulationFails, estimatedGas];
 }
 /**
  * Determine if the gas for the provided request should be fixed.
diff --git a/dist/utils/validation.cjs b/dist/utils/validation.cjs
index bd6fa9156ff04ab90e2ea538446e3def97792eba..9de7b7274d839b1e83d704ba00a76f61ba6674e2 100644
--- a/dist/utils/validation.cjs
+++ b/dist/utils/validation.cjs
@@ -1,6 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.validateBatchRequest = exports.validateParamTo = exports.validateTxParams = exports.validateTransactionOrigin = void 0;
+exports.validateBatchRequest = exports.validateParamTo = exports.validateTxParams = exports.validateTransactionOrigin = exports.ErrorCode = void 0;
 const abi_1 = require("@ethersproject/abi");
 const controller_utils_1 = require("@metamask/controller-utils");
 const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
@@ -8,6 +8,11 @@ const rpc_errors_1 = require("@metamask/rpc-errors");
 const utils_1 = require("@metamask/utils");
 const utils_2 = require("./utils.cjs");
 const types_1 = require("../types.cjs");
+var ErrorCode;
+(function (ErrorCode) {
+    ErrorCode[ErrorCode["DuplicateBundleId"] = 5720] = "DuplicateBundleId";
+    ErrorCode[ErrorCode["BundleTooLarge"] = 5740] = "BundleTooLarge";
+})(ErrorCode || (exports.ErrorCode = ErrorCode = {}));
 const TRANSACTION_ENVELOPE_TYPES_FEE_MARKET = [
     types_1.TransactionEnvelopeType.feeMarket,
     types_1.TransactionEnvelopeType.setCode,
@@ -62,15 +67,16 @@ exports.validateTransactionOrigin = validateTransactionOrigin;
  *
  * @param txParams - Transaction params object to validate.
  * @param isEIP1559Compatible - whether or not the current network supports EIP-1559 transactions.
+ * @param chainId - The chain ID of the transaction.
  */
-function validateTxParams(txParams, isEIP1559Compatible = true) {
+function validateTxParams(txParams, isEIP1559Compatible = true, chainId) {
     validateEnvelopeType(txParams.type);
     validateEIP1559Compatibility(txParams, isEIP1559Compatible);
     validateParamFrom(txParams.from);
     validateParamRecipient(txParams);
     validateParamValue(txParams.value);
     validateParamData(txParams.data);
-    validateParamChainId(txParams.chainId);
+    validateParamChainId(txParams.chainId, chainId);
     validateGasFeeParams(txParams);
     validateAuthorizationList(txParams);
 }
@@ -190,14 +196,19 @@ exports.validateParamTo = validateParamTo;
 function validateBatchRequest({ internalAccounts, request, sizeLimit, }) {
     const { origin } = request;
     const isExternal = origin && origin !== controller_utils_1.ORIGIN_METAMASK;
-    const transactionTargetsNormalized = request.transactions.map((tx) => tx.params.to?.toLowerCase());
     const internalAccountsNormalized = internalAccounts.map((account) => account.toLowerCase());
     if (isExternal &&
-        transactionTargetsNormalized.some((target) => internalAccountsNormalized.includes(target))) {
-        throw rpc_errors_1.rpcErrors.invalidParams('Calls to internal accounts are not supported');
+        request.transactions.some((nestedTransaction) => {
+            const normalizedCallTo = nestedTransaction.params.to?.toLowerCase();
+            const callData = nestedTransaction.params.data;
+            const isInternalAccount = internalAccountsNormalized.includes(normalizedCallTo);
+            const hasData = Boolean(callData && callData !== '0x');
+            return isInternalAccount && hasData;
+        })) {
+        throw rpc_errors_1.rpcErrors.invalidParams('External calls to internal accounts cannot include data');
     }
     if (isExternal && request.transactions.length > sizeLimit) {
-        throw rpc_errors_1.rpcErrors.invalidParams(`Batch size cannot exceed ${sizeLimit}. got: ${request.transactions.length}`);
+        throw new rpc_errors_1.JsonRpcError(ErrorCode.BundleTooLarge, `Batch size cannot exceed ${sizeLimit}. got: ${request.transactions.length}`);
     }
 }
 exports.validateBatchRequest = validateBatchRequest;
@@ -225,16 +236,14 @@ function validateParamData(value) {
 /**
  * Validates chainId type.
  *
- * @param chainId - The chainId to validate.
+ * @param chainIdParams - The chain ID to validate.
+ * @param chainIdNetworkClient - The chain ID of the network client.
  */
-function validateParamChainId(chainId) {
-    if (chainId !== undefined &&
-        typeof chainId !== 'number' &&
-        typeof chainId !== 'string') {
-        throw rpc_errors_1.rpcErrors.invalidParams(
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
-        `Invalid transaction params: chainId is not a Number or hex string. got: (${chainId})`);
+function validateParamChainId(chainIdParams, chainIdNetworkClient) {
+    if (chainIdParams &&
+        chainIdNetworkClient &&
+        chainIdParams.toLowerCase?.() !== chainIdNetworkClient.toLowerCase()) {
+        throw rpc_errors_1.rpcErrors.invalidParams(`Invalid transaction params: chainId must match the network client, got: ${chainIdParams}, expected: ${chainIdNetworkClient}`);
     }
 }
 /**
diff --git a/dist/utils/validation.d.cts b/dist/utils/validation.d.cts
index 7cb8efdfc990face2f6a9f0b8a35d46640635286..81a9ed5cc081a5eab3cc0f18943d774e0958c624 100644
--- a/dist/utils/validation.d.cts
+++ b/dist/utils/validation.d.cts
@@ -1,5 +1,10 @@
+import type { Hex } from "@metamask/utils";
 import type { TransactionBatchRequest } from "../types.cjs";
 import { TransactionType, type TransactionParams } from "../types.cjs";
+export declare enum ErrorCode {
+    DuplicateBundleId = 5720,
+    BundleTooLarge = 5740
+}
 /**
  * Validates whether a transaction initiated by a specific 'from' address is permitted by the origin.
  *
@@ -30,8 +35,9 @@ export declare function validateTransactionOrigin({ data, from, internalAccounts
  *
  * @param txParams - Transaction params object to validate.
  * @param isEIP1559Compatible - whether or not the current network supports EIP-1559 transactions.
+ * @param chainId - The chain ID of the transaction.
  */
-export declare function validateTxParams(txParams: TransactionParams, isEIP1559Compatible?: boolean): void;
+export declare function validateTxParams(txParams: TransactionParams, isEIP1559Compatible?: boolean, chainId?: Hex): void;
 /**
  * Validates the recipient address in a transaction's parameters.
  *
diff --git a/dist/utils/validation.d.mts b/dist/utils/validation.d.mts
index f4a60a3e1336e3754dde219ac7d68a50131ce37f..d0cb41b42a6747df194ac46922248c52f5f0667f 100644
--- a/dist/utils/validation.d.mts
+++ b/dist/utils/validation.d.mts
@@ -1,5 +1,10 @@
+import type { Hex } from "@metamask/utils";
 import type { TransactionBatchRequest } from "../types.mjs";
 import { TransactionType, type TransactionParams } from "../types.mjs";
+export declare enum ErrorCode {
+    DuplicateBundleId = 5720,
+    BundleTooLarge = 5740
+}
 /**
  * Validates whether a transaction initiated by a specific 'from' address is permitted by the origin.
  *
@@ -30,8 +35,9 @@ export declare function validateTransactionOrigin({ data, from, internalAccounts
  *
  * @param txParams - Transaction params object to validate.
  * @param isEIP1559Compatible - whether or not the current network supports EIP-1559 transactions.
+ * @param chainId - The chain ID of the transaction.
  */
-export declare function validateTxParams(txParams: TransactionParams, isEIP1559Compatible?: boolean): void;
+export declare function validateTxParams(txParams: TransactionParams, isEIP1559Compatible?: boolean, chainId?: Hex): void;
 /**
  * Validates the recipient address in a transaction's parameters.
  *
diff --git a/dist/utils/validation.mjs b/dist/utils/validation.mjs
index 70d3d5a73f104d3c50c1d3bc746ac19a5dac281c..29a0fae2c4e7a121480cff03be04fc30188e7823 100644
--- a/dist/utils/validation.mjs
+++ b/dist/utils/validation.mjs
@@ -1,10 +1,15 @@
 import { Interface } from "@ethersproject/abi";
 import { ORIGIN_METAMASK, isValidHexAddress } from "@metamask/controller-utils";
 import { abiERC20 } from "@metamask/metamask-eth-abis";
-import { providerErrors, rpcErrors } from "@metamask/rpc-errors";
+import { JsonRpcError, providerErrors, rpcErrors } from "@metamask/rpc-errors";
 import { isStrictHexString, remove0x } from "@metamask/utils";
 import { isEIP1559Transaction } from "./utils.mjs";
 import { TransactionEnvelopeType, TransactionType } from "../types.mjs";
+export var ErrorCode;
+(function (ErrorCode) {
+    ErrorCode[ErrorCode["DuplicateBundleId"] = 5720] = "DuplicateBundleId";
+    ErrorCode[ErrorCode["BundleTooLarge"] = 5740] = "BundleTooLarge";
+})(ErrorCode || (ErrorCode = {}));
 const TRANSACTION_ENVELOPE_TYPES_FEE_MARKET = [
     TransactionEnvelopeType.feeMarket,
     TransactionEnvelopeType.setCode,
@@ -58,15 +63,16 @@ export async function validateTransactionOrigin({ data, from, internalAccounts,
  *
  * @param txParams - Transaction params object to validate.
  * @param isEIP1559Compatible - whether or not the current network supports EIP-1559 transactions.
+ * @param chainId - The chain ID of the transaction.
  */
-export function validateTxParams(txParams, isEIP1559Compatible = true) {
+export function validateTxParams(txParams, isEIP1559Compatible = true, chainId) {
     validateEnvelopeType(txParams.type);
     validateEIP1559Compatibility(txParams, isEIP1559Compatible);
     validateParamFrom(txParams.from);
     validateParamRecipient(txParams);
     validateParamValue(txParams.value);
     validateParamData(txParams.data);
-    validateParamChainId(txParams.chainId);
+    validateParamChainId(txParams.chainId, chainId);
     validateGasFeeParams(txParams);
     validateAuthorizationList(txParams);
 }
@@ -184,14 +190,19 @@ export function validateParamTo(to) {
 export function validateBatchRequest({ internalAccounts, request, sizeLimit, }) {
     const { origin } = request;
     const isExternal = origin && origin !== ORIGIN_METAMASK;
-    const transactionTargetsNormalized = request.transactions.map((tx) => tx.params.to?.toLowerCase());
     const internalAccountsNormalized = internalAccounts.map((account) => account.toLowerCase());
     if (isExternal &&
-        transactionTargetsNormalized.some((target) => internalAccountsNormalized.includes(target))) {
-        throw rpcErrors.invalidParams('Calls to internal accounts are not supported');
+        request.transactions.some((nestedTransaction) => {
+            const normalizedCallTo = nestedTransaction.params.to?.toLowerCase();
+            const callData = nestedTransaction.params.data;
+            const isInternalAccount = internalAccountsNormalized.includes(normalizedCallTo);
+            const hasData = Boolean(callData && callData !== '0x');
+            return isInternalAccount && hasData;
+        })) {
+        throw rpcErrors.invalidParams('External calls to internal accounts cannot include data');
     }
     if (isExternal && request.transactions.length > sizeLimit) {
-        throw rpcErrors.invalidParams(`Batch size cannot exceed ${sizeLimit}. got: ${request.transactions.length}`);
+        throw new JsonRpcError(ErrorCode.BundleTooLarge, `Batch size cannot exceed ${sizeLimit}. got: ${request.transactions.length}`);
     }
 }
 /**
@@ -218,16 +229,14 @@ function validateParamData(value) {
 /**
  * Validates chainId type.
  *
- * @param chainId - The chainId to validate.
+ * @param chainIdParams - The chain ID to validate.
+ * @param chainIdNetworkClient - The chain ID of the network client.
  */
-function validateParamChainId(chainId) {
-    if (chainId !== undefined &&
-        typeof chainId !== 'number' &&
-        typeof chainId !== 'string') {
-        throw rpcErrors.invalidParams(
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
-        `Invalid transaction params: chainId is not a Number or hex string. got: (${chainId})`);
+function validateParamChainId(chainIdParams, chainIdNetworkClient) {
+    if (chainIdParams &&
+        chainIdNetworkClient &&
+        chainIdParams.toLowerCase?.() !== chainIdNetworkClient.toLowerCase()) {
+        throw rpcErrors.invalidParams(`Invalid transaction params: chainId must match the network client, got: ${chainIdParams}, expected: ${chainIdNetworkClient}`);
     }
 }
 /**
