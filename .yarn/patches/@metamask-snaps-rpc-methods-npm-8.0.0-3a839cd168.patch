diff --git a/dist/chunk-PS6OEQXL.js b/dist/chunk-PS6OEQXL.js
index c202d09bb9f82e0e64956ab3cfe5ff3f37b725a7..2c7d2591a2747228b7f4174b431dc7c57d4daaaa 100644
--- a/dist/chunk-PS6OEQXL.js
+++ b/dist/chunk-PS6OEQXL.js
@@ -57,7 +57,9 @@ function getSnapPermissionsRequest(existingPermissions, requestedPermissions) {
 }
 async function requestSnapsImplementation(req, res, _next, end, { installSnaps, requestPermissions, getPermissions }) {
   const requestedSnaps = req.params;
+  console.log('requestSnapsImplementation requestedSnaps', JSON.stringify(requestedSnaps))
   if (!_utils.isObject.call(void 0, requestedSnaps)) {
+    console.log('requestSnapsImplementation requestedSnaps 1')
     return end(
       _rpcerrors.rpcErrors.invalidParams({
         message: '"params" must be an object.'
@@ -65,33 +67,45 @@ async function requestSnapsImplementation(req, res, _next, end, { installSnaps,
     );
   }
   try {
+    console.log('requestSnapsImplementation requestedSnaps 2')
     if (Object.keys(requestedSnaps).length === 0) {
+      console.log('requestSnapsImplementation requestedSnaps 3')
       return end(
         _rpcerrors.rpcErrors.invalidParams({
           message: "Request must have at least one requested snap."
         })
       );
     }
+    console.log('requestSnapsImplementation requestedSnaps 4')
     const requestedPermissions = {
       [_chunkFFHVA6PPjs.WALLET_SNAP_PERMISSION_KEY]: {
         caveats: [{ type: _snapsutils.SnapCaveatType.SnapIds, value: requestedSnaps }]
       }
     };
+    console.log('requestSnapsImplementation requestedSnaps 5')
     const existingPermissions = await getPermissions();
+    console.log('requestSnapsImplementation requestedSnaps 6')
     if (!existingPermissions) {
+      console.log('requestSnapsImplementation requestedSnaps 7')
       const [, metadata] = await requestPermissions(requestedPermissions);
+      console.log('requestSnapsImplementation requestedSnaps 8', JSON.stringify(res), JSON.stringify(metadata.data[_chunkFFHVA6PPjs.WALLET_SNAP_PERMISSION_KEY]))
       res.result = metadata.data[_chunkFFHVA6PPjs.WALLET_SNAP_PERMISSION_KEY];
     } else if (hasRequestedSnaps(existingPermissions, requestedSnaps)) {
+      console.log('requestSnapsImplementation requestedSnaps 9')
       res.result = await installSnaps(requestedSnaps);
+      console.log('requestSnapsImplementation requestedSnaps 10')
     } else {
+      console.log('requestSnapsImplementation requestedSnaps 11')
       const mergedPermissionsRequest = getSnapPermissionsRequest(
         existingPermissions,
         requestedPermissions
       );
       const [, metadata] = await requestPermissions(mergedPermissionsRequest);
+      console.log('requestSnapsImplementation requestedSnaps 12', JSON.stringify(res), JSON.stringify(metadata.data[_chunkFFHVA6PPjs.WALLET_SNAP_PERMISSION_KEY]))
       res.result = metadata.data[_chunkFFHVA6PPjs.WALLET_SNAP_PERMISSION_KEY];
     }
   } catch (error) {
+    console.log('requestSnapsImplementation requestedSnaps 13', JSON.stringify(error), JSON.stringify(res))
     res.error = error;
   }
   return end();
diff --git a/dist/chunk-PS6OEQXL.js.map b/dist/chunk-PS6OEQXL.js.map
index 78ef462b0cb89714063a3550e863034ed93b79d3..79f00ac5474aca3e08875c7e23c1669ca94dad5e 100644
--- a/dist/chunk-PS6OEQXL.js.map
+++ b/dist/chunk-PS6OEQXL.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/permitted/requestSnaps.ts"],"names":[],"mappings":";;;;;AAOA,SAAS,iBAAiB;AAM1B;AAAA,EACE;AAAA,EACA;AAAA,OACK;AAMP,SAAS,aAAa,gBAAgB;AAKtC,IAAM,YAAkD;AAAA,EACtD,cAAc;AAAA,EACd,oBAAoB;AAAA,EACpB,gBAAgB;AAClB;AAKO,IAAM,sBAIT;AAAA,EACF,aAAa,CAAC,qBAAqB;AAAA,EACnC,gBAAgB;AAAA,EAChB;AACF;AA0CO,SAAS,kBACd,qBACA,gBACS;AACT,QAAM,eAAe,oBACnB,0BACF,GAAG,SAAS;AAAA,IACV,CAAC,WAAiC,OAAO,SAAS,eAAe;AAAA,EACnE;AAEA,QAAM,iBAAiB,cAAc;AACrC,MAAI,SAAS,cAAc,GAAG;AAC5B,WAAO,OAAO,KAAK,cAAc,EAAE;AAAA,MAAM,CAAC,kBACxC,YAAY,gBAAgB,aAAa;AAAA,IAC3C;AAAA,EACF;AACA,SAAO;AACT;AAUO,SAAS,0BACd,qBACA,sBACwB;AACxB,iCAA+B,oBAAoB;AAEnD,MAAI,CAAC,oBAAoB,0BAA0B,GAAG;AACpD,WAAO;AAAA,EACT;AAEA,QAAM,eAAe,oBACnB,0BACF,EAAE,SAAS;AAAA,IACT,CAAC,WAAiC,OAAO,SAAS,eAAe;AAAA,EACnE;AAEA,QAAM,iBAAkB,cAAc,SAAkC,CAAC;AAEzE,QAAM,iBACJ,qBAAqB,0BAA0B,EAAE,QAAQ,CAAC,EAAE;AAE9D,QAAM,YAAY,oBAAI,IAAI;AAAA,IACxB,GAAG,OAAO,KAAK,cAAc;AAAA,IAC7B,GAAG,OAAO,KAAK,cAAc;AAAA,EAC/B,CAAC;AAED,QAAM,oBAAoB,CAAC,GAAG,SAAS,EAAE;AAAA,IACvC,CAAC,SAAS,WAAW;AACnB,cAAQ,MAAM,IAAI,eAAe,MAAM,KAAK,eAAe,MAAM;AACjE,aAAO;AAAA,IACT;AAAA,IACA,CAAC;AAAA,EACH;AAEA,uBAAqB,0BAA0B,EAAE,QAAQ,CAAC,EAAE,QAC1D;AAEF,SAAO;AACT;AAmBA,eAAe,2BACb,KACA,KACA,OACA,KACA,EAAE,cAAc,oBAAoB,eAAe,GACpC;AACf,QAAM,iBAAiB,IAAI;AAC3B,MAAI,CAAC,SAAS,cAAc,GAAG;AAC7B,WAAO;AAAA,MACL,UAAU,cAAc;AAAA,QACtB,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAAA,EACF;AAEA,MAAI;AACF,QAAI,OAAO,KAAK,cAAc,EAAE,WAAW,GAAG;AAC5C,aAAO;AAAA,QACL,UAAU,cAAc;AAAA,UACtB,SAAS;AAAA,QACX,CAAC;AAAA,MACH;AAAA,IACF;AAEA,UAAM,uBAAuB;AAAA,MAC3B,CAAC,0BAA0B,GAAG;AAAA,QAC5B,SAAS,CAAC,EAAE,MAAM,eAAe,SAAS,OAAO,eAAe,CAAC;AAAA,MACnE;AAAA,IACF;AACA,UAAM,sBAAsB,MAAM,eAAe;AAEjD,QAAI,CAAC,qBAAqB;AACxB,YAAM,CAAC,EAAE,QAAQ,IAAI,MAAM,mBAAmB,oBAAoB;AAClE,UAAI,SAAS,SAAS,KACpB,0BACF;AAAA,IACF,WAAW,kBAAkB,qBAAqB,cAAc,GAAG;AACjE,UAAI,SAAS,MAAM,aAAa,cAAc;AAAA,IAChD,OAAO;AACL,YAAM,2BAA2B;AAAA,QAC/B;AAAA,QACA;AAAA,MACF;AAEA,YAAM,CAAC,EAAE,QAAQ,IAAI,MAAM,mBAAmB,wBAAwB;AACtE,UAAI,SAAS,SAAS,KACpB,0BACF;AAAA,IACF;AAAA,EACF,SAAS,OAAO;AACd,QAAI,QAAQ;AAAA,EACd;AAEA,SAAO,IAAI;AACb","sourcesContent":["import type { JsonRpcEngineEndCallback } from '@metamask/json-rpc-engine';\nimport type {\n  PermissionConstraint,\n  RequestedPermissions,\n  Caveat,\n  PermittedHandlerExport,\n} from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type {\n  RequestSnapsParams,\n  RequestSnapsResult,\n} from '@metamask/snaps-sdk';\nimport type { SnapsPermissionRequest } from '@metamask/snaps-utils';\nimport {\n  SnapCaveatType,\n  verifyRequestedSnapPermissions,\n} from '@metamask/snaps-utils';\nimport type {\n  JsonRpcRequest,\n  PendingJsonRpcResponse,\n  Json,\n} from '@metamask/utils';\nimport { hasProperty, isObject } from '@metamask/utils';\n\nimport { WALLET_SNAP_PERMISSION_KEY } from '../restricted/invokeSnap';\nimport type { MethodHooksObject } from '../utils';\n\nconst hookNames: MethodHooksObject<RequestSnapsHooks> = {\n  installSnaps: true,\n  requestPermissions: true,\n  getPermissions: true,\n};\n\n/**\n * `wallet_requestSnaps` installs the requested Snaps and requests permission to use them if necessary.\n */\nexport const requestSnapsHandler: PermittedHandlerExport<\n  RequestSnapsHooks,\n  RequestSnapsParams,\n  RequestSnapsResult\n> = {\n  methodNames: ['wallet_requestSnaps'],\n  implementation: requestSnapsImplementation,\n  hookNames,\n};\n\nexport type RequestSnapsHooks = {\n  /**\n   * Installs the requested snaps if they are permitted.\n   */\n  installSnaps: (\n    requestedSnaps: RequestSnapsParams,\n  ) => Promise<RequestSnapsResult>;\n\n  /**\n   * Initiates a permission request for the requesting origin.\n   *\n   * @returns The result of the permissions request.\n   */\n  requestPermissions: (\n    permissions: RequestedPermissions,\n  ) => Promise<\n    [\n      Record<string, PermissionConstraint>,\n      { data: Record<string, unknown>; id: string; origin: string },\n    ]\n  >;\n\n  /**\n   * Gets the current permissions for the requesting origin.\n   *\n   * @returns The current permissions of the requesting origin.\n   */\n  getPermissions: () => Promise<\n    Record<string, PermissionConstraint> | undefined\n  >;\n};\n\n/**\n * Checks whether an origin has existing `wallet_snap` permission and\n * whether or not it has the requested snapIds caveat.\n *\n * @param existingPermissions - The existing permissions for the origin.\n * @param requestedSnaps - The requested snaps.\n * @returns True if the existing permissions satisfy the requested snaps, otherwise false.\n */\nexport function hasRequestedSnaps(\n  existingPermissions: Record<string, PermissionConstraint>,\n  requestedSnaps: Record<string, unknown>,\n): boolean {\n  const snapIdCaveat = existingPermissions[\n    WALLET_SNAP_PERMISSION_KEY\n  ]?.caveats?.find(\n    (caveat: Caveat<string, Json>) => caveat.type === SnapCaveatType.SnapIds,\n  );\n\n  const permittedSnaps = snapIdCaveat?.value;\n  if (isObject(permittedSnaps)) {\n    return Object.keys(requestedSnaps).every((requestedSnap) =>\n      hasProperty(permittedSnaps, requestedSnap),\n    );\n  }\n  return false;\n}\n\n/**\n * Constructs a valid permission request with merged caveats based on existing permissions\n * and the requested snaps.\n *\n * @param existingPermissions - The existing permissions for the origin.\n * @param requestedPermissions - The permission request passed into `requestPermissions`.\n * @returns `requestedPermissions`.\n */\nexport function getSnapPermissionsRequest(\n  existingPermissions: Record<string, PermissionConstraint>,\n  requestedPermissions: unknown,\n): SnapsPermissionRequest {\n  verifyRequestedSnapPermissions(requestedPermissions);\n\n  if (!existingPermissions[WALLET_SNAP_PERMISSION_KEY]) {\n    return requestedPermissions;\n  }\n\n  const snapIdCaveat = existingPermissions[\n    WALLET_SNAP_PERMISSION_KEY\n  ].caveats?.find(\n    (caveat: Caveat<string, Json>) => caveat.type === SnapCaveatType.SnapIds,\n  );\n\n  const permittedSnaps = (snapIdCaveat?.value as Record<string, Json>) ?? {};\n\n  const requestedSnaps =\n    requestedPermissions[WALLET_SNAP_PERMISSION_KEY].caveats[0].value;\n\n  const snapIdSet = new Set([\n    ...Object.keys(permittedSnaps),\n    ...Object.keys(requestedSnaps),\n  ]);\n\n  const mergedCaveatValue = [...snapIdSet].reduce<Record<string, Json>>(\n    (request, snapId) => {\n      request[snapId] = requestedSnaps[snapId] ?? permittedSnaps[snapId];\n      return request;\n    },\n    {},\n  );\n\n  requestedPermissions[WALLET_SNAP_PERMISSION_KEY].caveats[0].value =\n    mergedCaveatValue;\n\n  return requestedPermissions;\n}\n\n/**\n * The `wallet_requestSnaps` method implementation.\n * Tries to install the requested snaps and adds them to the JSON-RPC response.\n *\n * @param req - The JSON-RPC request object.\n * @param res - The JSON-RPC response object.\n * @param _next - The `json-rpc-engine` \"next\" callback. Not used by this\n * function.\n * @param end - The `json-rpc-engine` \"end\" callback.\n * @param hooks - The RPC method hooks.\n * @param hooks.installSnaps - A function that tries to install a given snap, prompting the user if necessary.\n * @param hooks.requestPermissions - A function that requests permissions on\n * behalf of a subject.\n * @param hooks.getPermissions - A function that gets the current permissions.\n * @returns A promise that resolves once the JSON-RPC response has been modified.\n * @throws If the params are invalid.\n */\nasync function requestSnapsImplementation(\n  req: JsonRpcRequest<RequestSnapsParams>,\n  res: PendingJsonRpcResponse<RequestSnapsResult>,\n  _next: unknown,\n  end: JsonRpcEngineEndCallback,\n  { installSnaps, requestPermissions, getPermissions }: RequestSnapsHooks,\n): Promise<void> {\n  const requestedSnaps = req.params;\n  if (!isObject(requestedSnaps)) {\n    return end(\n      rpcErrors.invalidParams({\n        message: '\"params\" must be an object.',\n      }),\n    );\n  }\n\n  try {\n    if (Object.keys(requestedSnaps).length === 0) {\n      return end(\n        rpcErrors.invalidParams({\n          message: 'Request must have at least one requested snap.',\n        }),\n      );\n    }\n\n    const requestedPermissions = {\n      [WALLET_SNAP_PERMISSION_KEY]: {\n        caveats: [{ type: SnapCaveatType.SnapIds, value: requestedSnaps }],\n      },\n    } as RequestedPermissions;\n    const existingPermissions = await getPermissions();\n\n    if (!existingPermissions) {\n      const [, metadata] = await requestPermissions(requestedPermissions);\n      res.result = metadata.data[\n        WALLET_SNAP_PERMISSION_KEY\n      ] as RequestSnapsResult;\n    } else if (hasRequestedSnaps(existingPermissions, requestedSnaps)) {\n      res.result = await installSnaps(requestedSnaps);\n    } else {\n      const mergedPermissionsRequest = getSnapPermissionsRequest(\n        existingPermissions,\n        requestedPermissions,\n      );\n\n      const [, metadata] = await requestPermissions(mergedPermissionsRequest);\n      res.result = metadata.data[\n        WALLET_SNAP_PERMISSION_KEY\n      ] as RequestSnapsResult;\n    }\n  } catch (error) {\n    res.error = error;\n  }\n\n  return end();\n}\n"]}
\ No newline at end of file
+{"version":3,"sources":["../src/permitted/requestSnaps.ts"],"names":[],"mappings":";;;;;AAOA,SAAS,iBAAiB;AAM1B;AAAA,EACE;AAAA,EACA;AAAA,OACK;AAMP,SAAS,aAAa,gBAAgB;AAKtC,IAAM,YAAkD;AAAA,EACtD,cAAc;AAAA,EACd,oBAAoB;AAAA,EACpB,gBAAgB;AAClB;AAKO,IAAM,sBAIT;AAAA,EACF,aAAa,CAAC,qBAAqB;AAAA,EACnC,gBAAgB;AAAA,EAChB;AACF;AA0CO,SAAS,kBACd,qBACA,gBACS;AACT,QAAM,eAAe,oBACnB,0BACF,GAAG,SAAS;AAAA,IACV,CAAC,WAAiC,OAAO,SAAS,eAAe;AAAA,EACnE;AAEA,QAAM,iBAAiB,cAAc;AACrC,MAAI,SAAS,cAAc,GAAG;AAC5B,WAAO,OAAO,KAAK,cAAc,EAAE;AAAA,MAAM,CAAC,kBACxC,YAAY,gBAAgB,aAAa;AAAA,IAC3C;AAAA,EACF;AACA,SAAO;AACT;AAUO,SAAS,0BACd,qBACA,sBACwB;AACxB,iCAA+B,oBAAoB;AAEnD,MAAI,CAAC,oBAAoB,0BAA0B,GAAG;AACpD,WAAO;AAAA,EACT;AAEA,QAAM,eAAe,oBACnB,0BACF,EAAE,SAAS;AAAA,IACT,CAAC,WAAiC,OAAO,SAAS,eAAe;AAAA,EACnE;AAEA,QAAM,iBAAkB,cAAc,SAAkC,CAAC;AAEzE,QAAM,iBACJ,qBAAqB,0BAA0B,EAAE,QAAQ,CAAC,EAAE;AAE9D,QAAM,YAAY,oBAAI,IAAI;AAAA,IACxB,GAAG,OAAO,KAAK,cAAc;AAAA,IAC7B,GAAG,OAAO,KAAK,cAAc;AAAA,EAC/B,CAAC;AAED,QAAM,oBAAoB,CAAC,GAAG,SAAS,EAAE;AAAA,IACvC,CAAC,SAAS,WAAW;AACnB,cAAQ,MAAM,IAAI,eAAe,MAAM,KAAK,eAAe,MAAM;AACjE,aAAO;AAAA,IACT;AAAA,IACA,CAAC;AAAA,EACH;AAEA,uBAAqB,0BAA0B,EAAE,QAAQ,CAAC,EAAE,QAC1D;AAEF,SAAO;AACT;AAmBA,eAAe,2BACb,KACA,KACA,OACA,KACA,EAAE,cAAc,oBAAoB,eAAe,GACpC;AACf,QAAM,iBAAiB,IAAI;AAC3B,MAAI,CAAC,SAAS,cAAc,GAAG;AAC7B,WAAO;AAAA,MACL,UAAU,cAAc;AAAA,QACtB,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAAA,EACF;AAEA,MAAI;AACF,QAAI,OAAO,KAAK,cAAc,EAAE,WAAW,GAAG;AAC5C,aAAO;AAAA,QACL,UAAU,cAAc;AAAA,UACtB,SAAS;AAAA,QACX,CAAC;AAAA,MACH;AAAA,IACF;AAEA,UAAM,uBAAuB;AAAA,MAC3B,CAAC,0BAA0B,GAAG;AAAA,QAC5B,SAAS,CAAC,EAAE,MAAM,eAAe,SAAS,OAAO,eAAe,CAAC;AAAA,MACnE;AAAA,IACF;AACA,UAAM,sBAAsB,MAAM,eAAe;AAEjD,QAAI,CAAC,qBAAqB;AACxB,YAAM,CAAC,EAAE,QAAQ,IAAI,MAAM,mBAAmB,oBAAoB;AAClE,UAAI,SAAS,SAAS,KACpB,0BACF;AAAA,IACF,WAAW,kBAAkB,qBAAqB,cAAc,GAAG;AACjE,UAAI,SAAS,MAAM,aAAa,cAAc;AAAA,IAChD,OAAO;AACL,YAAM,2BAA2B;AAAA,QAC/B;AAAA,QACA;AAAA,MACF;AAEA,YAAM,CAAC,EAAE,QAAQ,IAAI,MAAM,mBAAmB,wBAAwB;AACtE,UAAI,SAAS,SAAS,KACpB,0BACF;AAAA,IACF;AAAA,EACF,SAAS,OAAO;AACd,QAAI,QAAQ;AAAA,EACd;AAEA,SAAO,IAAI;AACb","sourcesContent":["import type { JsonRpcEngineEndCallback } from '@metamask/json-rpc-engine';\nimport type {\n  PermissionConstraint,\n  RequestedPermissions,\n  Caveat,\n  PermittedHandlerExport,\n} from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type {\n  RequestSnapsParams,\n  RequestSnapsResult,\n} from '@metamask/snaps-sdk';\nimport type { SnapsPermissionRequest } from '@metamask/snaps-utils';\nimport {\n  SnapCaveatType,\n  verifyRequestedSnapPermissions,\n} from '@metamask/snaps-utils';\nimport type {\n  JsonRpcRequest,\n  PendingJsonRpcResponse,\n  Json,\n} from '@metamask/utils';\nimport { hasProperty, isObject } from '@metamask/utils';\n\nimport { WALLET_SNAP_PERMISSION_KEY } from '../restricted/invokeSnap';\nimport type { MethodHooksObject } from '../utils';\n\nconst hookNames: MethodHooksObject<RequestSnapsHooks> = {\n  installSnaps: true,\n  requestPermissions: true,\n  getPermissions: true,\n};\n\n/**\n * `wallet_requestSnaps` installs the requested Snaps and requests permission to use them if necessary.\n */\nexport const requestSnapsHandler: PermittedHandlerExport<\n  RequestSnapsHooks,\n  RequestSnapsParams,\n  RequestSnapsResult\n> = {\n  methodNames: ['wallet_requestSnaps'],\n  implementation: requestSnapsImplementation,\n  hookNames,\n};\n\nexport type RequestSnapsHooks = {\n  /**\n   * Installs the requested snaps if they are permitted.\n   */\n  installSnaps: (\n    requestedSnaps: RequestSnapsParams,\n  ) => Promise<RequestSnapsResult>;\n\n  /**\n   * Initiates a permission request for the requesting origin.\n   *\n   * @returns The result of the permissions request.\n   */\n  requestPermissions: (\n    permissions: RequestedPermissions,\n  ) => Promise<\n    [\n      Record<string, PermissionConstraint>,\n      { data: Record<string, unknown>; id: string; origin: string },\n    ]\n  >;\n\n  /**\n   * Gets the current permissions for the requesting origin.\n   *\n   * @returns The current permissions of the requesting origin.\n   */\n  getPermissions: () => Promise<\n    Record<string, PermissionConstraint> | undefined\n  >;\n};\n\n/**\n * Checks whether an origin has existing `wallet_snap` permission and\n * whether or not it has the requested snapIds caveat.\n *\n * @param existingPermissions - The existing permissions for the origin.\n * @param requestedSnaps - The requested snaps.\n * @returns True if the existing permissions satisfy the requested snaps, otherwise false.\n */\nexport function hasRequestedSnaps(\n  existingPermissions: Record<string, PermissionConstraint>,\n  requestedSnaps: Record<string, unknown>,\n): boolean {\n  const snapIdCaveat = existingPermissions[\n    WALLET_SNAP_PERMISSION_KEY\n  ]?.caveats?.find(\n    (caveat: Caveat<string, Json>) => caveat.type === SnapCaveatType.SnapIds,\n  );\n\n  const permittedSnaps = snapIdCaveat?.value;\n  if (isObject(permittedSnaps)) {\n    return Object.keys(requestedSnaps).every((requestedSnap) =>\n      hasProperty(permittedSnaps, requestedSnap),\n    );\n  }\n  return false;\n}\n\n/**\n * Constructs a valid permission request with merged caveats based on existing permissions\n * and the requested snaps.\n *\n * @param existingPermissions - The existing permissions for the origin.\n * @param requestedPermissions - The permission request passed into `requestPermissions`.\n * @returns `requestedPermissions`.\n */\nexport function getSnapPermissionsRequest(\n  existingPermissions: Record<string, PermissionConstraint>,\n  requestedPermissions: unknown,\n): SnapsPermissionRequest {\n  verifyRequestedSnapPermissions(requestedPermissions);\n\n  if (!existingPermissions[WALLET_SNAP_PERMISSION_KEY]) {\n    return requestedPermissions;\n  }\n\n  const snapIdCaveat = existingPermissions[\n    WALLET_SNAP_PERMISSION_KEY\n  ].caveats?.find(\n    (caveat: Caveat<string, Json>) => caveat.type === SnapCaveatType.SnapIds,\n  );\n\n  const permittedSnaps = (snapIdCaveat?.value as Record<string, Json>) ?? {};\n\n  const requestedSnaps =\n    requestedPermissions[WALLET_SNAP_PERMISSION_KEY].caveats[0].value;\n\n  const snapIdSet = new Set([\n    ...Object.keys(permittedSnaps),\n    ...Object.keys(requestedSnaps),\n  ]);\n\n  const mergedCaveatValue = [...snapIdSet].reduce<Record<string, Json>>(\n    (request, snapId) => {\n      request[snapId] = requestedSnaps[snapId] ?? permittedSnaps[snapId];\n      return request;\n    },\n    {},\n  );\n\n  requestedPermissions[WALLET_SNAP_PERMISSION_KEY].caveats[0].value =\n    mergedCaveatValue;\n\n  return requestedPermissions;\n}\n\n/**\n * The `wallet_requestSnaps` method implementation.\n * Tries to install the requested snaps and adds them to the JSON-RPC response.\n *\n * @param req - The JSON-RPC request object.\n * @param res - The JSON-RPC response object.\n * @param _next - The `json-rpc-engine` \"next\" callback. Not used by this\n * function.\n * @param end - The `json-rpc-engine` \"end\" callback.\n * @param hooks - The RPC method hooks.\n * @param hooks.installSnaps - A function that tries to install a given snap, prompting the user if necessary.\n * @param hooks.requestPermissions - A function that requests permissions on\n * behalf of a subject.\n * @param hooks.getPermissions - A function that gets the current permissions.\n * @returns A promise that resolves once the JSON-RPC response has been modified.\n * @throws If the params are invalid.\n */\nasync function requestSnapsImplementation(\n  req: JsonRpcRequest<RequestSnapsParams>,\n  res: PendingJsonRpcResponse<RequestSnapsResult>,\n  _next: unknown,\n  end: JsonRpcEngineEndCallback,\n  { installSnaps, requestPermissions, getPermissions }: RequestSnapsHooks,\n): Promise<void> {\n  const requestedSnaps = req.params;\n  console.log('requestSnapsImplementation requestedSnaps', requestedSnaps);\n if (!isObject(requestedSnaps)) {\n    return end(\n      rpcErrors.invalidParams({\n        message: '\"params\" must be an object.',\n      }),\n    );\n  }\n\n  try {\n    if (Object.keys(requestedSnaps).length === 0) {\n      return end(\n        rpcErrors.invalidParams({\n          message: 'Request must have at least one requested snap.',\n        }),\n      );\n    }\n\n    const requestedPermissions = {\n      [WALLET_SNAP_PERMISSION_KEY]: {\n        caveats: [{ type: SnapCaveatType.SnapIds, value: requestedSnaps }],\n      },\n    } as RequestedPermissions;\n    const existingPermissions = await getPermissions();\n\n    if (!existingPermissions) {\n      const [, metadata] = await requestPermissions(requestedPermissions);\n      res.result = metadata.data[\n        WALLET_SNAP_PERMISSION_KEY\n      ] as RequestSnapsResult;\n    } else if (hasRequestedSnaps(existingPermissions, requestedSnaps)) {\n      res.result = await installSnaps(requestedSnaps);\n    } else {\n      const mergedPermissionsRequest = getSnapPermissionsRequest(\n        existingPermissions,\n        requestedPermissions,\n      );\n\n      const [, metadata] = await requestPermissions(mergedPermissionsRequest);\n      res.result = metadata.data[\n        WALLET_SNAP_PERMISSION_KEY\n      ] as RequestSnapsResult;\n    }\n  } catch (error) {\n    res.error = error;\n  }\n\n  return end();\n}\n"]}
\ No newline at end of file
