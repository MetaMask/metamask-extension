diff --git a/dist/KeyringController.cjs b/dist/KeyringController.cjs
index 0632dc6786b8113acc07e251d58783eb6a62aef2..385b4eaafc043348bbae6484e555cf2fe7077897 100644
--- a/dist/KeyringController.cjs
+++ b/dist/KeyringController.cjs
@@ -36,7 +36,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _KeyringController_instances, _KeyringController_controllerOperationMutex, _KeyringController_vaultOperationMutex, _KeyringController_keyringBuilders, _KeyringController_unsupportedKeyrings, _KeyringController_encryptor, _KeyringController_cacheEncryptionKey, _KeyringController_keyrings, _KeyringController_keyringsMetadata, _KeyringController_password, _KeyringController_qrKeyringStateListener, _KeyringController_registerMessageHandlers, _KeyringController_getKeyringById, _KeyringController_getKeyringByIdOrDefault, _KeyringController_getKeyringBuilderForType, _KeyringController_addQRKeyring, _KeyringController_subscribeToQRKeyringEvents, _KeyringController_unsubscribeFromQRKeyringsEvents, _KeyringController_createNewVaultWithKeyring, _KeyringController_verifySeedPhrase, _KeyringController_getUpdatedKeyrings, _KeyringController_getSerializedKeyrings, _KeyringController_restoreSerializedKeyrings, _KeyringController_unlockKeyrings, _KeyringController_updateVault, _KeyringController_getAccountsFromKeyrings, _KeyringController_createKeyringWithFirstAccount, _KeyringController_newKeyring, _KeyringController_createKeyring, _KeyringController_clearKeyrings, _KeyringController_restoreKeyring, _KeyringController_destroyKeyring, _KeyringController_removeEmptyKeyrings, _KeyringController_checkForDuplicate, _KeyringController_setUnlocked, _KeyringController_assertIsUnlocked, _KeyringController_persistOrRollback, _KeyringController_withRollback, _KeyringController_assertControllerMutexIsLocked, _KeyringController_withControllerLock, _KeyringController_withVaultLock;
+var _KeyringController_instances, _KeyringController_controllerOperationMutex, _KeyringController_vaultOperationMutex, _KeyringController_keyringBuilders, _KeyringController_unsupportedKeyrings, _KeyringController_encryptor, _KeyringController_cacheEncryptionKey, _KeyringController_keyrings, _KeyringController_password, _KeyringController_qrKeyringStateListener, _KeyringController_registerMessageHandlers, _KeyringController_getKeyringBuilderForType, _KeyringController_addQRKeyring, _KeyringController_subscribeToQRKeyringEvents, _KeyringController_unsubscribeFromQRKeyringsEvents, _KeyringController_createNewVaultWithKeyring, _KeyringController_verifySeedPhrase, _KeyringController_getUpdatedKeyrings, _KeyringController_getSerializedKeyrings, _KeyringController_restoreSerializedKeyrings, _KeyringController_unlockKeyrings, _KeyringController_updateVault, _KeyringController_getAccountsFromKeyrings, _KeyringController_createKeyringWithFirstAccount, _KeyringController_newKeyring, _KeyringController_clearKeyrings, _KeyringController_restoreKeyring, _KeyringController_destroyKeyring, _KeyringController_removeEmptyKeyrings, _KeyringController_checkForDuplicate, _KeyringController_setUnlocked, _KeyringController_assertIsUnlocked, _KeyringController_persistOrRollback, _KeyringController_withRollback, _KeyringController_assertControllerMutexIsLocked, _KeyringController_withControllerLock, _KeyringController_withVaultLock;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.KeyringController = exports.getDefaultKeyringState = exports.keyringBuilderFactory = exports.SignTypedDataVersion = exports.AccountImportStrategy = exports.isCustodyKeyring = exports.KeyringTypes = void 0;
 const util_1 = require("@ethereumjs/util");
@@ -48,8 +48,6 @@ const eth_simple_keyring_1 = __importDefault(require("@metamask/eth-simple-keyri
 const utils_1 = require("@metamask/utils");
 const async_mutex_1 = require("async-mutex");
 const ethereumjs_wallet_1 = __importStar(require("ethereumjs-wallet"));
-// When generating a ULID within the same millisecond, monotonicFactory provides some guarantees regarding sort order.
-const ulid_1 = require("ulid");
 const constants_1 = require("./constants.cjs");
 const name = 'KeyringController';
 /**
@@ -121,7 +119,6 @@ const getDefaultKeyringState = () => {
     return {
         isUnlocked: false,
         keyrings: [],
-        keyringsMetadata: [],
     };
 };
 exports.getDefaultKeyringState = getDefaultKeyringState;
@@ -253,7 +250,6 @@ class KeyringController extends base_controller_1.BaseController {
                 vault: { persist: true, anonymous: false },
                 isUnlocked: { persist: false, anonymous: true },
                 keyrings: { persist: false, anonymous: false },
-                keyringsMetadata: { persist: true, anonymous: false },
                 encryptionKey: { persist: false, anonymous: false },
                 encryptionSalt: { persist: false, anonymous: false },
             },
@@ -271,7 +267,6 @@ class KeyringController extends base_controller_1.BaseController {
         _KeyringController_encryptor.set(this, void 0);
         _KeyringController_cacheEncryptionKey.set(this, void 0);
         _KeyringController_keyrings.set(this, void 0);
-        _KeyringController_keyringsMetadata.set(this, void 0);
         _KeyringController_password.set(this, void 0);
         _KeyringController_qrKeyringStateListener.set(this, void 0);
         __classPrivateFieldSet(this, _KeyringController_keyringBuilders, keyringBuilders
@@ -279,7 +274,6 @@ class KeyringController extends base_controller_1.BaseController {
             : defaultKeyringBuilders, "f");
         __classPrivateFieldSet(this, _KeyringController_encryptor, encryptor, "f");
         __classPrivateFieldSet(this, _KeyringController_keyrings, [], "f");
-        __classPrivateFieldSet(this, _KeyringController_keyringsMetadata, state?.keyringsMetadata ?? [], "f");
         __classPrivateFieldSet(this, _KeyringController_unsupportedKeyrings, [], "f");
         // This option allows the controller to cache an exported key
         // for use in decrypting and encrypting data without password
@@ -428,18 +422,13 @@ class KeyringController extends base_controller_1.BaseController {
      * Gets the seed phrase of the HD keyring.
      *
      * @param password - Password of the keyring.
-     * @param keyringId - The id of the keyring.
      * @returns Promise resolving to the seed phrase.
      */
-    async exportSeedPhrase(password, keyringId) {
+    async exportSeedPhrase(password) {
         __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_assertIsUnlocked).call(this);
         await this.verifyPassword(password);
-        const selectedKeyring = __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getKeyringByIdOrDefault).call(this, keyringId);
-        if (!selectedKeyring) {
-            throw new Error('Keyring not found');
-        }
-        assertHasUint8ArrayMnemonic(selectedKeyring);
-        return selectedKeyring.mnemonic;
+        assertHasUint8ArrayMnemonic(__classPrivateFieldGet(this, _KeyringController_keyrings, "f")[0]);
+        return __classPrivateFieldGet(this, _KeyringController_keyrings, "f")[0].mnemonic;
     }
     /**
      * Gets the private key from the keyring controlling an address.
@@ -624,13 +613,6 @@ class KeyringController extends base_controller_1.BaseController {
         __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_assertIsUnlocked).call(this);
         await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_persistOrRollback).call(this, async () => {
             const keyring = (await this.getKeyringForAccount(address));
-            const keyringIndex = this.state.keyrings.findIndex((kr) => kr.accounts.includes(address));
-            const isPrimaryKeyring = keyringIndex === 0;
-            const shouldRemoveKeyring = (await keyring.getAccounts()).length === 1;
-            // Primary keyring should never be removed, so we need to keep at least one account in it
-            if (isPrimaryKeyring && shouldRemoveKeyring) {
-                throw new Error(constants_1.KeyringControllerError.LastAccountInPrimaryKeyring);
-            }
             // Not all the keyrings support this, so we have to check
             if (!keyring.removeAccount) {
                 throw new Error(constants_1.KeyringControllerError.UnsupportedRemoveAccount);
@@ -641,7 +623,9 @@ class KeyringController extends base_controller_1.BaseController {
             // because `Keyring<State>.removeAccount` requires address to be `Hex`. Those
             // type would need to be updated for a full non-EVM support.
             keyring.removeAccount(address);
-            if (shouldRemoveKeyring) {
+            const accounts = await keyring.getAccounts();
+            // Check if this was the last/only account
+            if (accounts.length === 0) {
                 await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_removeEmptyKeyrings).call(this);
             }
         });
@@ -879,12 +863,11 @@ class KeyringController extends base_controller_1.BaseController {
     /**
      * Verifies the that the seed phrase restores the current keychain's accounts.
      *
-     * @param keyringId - The id of the keyring to verify.
      * @returns Promise resolving to the seed phrase as Uint8Array.
      */
-    async verifySeedPhrase(keyringId) {
+    async verifySeedPhrase() {
         __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_assertIsUnlocked).call(this);
-        return __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_withControllerLock).call(this, async () => __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_verifySeedPhrase).call(this, keyringId));
+        return __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_withControllerLock).call(this, async () => __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_verifySeedPhrase).call(this));
     }
     async withKeyring(selector, operation, options = {
         createIfMissing: false,
@@ -895,15 +878,12 @@ class KeyringController extends base_controller_1.BaseController {
             if ('address' in selector) {
                 keyring = (await this.getKeyringForAccount(selector.address));
             }
-            else if ('type' in selector) {
+            else {
                 keyring = this.getKeyringsByType(selector.type)[selector.index || 0];
                 if (!keyring && options.createIfMissing) {
                     keyring = (await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_newKeyring).call(this, selector.type, options.createWithData));
                 }
             }
-            else if ('id' in selector) {
-                keyring = __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getKeyringById).call(this, selector.id);
-            }
             if (!keyring) {
                 throw new Error(constants_1.KeyringControllerError.KeyringNotFound);
             }
@@ -1117,7 +1097,7 @@ class KeyringController extends base_controller_1.BaseController {
     }
 }
 exports.KeyringController = KeyringController;
-_KeyringController_controllerOperationMutex = new WeakMap(), _KeyringController_vaultOperationMutex = new WeakMap(), _KeyringController_keyringBuilders = new WeakMap(), _KeyringController_unsupportedKeyrings = new WeakMap(), _KeyringController_encryptor = new WeakMap(), _KeyringController_cacheEncryptionKey = new WeakMap(), _KeyringController_keyrings = new WeakMap(), _KeyringController_keyringsMetadata = new WeakMap(), _KeyringController_password = new WeakMap(), _KeyringController_qrKeyringStateListener = new WeakMap(), _KeyringController_instances = new WeakSet(), _KeyringController_registerMessageHandlers = function _KeyringController_registerMessageHandlers() {
+_KeyringController_controllerOperationMutex = new WeakMap(), _KeyringController_vaultOperationMutex = new WeakMap(), _KeyringController_keyringBuilders = new WeakMap(), _KeyringController_unsupportedKeyrings = new WeakMap(), _KeyringController_encryptor = new WeakMap(), _KeyringController_cacheEncryptionKey = new WeakMap(), _KeyringController_keyrings = new WeakMap(), _KeyringController_password = new WeakMap(), _KeyringController_qrKeyringStateListener = new WeakMap(), _KeyringController_instances = new WeakSet(), _KeyringController_registerMessageHandlers = function _KeyringController_registerMessageHandlers() {
     this.messagingSystem.registerActionHandler(`${name}:signMessage`, this.signMessage.bind(this));
     this.messagingSystem.registerActionHandler(`${name}:signEip7702Authorization`, this.signEip7702Authorization.bind(this));
     this.messagingSystem.registerActionHandler(`${name}:signPersonalMessage`, this.signPersonalMessage.bind(this));
@@ -1132,15 +1112,6 @@ _KeyringController_controllerOperationMutex = new WeakMap(), _KeyringController_
     this.messagingSystem.registerActionHandler(`${name}:patchUserOperation`, this.patchUserOperation.bind(this));
     this.messagingSystem.registerActionHandler(`${name}:signUserOperation`, this.signUserOperation.bind(this));
     this.messagingSystem.registerActionHandler(`${name}:addNewAccount`, this.addNewAccount.bind(this));
-    this.messagingSystem.registerActionHandler(`${name}:withKeyring`, this.withKeyring.bind(this));
-}, _KeyringController_getKeyringById = function _KeyringController_getKeyringById(keyringId) {
-    const index = this.state.keyringsMetadata.findIndex((metadata) => metadata.id === keyringId);
-    return __classPrivateFieldGet(this, _KeyringController_keyrings, "f")[index];
-}, _KeyringController_getKeyringByIdOrDefault = function _KeyringController_getKeyringByIdOrDefault(keyringId) {
-    if (!keyringId) {
-        return __classPrivateFieldGet(this, _KeyringController_keyrings, "f")[0];
-    }
-    return __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getKeyringById).call(this, keyringId);
 }, _KeyringController_getKeyringBuilderForType = function _KeyringController_getKeyringBuilderForType(type) {
     return __classPrivateFieldGet(this, _KeyringController_keyringBuilders, "f").find((keyringBuilder) => keyringBuilder.type === type);
 }, _KeyringController_addQRKeyring = 
@@ -1193,29 +1164,23 @@ async function _KeyringController_createNewVaultWithKeyring(password, keyring) {
     });
     __classPrivateFieldSet(this, _KeyringController_password, password, "f");
     await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_clearKeyrings).call(this);
-    __classPrivateFieldSet(this, _KeyringController_keyringsMetadata, [], "f");
     await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_createKeyringWithFirstAccount).call(this, keyring.type, keyring.opts);
     __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_setUnlocked).call(this);
 }, _KeyringController_verifySeedPhrase = 
 /**
  * Internal non-exclusive method to verify the seed phrase.
  *
- * @param keyringId - The id of the keyring to verify the seed phrase for.
  * @returns A promise resolving to the seed phrase as Uint8Array.
  */
-async function _KeyringController_verifySeedPhrase(keyringId) {
+async function _KeyringController_verifySeedPhrase() {
     __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_assertControllerMutexIsLocked).call(this);
-    const keyring = __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getKeyringByIdOrDefault).call(this, keyringId);
-    if (!keyring) {
-        throw new Error(constants_1.KeyringControllerError.KeyringNotFound);
-    }
-    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
-    if (keyring.type !== KeyringTypes.hd) {
-        throw new Error(constants_1.KeyringControllerError.UnsupportedVerifySeedPhrase);
+    const primaryKeyring = this.getKeyringsByType(KeyringTypes.hd)[0];
+    if (!primaryKeyring) {
+        throw new Error('No HD keyring found.');
     }
-    assertHasUint8ArrayMnemonic(keyring);
-    const seedWords = keyring.mnemonic;
-    const accounts = await keyring.getAccounts();
+    assertHasUint8ArrayMnemonic(primaryKeyring);
+    const seedWords = primaryKeyring.mnemonic;
+    const accounts = await primaryKeyring.getAccounts();
     /* istanbul ignore if */
     if (accounts.length === 0) {
         throw new Error('Cannot verify an empty keyring.');
@@ -1395,13 +1360,9 @@ async function _KeyringController_unlockKeyrings(password, encryptionKey, encryp
             throw new Error(constants_1.KeyringControllerError.MissingVaultData);
         }
         const updatedKeyrings = await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getUpdatedKeyrings).call(this);
-        if (updatedKeyrings.length !== __classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").length) {
-            throw new Error(constants_1.KeyringControllerError.KeyringMetadataLengthMismatch);
-        }
         this.update((state) => {
             state.vault = updatedState.vault;
             state.keyrings = updatedKeyrings;
-            state.keyringsMetadata = __classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").slice();
             if (updatedState.encryptionKey) {
                 state.encryptionKey = updatedState.encryptionKey;
                 state.encryptionSalt = JSON.parse(updatedState.vault).salt;
@@ -1441,48 +1402,19 @@ async function _KeyringController_createKeyringWithFirstAccount(type, opts) {
     if (!firstAccount) {
         throw new Error(constants_1.KeyringControllerError.NoFirstAccount);
     }
-    return firstAccount;
 }, _KeyringController_newKeyring = 
 /**
  * Instantiate, initialize and return a new keyring of the given `type`,
  * using the given `opts`. The keyring is built using the keyring builder
  * registered for the given `type`.
  *
- * The internal keyring and keyring metadata arrays are updated with the new
- * keyring as well.
  *
  * @param type - The type of keyring to add.
- * @param data - Keyring initialization options.
+ * @param data - The data to restore a previously serialized keyring.
  * @returns The new keyring.
  * @throws If the keyring includes duplicated accounts.
  */
 async function _KeyringController_newKeyring(type, data) {
-    const keyring = await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_createKeyring).call(this, type, data);
-    if (__classPrivateFieldGet(this, _KeyringController_keyrings, "f").length !== __classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").length) {
-        throw new Error('Keyring metadata missing');
-    }
-    __classPrivateFieldGet(this, _KeyringController_keyrings, "f").push(keyring);
-    __classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").push(getDefaultKeyringMetadata());
-    return keyring;
-}, _KeyringController_createKeyring = 
-/**
- * Instantiate, initialize and return a keyring of the given `type` using the
- * given `opts`. The keyring is built using the keyring builder registered
- * for the given `type`.
- *
- * The keyring might be new, or it might be restored from the vault. This
- * function should only be called from `#newKeyring` or `#restoreKeyring`,
- * for the "new" and "restore" cases respectively.
- *
- * The internal keyring and keyring metadata arrays are *not* updated, the
- * caller is expected to update them.
- *
- * @param type - The type of keyring to add.
- * @param data - Keyring initialization options.
- * @returns The new keyring.
- * @throws If the keyring includes duplicated accounts.
- */
-async function _KeyringController_createKeyring(type, data) {
     __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_assertControllerMutexIsLocked).call(this);
     const keyringBuilder = __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getKeyringBuilderForType).call(this, type);
     if (!keyringBuilder) {
@@ -1510,6 +1442,7 @@ async function _KeyringController_createKeyring(type, data) {
         // to its events after creating it
         __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_subscribeToQRKeyringEvents).call(this, keyring);
     }
+    __classPrivateFieldGet(this, _KeyringController_keyrings, "f").push(keyring);
     return keyring;
 }, _KeyringController_clearKeyrings = 
 /**
@@ -1534,15 +1467,7 @@ async function _KeyringController_restoreKeyring(serialized) {
     __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_assertControllerMutexIsLocked).call(this);
     try {
         const { type, data } = serialized;
-        const keyring = await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_createKeyring).call(this, type, data);
-        __classPrivateFieldGet(this, _KeyringController_keyrings, "f").push(keyring);
-        // If metadata is missing, assume the data is from an installation before
-        // we had keyring metadata.
-        if (__classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").length < __classPrivateFieldGet(this, _KeyringController_keyrings, "f").length) {
-            console.log(`Adding missing metadata for '${type}' keyring`);
-            __classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").push(getDefaultKeyringMetadata());
-        }
-        return keyring;
+        return await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_newKeyring).call(this, type, data);
     }
     catch (_) {
         __classPrivateFieldGet(this, _KeyringController_unsupportedKeyrings, "f").push(serialized);
@@ -1570,22 +1495,19 @@ async function _KeyringController_destroyKeyring(keyring) {
 async function _KeyringController_removeEmptyKeyrings() {
     __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_assertControllerMutexIsLocked).call(this);
     const validKeyrings = [];
-    const validKeyringMetadata = [];
     // Since getAccounts returns a Promise
     // We need to wait to hear back form each keyring
     // in order to decide which ones are now valid (accounts.length > 0)
-    await Promise.all(__classPrivateFieldGet(this, _KeyringController_keyrings, "f").map(async (keyring, index) => {
+    await Promise.all(__classPrivateFieldGet(this, _KeyringController_keyrings, "f").map(async (keyring) => {
         const accounts = await keyring.getAccounts();
         if (accounts.length > 0) {
             validKeyrings.push(keyring);
-            validKeyringMetadata.push(__classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f")[index]);
         }
         else {
             await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_destroyKeyring).call(this, keyring);
         }
     }));
     __classPrivateFieldSet(this, _KeyringController_keyrings, validKeyrings, "f");
-    __classPrivateFieldSet(this, _KeyringController_keyringsMetadata, validKeyringMetadata, "f");
 }, _KeyringController_checkForDuplicate = 
 /**
  * Checks for duplicate keypairs, using the the first account in the given
@@ -1651,7 +1573,6 @@ async function _KeyringController_withRollback(callback) {
     return __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_withControllerLock).call(this, async ({ releaseLock }) => {
         const currentSerializedKeyrings = await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getSerializedKeyrings).call(this);
         const currentPassword = __classPrivateFieldGet(this, _KeyringController_password, "f");
-        const currentKeyringsMetadata = __classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").slice();
         try {
             return await callback({ releaseLock });
         }
@@ -1659,7 +1580,6 @@ async function _KeyringController_withRollback(callback) {
             // Keyrings and password are restored to their previous state
             await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_restoreSerializedKeyrings).call(this, currentSerializedKeyrings);
             __classPrivateFieldSet(this, _KeyringController_password, currentPassword, "f");
-            __classPrivateFieldSet(this, _KeyringController_keyringsMetadata, currentKeyringsMetadata, "f");
             throw e;
         }
     });
@@ -1716,13 +1636,5 @@ async function withLock(mutex, callback) {
         releaseLock();
     }
 }
-/**
- * Generate a new keyring metadata object.
- *
- * @returns Keyring metadata.
- */
-function getDefaultKeyringMetadata() {
-    return { id: (0, ulid_1.ulid)(), name: '' };
-}
 exports.default = KeyringController;
 //# sourceMappingURL=KeyringController.cjs.map
\ No newline at end of file
diff --git a/dist/KeyringController.d.cts b/dist/KeyringController.d.cts
index c1dedc2b4e3e9c07da5bc36dab493d8b631f1f0d..b81a421ca2cc64d1dd416e9e291e811ae2164341 100644
--- a/dist/KeyringController.d.cts
+++ b/dist/KeyringController.d.cts
@@ -47,10 +47,6 @@ export type KeyringControllerState = {
      * Representations of managed keyrings.
      */
     keyrings: KeyringObject[];
-    /**
-     * Metadata for each keyring.
-     */
-    keyringsMetadata: KeyringMetadata[];
     /**
      * The encryption key derived from the password and used to encrypt
      * the vault. This is only stored if the `cacheEncryptionKey` option
@@ -123,10 +119,6 @@ export type KeyringControllerAddNewAccountAction = {
     type: `${typeof name}:addNewAccount`;
     handler: KeyringController['addNewAccount'];
 };
-export type KeyringControllerWithKeyringAction = {
-    type: `${typeof name}:withKeyring`;
-    handler: KeyringController['withKeyring'];
-};
 export type KeyringControllerStateChangeEvent = {
     type: `${typeof name}:stateChange`;
     payload: [KeyringControllerState, Patch[]];
@@ -147,7 +139,7 @@ export type KeyringControllerQRKeyringStateChangeEvent = {
     type: `${typeof name}:qrKeyringStateChange`;
     payload: [ReturnType<IQRKeyringState['getState']>];
 };
-export type KeyringControllerActions = KeyringControllerGetStateAction | KeyringControllerSignMessageAction | KeyringControllerSignEip7702AuthorizationAction | KeyringControllerSignPersonalMessageAction | KeyringControllerSignTypedMessageAction | KeyringControllerDecryptMessageAction | KeyringControllerGetEncryptionPublicKeyAction | KeyringControllerGetAccountsAction | KeyringControllerGetKeyringsByTypeAction | KeyringControllerGetKeyringForAccountAction | KeyringControllerPersistAllKeyringsAction | KeyringControllerPrepareUserOperationAction | KeyringControllerPatchUserOperationAction | KeyringControllerSignUserOperationAction | KeyringControllerAddNewAccountAction | KeyringControllerWithKeyringAction;
+export type KeyringControllerActions = KeyringControllerGetStateAction | KeyringControllerSignMessageAction | KeyringControllerSignEip7702AuthorizationAction | KeyringControllerSignPersonalMessageAction | KeyringControllerSignTypedMessageAction | KeyringControllerDecryptMessageAction | KeyringControllerGetEncryptionPublicKeyAction | KeyringControllerGetAccountsAction | KeyringControllerGetKeyringsByTypeAction | KeyringControllerGetKeyringForAccountAction | KeyringControllerPersistAllKeyringsAction | KeyringControllerPrepareUserOperationAction | KeyringControllerPatchUserOperationAction | KeyringControllerSignUserOperationAction | KeyringControllerAddNewAccountAction;
 export type KeyringControllerEvents = KeyringControllerStateChangeEvent | KeyringControllerLockEvent | KeyringControllerUnlockEvent | KeyringControllerAccountRemovedEvent | KeyringControllerQRKeyringStateChangeEvent;
 export type KeyringControllerMessenger = RestrictedMessenger<typeof name, KeyringControllerActions, KeyringControllerEvents, never, never>;
 export type KeyringControllerOptions = {
@@ -158,7 +150,6 @@ export type KeyringControllerOptions = {
     messenger: KeyringControllerMessenger;
     state?: {
         vault?: string;
-        keyringsMetadata?: KeyringMetadata[];
     };
 } & ({
     cacheEncryptionKey: true;
@@ -180,19 +171,6 @@ export type KeyringObject = {
      */
     type: string;
 };
-/**
- * Additional information related to a keyring.
- */
-export type KeyringMetadata = {
-    /**
-     * Keyring ID
-     */
-    id: string;
-    /**
-     * Keyring name
-     */
-    name: string;
-};
 /**
  * A strategy for importing an account
  */
@@ -303,8 +281,6 @@ export type KeyringSelector = {
     index?: number;
 } | {
     address: Hex;
-} | {
-    id: string;
 };
 /**
  * Get builder function for `Keyring`
@@ -403,10 +379,9 @@ export declare class KeyringController extends BaseController<typeof name, Keyri
      * Gets the seed phrase of the HD keyring.
      *
      * @param password - Password of the keyring.
-     * @param keyringId - The id of the keyring.
      * @returns Promise resolving to the seed phrase.
      */
-    exportSeedPhrase(password: string, keyringId?: string): Promise<Uint8Array>;
+    exportSeedPhrase(password: string): Promise<Uint8Array>;
     /**
      * Gets the private key from the keyring controlling an address.
      *
@@ -589,10 +564,9 @@ export declare class KeyringController extends BaseController<typeof name, Keyri
     /**
      * Verifies the that the seed phrase restores the current keychain's accounts.
      *
-     * @param keyringId - The id of the keyring to verify.
      * @returns Promise resolving to the seed phrase as Uint8Array.
      */
-    verifySeedPhrase(keyringId?: string): Promise<Uint8Array>;
+    verifySeedPhrase(): Promise<Uint8Array>;
     /**
      * Select a keyring and execute the given operation with
      * the selected keyring, as a mutually exclusive atomic
diff --git a/dist/KeyringController.d.mts b/dist/KeyringController.d.mts
index 1498ad8ec2a0e5459f235c7d321bf8a45be1584a..54f395942462577f7972874ea2d2bcceb6c2e83e 100644
--- a/dist/KeyringController.d.mts
+++ b/dist/KeyringController.d.mts
@@ -47,10 +47,6 @@ export type KeyringControllerState = {
      * Representations of managed keyrings.
      */
     keyrings: KeyringObject[];
-    /**
-     * Metadata for each keyring.
-     */
-    keyringsMetadata: KeyringMetadata[];
     /**
      * The encryption key derived from the password and used to encrypt
      * the vault. This is only stored if the `cacheEncryptionKey` option
@@ -123,10 +119,6 @@ export type KeyringControllerAddNewAccountAction = {
     type: `${typeof name}:addNewAccount`;
     handler: KeyringController['addNewAccount'];
 };
-export type KeyringControllerWithKeyringAction = {
-    type: `${typeof name}:withKeyring`;
-    handler: KeyringController['withKeyring'];
-};
 export type KeyringControllerStateChangeEvent = {
     type: `${typeof name}:stateChange`;
     payload: [KeyringControllerState, Patch[]];
@@ -147,7 +139,7 @@ export type KeyringControllerQRKeyringStateChangeEvent = {
     type: `${typeof name}:qrKeyringStateChange`;
     payload: [ReturnType<IQRKeyringState['getState']>];
 };
-export type KeyringControllerActions = KeyringControllerGetStateAction | KeyringControllerSignMessageAction | KeyringControllerSignEip7702AuthorizationAction | KeyringControllerSignPersonalMessageAction | KeyringControllerSignTypedMessageAction | KeyringControllerDecryptMessageAction | KeyringControllerGetEncryptionPublicKeyAction | KeyringControllerGetAccountsAction | KeyringControllerGetKeyringsByTypeAction | KeyringControllerGetKeyringForAccountAction | KeyringControllerPersistAllKeyringsAction | KeyringControllerPrepareUserOperationAction | KeyringControllerPatchUserOperationAction | KeyringControllerSignUserOperationAction | KeyringControllerAddNewAccountAction | KeyringControllerWithKeyringAction;
+export type KeyringControllerActions = KeyringControllerGetStateAction | KeyringControllerSignMessageAction | KeyringControllerSignEip7702AuthorizationAction | KeyringControllerSignPersonalMessageAction | KeyringControllerSignTypedMessageAction | KeyringControllerDecryptMessageAction | KeyringControllerGetEncryptionPublicKeyAction | KeyringControllerGetAccountsAction | KeyringControllerGetKeyringsByTypeAction | KeyringControllerGetKeyringForAccountAction | KeyringControllerPersistAllKeyringsAction | KeyringControllerPrepareUserOperationAction | KeyringControllerPatchUserOperationAction | KeyringControllerSignUserOperationAction | KeyringControllerAddNewAccountAction;
 export type KeyringControllerEvents = KeyringControllerStateChangeEvent | KeyringControllerLockEvent | KeyringControllerUnlockEvent | KeyringControllerAccountRemovedEvent | KeyringControllerQRKeyringStateChangeEvent;
 export type KeyringControllerMessenger = RestrictedMessenger<typeof name, KeyringControllerActions, KeyringControllerEvents, never, never>;
 export type KeyringControllerOptions = {
@@ -158,7 +150,6 @@ export type KeyringControllerOptions = {
     messenger: KeyringControllerMessenger;
     state?: {
         vault?: string;
-        keyringsMetadata?: KeyringMetadata[];
     };
 } & ({
     cacheEncryptionKey: true;
@@ -180,19 +171,6 @@ export type KeyringObject = {
      */
     type: string;
 };
-/**
- * Additional information related to a keyring.
- */
-export type KeyringMetadata = {
-    /**
-     * Keyring ID
-     */
-    id: string;
-    /**
-     * Keyring name
-     */
-    name: string;
-};
 /**
  * A strategy for importing an account
  */
@@ -303,8 +281,6 @@ export type KeyringSelector = {
     index?: number;
 } | {
     address: Hex;
-} | {
-    id: string;
 };
 /**
  * Get builder function for `Keyring`
@@ -403,10 +379,9 @@ export declare class KeyringController extends BaseController<typeof name, Keyri
      * Gets the seed phrase of the HD keyring.
      *
      * @param password - Password of the keyring.
-     * @param keyringId - The id of the keyring.
      * @returns Promise resolving to the seed phrase.
      */
-    exportSeedPhrase(password: string, keyringId?: string): Promise<Uint8Array>;
+    exportSeedPhrase(password: string): Promise<Uint8Array>;
     /**
      * Gets the private key from the keyring controlling an address.
      *
@@ -589,10 +564,9 @@ export declare class KeyringController extends BaseController<typeof name, Keyri
     /**
      * Verifies the that the seed phrase restores the current keychain's accounts.
      *
-     * @param keyringId - The id of the keyring to verify.
      * @returns Promise resolving to the seed phrase as Uint8Array.
      */
-    verifySeedPhrase(keyringId?: string): Promise<Uint8Array>;
+    verifySeedPhrase(): Promise<Uint8Array>;
     /**
      * Select a keyring and execute the given operation with
      * the selected keyring, as a mutually exclusive atomic
diff --git a/dist/KeyringController.mjs b/dist/KeyringController.mjs
index d1bb4efd63f0f0b16ec68721d4fce2b18a04be39..4b04aeb83971f230db25a88cad343d6e09d4aac9 100644
--- a/dist/KeyringController.mjs
+++ b/dist/KeyringController.mjs
@@ -9,7 +9,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
     return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
 };
-var _KeyringController_instances, _KeyringController_controllerOperationMutex, _KeyringController_vaultOperationMutex, _KeyringController_keyringBuilders, _KeyringController_unsupportedKeyrings, _KeyringController_encryptor, _KeyringController_cacheEncryptionKey, _KeyringController_keyrings, _KeyringController_keyringsMetadata, _KeyringController_password, _KeyringController_qrKeyringStateListener, _KeyringController_registerMessageHandlers, _KeyringController_getKeyringById, _KeyringController_getKeyringByIdOrDefault, _KeyringController_getKeyringBuilderForType, _KeyringController_addQRKeyring, _KeyringController_subscribeToQRKeyringEvents, _KeyringController_unsubscribeFromQRKeyringsEvents, _KeyringController_createNewVaultWithKeyring, _KeyringController_verifySeedPhrase, _KeyringController_getUpdatedKeyrings, _KeyringController_getSerializedKeyrings, _KeyringController_restoreSerializedKeyrings, _KeyringController_unlockKeyrings, _KeyringController_updateVault, _KeyringController_getAccountsFromKeyrings, _KeyringController_createKeyringWithFirstAccount, _KeyringController_newKeyring, _KeyringController_createKeyring, _KeyringController_clearKeyrings, _KeyringController_restoreKeyring, _KeyringController_destroyKeyring, _KeyringController_removeEmptyKeyrings, _KeyringController_checkForDuplicate, _KeyringController_setUnlocked, _KeyringController_assertIsUnlocked, _KeyringController_persistOrRollback, _KeyringController_withRollback, _KeyringController_assertControllerMutexIsLocked, _KeyringController_withControllerLock, _KeyringController_withVaultLock;
+var _KeyringController_instances, _KeyringController_controllerOperationMutex, _KeyringController_vaultOperationMutex, _KeyringController_keyringBuilders, _KeyringController_unsupportedKeyrings, _KeyringController_encryptor, _KeyringController_cacheEncryptionKey, _KeyringController_keyrings, _KeyringController_password, _KeyringController_qrKeyringStateListener, _KeyringController_registerMessageHandlers, _KeyringController_getKeyringBuilderForType, _KeyringController_addQRKeyring, _KeyringController_subscribeToQRKeyringEvents, _KeyringController_unsubscribeFromQRKeyringsEvents, _KeyringController_createNewVaultWithKeyring, _KeyringController_verifySeedPhrase, _KeyringController_getUpdatedKeyrings, _KeyringController_getSerializedKeyrings, _KeyringController_restoreSerializedKeyrings, _KeyringController_unlockKeyrings, _KeyringController_updateVault, _KeyringController_getAccountsFromKeyrings, _KeyringController_createKeyringWithFirstAccount, _KeyringController_newKeyring, _KeyringController_clearKeyrings, _KeyringController_restoreKeyring, _KeyringController_destroyKeyring, _KeyringController_removeEmptyKeyrings, _KeyringController_checkForDuplicate, _KeyringController_setUnlocked, _KeyringController_assertIsUnlocked, _KeyringController_persistOrRollback, _KeyringController_withRollback, _KeyringController_assertControllerMutexIsLocked, _KeyringController_withControllerLock, _KeyringController_withVaultLock;
 function $importDefault(module) {
     if (module?.__esModule) {
         return module.default;
@@ -27,8 +27,6 @@ import { Mutex } from "async-mutex";
 import $Wallet from "ethereumjs-wallet";
 const { thirdparty: importers } = $Wallet;
 const Wallet = $importDefault($Wallet);
-// When generating a ULID within the same millisecond, monotonicFactory provides some guarantees regarding sort order.
-import { ulid } from "ulid";
 import { KeyringControllerError } from "./constants.mjs";
 const name = 'KeyringController';
 /**
@@ -98,7 +96,6 @@ export const getDefaultKeyringState = () => {
     return {
         isUnlocked: false,
         keyrings: [],
-        keyringsMetadata: [],
     };
 };
 /**
@@ -229,7 +226,6 @@ export class KeyringController extends BaseController {
                 vault: { persist: true, anonymous: false },
                 isUnlocked: { persist: false, anonymous: true },
                 keyrings: { persist: false, anonymous: false },
-                keyringsMetadata: { persist: true, anonymous: false },
                 encryptionKey: { persist: false, anonymous: false },
                 encryptionSalt: { persist: false, anonymous: false },
             },
@@ -247,7 +243,6 @@ export class KeyringController extends BaseController {
         _KeyringController_encryptor.set(this, void 0);
         _KeyringController_cacheEncryptionKey.set(this, void 0);
         _KeyringController_keyrings.set(this, void 0);
-        _KeyringController_keyringsMetadata.set(this, void 0);
         _KeyringController_password.set(this, void 0);
         _KeyringController_qrKeyringStateListener.set(this, void 0);
         __classPrivateFieldSet(this, _KeyringController_keyringBuilders, keyringBuilders
@@ -255,7 +250,6 @@ export class KeyringController extends BaseController {
             : defaultKeyringBuilders, "f");
         __classPrivateFieldSet(this, _KeyringController_encryptor, encryptor, "f");
         __classPrivateFieldSet(this, _KeyringController_keyrings, [], "f");
-        __classPrivateFieldSet(this, _KeyringController_keyringsMetadata, state?.keyringsMetadata ?? [], "f");
         __classPrivateFieldSet(this, _KeyringController_unsupportedKeyrings, [], "f");
         // This option allows the controller to cache an exported key
         // for use in decrypting and encrypting data without password
@@ -404,18 +398,13 @@ export class KeyringController extends BaseController {
      * Gets the seed phrase of the HD keyring.
      *
      * @param password - Password of the keyring.
-     * @param keyringId - The id of the keyring.
      * @returns Promise resolving to the seed phrase.
      */
-    async exportSeedPhrase(password, keyringId) {
+    async exportSeedPhrase(password) {
         __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_assertIsUnlocked).call(this);
         await this.verifyPassword(password);
-        const selectedKeyring = __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getKeyringByIdOrDefault).call(this, keyringId);
-        if (!selectedKeyring) {
-            throw new Error('Keyring not found');
-        }
-        assertHasUint8ArrayMnemonic(selectedKeyring);
-        return selectedKeyring.mnemonic;
+        assertHasUint8ArrayMnemonic(__classPrivateFieldGet(this, _KeyringController_keyrings, "f")[0]);
+        return __classPrivateFieldGet(this, _KeyringController_keyrings, "f")[0].mnemonic;
     }
     /**
      * Gets the private key from the keyring controlling an address.
@@ -600,13 +589,6 @@ export class KeyringController extends BaseController {
         __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_assertIsUnlocked).call(this);
         await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_persistOrRollback).call(this, async () => {
             const keyring = (await this.getKeyringForAccount(address));
-            const keyringIndex = this.state.keyrings.findIndex((kr) => kr.accounts.includes(address));
-            const isPrimaryKeyring = keyringIndex === 0;
-            const shouldRemoveKeyring = (await keyring.getAccounts()).length === 1;
-            // Primary keyring should never be removed, so we need to keep at least one account in it
-            if (isPrimaryKeyring && shouldRemoveKeyring) {
-                throw new Error(KeyringControllerError.LastAccountInPrimaryKeyring);
-            }
             // Not all the keyrings support this, so we have to check
             if (!keyring.removeAccount) {
                 throw new Error(KeyringControllerError.UnsupportedRemoveAccount);
@@ -617,7 +599,9 @@ export class KeyringController extends BaseController {
             // because `Keyring<State>.removeAccount` requires address to be `Hex`. Those
             // type would need to be updated for a full non-EVM support.
             keyring.removeAccount(address);
-            if (shouldRemoveKeyring) {
+            const accounts = await keyring.getAccounts();
+            // Check if this was the last/only account
+            if (accounts.length === 0) {
                 await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_removeEmptyKeyrings).call(this);
             }
         });
@@ -855,12 +839,11 @@ export class KeyringController extends BaseController {
     /**
      * Verifies the that the seed phrase restores the current keychain's accounts.
      *
-     * @param keyringId - The id of the keyring to verify.
      * @returns Promise resolving to the seed phrase as Uint8Array.
      */
-    async verifySeedPhrase(keyringId) {
+    async verifySeedPhrase() {
         __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_assertIsUnlocked).call(this);
-        return __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_withControllerLock).call(this, async () => __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_verifySeedPhrase).call(this, keyringId));
+        return __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_withControllerLock).call(this, async () => __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_verifySeedPhrase).call(this));
     }
     async withKeyring(selector, operation, options = {
         createIfMissing: false,
@@ -871,15 +854,12 @@ export class KeyringController extends BaseController {
             if ('address' in selector) {
                 keyring = (await this.getKeyringForAccount(selector.address));
             }
-            else if ('type' in selector) {
+            else {
                 keyring = this.getKeyringsByType(selector.type)[selector.index || 0];
                 if (!keyring && options.createIfMissing) {
                     keyring = (await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_newKeyring).call(this, selector.type, options.createWithData));
                 }
             }
-            else if ('id' in selector) {
-                keyring = __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getKeyringById).call(this, selector.id);
-            }
             if (!keyring) {
                 throw new Error(KeyringControllerError.KeyringNotFound);
             }
@@ -1092,7 +1072,7 @@ export class KeyringController extends BaseController {
         });
     }
 }
-_KeyringController_controllerOperationMutex = new WeakMap(), _KeyringController_vaultOperationMutex = new WeakMap(), _KeyringController_keyringBuilders = new WeakMap(), _KeyringController_unsupportedKeyrings = new WeakMap(), _KeyringController_encryptor = new WeakMap(), _KeyringController_cacheEncryptionKey = new WeakMap(), _KeyringController_keyrings = new WeakMap(), _KeyringController_keyringsMetadata = new WeakMap(), _KeyringController_password = new WeakMap(), _KeyringController_qrKeyringStateListener = new WeakMap(), _KeyringController_instances = new WeakSet(), _KeyringController_registerMessageHandlers = function _KeyringController_registerMessageHandlers() {
+_KeyringController_controllerOperationMutex = new WeakMap(), _KeyringController_vaultOperationMutex = new WeakMap(), _KeyringController_keyringBuilders = new WeakMap(), _KeyringController_unsupportedKeyrings = new WeakMap(), _KeyringController_encryptor = new WeakMap(), _KeyringController_cacheEncryptionKey = new WeakMap(), _KeyringController_keyrings = new WeakMap(), _KeyringController_password = new WeakMap(), _KeyringController_qrKeyringStateListener = new WeakMap(), _KeyringController_instances = new WeakSet(), _KeyringController_registerMessageHandlers = function _KeyringController_registerMessageHandlers() {
     this.messagingSystem.registerActionHandler(`${name}:signMessage`, this.signMessage.bind(this));
     this.messagingSystem.registerActionHandler(`${name}:signEip7702Authorization`, this.signEip7702Authorization.bind(this));
     this.messagingSystem.registerActionHandler(`${name}:signPersonalMessage`, this.signPersonalMessage.bind(this));
@@ -1107,15 +1087,6 @@ _KeyringController_controllerOperationMutex = new WeakMap(), _KeyringController_
     this.messagingSystem.registerActionHandler(`${name}:patchUserOperation`, this.patchUserOperation.bind(this));
     this.messagingSystem.registerActionHandler(`${name}:signUserOperation`, this.signUserOperation.bind(this));
     this.messagingSystem.registerActionHandler(`${name}:addNewAccount`, this.addNewAccount.bind(this));
-    this.messagingSystem.registerActionHandler(`${name}:withKeyring`, this.withKeyring.bind(this));
-}, _KeyringController_getKeyringById = function _KeyringController_getKeyringById(keyringId) {
-    const index = this.state.keyringsMetadata.findIndex((metadata) => metadata.id === keyringId);
-    return __classPrivateFieldGet(this, _KeyringController_keyrings, "f")[index];
-}, _KeyringController_getKeyringByIdOrDefault = function _KeyringController_getKeyringByIdOrDefault(keyringId) {
-    if (!keyringId) {
-        return __classPrivateFieldGet(this, _KeyringController_keyrings, "f")[0];
-    }
-    return __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getKeyringById).call(this, keyringId);
 }, _KeyringController_getKeyringBuilderForType = function _KeyringController_getKeyringBuilderForType(type) {
     return __classPrivateFieldGet(this, _KeyringController_keyringBuilders, "f").find((keyringBuilder) => keyringBuilder.type === type);
 }, _KeyringController_addQRKeyring = 
@@ -1168,29 +1139,23 @@ async function _KeyringController_createNewVaultWithKeyring(password, keyring) {
     });
     __classPrivateFieldSet(this, _KeyringController_password, password, "f");
     await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_clearKeyrings).call(this);
-    __classPrivateFieldSet(this, _KeyringController_keyringsMetadata, [], "f");
     await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_createKeyringWithFirstAccount).call(this, keyring.type, keyring.opts);
     __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_setUnlocked).call(this);
 }, _KeyringController_verifySeedPhrase = 
 /**
  * Internal non-exclusive method to verify the seed phrase.
  *
- * @param keyringId - The id of the keyring to verify the seed phrase for.
  * @returns A promise resolving to the seed phrase as Uint8Array.
  */
-async function _KeyringController_verifySeedPhrase(keyringId) {
+async function _KeyringController_verifySeedPhrase() {
     __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_assertControllerMutexIsLocked).call(this);
-    const keyring = __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getKeyringByIdOrDefault).call(this, keyringId);
-    if (!keyring) {
-        throw new Error(KeyringControllerError.KeyringNotFound);
-    }
-    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
-    if (keyring.type !== KeyringTypes.hd) {
-        throw new Error(KeyringControllerError.UnsupportedVerifySeedPhrase);
+    const primaryKeyring = this.getKeyringsByType(KeyringTypes.hd)[0];
+    if (!primaryKeyring) {
+        throw new Error('No HD keyring found.');
     }
-    assertHasUint8ArrayMnemonic(keyring);
-    const seedWords = keyring.mnemonic;
-    const accounts = await keyring.getAccounts();
+    assertHasUint8ArrayMnemonic(primaryKeyring);
+    const seedWords = primaryKeyring.mnemonic;
+    const accounts = await primaryKeyring.getAccounts();
     /* istanbul ignore if */
     if (accounts.length === 0) {
         throw new Error('Cannot verify an empty keyring.');
@@ -1370,13 +1335,9 @@ async function _KeyringController_unlockKeyrings(password, encryptionKey, encryp
             throw new Error(KeyringControllerError.MissingVaultData);
         }
         const updatedKeyrings = await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getUpdatedKeyrings).call(this);
-        if (updatedKeyrings.length !== __classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").length) {
-            throw new Error(KeyringControllerError.KeyringMetadataLengthMismatch);
-        }
         this.update((state) => {
             state.vault = updatedState.vault;
             state.keyrings = updatedKeyrings;
-            state.keyringsMetadata = __classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").slice();
             if (updatedState.encryptionKey) {
                 state.encryptionKey = updatedState.encryptionKey;
                 state.encryptionSalt = JSON.parse(updatedState.vault).salt;
@@ -1416,48 +1377,19 @@ async function _KeyringController_createKeyringWithFirstAccount(type, opts) {
     if (!firstAccount) {
         throw new Error(KeyringControllerError.NoFirstAccount);
     }
-    return firstAccount;
 }, _KeyringController_newKeyring = 
 /**
  * Instantiate, initialize and return a new keyring of the given `type`,
  * using the given `opts`. The keyring is built using the keyring builder
  * registered for the given `type`.
  *
- * The internal keyring and keyring metadata arrays are updated with the new
- * keyring as well.
  *
  * @param type - The type of keyring to add.
- * @param data - Keyring initialization options.
+ * @param data - The data to restore a previously serialized keyring.
  * @returns The new keyring.
  * @throws If the keyring includes duplicated accounts.
  */
 async function _KeyringController_newKeyring(type, data) {
-    const keyring = await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_createKeyring).call(this, type, data);
-    if (__classPrivateFieldGet(this, _KeyringController_keyrings, "f").length !== __classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").length) {
-        throw new Error('Keyring metadata missing');
-    }
-    __classPrivateFieldGet(this, _KeyringController_keyrings, "f").push(keyring);
-    __classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").push(getDefaultKeyringMetadata());
-    return keyring;
-}, _KeyringController_createKeyring = 
-/**
- * Instantiate, initialize and return a keyring of the given `type` using the
- * given `opts`. The keyring is built using the keyring builder registered
- * for the given `type`.
- *
- * The keyring might be new, or it might be restored from the vault. This
- * function should only be called from `#newKeyring` or `#restoreKeyring`,
- * for the "new" and "restore" cases respectively.
- *
- * The internal keyring and keyring metadata arrays are *not* updated, the
- * caller is expected to update them.
- *
- * @param type - The type of keyring to add.
- * @param data - Keyring initialization options.
- * @returns The new keyring.
- * @throws If the keyring includes duplicated accounts.
- */
-async function _KeyringController_createKeyring(type, data) {
     __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_assertControllerMutexIsLocked).call(this);
     const keyringBuilder = __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getKeyringBuilderForType).call(this, type);
     if (!keyringBuilder) {
@@ -1485,6 +1417,7 @@ async function _KeyringController_createKeyring(type, data) {
         // to its events after creating it
         __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_subscribeToQRKeyringEvents).call(this, keyring);
     }
+    __classPrivateFieldGet(this, _KeyringController_keyrings, "f").push(keyring);
     return keyring;
 }, _KeyringController_clearKeyrings = 
 /**
@@ -1509,15 +1442,7 @@ async function _KeyringController_restoreKeyring(serialized) {
     __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_assertControllerMutexIsLocked).call(this);
     try {
         const { type, data } = serialized;
-        const keyring = await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_createKeyring).call(this, type, data);
-        __classPrivateFieldGet(this, _KeyringController_keyrings, "f").push(keyring);
-        // If metadata is missing, assume the data is from an installation before
-        // we had keyring metadata.
-        if (__classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").length < __classPrivateFieldGet(this, _KeyringController_keyrings, "f").length) {
-            console.log(`Adding missing metadata for '${type}' keyring`);
-            __classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").push(getDefaultKeyringMetadata());
-        }
-        return keyring;
+        return await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_newKeyring).call(this, type, data);
     }
     catch (_) {
         __classPrivateFieldGet(this, _KeyringController_unsupportedKeyrings, "f").push(serialized);
@@ -1545,22 +1470,19 @@ async function _KeyringController_destroyKeyring(keyring) {
 async function _KeyringController_removeEmptyKeyrings() {
     __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_assertControllerMutexIsLocked).call(this);
     const validKeyrings = [];
-    const validKeyringMetadata = [];
     // Since getAccounts returns a Promise
     // We need to wait to hear back form each keyring
     // in order to decide which ones are now valid (accounts.length > 0)
-    await Promise.all(__classPrivateFieldGet(this, _KeyringController_keyrings, "f").map(async (keyring, index) => {
+    await Promise.all(__classPrivateFieldGet(this, _KeyringController_keyrings, "f").map(async (keyring) => {
         const accounts = await keyring.getAccounts();
         if (accounts.length > 0) {
             validKeyrings.push(keyring);
-            validKeyringMetadata.push(__classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f")[index]);
         }
         else {
             await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_destroyKeyring).call(this, keyring);
         }
     }));
     __classPrivateFieldSet(this, _KeyringController_keyrings, validKeyrings, "f");
-    __classPrivateFieldSet(this, _KeyringController_keyringsMetadata, validKeyringMetadata, "f");
 }, _KeyringController_checkForDuplicate = 
 /**
  * Checks for duplicate keypairs, using the the first account in the given
@@ -1626,7 +1548,6 @@ async function _KeyringController_withRollback(callback) {
     return __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_withControllerLock).call(this, async ({ releaseLock }) => {
         const currentSerializedKeyrings = await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_getSerializedKeyrings).call(this);
         const currentPassword = __classPrivateFieldGet(this, _KeyringController_password, "f");
-        const currentKeyringsMetadata = __classPrivateFieldGet(this, _KeyringController_keyringsMetadata, "f").slice();
         try {
             return await callback({ releaseLock });
         }
@@ -1634,7 +1555,6 @@ async function _KeyringController_withRollback(callback) {
             // Keyrings and password are restored to their previous state
             await __classPrivateFieldGet(this, _KeyringController_instances, "m", _KeyringController_restoreSerializedKeyrings).call(this, currentSerializedKeyrings);
             __classPrivateFieldSet(this, _KeyringController_password, currentPassword, "f");
-            __classPrivateFieldSet(this, _KeyringController_keyringsMetadata, currentKeyringsMetadata, "f");
             throw e;
         }
     });
@@ -1691,13 +1611,5 @@ async function withLock(mutex, callback) {
         releaseLock();
     }
 }
-/**
- * Generate a new keyring metadata object.
- *
- * @returns Keyring metadata.
- */
-function getDefaultKeyringMetadata() {
-    return { id: ulid(), name: '' };
-}
 export default KeyringController;
 //# sourceMappingURL=KeyringController.mjs.map
\ No newline at end of file
diff --git a/dist/constants.cjs b/dist/constants.cjs
index e34a11b11cd1f297d2c03d01e218608202e668d0..0703a5c0b22464cbc4db5a24781dc84def053769 100644
--- a/dist/constants.cjs
+++ b/dist/constants.cjs
@@ -28,7 +28,6 @@ var KeyringControllerError;
     KeyringControllerError["UnsupportedPrepareUserOperation"] = "KeyringController - The keyring for the current address does not support the method prepareUserOperation.";
     KeyringControllerError["UnsupportedPatchUserOperation"] = "KeyringController - The keyring for the current address does not support the method patchUserOperation.";
     KeyringControllerError["UnsupportedSignUserOperation"] = "KeyringController - The keyring for the current address does not support the method signUserOperation.";
-    KeyringControllerError["UnsupportedVerifySeedPhrase"] = "KeyringController - The keyring does not support the method verifySeedPhrase.";
     KeyringControllerError["NoAccountOnKeychain"] = "KeyringController - The keychain doesn't have accounts.";
     KeyringControllerError["ControllerLocked"] = "KeyringController - The operation cannot be completed while the controller is locked.";
     KeyringControllerError["MissingCredentials"] = "KeyringController - Cannot persist vault without password and encryption key";
@@ -38,7 +37,5 @@ var KeyringControllerError;
     KeyringControllerError["DataType"] = "KeyringController - Incorrect data type provided";
     KeyringControllerError["NoHdKeyring"] = "KeyringController - No HD Keyring found";
     KeyringControllerError["ControllerLockRequired"] = "KeyringController - attempt to update vault during a non mutually exclusive operation";
-    KeyringControllerError["KeyringMetadataLengthMismatch"] = "KeyringController - keyring metadata length mismatch";
-    KeyringControllerError["LastAccountInPrimaryKeyring"] = "KeyringController - Last account in primary keyring cannot be removed";
 })(KeyringControllerError || (exports.KeyringControllerError = KeyringControllerError = {}));
 //# sourceMappingURL=constants.cjs.map
\ No newline at end of file
diff --git a/dist/constants.d.cts b/dist/constants.d.cts
index 4d59c048e451c0eb5971600eb0dbf1966fb05256..3c0d52c69ea2ec7863465d9ef3b259d9eb6689aa 100644
--- a/dist/constants.d.cts
+++ b/dist/constants.d.cts
@@ -24,7 +24,6 @@ export declare enum KeyringControllerError {
     UnsupportedPrepareUserOperation = "KeyringController - The keyring for the current address does not support the method prepareUserOperation.",
     UnsupportedPatchUserOperation = "KeyringController - The keyring for the current address does not support the method patchUserOperation.",
     UnsupportedSignUserOperation = "KeyringController - The keyring for the current address does not support the method signUserOperation.",
-    UnsupportedVerifySeedPhrase = "KeyringController - The keyring does not support the method verifySeedPhrase.",
     NoAccountOnKeychain = "KeyringController - The keychain doesn't have accounts.",
     ControllerLocked = "KeyringController - The operation cannot be completed while the controller is locked.",
     MissingCredentials = "KeyringController - Cannot persist vault without password and encryption key",
@@ -33,8 +32,6 @@ export declare enum KeyringControllerError {
     NoKeyringBuilder = "KeyringController - No keyringBuilder found for keyring",
     DataType = "KeyringController - Incorrect data type provided",
     NoHdKeyring = "KeyringController - No HD Keyring found",
-    ControllerLockRequired = "KeyringController - attempt to update vault during a non mutually exclusive operation",
-    KeyringMetadataLengthMismatch = "KeyringController - keyring metadata length mismatch",
-    LastAccountInPrimaryKeyring = "KeyringController - Last account in primary keyring cannot be removed"
+    ControllerLockRequired = "KeyringController - attempt to update vault during a non mutually exclusive operation"
 }
 //# sourceMappingURL=constants.d.cts.map
\ No newline at end of file
diff --git a/dist/constants.d.mts b/dist/constants.d.mts
index a1898eca3093648c83073b56dbd181ce605c4801..8a05c057d5e87eff342246b4367e12bbe15c4cc4 100644
--- a/dist/constants.d.mts
+++ b/dist/constants.d.mts
@@ -24,7 +24,6 @@ export declare enum KeyringControllerError {
     UnsupportedPrepareUserOperation = "KeyringController - The keyring for the current address does not support the method prepareUserOperation.",
     UnsupportedPatchUserOperation = "KeyringController - The keyring for the current address does not support the method patchUserOperation.",
     UnsupportedSignUserOperation = "KeyringController - The keyring for the current address does not support the method signUserOperation.",
-    UnsupportedVerifySeedPhrase = "KeyringController - The keyring does not support the method verifySeedPhrase.",
     NoAccountOnKeychain = "KeyringController - The keychain doesn't have accounts.",
     ControllerLocked = "KeyringController - The operation cannot be completed while the controller is locked.",
     MissingCredentials = "KeyringController - Cannot persist vault without password and encryption key",
@@ -33,8 +32,6 @@ export declare enum KeyringControllerError {
     NoKeyringBuilder = "KeyringController - No keyringBuilder found for keyring",
     DataType = "KeyringController - Incorrect data type provided",
     NoHdKeyring = "KeyringController - No HD Keyring found",
-    ControllerLockRequired = "KeyringController - attempt to update vault during a non mutually exclusive operation",
-    KeyringMetadataLengthMismatch = "KeyringController - keyring metadata length mismatch",
-    LastAccountInPrimaryKeyring = "KeyringController - Last account in primary keyring cannot be removed"
+    ControllerLockRequired = "KeyringController - attempt to update vault during a non mutually exclusive operation"
 }
 //# sourceMappingURL=constants.d.mts.map
\ No newline at end of file
diff --git a/dist/constants.mjs b/dist/constants.mjs
index 31b9f814f6299a25f4c671b7e5962bda0700db19..db1fd2c84583940ea8dc8122384f408ea44402c0 100644
--- a/dist/constants.mjs
+++ b/dist/constants.mjs
@@ -25,7 +25,6 @@ export var KeyringControllerError;
     KeyringControllerError["UnsupportedPrepareUserOperation"] = "KeyringController - The keyring for the current address does not support the method prepareUserOperation.";
     KeyringControllerError["UnsupportedPatchUserOperation"] = "KeyringController - The keyring for the current address does not support the method patchUserOperation.";
     KeyringControllerError["UnsupportedSignUserOperation"] = "KeyringController - The keyring for the current address does not support the method signUserOperation.";
-    KeyringControllerError["UnsupportedVerifySeedPhrase"] = "KeyringController - The keyring does not support the method verifySeedPhrase.";
     KeyringControllerError["NoAccountOnKeychain"] = "KeyringController - The keychain doesn't have accounts.";
     KeyringControllerError["ControllerLocked"] = "KeyringController - The operation cannot be completed while the controller is locked.";
     KeyringControllerError["MissingCredentials"] = "KeyringController - Cannot persist vault without password and encryption key";
@@ -35,7 +34,5 @@ export var KeyringControllerError;
     KeyringControllerError["DataType"] = "KeyringController - Incorrect data type provided";
     KeyringControllerError["NoHdKeyring"] = "KeyringController - No HD Keyring found";
     KeyringControllerError["ControllerLockRequired"] = "KeyringController - attempt to update vault during a non mutually exclusive operation";
-    KeyringControllerError["KeyringMetadataLengthMismatch"] = "KeyringController - keyring metadata length mismatch";
-    KeyringControllerError["LastAccountInPrimaryKeyring"] = "KeyringController - Last account in primary keyring cannot be removed";
 })(KeyringControllerError || (KeyringControllerError = {}));
 //# sourceMappingURL=constants.mjs.map
\ No newline at end of file
diff --git a/package.json b/package.json
index 843346b71985ccfb7cb1cfc832690bb3456dccd3..48334d6cd1509d0eba681d3c3a313d74359c7ba8 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@metamask/keyring-controller",
-  "version": "19.2.0",
+  "version": "19.1.0",
   "description": "Stores identities seen in the wallet and manages interactions such as signing",
   "keywords": [
     "MetaMask",
@@ -59,8 +59,7 @@
     "@metamask/utils": "^11.2.0",
     "async-mutex": "^0.5.0",
     "ethereumjs-wallet": "^1.0.1",
-    "immer": "^9.0.6",
-    "ulid": "^2.3.0"
+    "immer": "^9.0.6"
   },
   "devDependencies": {
     "@ethereumjs/common": "^3.2.0",
@@ -89,10 +88,6 @@
     "registry": "https://registry.npmjs.org/"
   },
   "lavamoat": {
-    "allowScripts": {
-      "@lavamoat/preinstall-always-fail": false,
-      "ethereumjs-wallet>ethereum-cryptography>keccak": false,
-      "ethereumjs-wallet>ethereum-cryptography>secp256k1": false
-    }
+    "allowScripts": {}
   }
 }
