diff --git a/dist/TransactionController.cjs b/dist/TransactionController.cjs
index 5953872a8422a26f0d077cba132dd42b50ab7b47..9bd96d10e2672dd02649abdfe8f6aa45c193b1f7 100644
--- a/dist/TransactionController.cjs
+++ b/dist/TransactionController.cjs
@@ -13,7 +13,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _TransactionController_instances, _TransactionController_afterAdd, _TransactionController_afterSign, _TransactionController_approvingTransactionIds, _TransactionController_beforeCheckPendingTransaction, _TransactionController_beforePublish, _TransactionController_gasFeeFlows, _TransactionController_getAdditionalSignArguments, _TransactionController_getCurrentAccountEIP1559Compatibility, _TransactionController_getCurrentNetworkEIP1559Compatibility, _TransactionController_getExternalPendingTransactions, _TransactionController_getGasFeeEstimates, _TransactionController_getNetworkState, _TransactionController_getPermittedAccounts, _TransactionController_getSavedGasFees, _TransactionController_incomingTransactionHelper, _TransactionController_incomingTransactionOptions, _TransactionController_internalEvents, _TransactionController_isAutomaticGasFeeUpdateEnabled, _TransactionController_isEIP7702GasFeeTokensEnabled, _TransactionController_isFirstTimeInteractionEnabled, _TransactionController_isHistoryDisabled, _TransactionController_isSendFlowHistoryDisabled, _TransactionController_isSimulationEnabled, _TransactionController_isSwapsDisabled, _TransactionController_layer1GasFeeFlows, _TransactionController_methodDataHelper, _TransactionController_multichainTrackingHelper, _TransactionController_pendingTransactionOptions, _TransactionController_publicKeyEIP7702, _TransactionController_publish, _TransactionController_publishBatchHook, _TransactionController_securityProviderRequest, _TransactionController_sign, _TransactionController_signAbortCallbacks, _TransactionController_testGasFeeFlows, _TransactionController_trace, _TransactionController_transactionHistoryLimit, _TransactionController_retryTransaction, _TransactionController_signExternalTransaction, _TransactionController_addMetadata, _TransactionController_updateGasProperties, _TransactionController_onBootCleanup, _TransactionController_failIncompleteTransactions, _TransactionController_processApproval, _TransactionController_approveTransaction, _TransactionController_publishTransaction, _TransactionController_rejectTransaction, _TransactionController_trimTransactionsForState, _TransactionController_isFinalState, _TransactionController_isLocalFinalState, _TransactionController_requestApproval, _TransactionController_getTransaction, _TransactionController_getTransactionOrThrow, _TransactionController_getApprovalId, _TransactionController_isTransactionCompleted, _TransactionController_getChainId, _TransactionController_getNetworkClientId, _TransactionController_getEthQuery, _TransactionController_getProvider, _TransactionController_onIncomingTransactions, _TransactionController_generateDappSuggestedGasFees, _TransactionController_addExternalTransaction, _TransactionController_markNonceDuplicatesDropped, _TransactionController_setTransactionStatusDropped, _TransactionController_getTransactionWithActionId, _TransactionController_waitForTransactionFinished, _TransactionController_updateTransactionMetaRSV, _TransactionController_getEIP1559Compatibility, _TransactionController_signTransaction, _TransactionController_onTransactionStatusChange, _TransactionController_getNonceTrackerTransactions, _TransactionController_onConfirmedTransaction, _TransactionController_updatePostBalance, _TransactionController_createNonceTracker, _TransactionController_createPendingTransactionTracker, _TransactionController_checkForPendingTransactionAndStartPolling, _TransactionController_stopAllTracking, _TransactionController_addIncomingTransactionHelperListeners, _TransactionController_removePendingTransactionTrackerListeners, _TransactionController_addPendingTransactionTrackerListeners, _TransactionController_getNonceTrackerPendingTransactions, _TransactionController_publishTransactionForRetry, _TransactionController_isTransactionAlreadyConfirmedError, _TransactionController_getGasFeeFlows, _TransactionController_getLayer1GasFeeFlows, _TransactionController_updateTransactionInternal, _TransactionController_updateFirstTimeInteraction, _TransactionController_updateSimulationData, _TransactionController_onGasFeePollerTransactionUpdate, _TransactionController_getSelectedAccount, _TransactionController_getInternalAccounts, _TransactionController_updateSubmitHistory, _TransactionController_updateGasEstimate, _TransactionController_registerActionHandlers, _TransactionController_deleteTransaction, _TransactionController_isRejectError, _TransactionController_rejectTransactionAndThrow, _TransactionController_failTransaction, _TransactionController_getSimulationData, _TransactionController_getSimulationAuthorizationList;
+var _TransactionController_instances, _TransactionController_afterAdd, _TransactionController_afterSign, _TransactionController_approvingTransactionIds, _TransactionController_beforeCheckPendingTransaction, _TransactionController_beforePublish, _TransactionController_gasFeeFlows, _TransactionController_getAdditionalSignArguments, _TransactionController_getCurrentAccountEIP1559Compatibility, _TransactionController_getCurrentNetworkEIP1559Compatibility, _TransactionController_getExternalPendingTransactions, _TransactionController_getGasFeeEstimates, _TransactionController_getNetworkState, _TransactionController_getPermittedAccounts, _TransactionController_getSavedGasFees, _TransactionController_incomingTransactionHelper, _TransactionController_incomingTransactionOptions, _TransactionController_internalEvents, _TransactionController_isAutomaticGasFeeUpdateEnabled, _TransactionController_isEIP7702GasFeeTokensEnabled, _TransactionController_isFirstTimeInteractionEnabled, _TransactionController_isHistoryDisabled, _TransactionController_isSendFlowHistoryDisabled, _TransactionController_isSimulationEnabled, _TransactionController_isSwapsDisabled, _TransactionController_layer1GasFeeFlows, _TransactionController_methodDataHelper, _TransactionController_multichainTrackingHelper, _TransactionController_pendingTransactionOptions, _TransactionController_publicKeyEIP7702, _TransactionController_publish, _TransactionController_publishBatchHook, _TransactionController_securityProviderRequest, _TransactionController_sign, _TransactionController_signAbortCallbacks, _TransactionController_testGasFeeFlows, _TransactionController_trace, _TransactionController_transactionHistoryLimit, _TransactionController_retryTransaction, _TransactionController_signExternalTransaction, _TransactionController_addMetadata, _TransactionController_updateGasProperties, _TransactionController_onBootCleanup, _TransactionController_failIncompleteTransactions, _TransactionController_processApproval, _TransactionController_approveTransaction, _TransactionController_publishTransaction, _TransactionController_rejectTransaction, _TransactionController_trimTransactionsForState, _TransactionController_isFinalState, _TransactionController_isLocalFinalState, _TransactionController_requestApproval, _TransactionController_getTransaction, _TransactionController_getTransactionOrThrow, _TransactionController_getApprovalId, _TransactionController_isTransactionCompleted, _TransactionController_getChainId, _TransactionController_getNetworkClientId, _TransactionController_getEthQuery, _TransactionController_getProvider, _TransactionController_onIncomingTransactions, _TransactionController_generateDappSuggestedGasFees, _TransactionController_addExternalTransaction, _TransactionController_markNonceDuplicatesDropped, _TransactionController_setTransactionStatusDropped, _TransactionController_getTransactionWithActionId, _TransactionController_waitForTransactionFinished, _TransactionController_updateTransactionMetaRSV, _TransactionController_getEIP1559Compatibility, _TransactionController_signTransaction, _TransactionController_onTransactionStatusChange, _TransactionController_getNonceTrackerTransactions, _TransactionController_onConfirmedTransaction, _TransactionController_updatePostBalance, _TransactionController_createNonceTracker, _TransactionController_createPendingTransactionTracker, _TransactionController_checkForPendingTransactionAndStartPolling, _TransactionController_stopAllTracking, _TransactionController_addIncomingTransactionHelperListeners, _TransactionController_removePendingTransactionTrackerListeners, _TransactionController_addPendingTransactionTrackerListeners, _TransactionController_getNonceTrackerPendingTransactions, _TransactionController_publishTransactionForRetry, _TransactionController_isTransactionAlreadyConfirmedError, _TransactionController_getGasFeeFlows, _TransactionController_getLayer1GasFeeFlows, _TransactionController_updateTransactionInternal, _TransactionController_updateFirstTimeInteraction, _TransactionController_updateSimulationData, _TransactionController_onGasFeePollerTransactionUpdate, _TransactionController_getSelectedAccount, _TransactionController_getInternalAccounts, _TransactionController_updateSubmitHistory, _TransactionController_updateGasEstimate, _TransactionController_registerActionHandlers, _TransactionController_deleteTransaction, _TransactionController_isRejectError, _TransactionController_rejectTransactionAndThrow, _TransactionController_failTransaction;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TransactionController = exports.ApprovalState = exports.SPEED_UP_RATE = exports.CANCEL_RATE = void 0;
 const base_controller_1 = require("@metamask/base-controller");
@@ -45,11 +45,12 @@ const ResimulateHelper_1 = require("./helpers/ResimulateHelper.cjs");
 const ExtraTransactionsPublishHook_1 = require("./hooks/ExtraTransactionsPublishHook.cjs");
 const logger_1 = require("./logger.cjs");
 const types_1 = require("./types.cjs");
+const balance_changes_1 = require("./utils/balance-changes.cjs");
 const batch_1 = require("./utils/batch.cjs");
 const eip7702_1 = require("./utils/eip7702.cjs");
 const external_transactions_1 = require("./utils/external-transactions.cjs");
-const feature_flags_1 = require("./utils/feature-flags.cjs");
 const gas_1 = require("./utils/gas.cjs");
+const gas_fee_tokens_1 = require("./utils/gas-fee-tokens.cjs");
 const gas_fees_1 = require("./utils/gas-fees.cjs");
 const gas_flow_1 = require("./utils/gas-flow.cjs");
 const history_1 = require("./utils/history.cjs");
@@ -57,7 +58,6 @@ const layer1_gas_fee_flow_1 = require("./utils/layer1-gas-fee-flow.cjs");
 const nonce_1 = require("./utils/nonce.cjs");
 const prepare_1 = require("./utils/prepare.cjs");
 const retry_1 = require("./utils/retry.cjs");
-const simulation_1 = require("./utils/simulation.cjs");
 const swaps_1 = require("./utils/swaps.cjs");
 const transaction_type_1 = require("./utils/transaction-type.cjs");
 const utils_2 = require("./utils/utils.cjs");
@@ -2037,7 +2037,7 @@ async function _TransactionController_approveTransaction(transactionId, traceCon
         (0, logger_1.projectLogger)('Error fetching account address relationship, skipping first time interaction update', error);
     }
 }, _TransactionController_updateSimulationData = async function _TransactionController_updateSimulationData(transactionMeta, { blockTime, traceContext, } = {}) {
-    const { id: transactionId, simulationData: prevSimulationData } = transactionMeta;
+    const { chainId, id: transactionId, nestedTransactions, networkClientId, simulationData: prevSimulationData, txParams, } = transactionMeta;
     let simulationData = {
         error: {
             code: types_1.SimulationErrorCode.Disabled,
@@ -2047,13 +2047,13 @@ async function _TransactionController_approveTransaction(transactionId, traceCon
     };
     let gasFeeTokens = [];
     if (__classPrivateFieldGet(this, _TransactionController_isSimulationEnabled, "f").call(this)) {
-        const result = await __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_getSimulationData).call(this, {
+        simulationData = await __classPrivateFieldGet(this, _TransactionController_trace, "f").call(this, { name: 'Simulate', parentContext: traceContext }, () => (0, balance_changes_1.getBalanceChanges)({
             blockTime,
-            traceContext,
-            transactionMeta,
-        });
-        gasFeeTokens = result?.gasFeeTokens;
-        simulationData = result?.simulationData;
+            chainId,
+            ethQuery: __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_getEthQuery).call(this, { networkClientId }),
+            nestedTransactions,
+            txParams,
+        }));
         if (blockTime &&
             prevSimulationData &&
             (0, ResimulateHelper_1.hasSimulationDataChanged)(prevSimulationData, simulationData)) {
@@ -2062,6 +2062,13 @@ async function _TransactionController_approveTransaction(transactionId, traceCon
                 isUpdatedAfterSecurityCheck: true,
             };
         }
+        gasFeeTokens = await (0, gas_fee_tokens_1.getGasFeeTokens)({
+            chainId,
+            isEIP7702GasFeeTokensEnabled: __classPrivateFieldGet(this, _TransactionController_isEIP7702GasFeeTokensEnabled, "f"),
+            messenger: this.messagingSystem,
+            publicKeyEIP7702: __classPrivateFieldGet(this, _TransactionController_publicKeyEIP7702, "f"),
+            transactionMeta,
+        });
     }
     const finalTransactionMeta = __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_getTransaction).call(this, transactionId);
     /* istanbul ignore if */
@@ -2182,50 +2189,5 @@ async function _TransactionController_approveTransaction(transactionId, traceCon
     __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_onTransactionStatusChange).call(this, newTransactionMeta);
     this.messagingSystem.publish(`${controllerName}:transactionFinished`, newTransactionMeta);
     __classPrivateFieldGet(this, _TransactionController_internalEvents, "f").emit(`${transactionMeta.id}:finished`, newTransactionMeta);
-}, _TransactionController_getSimulationData = async function _TransactionController_getSimulationData({ blockTime, traceContext, transactionMeta, }) {
-    const { chainId, delegationAddress, txParams } = transactionMeta;
-    const { authorizationList: authorizationListRequest, data, from, to, value, } = txParams;
-    const authorizationAddress = authorizationListRequest?.[0]?.address;
-    const senderCode = authorizationAddress &&
-        (eip7702_1.DELEGATION_PREFIX + (0, utils_1.remove0x)(authorizationAddress));
-    const is7702GasFeeTokensEnabled = await __classPrivateFieldGet(this, _TransactionController_isEIP7702GasFeeTokensEnabled, "f").call(this, transactionMeta);
-    const use7702Fees = is7702GasFeeTokensEnabled &&
-        (0, eip7702_1.doesChainSupportEIP7702)(chainId, this.messagingSystem);
-    let authorizationList = authorizationListRequest?.map((authorization) => ({
-        address: authorization.address,
-        from: from,
-    }));
-    if (use7702Fees && !delegationAddress && !authorizationList) {
-        authorizationList = __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_getSimulationAuthorizationList).call(this, {
-            chainId,
-            from: from,
-        });
-    }
-    return await __classPrivateFieldGet(this, _TransactionController_trace, "f").call(this, { name: 'Simulate', parentContext: traceContext }, () => (0, simulation_1.getSimulationData)({
-        authorizationList,
-        chainId,
-        data: data,
-        from: from,
-        to: to,
-        value: value,
-    }, {
-        blockTime,
-        senderCode,
-        use7702Fees,
-    }));
-}, _TransactionController_getSimulationAuthorizationList = function _TransactionController_getSimulationAuthorizationList({ chainId, from, }) {
-    if (!__classPrivateFieldGet(this, _TransactionController_publicKeyEIP7702, "f")) {
-        throw rpc_errors_1.rpcErrors.internal(eip7702_1.ERROR_MESSGE_PUBLIC_KEY);
-    }
-    const upgradeAddress = (0, feature_flags_1.getEIP7702UpgradeContractAddress)(chainId, this.messagingSystem, __classPrivateFieldGet(this, _TransactionController_publicKeyEIP7702, "f"));
-    if (!upgradeAddress) {
-        throw rpc_errors_1.rpcErrors.internal(batch_1.ERROR_MESSAGE_NO_UPGRADE_CONTRACT);
-    }
-    return [
-        {
-            address: upgradeAddress,
-            from: from,
-        },
-    ];
 };
 //# sourceMappingURL=TransactionController.cjs.map
\ No newline at end of file
diff --git a/dist/TransactionController.mjs b/dist/TransactionController.mjs
index b4e50899b809deefd4241de0c7d7dca4c233c924..b8ad0d0b7313d18511b86b87ff775ea9cadfdb72 100644
--- a/dist/TransactionController.mjs
+++ b/dist/TransactionController.mjs
@@ -9,7 +9,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
     if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
     return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
 };
-var _TransactionController_instances, _TransactionController_afterAdd, _TransactionController_afterSign, _TransactionController_approvingTransactionIds, _TransactionController_beforeCheckPendingTransaction, _TransactionController_beforePublish, _TransactionController_gasFeeFlows, _TransactionController_getAdditionalSignArguments, _TransactionController_getCurrentAccountEIP1559Compatibility, _TransactionController_getCurrentNetworkEIP1559Compatibility, _TransactionController_getExternalPendingTransactions, _TransactionController_getGasFeeEstimates, _TransactionController_getNetworkState, _TransactionController_getPermittedAccounts, _TransactionController_getSavedGasFees, _TransactionController_incomingTransactionHelper, _TransactionController_incomingTransactionOptions, _TransactionController_internalEvents, _TransactionController_isAutomaticGasFeeUpdateEnabled, _TransactionController_isEIP7702GasFeeTokensEnabled, _TransactionController_isFirstTimeInteractionEnabled, _TransactionController_isHistoryDisabled, _TransactionController_isSendFlowHistoryDisabled, _TransactionController_isSimulationEnabled, _TransactionController_isSwapsDisabled, _TransactionController_layer1GasFeeFlows, _TransactionController_methodDataHelper, _TransactionController_multichainTrackingHelper, _TransactionController_pendingTransactionOptions, _TransactionController_publicKeyEIP7702, _TransactionController_publish, _TransactionController_publishBatchHook, _TransactionController_securityProviderRequest, _TransactionController_sign, _TransactionController_signAbortCallbacks, _TransactionController_testGasFeeFlows, _TransactionController_trace, _TransactionController_transactionHistoryLimit, _TransactionController_retryTransaction, _TransactionController_signExternalTransaction, _TransactionController_addMetadata, _TransactionController_updateGasProperties, _TransactionController_onBootCleanup, _TransactionController_failIncompleteTransactions, _TransactionController_processApproval, _TransactionController_approveTransaction, _TransactionController_publishTransaction, _TransactionController_rejectTransaction, _TransactionController_trimTransactionsForState, _TransactionController_isFinalState, _TransactionController_isLocalFinalState, _TransactionController_requestApproval, _TransactionController_getTransaction, _TransactionController_getTransactionOrThrow, _TransactionController_getApprovalId, _TransactionController_isTransactionCompleted, _TransactionController_getChainId, _TransactionController_getNetworkClientId, _TransactionController_getEthQuery, _TransactionController_getProvider, _TransactionController_onIncomingTransactions, _TransactionController_generateDappSuggestedGasFees, _TransactionController_addExternalTransaction, _TransactionController_markNonceDuplicatesDropped, _TransactionController_setTransactionStatusDropped, _TransactionController_getTransactionWithActionId, _TransactionController_waitForTransactionFinished, _TransactionController_updateTransactionMetaRSV, _TransactionController_getEIP1559Compatibility, _TransactionController_signTransaction, _TransactionController_onTransactionStatusChange, _TransactionController_getNonceTrackerTransactions, _TransactionController_onConfirmedTransaction, _TransactionController_updatePostBalance, _TransactionController_createNonceTracker, _TransactionController_createPendingTransactionTracker, _TransactionController_checkForPendingTransactionAndStartPolling, _TransactionController_stopAllTracking, _TransactionController_addIncomingTransactionHelperListeners, _TransactionController_removePendingTransactionTrackerListeners, _TransactionController_addPendingTransactionTrackerListeners, _TransactionController_getNonceTrackerPendingTransactions, _TransactionController_publishTransactionForRetry, _TransactionController_isTransactionAlreadyConfirmedError, _TransactionController_getGasFeeFlows, _TransactionController_getLayer1GasFeeFlows, _TransactionController_updateTransactionInternal, _TransactionController_updateFirstTimeInteraction, _TransactionController_updateSimulationData, _TransactionController_onGasFeePollerTransactionUpdate, _TransactionController_getSelectedAccount, _TransactionController_getInternalAccounts, _TransactionController_updateSubmitHistory, _TransactionController_updateGasEstimate, _TransactionController_registerActionHandlers, _TransactionController_deleteTransaction, _TransactionController_isRejectError, _TransactionController_rejectTransactionAndThrow, _TransactionController_failTransaction, _TransactionController_getSimulationData, _TransactionController_getSimulationAuthorizationList;
+var _TransactionController_instances, _TransactionController_afterAdd, _TransactionController_afterSign, _TransactionController_approvingTransactionIds, _TransactionController_beforeCheckPendingTransaction, _TransactionController_beforePublish, _TransactionController_gasFeeFlows, _TransactionController_getAdditionalSignArguments, _TransactionController_getCurrentAccountEIP1559Compatibility, _TransactionController_getCurrentNetworkEIP1559Compatibility, _TransactionController_getExternalPendingTransactions, _TransactionController_getGasFeeEstimates, _TransactionController_getNetworkState, _TransactionController_getPermittedAccounts, _TransactionController_getSavedGasFees, _TransactionController_incomingTransactionHelper, _TransactionController_incomingTransactionOptions, _TransactionController_internalEvents, _TransactionController_isAutomaticGasFeeUpdateEnabled, _TransactionController_isEIP7702GasFeeTokensEnabled, _TransactionController_isFirstTimeInteractionEnabled, _TransactionController_isHistoryDisabled, _TransactionController_isSendFlowHistoryDisabled, _TransactionController_isSimulationEnabled, _TransactionController_isSwapsDisabled, _TransactionController_layer1GasFeeFlows, _TransactionController_methodDataHelper, _TransactionController_multichainTrackingHelper, _TransactionController_pendingTransactionOptions, _TransactionController_publicKeyEIP7702, _TransactionController_publish, _TransactionController_publishBatchHook, _TransactionController_securityProviderRequest, _TransactionController_sign, _TransactionController_signAbortCallbacks, _TransactionController_testGasFeeFlows, _TransactionController_trace, _TransactionController_transactionHistoryLimit, _TransactionController_retryTransaction, _TransactionController_signExternalTransaction, _TransactionController_addMetadata, _TransactionController_updateGasProperties, _TransactionController_onBootCleanup, _TransactionController_failIncompleteTransactions, _TransactionController_processApproval, _TransactionController_approveTransaction, _TransactionController_publishTransaction, _TransactionController_rejectTransaction, _TransactionController_trimTransactionsForState, _TransactionController_isFinalState, _TransactionController_isLocalFinalState, _TransactionController_requestApproval, _TransactionController_getTransaction, _TransactionController_getTransactionOrThrow, _TransactionController_getApprovalId, _TransactionController_isTransactionCompleted, _TransactionController_getChainId, _TransactionController_getNetworkClientId, _TransactionController_getEthQuery, _TransactionController_getProvider, _TransactionController_onIncomingTransactions, _TransactionController_generateDappSuggestedGasFees, _TransactionController_addExternalTransaction, _TransactionController_markNonceDuplicatesDropped, _TransactionController_setTransactionStatusDropped, _TransactionController_getTransactionWithActionId, _TransactionController_waitForTransactionFinished, _TransactionController_updateTransactionMetaRSV, _TransactionController_getEIP1559Compatibility, _TransactionController_signTransaction, _TransactionController_onTransactionStatusChange, _TransactionController_getNonceTrackerTransactions, _TransactionController_onConfirmedTransaction, _TransactionController_updatePostBalance, _TransactionController_createNonceTracker, _TransactionController_createPendingTransactionTracker, _TransactionController_checkForPendingTransactionAndStartPolling, _TransactionController_stopAllTracking, _TransactionController_addIncomingTransactionHelperListeners, _TransactionController_removePendingTransactionTrackerListeners, _TransactionController_addPendingTransactionTrackerListeners, _TransactionController_getNonceTrackerPendingTransactions, _TransactionController_publishTransactionForRetry, _TransactionController_isTransactionAlreadyConfirmedError, _TransactionController_getGasFeeFlows, _TransactionController_getLayer1GasFeeFlows, _TransactionController_updateTransactionInternal, _TransactionController_updateFirstTimeInteraction, _TransactionController_updateSimulationData, _TransactionController_onGasFeePollerTransactionUpdate, _TransactionController_getSelectedAccount, _TransactionController_getInternalAccounts, _TransactionController_updateSubmitHistory, _TransactionController_updateGasEstimate, _TransactionController_registerActionHandlers, _TransactionController_deleteTransaction, _TransactionController_isRejectError, _TransactionController_rejectTransactionAndThrow, _TransactionController_failTransaction;
 function $importDefault(module) {
     if (module?.__esModule) {
         return module.default;
@@ -23,7 +23,7 @@ const EthQuery = $importDefault($EthQuery);
 import { NetworkClientType } from "@metamask/network-controller";
 import { NonceTracker } from "@metamask/nonce-tracker";
 import { errorCodes, rpcErrors, providerErrors, JsonRpcError } from "@metamask/rpc-errors";
-import { add0x, hexToNumber, remove0x } from "@metamask/utils";
+import { add0x, hexToNumber } from "@metamask/utils";
 // This package purposefully relies on Node's EventEmitter module.
 // eslint-disable-next-line import-x/no-nodejs-modules
 import { EventEmitter } from "events";
@@ -47,11 +47,12 @@ import { ResimulateHelper, hasSimulationDataChanged, shouldResimulate } from "./
 import { ExtraTransactionsPublishHook } from "./hooks/ExtraTransactionsPublishHook.mjs";
 import { projectLogger as log } from "./logger.mjs";
 import { TransactionEnvelopeType, TransactionType, TransactionStatus, SimulationErrorCode, GasFeeEstimateLevel } from "./types.mjs";
-import { addTransactionBatch, ERROR_MESSAGE_NO_UPGRADE_CONTRACT, isAtomicBatchSupported } from "./utils/batch.mjs";
-import { DELEGATION_PREFIX, doesChainSupportEIP7702, ERROR_MESSGE_PUBLIC_KEY, generateEIP7702BatchTransaction, getDelegationAddress, signAuthorizationList } from "./utils/eip7702.mjs";
+import { getBalanceChanges } from "./utils/balance-changes.mjs";
+import { addTransactionBatch, isAtomicBatchSupported } from "./utils/batch.mjs";
+import { generateEIP7702BatchTransaction, getDelegationAddress, signAuthorizationList } from "./utils/eip7702.mjs";
 import { validateConfirmedExternalTransaction } from "./utils/external-transactions.mjs";
-import { getEIP7702UpgradeContractAddress } from "./utils/feature-flags.mjs";
 import { addGasBuffer, estimateGas, updateGas } from "./utils/gas.mjs";
+import { getGasFeeTokens } from "./utils/gas-fee-tokens.mjs";
 import { updateGasFees } from "./utils/gas-fees.mjs";
 import { getGasFeeFlow } from "./utils/gas-flow.mjs";
 import { addInitialHistorySnapshot, updateTransactionHistory } from "./utils/history.mjs";
@@ -59,7 +60,6 @@ import { getTransactionLayer1GasFee, updateTransactionLayer1GasFee } from "./uti
 import { getAndFormatTransactionsForNonceTracker, getNextNonce } from "./utils/nonce.mjs";
 import { prepareTransaction, serializeTransaction } from "./utils/prepare.mjs";
 import { getTransactionParamsWithIncreasedGasFee } from "./utils/retry.mjs";
-import { getSimulationData } from "./utils/simulation.mjs";
 import { updatePostTransactionBalance, updateSwapsTransaction } from "./utils/swaps.mjs";
 import { determineTransactionType } from "./utils/transaction-type.mjs";
 import { normalizeTransactionParams, isEIP1559Transaction, validateGasValues, validateIfTransactionUnapproved, normalizeTxError, normalizeGasFeeValues, setEnvelopeType } from "./utils/utils.mjs";
@@ -2038,7 +2038,7 @@ async function _TransactionController_approveTransaction(transactionId, traceCon
         log('Error fetching account address relationship, skipping first time interaction update', error);
     }
 }, _TransactionController_updateSimulationData = async function _TransactionController_updateSimulationData(transactionMeta, { blockTime, traceContext, } = {}) {
-    const { id: transactionId, simulationData: prevSimulationData } = transactionMeta;
+    const { chainId, id: transactionId, nestedTransactions, networkClientId, simulationData: prevSimulationData, txParams, } = transactionMeta;
     let simulationData = {
         error: {
             code: SimulationErrorCode.Disabled,
@@ -2048,13 +2048,13 @@ async function _TransactionController_approveTransaction(transactionId, traceCon
     };
     let gasFeeTokens = [];
     if (__classPrivateFieldGet(this, _TransactionController_isSimulationEnabled, "f").call(this)) {
-        const result = await __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_getSimulationData).call(this, {
+        simulationData = await __classPrivateFieldGet(this, _TransactionController_trace, "f").call(this, { name: 'Simulate', parentContext: traceContext }, () => getBalanceChanges({
             blockTime,
-            traceContext,
-            transactionMeta,
-        });
-        gasFeeTokens = result?.gasFeeTokens;
-        simulationData = result?.simulationData;
+            chainId,
+            ethQuery: __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_getEthQuery).call(this, { networkClientId }),
+            nestedTransactions,
+            txParams,
+        }));
         if (blockTime &&
             prevSimulationData &&
             hasSimulationDataChanged(prevSimulationData, simulationData)) {
@@ -2063,6 +2063,13 @@ async function _TransactionController_approveTransaction(transactionId, traceCon
                 isUpdatedAfterSecurityCheck: true,
             };
         }
+        gasFeeTokens = await getGasFeeTokens({
+            chainId,
+            isEIP7702GasFeeTokensEnabled: __classPrivateFieldGet(this, _TransactionController_isEIP7702GasFeeTokensEnabled, "f"),
+            messenger: this.messagingSystem,
+            publicKeyEIP7702: __classPrivateFieldGet(this, _TransactionController_publicKeyEIP7702, "f"),
+            transactionMeta,
+        });
     }
     const finalTransactionMeta = __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_getTransaction).call(this, transactionId);
     /* istanbul ignore if */
@@ -2183,50 +2190,5 @@ async function _TransactionController_approveTransaction(transactionId, traceCon
     __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_onTransactionStatusChange).call(this, newTransactionMeta);
     this.messagingSystem.publish(`${controllerName}:transactionFinished`, newTransactionMeta);
     __classPrivateFieldGet(this, _TransactionController_internalEvents, "f").emit(`${transactionMeta.id}:finished`, newTransactionMeta);
-}, _TransactionController_getSimulationData = async function _TransactionController_getSimulationData({ blockTime, traceContext, transactionMeta, }) {
-    const { chainId, delegationAddress, txParams } = transactionMeta;
-    const { authorizationList: authorizationListRequest, data, from, to, value, } = txParams;
-    const authorizationAddress = authorizationListRequest?.[0]?.address;
-    const senderCode = authorizationAddress &&
-        (DELEGATION_PREFIX + remove0x(authorizationAddress));
-    const is7702GasFeeTokensEnabled = await __classPrivateFieldGet(this, _TransactionController_isEIP7702GasFeeTokensEnabled, "f").call(this, transactionMeta);
-    const use7702Fees = is7702GasFeeTokensEnabled &&
-        doesChainSupportEIP7702(chainId, this.messagingSystem);
-    let authorizationList = authorizationListRequest?.map((authorization) => ({
-        address: authorization.address,
-        from: from,
-    }));
-    if (use7702Fees && !delegationAddress && !authorizationList) {
-        authorizationList = __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_getSimulationAuthorizationList).call(this, {
-            chainId,
-            from: from,
-        });
-    }
-    return await __classPrivateFieldGet(this, _TransactionController_trace, "f").call(this, { name: 'Simulate', parentContext: traceContext }, () => getSimulationData({
-        authorizationList,
-        chainId,
-        data: data,
-        from: from,
-        to: to,
-        value: value,
-    }, {
-        blockTime,
-        senderCode,
-        use7702Fees,
-    }));
-}, _TransactionController_getSimulationAuthorizationList = function _TransactionController_getSimulationAuthorizationList({ chainId, from, }) {
-    if (!__classPrivateFieldGet(this, _TransactionController_publicKeyEIP7702, "f")) {
-        throw rpcErrors.internal(ERROR_MESSGE_PUBLIC_KEY);
-    }
-    const upgradeAddress = getEIP7702UpgradeContractAddress(chainId, this.messagingSystem, __classPrivateFieldGet(this, _TransactionController_publicKeyEIP7702, "f"));
-    if (!upgradeAddress) {
-        throw rpcErrors.internal(ERROR_MESSAGE_NO_UPGRADE_CONTRACT);
-    }
-    return [
-        {
-            address: upgradeAddress,
-            from: from,
-        },
-    ];
 };
 //# sourceMappingURL=TransactionController.mjs.map
\ No newline at end of file
diff --git a/dist/api/simulation-api.d.cts b/dist/api/simulation-api.d.cts
index 7321958c90236a6c764ef34985b7d7f84975e53e..b31bb8f04c71aac5d83603dfa7123f23444f6caa 100644
--- a/dist/api/simulation-api.d.cts
+++ b/dist/api/simulation-api.d.cts
@@ -24,11 +24,6 @@ export type SimulationRequestTransaction = {
 };
 /** Request to the simulation API to simulate transactions. */
 export type SimulationRequest = {
-    /**
-     * Transactions to be sequentially simulated.
-     * State changes impact subsequent transactions in the list.
-     */
-    transactions: SimulationRequestTransaction[];
     blockOverrides?: {
         time?: Hex;
     };
@@ -53,11 +48,26 @@ export type SimulationRequest = {
         withFeeTransfer?: boolean;
         withTransfer?: boolean;
     };
+    /**
+     * Transactions to be sequentially simulated.
+     * State changes impact subsequent transactions in the list.
+     */
+    transactions: SimulationRequestTransaction[];
     /**
      * Whether to include call traces in the response.
      * Defaults to false.
      */
     withCallTrace?: boolean;
+    /**
+     * Whether to include the default block data in the simulation.
+     * Defaults to false.
+     */
+    withDefaultBlockOverrides?: boolean;
+    /**
+     * Whether to use the gas fees in the simulation.
+     * Defaults to false.
+     */
+    withGas?: boolean;
     /**
      * Whether to include event logs in the response.
      * Defaults to false.
@@ -114,6 +124,8 @@ export type SimulationResponseTokenFee = {
     feeRecipient: Hex;
     /** Conversation rate of 1 token to native WEI. */
     rateWei: Hex;
+    /** Portion of `balanceNeededToken` that is the fee paid to MetaMask. */
+    serviceFee?: Hex;
     /** Estimated gas limit required for fee transfer. */
     transferEstimate: Hex;
 };
@@ -134,6 +146,11 @@ export type SimulationResponseTransaction = {
         /** Token fee data for the fee level. */
         tokenFees: SimulationResponseTokenFee[];
     }[];
+    /**
+     * Estimated total gas cost of the transaction.
+     * Included in the stateDiff if `withGas` is true.
+     */
+    gasCost?: number;
     /** Required `gasLimit` for the transaction. */
     gasLimit?: Hex;
     /** Total gas used by the transaction. */
diff --git a/dist/api/simulation-api.d.mts b/dist/api/simulation-api.d.mts
index 86256c229d84f5dc89cb5831f72258e32812092f..80fdfb36a72e2f37fcb235038bcfebaeb706742d 100644
--- a/dist/api/simulation-api.d.mts
+++ b/dist/api/simulation-api.d.mts
@@ -24,11 +24,6 @@ export type SimulationRequestTransaction = {
 };
 /** Request to the simulation API to simulate transactions. */
 export type SimulationRequest = {
-    /**
-     * Transactions to be sequentially simulated.
-     * State changes impact subsequent transactions in the list.
-     */
-    transactions: SimulationRequestTransaction[];
     blockOverrides?: {
         time?: Hex;
     };
@@ -53,11 +48,26 @@ export type SimulationRequest = {
         withFeeTransfer?: boolean;
         withTransfer?: boolean;
     };
+    /**
+     * Transactions to be sequentially simulated.
+     * State changes impact subsequent transactions in the list.
+     */
+    transactions: SimulationRequestTransaction[];
     /**
      * Whether to include call traces in the response.
      * Defaults to false.
      */
     withCallTrace?: boolean;
+    /**
+     * Whether to include the default block data in the simulation.
+     * Defaults to false.
+     */
+    withDefaultBlockOverrides?: boolean;
+    /**
+     * Whether to use the gas fees in the simulation.
+     * Defaults to false.
+     */
+    withGas?: boolean;
     /**
      * Whether to include event logs in the response.
      * Defaults to false.
@@ -114,6 +124,8 @@ export type SimulationResponseTokenFee = {
     feeRecipient: Hex;
     /** Conversation rate of 1 token to native WEI. */
     rateWei: Hex;
+    /** Portion of `balanceNeededToken` that is the fee paid to MetaMask. */
+    serviceFee?: Hex;
     /** Estimated gas limit required for fee transfer. */
     transferEstimate: Hex;
 };
@@ -134,6 +146,11 @@ export type SimulationResponseTransaction = {
         /** Token fee data for the fee level. */
         tokenFees: SimulationResponseTokenFee[];
     }[];
+    /**
+     * Estimated total gas cost of the transaction.
+     * Included in the stateDiff if `withGas` is true.
+     */
+    gasCost?: number;
     /** Required `gasLimit` for the transaction. */
     gasLimit?: Hex;
     /** Total gas used by the transaction. */
diff --git a/dist/types.d.cts b/dist/types.d.cts
index 688e2b61f615f8412425f2c50e6704533178d963..839df4fb3515e1c0ee1cd7b2a7a57784e365c6d5 100644
--- a/dist/types.d.cts
+++ b/dist/types.d.cts
@@ -1362,6 +1362,8 @@ export type ValidateSecurityRequest = {
     params: unknown[];
     /** Optional EIP-7702 delegation to mock for the transaction sender. */
     delegationMock?: Hex;
+    /** Origin of the request, such as a dApp hostname or `ORIGIN_METAMASK` if internal. */
+    origin?: string;
 };
 /** Data required to pay for transaction gas using an ERC-20 token. */
 export type GasFeeToken = {
@@ -1371,6 +1373,8 @@ export type GasFeeToken = {
     balance: Hex;
     /** Decimals of the token. */
     decimals: number;
+    /** Portion of the amount that is the fee paid to MetaMask. */
+    fee?: Hex;
     /** Estimated gas limit required for original transaction. */
     gas: Hex;
     /** Estimated gas limit required for fee transfer. */
diff --git a/dist/types.d.mts b/dist/types.d.mts
index 39437379176b51b13bed5ce5aa3d470d8758f760..0c8179598c6e6700abb54b5f4de0cb0246bcae04 100644
--- a/dist/types.d.mts
+++ b/dist/types.d.mts
@@ -1362,6 +1362,8 @@ export type ValidateSecurityRequest = {
     params: unknown[];
     /** Optional EIP-7702 delegation to mock for the transaction sender. */
     delegationMock?: Hex;
+    /** Origin of the request, such as a dApp hostname or `ORIGIN_METAMASK` if internal. */
+    origin?: string;
 };
 /** Data required to pay for transaction gas using an ERC-20 token. */
 export type GasFeeToken = {
@@ -1371,6 +1373,8 @@ export type GasFeeToken = {
     balance: Hex;
     /** Decimals of the token. */
     decimals: number;
+    /** Portion of the amount that is the fee paid to MetaMask. */
+    fee?: Hex;
     /** Estimated gas limit required for original transaction. */
     gas: Hex;
     /** Estimated gas limit required for fee transfer. */
diff --git a/dist/utils/balance-changes.cjs b/dist/utils/balance-changes.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..be05fcbb1c39f70bcf1ab156edb76eb27775b24e
--- /dev/null
+++ b/dist/utils/balance-changes.cjs
@@ -0,0 +1,547 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.getBalanceChanges = exports.SupportedToken = void 0;
+const abi_1 = require("@ethersproject/abi");
+const controller_utils_1 = require("@metamask/controller-utils");
+const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
+const utils_1 = require("@metamask/utils");
+const bn_js_1 = __importDefault(require("bn.js"));
+const simulation_api_1 = require("../api/simulation-api.cjs");
+const constants_1 = require("../constants.cjs");
+const errors_1 = require("../errors.cjs");
+const logger_1 = require("../logger.cjs");
+const types_1 = require("../types.cjs");
+var SupportedToken;
+(function (SupportedToken) {
+    SupportedToken["ERC20"] = "erc20";
+    SupportedToken["ERC721"] = "erc721";
+    SupportedToken["ERC1155"] = "erc1155";
+    SupportedToken["ERC20_WRAPPED"] = "erc20Wrapped";
+    SupportedToken["ERC721_LEGACY"] = "erc721Legacy";
+})(SupportedToken || (exports.SupportedToken = SupportedToken = {}));
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'balance-changes');
+const SUPPORTED_EVENTS = [
+    'Transfer',
+    'TransferSingle',
+    'TransferBatch',
+    'Deposit',
+    'Withdrawal',
+];
+const SUPPORTED_TOKEN_ABIS = {
+    [SupportedToken.ERC20]: {
+        abi: metamask_eth_abis_1.abiERC20,
+        standard: types_1.SimulationTokenStandard.erc20,
+    },
+    [SupportedToken.ERC721]: {
+        abi: metamask_eth_abis_1.abiERC721,
+        standard: types_1.SimulationTokenStandard.erc721,
+    },
+    [SupportedToken.ERC1155]: {
+        abi: metamask_eth_abis_1.abiERC1155,
+        standard: types_1.SimulationTokenStandard.erc1155,
+    },
+    [SupportedToken.ERC20_WRAPPED]: {
+        abi: constants_1.ABI_SIMULATION_ERC20_WRAPPED,
+        standard: types_1.SimulationTokenStandard.erc20,
+    },
+    [SupportedToken.ERC721_LEGACY]: {
+        abi: constants_1.ABI_SIMULATION_ERC721_LEGACY,
+        standard: types_1.SimulationTokenStandard.erc721,
+    },
+};
+const REVERTED_ERRORS = ['execution reverted', 'insufficient funds for gas'];
+/**
+ * Generate simulation data for a transaction.
+ *
+ * @param request - The transaction to simulate.
+ * @param request.chainId - The chain ID of the transaction.
+ * @param request.from - The sender of the transaction.
+ * @param request.to - The recipient of the transaction.
+ * @param request.value - The value of the transaction.
+ * @param request.data - The data of the transaction.
+ * @returns The simulation data.
+ */
+async function getBalanceChanges(request) {
+    log('Request', request);
+    try {
+        const response = await baseRequest({
+            request,
+            params: {
+                withCallTrace: true,
+                withLogs: true,
+            },
+        });
+        const transactionError = response.transactions?.[0]?.error;
+        if (transactionError) {
+            throw new errors_1.SimulationError(transactionError);
+        }
+        const nativeBalanceChange = getNativeBalanceChange(request, response);
+        const events = getEvents(response);
+        log('Parsed events', events);
+        const tokenBalanceChanges = await getTokenBalanceChanges(request, events);
+        const simulationData = {
+            nativeBalanceChange,
+            tokenBalanceChanges,
+        };
+        return simulationData;
+    }
+    catch (error) {
+        log('Failed to get balance changes', error, request);
+        let simulationError = error;
+        if (REVERTED_ERRORS.some((revertErrorMessage) => simulationError.message?.includes(revertErrorMessage))) {
+            simulationError = new errors_1.SimulationRevertedError();
+        }
+        const { code, message } = simulationError;
+        return {
+            tokenBalanceChanges: [],
+            error: {
+                code,
+                message,
+            },
+        };
+    }
+}
+exports.getBalanceChanges = getBalanceChanges;
+/**
+ * Extract the native balance change from a simulation response.
+ *
+ * @param request - Simulation request.
+ * @param response - Simulation response.
+ * @returns Native balance change or undefined if unchanged.
+ */
+function getNativeBalanceChange(request, response) {
+    const transactionResponse = response.transactions[0];
+    /* istanbul ignore next */
+    if (!transactionResponse) {
+        return undefined;
+    }
+    const { txParams } = request;
+    const userAddress = txParams.from;
+    const { stateDiff } = transactionResponse;
+    const previousBalance = stateDiff?.pre?.[userAddress]?.balance;
+    const newBalance = stateDiff?.post?.[userAddress]?.balance;
+    if (!previousBalance || !newBalance) {
+        return undefined;
+    }
+    return getSimulationBalanceChange(previousBalance, newBalance, transactionResponse.gasCost);
+}
+/**
+ * Extract events from a simulation response.
+ *
+ * @param response - The simulation response.
+ * @returns The parsed events.
+ */
+function getEvents(response) {
+    /* istanbul ignore next */
+    const logs = extractLogs(response.transactions[0]?.callTrace ?? {});
+    log('Extracted logs', logs);
+    const interfaces = getContractInterfaces();
+    return logs
+        .map((currentLog) => {
+        const event = parseLog(currentLog, interfaces);
+        if (!event) {
+            log('Failed to parse log', currentLog);
+            return undefined;
+        }
+        /* istanbul ignore next */
+        const inputs = event.abi.find((e) => e.name === event.name)?.inputs;
+        /* istanbul ignore if */
+        if (!inputs) {
+            log('Failed to find inputs for event', event);
+            return undefined;
+        }
+        if (!SUPPORTED_EVENTS.includes(event.name)) {
+            log('Ignoring unsupported event', event.name, event);
+            return undefined;
+        }
+        log('Normalizing event args', event.name, event);
+        const args = normalizeEventArgs(event.args, inputs);
+        return {
+            contractAddress: currentLog.address,
+            tokenStandard: event.standard,
+            name: event.name,
+            args,
+            abi: event.abi,
+        };
+    })
+        .filter((e) => e !== undefined);
+}
+/**
+ * Normalize event arguments using ABI input definitions.
+ *
+ * @param args - The raw event arguments.
+ * @param abiInputs - The ABI input definitions.
+ * @returns The normalized event arguments.
+ */
+function normalizeEventArgs(args, abiInputs) {
+    return args.reduce((result, arg, index) => {
+        const name = abiInputs[index].name.replace('_', '');
+        const value = normalizeEventArgValue(arg);
+        result[name] = value;
+        return result;
+    }, {});
+}
+/**
+ * Normalize an event argument value.
+ *
+ * @param value - The event argument value.
+ * @returns The normalized event argument value.
+ */
+// eslint-disable-next-line @typescript-eslint/no-explicit-any
+function normalizeEventArgValue(value) {
+    if (Array.isArray(value)) {
+        return value.map(normalizeEventArgValue);
+    }
+    let normalizedValue = value;
+    normalizedValue = normalizedValue.toHexString?.() ?? normalizedValue;
+    normalizedValue = normalizedValue.toLowerCase?.() ?? normalizedValue;
+    return normalizedValue;
+}
+/**
+ * Generate token balance changes from parsed events.
+ *
+ * @param request - The transaction that was simulated.
+ * @param events - The parsed events.
+ * @returns An array of token balance changes.
+ */
+async function getTokenBalanceChanges(request, events) {
+    const { txParams } = request;
+    const from = txParams.from;
+    const balanceTxs = getTokenBalanceTransactions(request, events);
+    log('Generated balance transactions', [...balanceTxs.after.values()]);
+    const transactionCount = balanceTxs.before.size + balanceTxs.after.size + 1;
+    if (transactionCount === 1) {
+        return [];
+    }
+    const response = await baseRequest({
+        request,
+        before: [...balanceTxs.before.values()],
+        after: [...balanceTxs.after.values()],
+    });
+    log('Balance simulation response', response);
+    if (response.transactions.length !== transactionCount) {
+        throw new errors_1.SimulationInvalidResponseError();
+    }
+    let prevBalanceTxIndex = 0;
+    return [...balanceTxs.after.keys()]
+        .map((token, index) => {
+        const previousBalanceCheckSkipped = !balanceTxs.before.get(token);
+        const previousBalance = previousBalanceCheckSkipped
+            ? '0x0'
+            : getAmountFromBalanceTransactionResult(from, token, 
+            // eslint-disable-next-line no-plusplus
+            response.transactions[prevBalanceTxIndex++]);
+        const newBalance = getAmountFromBalanceTransactionResult(from, token, response.transactions[index + balanceTxs.before.size + 1]);
+        const balanceChange = getSimulationBalanceChange(previousBalance, newBalance);
+        if (!balanceChange) {
+            return undefined;
+        }
+        return {
+            ...token,
+            ...balanceChange,
+        };
+    })
+        .filter((change) => change !== undefined);
+}
+/**
+ * Generate transactions to check token balances.
+ *
+ * @param request - The transaction that was simulated.
+ * @param events - The parsed events.
+ * @returns A map of token balance transactions keyed by token.
+ */
+function getTokenBalanceTransactions(request, events) {
+    const tokenKeys = new Set();
+    const before = new Map();
+    const after = new Map();
+    const from = request.txParams.from;
+    const userEvents = events.filter((event) => [event.args.from, event.args.to].includes(from));
+    log('Filtered user events', userEvents);
+    for (const event of userEvents) {
+        const tokenIds = getEventTokenIds(event);
+        log('Extracted token IDs', tokenIds);
+        for (const tokenId of tokenIds) {
+            const simulationToken = {
+                address: event.contractAddress,
+                standard: event.tokenStandard,
+                id: tokenId,
+            };
+            const tokenKey = JSON.stringify(simulationToken);
+            if (tokenKeys.has(tokenKey)) {
+                log('Ignoring additional event with same contract and token ID', simulationToken);
+                continue;
+            }
+            tokenKeys.add(tokenKey);
+            const data = getBalanceTransactionData(event.tokenStandard, from, tokenId);
+            const transaction = {
+                from,
+                to: event.contractAddress,
+                data,
+            };
+            if (skipPriorBalanceCheck(event)) {
+                after.set(simulationToken, transaction);
+            }
+            else {
+                before.set(simulationToken, transaction);
+                after.set(simulationToken, transaction);
+            }
+        }
+    }
+    return { before, after };
+}
+/**
+ * Check if an event needs to check the previous balance.
+ *
+ * @param event - The parsed event.
+ * @returns True if the prior balance check should be skipped.
+ */
+function skipPriorBalanceCheck(event) {
+    // In the case of an NFT mint, we cannot check the NFT owner before the mint
+    // as the balance check transaction would revert.
+    return (event.name === 'Transfer' &&
+        event.tokenStandard === types_1.SimulationTokenStandard.erc721 &&
+        parseInt(event.args.from, 16) === 0);
+}
+/**
+ * Extract token IDs from a parsed event.
+ *
+ * @param event - The parsed event.
+ * @returns An array of token IDs.
+ */
+function getEventTokenIds(event) {
+    if (event.tokenStandard === types_1.SimulationTokenStandard.erc721) {
+        return [event.args.tokenId];
+    }
+    if (event.tokenStandard === types_1.SimulationTokenStandard.erc1155 &&
+        event.name === 'TransferSingle') {
+        return [event.args.id];
+    }
+    if (event.tokenStandard === types_1.SimulationTokenStandard.erc1155 &&
+        event.name === 'TransferBatch') {
+        return event.args.ids;
+    }
+    // ERC-20 does not have a token ID so default to undefined.
+    return [undefined];
+}
+/**
+ * Get the interface for a token standard.
+ *
+ * @param tokenStandard - The token standard.
+ * @returns The interface for the token standard.
+ */
+function getContractInterface(tokenStandard) {
+    switch (tokenStandard) {
+        case types_1.SimulationTokenStandard.erc721:
+            return new abi_1.Interface(metamask_eth_abis_1.abiERC721);
+        case types_1.SimulationTokenStandard.erc1155:
+            return new abi_1.Interface(metamask_eth_abis_1.abiERC1155);
+        default:
+            return new abi_1.Interface(metamask_eth_abis_1.abiERC20);
+    }
+}
+/**
+ * Extract the value from a balance transaction response using the correct ABI.
+ *
+ * @param from - The address to check the balance of.
+ * @param token - The token to check the balance of.
+ * @param response - The balance transaction response.
+ * @returns The value of the balance transaction as Hex.
+ */
+function getAmountFromBalanceTransactionResult(from, token, response) {
+    const contract = getContractInterface(token.standard);
+    try {
+        if (token.standard === types_1.SimulationTokenStandard.erc721) {
+            const result = contract.decodeFunctionResult('ownerOf', response.return);
+            const owner = result[0];
+            return owner.toLowerCase() === from.toLowerCase() ? '0x1' : '0x0';
+        }
+        const result = contract.decodeFunctionResult('balanceOf', response.return);
+        return (0, controller_utils_1.toHex)(result[0]);
+    }
+    catch (error) {
+        log('Failed to decode balance transaction', error, { token, response });
+        throw new errors_1.SimulationError(`Failed to decode balance transaction for token ${token.address}: ${String(error)}`);
+    }
+}
+/**
+ * Generate the balance transaction data for a token.
+ *
+ * @param tokenStandard - The token standard.
+ * @param from - The address to check the balance of.
+ * @param tokenId - The token ID to check the balance of.
+ * @returns The balance transaction data.
+ */
+function getBalanceTransactionData(tokenStandard, from, tokenId) {
+    const contract = getContractInterface(tokenStandard);
+    switch (tokenStandard) {
+        case types_1.SimulationTokenStandard.erc721:
+            return contract.encodeFunctionData('ownerOf', [tokenId]);
+        case types_1.SimulationTokenStandard.erc1155:
+            return contract.encodeFunctionData('balanceOf', [from, tokenId]);
+        default:
+            return contract.encodeFunctionData('balanceOf', [from]);
+    }
+}
+/**
+ * Parse a raw event log using known ABIs.
+ *
+ * @param eventLog - The raw event log.
+ * @param interfaces - The contract interfaces.
+ * @returns The parsed event log or undefined if it could not be parsed.
+ */
+function parseLog(eventLog, interfaces) {
+    const supportedTokens = Object.values(SupportedToken);
+    for (const token of supportedTokens) {
+        try {
+            const contractInterface = interfaces.get(token);
+            const { abi, standard } = SUPPORTED_TOKEN_ABIS[token];
+            return {
+                ...contractInterface.parseLog(eventLog),
+                abi,
+                standard,
+            };
+            // Not used
+            // eslint-disable-next-line @typescript-eslint/no-unused-vars
+        }
+        catch (e) {
+            continue;
+        }
+    }
+    return undefined;
+}
+/**
+ * Extract all logs from a call trace tree.
+ *
+ * @param call - The root call trace.
+ * @returns An array of logs.
+ */
+function extractLogs(call) {
+    /* istanbul ignore next */
+    const logs = call.logs ?? [];
+    /* istanbul ignore next */
+    const nestedCalls = call.calls ?? [];
+    return [
+        ...logs,
+        ...nestedCalls.map((nestedCall) => extractLogs(nestedCall)).flat(),
+    ];
+}
+/**
+ * Generate balance change data from previous and new balances.
+ *
+ * @param previousBalance - The previous balance.
+ * @param newBalance - The new balance.
+ * @param offset - Optional offset to apply to the new balance.
+ * @returns The balance change data or undefined if unchanged.
+ */
+function getSimulationBalanceChange(previousBalance, newBalance, offset = 0) {
+    const newBalanceBN = (0, controller_utils_1.hexToBN)(newBalance).add(new bn_js_1.default(offset));
+    const previousBalanceBN = (0, controller_utils_1.hexToBN)(previousBalance);
+    const differenceBN = newBalanceBN.sub(previousBalanceBN);
+    const isDecrease = differenceBN.isNeg();
+    const difference = (0, controller_utils_1.toHex)(differenceBN.abs());
+    if (differenceBN.isZero()) {
+        log('Balance change is zero');
+        return undefined;
+    }
+    return {
+        previousBalance,
+        newBalance: (0, controller_utils_1.toHex)(newBalanceBN),
+        difference,
+        isDecrease,
+    };
+}
+/**
+ * Get the contract interfaces for all supported tokens.
+ *
+ * @returns A map of supported tokens to their contract interfaces.
+ */
+function getContractInterfaces() {
+    const supportedTokens = Object.values(SupportedToken);
+    return new Map(supportedTokens.map((tokenType) => {
+        const { abi } = SUPPORTED_TOKEN_ABIS[tokenType];
+        const contractInterface = new abi_1.Interface(abi);
+        return [tokenType, contractInterface];
+    }));
+}
+/**
+ * Base request to simulation API.
+ *
+ * @param options - Options bag.
+ * @param options.after - Transactions to simulate after user's transaction.
+ * @param options.before - Transactions to simulate before user's transaction.
+ * @param options.params - Additional parameters for the request.
+ * @param options.request - Original request object.
+ * @returns The simulation response.
+ */
+async function baseRequest({ request, params, before = [], after = [], }) {
+    const { blockTime, chainId, ethQuery, txParams } = request;
+    const { authorizationList } = txParams;
+    const from = txParams.from;
+    const authorizationListFinal = authorizationList?.map((authorization) => ({
+        address: authorization.address,
+        from,
+    }));
+    const userTransaction = {
+        authorizationList: authorizationListFinal,
+        data: txParams.data,
+        from: txParams.from,
+        gas: txParams.gas,
+        maxFeePerGas: (txParams.maxFeePerGas ?? txParams.gasPrice),
+        maxPriorityFeePerGas: (txParams.maxPriorityFeePerGas ??
+            txParams.gasPrice),
+        to: txParams.to,
+        value: txParams.value,
+    };
+    const transactions = [...before, userTransaction, ...after];
+    const requiredBalanceBN = getRequiredBalance(request);
+    const requiredBalanceHex = (0, controller_utils_1.toHex)(requiredBalanceBN);
+    log('Required balance', requiredBalanceHex);
+    const currentBalanceHex = (await (0, controller_utils_1.query)(ethQuery, 'getBalance', [
+        from,
+        'latest',
+    ]));
+    const currentBalanceBN = (0, controller_utils_1.hexToBN)(currentBalanceHex);
+    log('Current balance', currentBalanceHex);
+    const isInsufficientBalance = currentBalanceBN.lt(requiredBalanceBN);
+    return await (0, simulation_api_1.simulateTransactions)(chainId, {
+        ...params,
+        transactions,
+        withGas: true,
+        withDefaultBlockOverrides: true,
+        ...(blockTime && {
+            blockOverrides: {
+                ...params?.blockOverrides,
+                time: (0, controller_utils_1.toHex)(blockTime),
+            },
+        }),
+        ...(isInsufficientBalance && {
+            overrides: {
+                ...params?.overrides,
+                [from]: {
+                    ...params?.overrides?.[from],
+                    balance: requiredBalanceHex,
+                },
+            },
+        }),
+    });
+}
+/**
+ * Calculate the required minimum balance for a transaction.
+ *
+ * @param request - The transaction request.
+ * @returns The minimal balance as a BN.
+ */
+function getRequiredBalance(request) {
+    const { txParams } = request;
+    const gasLimit = (0, controller_utils_1.hexToBN)(txParams.gas ?? '0x0');
+    const gasPrice = (0, controller_utils_1.hexToBN)(txParams.maxFeePerGas ?? txParams.gasPrice ?? '0x0');
+    const value = (0, controller_utils_1.hexToBN)(txParams.value ?? '0x0');
+    const nestedValue = (request.nestedTransactions ?? [])
+        .map((tx) => (0, controller_utils_1.hexToBN)(tx.value ?? '0x0'))
+        .reduce((acc, val) => acc.add(val), new bn_js_1.default(0));
+    return gasLimit.mul(gasPrice).add(value).add(nestedValue);
+}
+//# sourceMappingURL=balance-changes.cjs.map
\ No newline at end of file
diff --git a/dist/utils/balance-changes.d.cts b/dist/utils/balance-changes.d.cts
new file mode 100644
index 0000000000000000000000000000000000000000..c4644cf1533af8bfa1b32b04dc9705ff2928df84
--- /dev/null
+++ b/dist/utils/balance-changes.d.cts
@@ -0,0 +1,30 @@
+import type EthQuery from "@metamask/eth-query";
+import { type Hex } from "@metamask/utils";
+import type { SimulationData, TransactionParams, NestedTransactionMetadata } from "../types.cjs";
+export declare enum SupportedToken {
+    ERC20 = "erc20",
+    ERC721 = "erc721",
+    ERC1155 = "erc1155",
+    ERC20_WRAPPED = "erc20Wrapped",
+    ERC721_LEGACY = "erc721Legacy"
+}
+export type GetBalanceChangesRequest = {
+    blockTime?: number;
+    chainId: Hex;
+    ethQuery: EthQuery;
+    nestedTransactions?: NestedTransactionMetadata[];
+    txParams: TransactionParams;
+};
+/**
+ * Generate simulation data for a transaction.
+ *
+ * @param request - The transaction to simulate.
+ * @param request.chainId - The chain ID of the transaction.
+ * @param request.from - The sender of the transaction.
+ * @param request.to - The recipient of the transaction.
+ * @param request.value - The value of the transaction.
+ * @param request.data - The data of the transaction.
+ * @returns The simulation data.
+ */
+export declare function getBalanceChanges(request: GetBalanceChangesRequest): Promise<SimulationData>;
+//# sourceMappingURL=balance-changes.d.cts.map
\ No newline at end of file
diff --git a/dist/utils/balance-changes.d.mts b/dist/utils/balance-changes.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..2f82d4b743409ffd86c3ca8d2c8d7004733ee14b
--- /dev/null
+++ b/dist/utils/balance-changes.d.mts
@@ -0,0 +1,30 @@
+import type EthQuery from "@metamask/eth-query";
+import { type Hex } from "@metamask/utils";
+import type { SimulationData, TransactionParams, NestedTransactionMetadata } from "../types.mjs";
+export declare enum SupportedToken {
+    ERC20 = "erc20",
+    ERC721 = "erc721",
+    ERC1155 = "erc1155",
+    ERC20_WRAPPED = "erc20Wrapped",
+    ERC721_LEGACY = "erc721Legacy"
+}
+export type GetBalanceChangesRequest = {
+    blockTime?: number;
+    chainId: Hex;
+    ethQuery: EthQuery;
+    nestedTransactions?: NestedTransactionMetadata[];
+    txParams: TransactionParams;
+};
+/**
+ * Generate simulation data for a transaction.
+ *
+ * @param request - The transaction to simulate.
+ * @param request.chainId - The chain ID of the transaction.
+ * @param request.from - The sender of the transaction.
+ * @param request.to - The recipient of the transaction.
+ * @param request.value - The value of the transaction.
+ * @param request.data - The data of the transaction.
+ * @returns The simulation data.
+ */
+export declare function getBalanceChanges(request: GetBalanceChangesRequest): Promise<SimulationData>;
+//# sourceMappingURL=balance-changes.d.mts.map
\ No newline at end of file
diff --git a/dist/utils/balance-changes.mjs b/dist/utils/balance-changes.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..a447db241da11d552091bacf32645c4e469cb624
--- /dev/null
+++ b/dist/utils/balance-changes.mjs
@@ -0,0 +1,547 @@
+function $importDefault(module) {
+    if (module?.__esModule) {
+        return module.default;
+    }
+    return module;
+}
+import { Interface } from "@ethersproject/abi";
+import { hexToBN, query, toHex } from "@metamask/controller-utils";
+import { abiERC20, abiERC721, abiERC1155 } from "@metamask/metamask-eth-abis";
+import { createModuleLogger } from "@metamask/utils";
+import $BN from "bn.js";
+const BN = $importDefault($BN);
+import { simulateTransactions } from "../api/simulation-api.mjs";
+import { ABI_SIMULATION_ERC20_WRAPPED, ABI_SIMULATION_ERC721_LEGACY } from "../constants.mjs";
+import { SimulationError, SimulationInvalidResponseError, SimulationRevertedError } from "../errors.mjs";
+import { projectLogger } from "../logger.mjs";
+import { SimulationTokenStandard } from "../types.mjs";
+export var SupportedToken;
+(function (SupportedToken) {
+    SupportedToken["ERC20"] = "erc20";
+    SupportedToken["ERC721"] = "erc721";
+    SupportedToken["ERC1155"] = "erc1155";
+    SupportedToken["ERC20_WRAPPED"] = "erc20Wrapped";
+    SupportedToken["ERC721_LEGACY"] = "erc721Legacy";
+})(SupportedToken || (SupportedToken = {}));
+const log = createModuleLogger(projectLogger, 'balance-changes');
+const SUPPORTED_EVENTS = [
+    'Transfer',
+    'TransferSingle',
+    'TransferBatch',
+    'Deposit',
+    'Withdrawal',
+];
+const SUPPORTED_TOKEN_ABIS = {
+    [SupportedToken.ERC20]: {
+        abi: abiERC20,
+        standard: SimulationTokenStandard.erc20,
+    },
+    [SupportedToken.ERC721]: {
+        abi: abiERC721,
+        standard: SimulationTokenStandard.erc721,
+    },
+    [SupportedToken.ERC1155]: {
+        abi: abiERC1155,
+        standard: SimulationTokenStandard.erc1155,
+    },
+    [SupportedToken.ERC20_WRAPPED]: {
+        abi: ABI_SIMULATION_ERC20_WRAPPED,
+        standard: SimulationTokenStandard.erc20,
+    },
+    [SupportedToken.ERC721_LEGACY]: {
+        abi: ABI_SIMULATION_ERC721_LEGACY,
+        standard: SimulationTokenStandard.erc721,
+    },
+};
+const REVERTED_ERRORS = ['execution reverted', 'insufficient funds for gas'];
+/**
+ * Generate simulation data for a transaction.
+ *
+ * @param request - The transaction to simulate.
+ * @param request.chainId - The chain ID of the transaction.
+ * @param request.from - The sender of the transaction.
+ * @param request.to - The recipient of the transaction.
+ * @param request.value - The value of the transaction.
+ * @param request.data - The data of the transaction.
+ * @returns The simulation data.
+ */
+export async function getBalanceChanges(request) {
+    log('Request', request);
+    try {
+        const response = await baseRequest({
+            request,
+            params: {
+                withCallTrace: true,
+                withLogs: true,
+            },
+        });
+        const transactionError = response.transactions?.[0]?.error;
+        if (transactionError) {
+            throw new SimulationError(transactionError);
+        }
+        const nativeBalanceChange = getNativeBalanceChange(request, response);
+        const events = getEvents(response);
+        log('Parsed events', events);
+        const tokenBalanceChanges = await getTokenBalanceChanges(request, events);
+        const simulationData = {
+            nativeBalanceChange,
+            tokenBalanceChanges,
+        };
+        return simulationData;
+    }
+    catch (error) {
+        log('Failed to get balance changes', error, request);
+        let simulationError = error;
+        if (REVERTED_ERRORS.some((revertErrorMessage) => simulationError.message?.includes(revertErrorMessage))) {
+            simulationError = new SimulationRevertedError();
+        }
+        const { code, message } = simulationError;
+        return {
+            tokenBalanceChanges: [],
+            error: {
+                code,
+                message,
+            },
+        };
+    }
+}
+/**
+ * Extract the native balance change from a simulation response.
+ *
+ * @param request - Simulation request.
+ * @param response - Simulation response.
+ * @returns Native balance change or undefined if unchanged.
+ */
+function getNativeBalanceChange(request, response) {
+    const transactionResponse = response.transactions[0];
+    /* istanbul ignore next */
+    if (!transactionResponse) {
+        return undefined;
+    }
+    const { txParams } = request;
+    const userAddress = txParams.from;
+    const { stateDiff } = transactionResponse;
+    const previousBalance = stateDiff?.pre?.[userAddress]?.balance;
+    const newBalance = stateDiff?.post?.[userAddress]?.balance;
+    if (!previousBalance || !newBalance) {
+        return undefined;
+    }
+    return getSimulationBalanceChange(previousBalance, newBalance, transactionResponse.gasCost);
+}
+/**
+ * Extract events from a simulation response.
+ *
+ * @param response - The simulation response.
+ * @returns The parsed events.
+ */
+function getEvents(response) {
+    /* istanbul ignore next */
+    const logs = extractLogs(response.transactions[0]?.callTrace ?? {});
+    log('Extracted logs', logs);
+    const interfaces = getContractInterfaces();
+    return logs
+        .map((currentLog) => {
+        const event = parseLog(currentLog, interfaces);
+        if (!event) {
+            log('Failed to parse log', currentLog);
+            return undefined;
+        }
+        /* istanbul ignore next */
+        const inputs = event.abi.find((e) => e.name === event.name)?.inputs;
+        /* istanbul ignore if */
+        if (!inputs) {
+            log('Failed to find inputs for event', event);
+            return undefined;
+        }
+        if (!SUPPORTED_EVENTS.includes(event.name)) {
+            log('Ignoring unsupported event', event.name, event);
+            return undefined;
+        }
+        log('Normalizing event args', event.name, event);
+        const args = normalizeEventArgs(event.args, inputs);
+        return {
+            contractAddress: currentLog.address,
+            tokenStandard: event.standard,
+            name: event.name,
+            args,
+            abi: event.abi,
+        };
+    })
+        .filter((e) => e !== undefined);
+}
+/**
+ * Normalize event arguments using ABI input definitions.
+ *
+ * @param args - The raw event arguments.
+ * @param abiInputs - The ABI input definitions.
+ * @returns The normalized event arguments.
+ */
+function normalizeEventArgs(args, abiInputs) {
+    return args.reduce((result, arg, index) => {
+        const name = abiInputs[index].name.replace('_', '');
+        const value = normalizeEventArgValue(arg);
+        result[name] = value;
+        return result;
+    }, {});
+}
+/**
+ * Normalize an event argument value.
+ *
+ * @param value - The event argument value.
+ * @returns The normalized event argument value.
+ */
+// eslint-disable-next-line @typescript-eslint/no-explicit-any
+function normalizeEventArgValue(value) {
+    if (Array.isArray(value)) {
+        return value.map(normalizeEventArgValue);
+    }
+    let normalizedValue = value;
+    normalizedValue = normalizedValue.toHexString?.() ?? normalizedValue;
+    normalizedValue = normalizedValue.toLowerCase?.() ?? normalizedValue;
+    return normalizedValue;
+}
+/**
+ * Generate token balance changes from parsed events.
+ *
+ * @param request - The transaction that was simulated.
+ * @param events - The parsed events.
+ * @returns An array of token balance changes.
+ */
+async function getTokenBalanceChanges(request, events) {
+    const { txParams } = request;
+    const from = txParams.from;
+    const balanceTxs = getTokenBalanceTransactions(request, events);
+    log('Generated balance transactions', [...balanceTxs.after.values()]);
+    const transactionCount = balanceTxs.before.size + balanceTxs.after.size + 1;
+    if (transactionCount === 1) {
+        return [];
+    }
+    const response = await baseRequest({
+        request,
+        before: [...balanceTxs.before.values()],
+        after: [...balanceTxs.after.values()],
+    });
+    log('Balance simulation response', response);
+    if (response.transactions.length !== transactionCount) {
+        throw new SimulationInvalidResponseError();
+    }
+    let prevBalanceTxIndex = 0;
+    return [...balanceTxs.after.keys()]
+        .map((token, index) => {
+        const previousBalanceCheckSkipped = !balanceTxs.before.get(token);
+        const previousBalance = previousBalanceCheckSkipped
+            ? '0x0'
+            : getAmountFromBalanceTransactionResult(from, token, 
+            // eslint-disable-next-line no-plusplus
+            response.transactions[prevBalanceTxIndex++]);
+        const newBalance = getAmountFromBalanceTransactionResult(from, token, response.transactions[index + balanceTxs.before.size + 1]);
+        const balanceChange = getSimulationBalanceChange(previousBalance, newBalance);
+        if (!balanceChange) {
+            return undefined;
+        }
+        return {
+            ...token,
+            ...balanceChange,
+        };
+    })
+        .filter((change) => change !== undefined);
+}
+/**
+ * Generate transactions to check token balances.
+ *
+ * @param request - The transaction that was simulated.
+ * @param events - The parsed events.
+ * @returns A map of token balance transactions keyed by token.
+ */
+function getTokenBalanceTransactions(request, events) {
+    const tokenKeys = new Set();
+    const before = new Map();
+    const after = new Map();
+    const from = request.txParams.from;
+    const userEvents = events.filter((event) => [event.args.from, event.args.to].includes(from));
+    log('Filtered user events', userEvents);
+    for (const event of userEvents) {
+        const tokenIds = getEventTokenIds(event);
+        log('Extracted token IDs', tokenIds);
+        for (const tokenId of tokenIds) {
+            const simulationToken = {
+                address: event.contractAddress,
+                standard: event.tokenStandard,
+                id: tokenId,
+            };
+            const tokenKey = JSON.stringify(simulationToken);
+            if (tokenKeys.has(tokenKey)) {
+                log('Ignoring additional event with same contract and token ID', simulationToken);
+                continue;
+            }
+            tokenKeys.add(tokenKey);
+            const data = getBalanceTransactionData(event.tokenStandard, from, tokenId);
+            const transaction = {
+                from,
+                to: event.contractAddress,
+                data,
+            };
+            if (skipPriorBalanceCheck(event)) {
+                after.set(simulationToken, transaction);
+            }
+            else {
+                before.set(simulationToken, transaction);
+                after.set(simulationToken, transaction);
+            }
+        }
+    }
+    return { before, after };
+}
+/**
+ * Check if an event needs to check the previous balance.
+ *
+ * @param event - The parsed event.
+ * @returns True if the prior balance check should be skipped.
+ */
+function skipPriorBalanceCheck(event) {
+    // In the case of an NFT mint, we cannot check the NFT owner before the mint
+    // as the balance check transaction would revert.
+    return (event.name === 'Transfer' &&
+        event.tokenStandard === SimulationTokenStandard.erc721 &&
+        parseInt(event.args.from, 16) === 0);
+}
+/**
+ * Extract token IDs from a parsed event.
+ *
+ * @param event - The parsed event.
+ * @returns An array of token IDs.
+ */
+function getEventTokenIds(event) {
+    if (event.tokenStandard === SimulationTokenStandard.erc721) {
+        return [event.args.tokenId];
+    }
+    if (event.tokenStandard === SimulationTokenStandard.erc1155 &&
+        event.name === 'TransferSingle') {
+        return [event.args.id];
+    }
+    if (event.tokenStandard === SimulationTokenStandard.erc1155 &&
+        event.name === 'TransferBatch') {
+        return event.args.ids;
+    }
+    // ERC-20 does not have a token ID so default to undefined.
+    return [undefined];
+}
+/**
+ * Get the interface for a token standard.
+ *
+ * @param tokenStandard - The token standard.
+ * @returns The interface for the token standard.
+ */
+function getContractInterface(tokenStandard) {
+    switch (tokenStandard) {
+        case SimulationTokenStandard.erc721:
+            return new Interface(abiERC721);
+        case SimulationTokenStandard.erc1155:
+            return new Interface(abiERC1155);
+        default:
+            return new Interface(abiERC20);
+    }
+}
+/**
+ * Extract the value from a balance transaction response using the correct ABI.
+ *
+ * @param from - The address to check the balance of.
+ * @param token - The token to check the balance of.
+ * @param response - The balance transaction response.
+ * @returns The value of the balance transaction as Hex.
+ */
+function getAmountFromBalanceTransactionResult(from, token, response) {
+    const contract = getContractInterface(token.standard);
+    try {
+        if (token.standard === SimulationTokenStandard.erc721) {
+            const result = contract.decodeFunctionResult('ownerOf', response.return);
+            const owner = result[0];
+            return owner.toLowerCase() === from.toLowerCase() ? '0x1' : '0x0';
+        }
+        const result = contract.decodeFunctionResult('balanceOf', response.return);
+        return toHex(result[0]);
+    }
+    catch (error) {
+        log('Failed to decode balance transaction', error, { token, response });
+        throw new SimulationError(`Failed to decode balance transaction for token ${token.address}: ${String(error)}`);
+    }
+}
+/**
+ * Generate the balance transaction data for a token.
+ *
+ * @param tokenStandard - The token standard.
+ * @param from - The address to check the balance of.
+ * @param tokenId - The token ID to check the balance of.
+ * @returns The balance transaction data.
+ */
+function getBalanceTransactionData(tokenStandard, from, tokenId) {
+    const contract = getContractInterface(tokenStandard);
+    switch (tokenStandard) {
+        case SimulationTokenStandard.erc721:
+            return contract.encodeFunctionData('ownerOf', [tokenId]);
+        case SimulationTokenStandard.erc1155:
+            return contract.encodeFunctionData('balanceOf', [from, tokenId]);
+        default:
+            return contract.encodeFunctionData('balanceOf', [from]);
+    }
+}
+/**
+ * Parse a raw event log using known ABIs.
+ *
+ * @param eventLog - The raw event log.
+ * @param interfaces - The contract interfaces.
+ * @returns The parsed event log or undefined if it could not be parsed.
+ */
+function parseLog(eventLog, interfaces) {
+    const supportedTokens = Object.values(SupportedToken);
+    for (const token of supportedTokens) {
+        try {
+            const contractInterface = interfaces.get(token);
+            const { abi, standard } = SUPPORTED_TOKEN_ABIS[token];
+            return {
+                ...contractInterface.parseLog(eventLog),
+                abi,
+                standard,
+            };
+            // Not used
+            // eslint-disable-next-line @typescript-eslint/no-unused-vars
+        }
+        catch (e) {
+            continue;
+        }
+    }
+    return undefined;
+}
+/**
+ * Extract all logs from a call trace tree.
+ *
+ * @param call - The root call trace.
+ * @returns An array of logs.
+ */
+function extractLogs(call) {
+    /* istanbul ignore next */
+    const logs = call.logs ?? [];
+    /* istanbul ignore next */
+    const nestedCalls = call.calls ?? [];
+    return [
+        ...logs,
+        ...nestedCalls.map((nestedCall) => extractLogs(nestedCall)).flat(),
+    ];
+}
+/**
+ * Generate balance change data from previous and new balances.
+ *
+ * @param previousBalance - The previous balance.
+ * @param newBalance - The new balance.
+ * @param offset - Optional offset to apply to the new balance.
+ * @returns The balance change data or undefined if unchanged.
+ */
+function getSimulationBalanceChange(previousBalance, newBalance, offset = 0) {
+    const newBalanceBN = hexToBN(newBalance).add(new BN(offset));
+    const previousBalanceBN = hexToBN(previousBalance);
+    const differenceBN = newBalanceBN.sub(previousBalanceBN);
+    const isDecrease = differenceBN.isNeg();
+    const difference = toHex(differenceBN.abs());
+    if (differenceBN.isZero()) {
+        log('Balance change is zero');
+        return undefined;
+    }
+    return {
+        previousBalance,
+        newBalance: toHex(newBalanceBN),
+        difference,
+        isDecrease,
+    };
+}
+/**
+ * Get the contract interfaces for all supported tokens.
+ *
+ * @returns A map of supported tokens to their contract interfaces.
+ */
+function getContractInterfaces() {
+    const supportedTokens = Object.values(SupportedToken);
+    return new Map(supportedTokens.map((tokenType) => {
+        const { abi } = SUPPORTED_TOKEN_ABIS[tokenType];
+        const contractInterface = new Interface(abi);
+        return [tokenType, contractInterface];
+    }));
+}
+/**
+ * Base request to simulation API.
+ *
+ * @param options - Options bag.
+ * @param options.after - Transactions to simulate after user's transaction.
+ * @param options.before - Transactions to simulate before user's transaction.
+ * @param options.params - Additional parameters for the request.
+ * @param options.request - Original request object.
+ * @returns The simulation response.
+ */
+async function baseRequest({ request, params, before = [], after = [], }) {
+    const { blockTime, chainId, ethQuery, txParams } = request;
+    const { authorizationList } = txParams;
+    const from = txParams.from;
+    const authorizationListFinal = authorizationList?.map((authorization) => ({
+        address: authorization.address,
+        from,
+    }));
+    const userTransaction = {
+        authorizationList: authorizationListFinal,
+        data: txParams.data,
+        from: txParams.from,
+        gas: txParams.gas,
+        maxFeePerGas: (txParams.maxFeePerGas ?? txParams.gasPrice),
+        maxPriorityFeePerGas: (txParams.maxPriorityFeePerGas ??
+            txParams.gasPrice),
+        to: txParams.to,
+        value: txParams.value,
+    };
+    const transactions = [...before, userTransaction, ...after];
+    const requiredBalanceBN = getRequiredBalance(request);
+    const requiredBalanceHex = toHex(requiredBalanceBN);
+    log('Required balance', requiredBalanceHex);
+    const currentBalanceHex = (await query(ethQuery, 'getBalance', [
+        from,
+        'latest',
+    ]));
+    const currentBalanceBN = hexToBN(currentBalanceHex);
+    log('Current balance', currentBalanceHex);
+    const isInsufficientBalance = currentBalanceBN.lt(requiredBalanceBN);
+    return await simulateTransactions(chainId, {
+        ...params,
+        transactions,
+        withGas: true,
+        withDefaultBlockOverrides: true,
+        ...(blockTime && {
+            blockOverrides: {
+                ...params?.blockOverrides,
+                time: toHex(blockTime),
+            },
+        }),
+        ...(isInsufficientBalance && {
+            overrides: {
+                ...params?.overrides,
+                [from]: {
+                    ...params?.overrides?.[from],
+                    balance: requiredBalanceHex,
+                },
+            },
+        }),
+    });
+}
+/**
+ * Calculate the required minimum balance for a transaction.
+ *
+ * @param request - The transaction request.
+ * @returns The minimal balance as a BN.
+ */
+function getRequiredBalance(request) {
+    const { txParams } = request;
+    const gasLimit = hexToBN(txParams.gas ?? '0x0');
+    const gasPrice = hexToBN(txParams.maxFeePerGas ?? txParams.gasPrice ?? '0x0');
+    const value = hexToBN(txParams.value ?? '0x0');
+    const nestedValue = (request.nestedTransactions ?? [])
+        .map((tx) => hexToBN(tx.value ?? '0x0'))
+        .reduce((acc, val) => acc.add(val), new BN(0));
+    return gasLimit.mul(gasPrice).add(value).add(nestedValue);
+}
+//# sourceMappingURL=balance-changes.mjs.map
\ No newline at end of file
diff --git a/dist/utils/batch.cjs b/dist/utils/batch.cjs
index a22b250a46958d1baf6e7dc35b22768f1df8ad03..a1260cb446884f5a185a180f5880fa62b4cd3ea8 100644
--- a/dist/utils/batch.cjs
+++ b/dist/utils/batch.cjs
@@ -147,6 +147,7 @@ async function addTransactionBatchWith7702(request) {
                 },
             ],
             delegationMock: txParams.authorizationList?.[0]?.address,
+            origin,
         };
         log('Security request', securityRequest);
         validateSecurity(securityRequest, chainId).catch((error) => {
diff --git a/dist/utils/batch.mjs b/dist/utils/batch.mjs
index 3b3a2fb60142754598a17a264b06265514167207..9e51b0c13be834868a0b2ff1b59f2bd63f88e607 100644
--- a/dist/utils/batch.mjs
+++ b/dist/utils/batch.mjs
@@ -142,6 +142,7 @@ async function addTransactionBatchWith7702(request) {
                 },
             ],
             delegationMock: txParams.authorizationList?.[0]?.address,
+            origin,
         };
         log('Security request', securityRequest);
         validateSecurity(securityRequest, chainId).catch((error) => {
diff --git a/dist/utils/gas-fee-tokens.cjs b/dist/utils/gas-fee-tokens.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..e67898cab6c3efb96cc4b62f6aea09f65718ab00
--- /dev/null
+++ b/dist/utils/gas-fee-tokens.cjs
@@ -0,0 +1,123 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.getGasFeeTokens = void 0;
+const rpc_errors_1 = require("@metamask/rpc-errors");
+const utils_1 = require("@metamask/utils");
+const batch_1 = require("./batch.cjs");
+const eip7702_1 = require("./eip7702.cjs");
+const feature_flags_1 = require("./feature-flags.cjs");
+const simulation_api_1 = require("../api/simulation-api.cjs");
+const logger_1 = require("../logger.cjs");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas-fee-tokens');
+/**
+ * Get gas fee tokens for a transaction.
+ *
+ * @param request - The request object.
+ * @param request.chainId - The chain ID of the transaction.
+ * @param request.isEIP7702GasFeeTokensEnabled - Callback to check if EIP-7702 gas fee tokens are enabled.
+ * @param request.messenger - The messenger instance.
+ * @param request.publicKeyEIP7702 - Public key to validate EIP-7702 contract signatures.
+ * @param request.transactionMeta - The transaction metadata.
+ * @returns An array of gas fee tokens.
+ */
+async function getGasFeeTokens({ chainId, isEIP7702GasFeeTokensEnabled, messenger, publicKeyEIP7702, transactionMeta, }) {
+    const { delegationAddress, txParams } = transactionMeta;
+    const { authorizationList: authorizationListRequest } = txParams;
+    const data = txParams.data;
+    const from = txParams.from;
+    const to = txParams.to;
+    const value = txParams.value;
+    log('Request', { chainId, txParams });
+    const is7702GasFeeTokensEnabled = await isEIP7702GasFeeTokensEnabled(transactionMeta);
+    const with7702 = is7702GasFeeTokensEnabled && (0, eip7702_1.doesChainSupportEIP7702)(chainId, messenger);
+    let authorizationList = authorizationListRequest?.map((authorization) => ({
+        address: authorization.address,
+        from: from,
+    }));
+    if (with7702 && !delegationAddress && !authorizationList) {
+        authorizationList = buildAuthorizationList({
+            chainId,
+            from: from,
+            messenger,
+            publicKeyEIP7702,
+        });
+    }
+    try {
+        const response = await (0, simulation_api_1.simulateTransactions)(chainId, {
+            transactions: [
+                {
+                    authorizationList,
+                    data,
+                    from,
+                    to,
+                    value,
+                },
+            ],
+            suggestFees: {
+                withTransfer: true,
+                withFeeTransfer: true,
+                with7702,
+            },
+        });
+        log('Response', response);
+        const result = parseGasFeeTokens(response);
+        log('Gas fee tokens', result);
+        return result;
+    }
+    catch (error) {
+        log('Failed to gas fee tokens', error);
+        return [];
+    }
+}
+exports.getGasFeeTokens = getGasFeeTokens;
+/**
+ * Extract gas fee tokens from a simulation response.
+ *
+ * @param response - The simulation response.
+ * @returns An array of gas fee tokens.
+ */
+function parseGasFeeTokens(response) {
+    const feeLevel = response.transactions?.[0]
+        ?.fees?.[0];
+    const tokenFees = feeLevel?.tokenFees ?? [];
+    return tokenFees.map((tokenFee) => ({
+        amount: tokenFee.balanceNeededToken,
+        balance: tokenFee.currentBalanceToken,
+        decimals: tokenFee.token.decimals,
+        fee: tokenFee.serviceFee,
+        gas: feeLevel.gas,
+        gasTransfer: tokenFee.transferEstimate,
+        maxFeePerGas: feeLevel.maxFeePerGas,
+        maxPriorityFeePerGas: feeLevel.maxPriorityFeePerGas,
+        rateWei: tokenFee.rateWei,
+        recipient: tokenFee.feeRecipient,
+        symbol: tokenFee.token.symbol,
+        tokenAddress: tokenFee.token.address,
+    }));
+}
+/**
+ * Generate the authorization list for the request.
+ *
+ * @param request - The request object.
+ * @param request.chainId - The chain ID.
+ * @param request.from - The sender's address.
+ * @param request.messenger - The messenger instance.
+ * @param request.publicKeyEIP7702 - The public key for EIP-7702.
+ * @returns The authorization list.
+ */
+function buildAuthorizationList({ chainId, from, messenger, publicKeyEIP7702, }) {
+    if (!publicKeyEIP7702) {
+        throw rpc_errors_1.rpcErrors.internal(eip7702_1.ERROR_MESSGE_PUBLIC_KEY);
+    }
+    const upgradeAddress = (0, feature_flags_1.getEIP7702UpgradeContractAddress)(chainId, messenger, publicKeyEIP7702);
+    if (!upgradeAddress) {
+        throw rpc_errors_1.rpcErrors.internal(batch_1.ERROR_MESSAGE_NO_UPGRADE_CONTRACT);
+    }
+    return [
+        {
+            address: upgradeAddress,
+            from: from,
+        },
+    ];
+}
+//# sourceMappingURL=gas-fee-tokens.cjs.map
\ No newline at end of file
diff --git a/dist/utils/gas-fee-tokens.d.cts b/dist/utils/gas-fee-tokens.d.cts
new file mode 100644
index 0000000000000000000000000000000000000000..b9081fe061605e4b2061010eaccc60266f5ab506
--- /dev/null
+++ b/dist/utils/gas-fee-tokens.d.cts
@@ -0,0 +1,22 @@
+import type { Hex } from "@metamask/utils";
+import type { GasFeeToken, TransactionControllerMessenger, TransactionMeta } from "../index.cjs";
+export type GetGasFeeTokensRequest = {
+    chainId: Hex;
+    isEIP7702GasFeeTokensEnabled: (transactionMeta: TransactionMeta) => Promise<boolean>;
+    messenger: TransactionControllerMessenger;
+    publicKeyEIP7702?: Hex;
+    transactionMeta: TransactionMeta;
+};
+/**
+ * Get gas fee tokens for a transaction.
+ *
+ * @param request - The request object.
+ * @param request.chainId - The chain ID of the transaction.
+ * @param request.isEIP7702GasFeeTokensEnabled - Callback to check if EIP-7702 gas fee tokens are enabled.
+ * @param request.messenger - The messenger instance.
+ * @param request.publicKeyEIP7702 - Public key to validate EIP-7702 contract signatures.
+ * @param request.transactionMeta - The transaction metadata.
+ * @returns An array of gas fee tokens.
+ */
+export declare function getGasFeeTokens({ chainId, isEIP7702GasFeeTokensEnabled, messenger, publicKeyEIP7702, transactionMeta, }: GetGasFeeTokensRequest): Promise<GasFeeToken[]>;
+//# sourceMappingURL=gas-fee-tokens.d.cts.map
\ No newline at end of file
diff --git a/dist/utils/gas-fee-tokens.d.mts b/dist/utils/gas-fee-tokens.d.mts
new file mode 100644
index 0000000000000000000000000000000000000000..1d1151204e554facb94a2760bff2bda9cfbadf37
--- /dev/null
+++ b/dist/utils/gas-fee-tokens.d.mts
@@ -0,0 +1,22 @@
+import type { Hex } from "@metamask/utils";
+import type { GasFeeToken, TransactionControllerMessenger, TransactionMeta } from "../index.mjs";
+export type GetGasFeeTokensRequest = {
+    chainId: Hex;
+    isEIP7702GasFeeTokensEnabled: (transactionMeta: TransactionMeta) => Promise<boolean>;
+    messenger: TransactionControllerMessenger;
+    publicKeyEIP7702?: Hex;
+    transactionMeta: TransactionMeta;
+};
+/**
+ * Get gas fee tokens for a transaction.
+ *
+ * @param request - The request object.
+ * @param request.chainId - The chain ID of the transaction.
+ * @param request.isEIP7702GasFeeTokensEnabled - Callback to check if EIP-7702 gas fee tokens are enabled.
+ * @param request.messenger - The messenger instance.
+ * @param request.publicKeyEIP7702 - Public key to validate EIP-7702 contract signatures.
+ * @param request.transactionMeta - The transaction metadata.
+ * @returns An array of gas fee tokens.
+ */
+export declare function getGasFeeTokens({ chainId, isEIP7702GasFeeTokensEnabled, messenger, publicKeyEIP7702, transactionMeta, }: GetGasFeeTokensRequest): Promise<GasFeeToken[]>;
+//# sourceMappingURL=gas-fee-tokens.d.mts.map
\ No newline at end of file
diff --git a/dist/utils/gas-fee-tokens.mjs b/dist/utils/gas-fee-tokens.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..5839cfa04c1920d28022b387ead07304684dbf2b
--- /dev/null
+++ b/dist/utils/gas-fee-tokens.mjs
@@ -0,0 +1,119 @@
+import { rpcErrors } from "@metamask/rpc-errors";
+import { createModuleLogger } from "@metamask/utils";
+import { ERROR_MESSAGE_NO_UPGRADE_CONTRACT } from "./batch.mjs";
+import { ERROR_MESSGE_PUBLIC_KEY, doesChainSupportEIP7702 } from "./eip7702.mjs";
+import { getEIP7702UpgradeContractAddress } from "./feature-flags.mjs";
+import { simulateTransactions } from "../api/simulation-api.mjs";
+import { projectLogger } from "../logger.mjs";
+const log = createModuleLogger(projectLogger, 'gas-fee-tokens');
+/**
+ * Get gas fee tokens for a transaction.
+ *
+ * @param request - The request object.
+ * @param request.chainId - The chain ID of the transaction.
+ * @param request.isEIP7702GasFeeTokensEnabled - Callback to check if EIP-7702 gas fee tokens are enabled.
+ * @param request.messenger - The messenger instance.
+ * @param request.publicKeyEIP7702 - Public key to validate EIP-7702 contract signatures.
+ * @param request.transactionMeta - The transaction metadata.
+ * @returns An array of gas fee tokens.
+ */
+export async function getGasFeeTokens({ chainId, isEIP7702GasFeeTokensEnabled, messenger, publicKeyEIP7702, transactionMeta, }) {
+    const { delegationAddress, txParams } = transactionMeta;
+    const { authorizationList: authorizationListRequest } = txParams;
+    const data = txParams.data;
+    const from = txParams.from;
+    const to = txParams.to;
+    const value = txParams.value;
+    log('Request', { chainId, txParams });
+    const is7702GasFeeTokensEnabled = await isEIP7702GasFeeTokensEnabled(transactionMeta);
+    const with7702 = is7702GasFeeTokensEnabled && doesChainSupportEIP7702(chainId, messenger);
+    let authorizationList = authorizationListRequest?.map((authorization) => ({
+        address: authorization.address,
+        from: from,
+    }));
+    if (with7702 && !delegationAddress && !authorizationList) {
+        authorizationList = buildAuthorizationList({
+            chainId,
+            from: from,
+            messenger,
+            publicKeyEIP7702,
+        });
+    }
+    try {
+        const response = await simulateTransactions(chainId, {
+            transactions: [
+                {
+                    authorizationList,
+                    data,
+                    from,
+                    to,
+                    value,
+                },
+            ],
+            suggestFees: {
+                withTransfer: true,
+                withFeeTransfer: true,
+                with7702,
+            },
+        });
+        log('Response', response);
+        const result = parseGasFeeTokens(response);
+        log('Gas fee tokens', result);
+        return result;
+    }
+    catch (error) {
+        log('Failed to gas fee tokens', error);
+        return [];
+    }
+}
+/**
+ * Extract gas fee tokens from a simulation response.
+ *
+ * @param response - The simulation response.
+ * @returns An array of gas fee tokens.
+ */
+function parseGasFeeTokens(response) {
+    const feeLevel = response.transactions?.[0]
+        ?.fees?.[0];
+    const tokenFees = feeLevel?.tokenFees ?? [];
+    return tokenFees.map((tokenFee) => ({
+        amount: tokenFee.balanceNeededToken,
+        balance: tokenFee.currentBalanceToken,
+        decimals: tokenFee.token.decimals,
+        fee: tokenFee.serviceFee,
+        gas: feeLevel.gas,
+        gasTransfer: tokenFee.transferEstimate,
+        maxFeePerGas: feeLevel.maxFeePerGas,
+        maxPriorityFeePerGas: feeLevel.maxPriorityFeePerGas,
+        rateWei: tokenFee.rateWei,
+        recipient: tokenFee.feeRecipient,
+        symbol: tokenFee.token.symbol,
+        tokenAddress: tokenFee.token.address,
+    }));
+}
+/**
+ * Generate the authorization list for the request.
+ *
+ * @param request - The request object.
+ * @param request.chainId - The chain ID.
+ * @param request.from - The sender's address.
+ * @param request.messenger - The messenger instance.
+ * @param request.publicKeyEIP7702 - The public key for EIP-7702.
+ * @returns The authorization list.
+ */
+function buildAuthorizationList({ chainId, from, messenger, publicKeyEIP7702, }) {
+    if (!publicKeyEIP7702) {
+        throw rpcErrors.internal(ERROR_MESSGE_PUBLIC_KEY);
+    }
+    const upgradeAddress = getEIP7702UpgradeContractAddress(chainId, messenger, publicKeyEIP7702);
+    if (!upgradeAddress) {
+        throw rpcErrors.internal(ERROR_MESSAGE_NO_UPGRADE_CONTRACT);
+    }
+    return [
+        {
+            address: upgradeAddress,
+            from: from,
+        },
+    ];
+}
+//# sourceMappingURL=gas-fee-tokens.mjs.map
\ No newline at end of file
