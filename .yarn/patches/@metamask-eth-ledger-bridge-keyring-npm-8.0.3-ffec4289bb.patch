diff --git a/dist/ledger-keyring.cjs b/dist/ledger-keyring.cjs
index ea0e5a32365aa77365aa4aa727498d800248d974..eb76023bbc89a42486240fcfa78e3c31b5e25b3d 100644
--- a/dist/ledger-keyring.cjs
+++ b/dist/ledger-keyring.cjs
@@ -37,6 +37,7 @@ const rlp_1 = require("@ethereumjs/rlp");
 const tx_1 = require("@ethereumjs/tx");
 const ethUtil = __importStar(require("@ethereumjs/util"));
 const eth_sig_util_1 = require("@metamask/eth-sig-util");
+const utils_1 = require("@metamask/utils");
 const buffer_1 = require("buffer");
 const events_1 = require("events");
 const hdkey_1 = __importDefault(require("hdkey"));
@@ -241,7 +242,7 @@ class LedgerKeyring extends events_1.EventEmitter {
             // value. In newer versions the chainId is communicated via the 'Common'
             // object.
             // @ts-expect-error tx.v should be a Buffer, but we are assigning a string
-            tx.v = ethUtil.bufferToHex(tx.getChainId());
+            tx.v = ethUtil.bytesToHex(tx.getChainId());
             // @ts-expect-error tx.r should be a Buffer, but we are assigning a string
             tx.r = '0x00';
             // @ts-expect-error tx.s should be a Buffer, but we are assigning a string
@@ -261,10 +262,10 @@ class LedgerKeyring extends events_1.EventEmitter {
         // Note also that `getMessageToSign` will return valid RLP for all transaction types, whereas the
         // `serialize` method will not for any transaction type except legacy. This is because `serialize` includes
         // empty r, s and v values in the encoded rlp. This is why we use `getMessageToSign` here instead of `serialize`.
-        const messageToSign = tx.getMessageToSign(false);
-        rawTxHex = buffer_1.Buffer.isBuffer(messageToSign)
-            ? messageToSign.toString('hex')
-            : buffer_1.Buffer.from(rlp_1.RLP.encode(messageToSign)).toString('hex');
+        const messageToSign = tx.getMessageToSign();
+        rawTxHex = Array.isArray(messageToSign)
+            ? buffer_1.Buffer.from(rlp_1.RLP.encode(messageToSign)).toString('hex')
+            : (0, utils_1.bytesToHex)(messageToSign);
         return __classPrivateFieldGet(this, _LedgerKeyring_instances, "m", _LedgerKeyring_signTransaction).call(this, address, rawTxHex, (payload) => {
             // Because tx will be immutable, first get a plain javascript object that
             // represents the transaction. Using txData here as it aligns with the
@@ -505,9 +506,7 @@ async function _LedgerKeyring_getPage(increment) {
     return accounts;
 }, _LedgerKeyring_addressFromIndex = function _LedgerKeyring_addressFromIndex(basePath, i) {
     const dkey = this.hdk.derive(`${basePath}/${i}`);
-    const address = ethUtil
-        .publicToAddress(dkey.publicKey, true)
-        .toString('hex');
+    const address = (0, utils_1.remove0x)((0, utils_1.bytesToHex)(ethUtil.publicToAddress(dkey.publicKey, true)));
     return ethUtil.toChecksumAddress(`0x${address}`);
 }, _LedgerKeyring_pathFromAddress = function _LedgerKeyring_pathFromAddress(address) {
     const checksummedAddress = ethUtil.toChecksumAddress(address);
diff --git a/dist/ledger-keyring.mjs b/dist/ledger-keyring.mjs
index 2e13aee8f2f542da554f1749293cabd3cf28ee18..b5ddb1233750645f6641b974d1df8041f56fb57f 100644
--- a/dist/ledger-keyring.mjs
+++ b/dist/ledger-keyring.mjs
@@ -11,11 +11,10 @@ function $importDefault(module) {
     return module;
 }
 import { RLP } from "@ethereumjs/rlp";
-import { TransactionFactory } from "@ethereumjs/tx";
-import $ethereumjstx from "@ethereumjs/tx";
-const { TxData, TypedTransaction } = $ethereumjstx;
+import { TransactionFactory, TypedTransaction, TypedTxData } from "@ethereumjs/tx";
 import * as ethUtil from "@ethereumjs/util";
 import { recoverPersonalSignature, recoverTypedSignature, SignTypedDataVersion, TypedDataUtils } from "@metamask/eth-sig-util";
+import { bytesToHex, remove0x } from "@metamask/utils";
 import { Buffer } from "buffer";
 import { EventEmitter } from "events";
 import $HDKey from "hdkey";
@@ -221,7 +220,7 @@ export class LedgerKeyring extends EventEmitter {
             // value. In newer versions the chainId is communicated via the 'Common'
             // object.
             // @ts-expect-error tx.v should be a Buffer, but we are assigning a string
-            tx.v = ethUtil.bufferToHex(tx.getChainId());
+            tx.v = ethUtil.bytesToHex(tx.getChainId());
             // @ts-expect-error tx.r should be a Buffer, but we are assigning a string
             tx.r = '0x00';
             // @ts-expect-error tx.s should be a Buffer, but we are assigning a string
@@ -241,10 +240,10 @@ export class LedgerKeyring extends EventEmitter {
         // Note also that `getMessageToSign` will return valid RLP for all transaction types, whereas the
         // `serialize` method will not for any transaction type except legacy. This is because `serialize` includes
         // empty r, s and v values in the encoded rlp. This is why we use `getMessageToSign` here instead of `serialize`.
-        const messageToSign = tx.getMessageToSign(false);
-        rawTxHex = Buffer.isBuffer(messageToSign)
-            ? messageToSign.toString('hex')
-            : Buffer.from(RLP.encode(messageToSign)).toString('hex');
+        const messageToSign = tx.getMessageToSign();
+        rawTxHex = Array.isArray(messageToSign)
+            ? Buffer.from(RLP.encode(messageToSign)).toString('hex')
+            : bytesToHex(messageToSign);
         return __classPrivateFieldGet(this, _LedgerKeyring_instances, "m", _LedgerKeyring_signTransaction).call(this, address, rawTxHex, (payload) => {
             // Because tx will be immutable, first get a plain javascript object that
             // represents the transaction. Using txData here as it aligns with the
@@ -484,9 +483,7 @@ async function _LedgerKeyring_getPage(increment) {
     return accounts;
 }, _LedgerKeyring_addressFromIndex = function _LedgerKeyring_addressFromIndex(basePath, i) {
     const dkey = this.hdk.derive(`${basePath}/${i}`);
-    const address = ethUtil
-        .publicToAddress(dkey.publicKey, true)
-        .toString('hex');
+    const address = remove0x(bytesToHex(ethUtil.publicToAddress(dkey.publicKey, true)));
     return ethUtil.toChecksumAddress(`0x${address}`);
 }, _LedgerKeyring_pathFromAddress = function _LedgerKeyring_pathFromAddress(address) {
     const checksummedAddress = ethUtil.toChecksumAddress(address);
diff --git a/package.json b/package.json
index 558c94c0cd8c96c3bea7ce40a095535791e39ef4..7f2787e61e11f64c85c88bc977726c25fc5198d6 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
   "name": "@metamask/eth-ledger-bridge-keyring",
-  "version": "8.0.3",
+  "version": "8.0.4",
   "description": "A MetaMask compatible keyring, for ledger hardware wallets",
   "keywords": [
     "ethereum",
@@ -17,7 +17,6 @@
     "url": "https://github.com/MetaMask/eth-ledger-bridge-keyring.git"
   },
   "license": "ISC",
-  "author": "Bruno Barbieri",
   "exports": {
     ".": {
       "import": {
@@ -48,14 +47,14 @@
   },
   "dependencies": {
     "@ethereumjs/rlp": "^5.0.2",
-    "@ethereumjs/tx": "^4.2.0",
-    "@ethereumjs/util": "^8.1.0",
+    "@ethereumjs/tx": "^5.4.0",
+    "@ethereumjs/util": "^9.1.0",
     "@ledgerhq/hw-app-eth": "^6.42.0",
-    "@metamask/eth-sig-util": "^8.1.2",
+    "@metamask/eth-sig-util": "^8.2.0",
     "hdkey": "^2.1.0"
   },
   "devDependencies": {
-    "@ethereumjs/common": "^3.2.0",
+    "@ethereumjs/common": "^4.4.0",
     "@lavamoat/allow-scripts": "^3.2.1",
     "@lavamoat/preinstall-always-fail": "^2.1.0",
     "@ledgerhq/hw-transport": "^6.31.3",
@@ -63,7 +62,7 @@
     "@ledgerhq/types-devices": "^6.25.3",
     "@ledgerhq/types-live": "^6.52.0",
     "@metamask/auto-changelog": "^3.4.4",
-    "@metamask/utils": "^11.0.1",
+    "@metamask/utils": "^11.1.0",
     "@ts-bridge/cli": "^0.6.1",
     "@types/ethereumjs-tx": "^1.0.1",
     "@types/hdkey": "^2.0.1",
