diff --git a/PATCH.txt b/PATCH.txt
new file mode 100644
index 0000000000000000000000000000000000000000..376255036ca54b83a3f3c3e0277c2666473df30e
--- /dev/null
+++ b/PATCH.txt
@@ -0,0 +1,4 @@
+We remove lookupNetwork from initializeProvider in the network controller to prevent network requests before user onboarding is completed.
+The network lookup is done after onboarding is completed, and when the extension reloads if onboarding has been completed.
+This patch is part of a temporary fix that will be reverted soon to make way for a more permanent solution. https://github.com/MetaMask/metamask-extension/pull/23005
+You can see the changes before compilation on this branch: https://github.com/MetaMask/core/compare/pnf/ext-23622-review?expand=1
diff --git a/dist/NetworkController.cjs b/dist/NetworkController.cjs
index 00b24d49acfd88df1d26ba31dcba47927e2471aa..51c9de66f978190e4b17e57127b4d649288bbacd 100644
--- a/dist/NetworkController.cjs
+++ b/dist/NetworkController.cjs
@@ -46,6 +46,7 @@ const rpc_errors_1 = require("@metamask/rpc-errors");
 const swappable_obj_proxy_1 = require("@metamask/swappable-obj-proxy");
 const utils_1 = require("@metamask/utils");
 const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
+const immer_1 = require("immer");
 const lodash_1 = require("lodash");
 const reselect_1 = require("reselect");
 const URI = __importStar(require("uri-js"));
@@ -300,7 +301,7 @@ function deriveInfuraNetworkNameFromRpcEndpointUrl(rpcEndpointUrl) {
  * @param state - The NetworkController state to verify.
  * @throws if the state is invalid in some way.
  */
-function validateNetworkControllerState(state) {
+function validateInitialState(state) {
     const networkConfigurationEntries = Object.entries(state.networkConfigurationsByChainId);
     const networkClientIds = getAvailableNetworkClientIds(getNetworkConfigurations(state));
     if (networkConfigurationEntries.length === 0) {
@@ -324,12 +325,27 @@ function validateNetworkControllerState(state) {
     if ([...new Set(networkClientIds)].length < networkClientIds.length) {
         throw new Error('NetworkController state has invalid `networkConfigurationsByChainId`: Every RPC endpoint across all network configurations must have a unique `networkClientId`');
     }
-    if (!networkClientIds.includes(state.selectedNetworkClientId)) {
-        throw new Error(
-        // This ESLint rule mistakenly produces an error.
-        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
-        `NetworkController state is invalid: \`selectedNetworkClientId\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration`);
-    }
+}
+/**
+ * Checks that the given initial NetworkController state is internally
+ * consistent similar to `validateInitialState`, but if an anomaly is detected,
+ * it does its best to correct the state and logs an error to Sentry.
+ *
+ * @param state - The NetworkController state to verify.
+ * @param messenger - The NetworkController messenger.
+ * @returns The corrected state.
+ */
+function correctInitialState(state, messenger) {
+    const networkConfigurationsSortedByChainId = getNetworkConfigurations(state).sort((a, b) => a.chainId.localeCompare(b.chainId));
+    const networkClientIds = getAvailableNetworkClientIds(networkConfigurationsSortedByChainId);
+    return (0, immer_1.produce)(state, (newState) => {
+        if (!networkClientIds.includes(state.selectedNetworkClientId)) {
+            const firstNetworkConfiguration = networkConfigurationsSortedByChainId[0];
+            const newSelectedNetworkClientId = firstNetworkConfiguration.rpcEndpoints[firstNetworkConfiguration.defaultRpcEndpointIndex].networkClientId;
+            messenger.call('ErrorReportingService:captureException', new Error(`\`selectedNetworkClientId\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration; correcting to '${newSelectedNetworkClientId}'`));
+            newState.selectedNetworkClientId = newSelectedNetworkClientId;
+        }
+    });
 }
 /**
  * Transforms a map of chain ID to network configuration to a map of network
@@ -361,7 +377,8 @@ class NetworkController extends base_controller_1.BaseController {
             ...getDefaultNetworkControllerState(additionalDefaultNetworks),
             ...state,
         };
-        validateNetworkControllerState(initialState);
+        validateInitialState(initialState);
+        const correctedInitialState = correctInitialState(initialState, messenger);
         if (!infuraProjectId || typeof infuraProjectId !== 'string') {
             throw new Error('Invalid Infura project ID');
         }
@@ -382,7 +399,7 @@ class NetworkController extends base_controller_1.BaseController {
                 },
             },
             messenger,
-            state: initialState,
+            state: correctedInitialState,
         });
         _NetworkController_instances.add(this);
         _NetworkController_ethQuery.set(this, void 0);
@@ -549,7 +566,6 @@ class NetworkController extends base_controller_1.BaseController {
      */
     async initializeProvider() {
         __classPrivateFieldGet(this, _NetworkController_instances, "m", _NetworkController_applyNetworkSelection).call(this, this.state.selectedNetworkClientId);
-        await this.lookupNetwork();
     }
     /**
      * Refreshes the network meta with EIP-1559 support and the network status
diff --git a/dist/NetworkController.mjs b/dist/NetworkController.mjs
index 3a2341a661225d48317c53cbc2e076633eb2157f..230cbcc9a5eebe97813275df4fb5b6e17d8a1481 100644
--- a/dist/NetworkController.mjs
+++ b/dist/NetworkController.mjs
@@ -25,6 +25,7 @@ import { createEventEmitterProxy } from "@metamask/swappable-obj-proxy";
 import { hasProperty, isPlainObject, isStrictHexString } from "@metamask/utils";
 import $deepEqual from "fast-deep-equal";
 const deepEqual = $importDefault($deepEqual);
+import { produce } from "immer";
 import $lodash from "lodash";
 const { cloneDeep } = $lodash;
 import { createSelector } from "reselect";
@@ -276,7 +277,7 @@ function deriveInfuraNetworkNameFromRpcEndpointUrl(rpcEndpointUrl) {
  * @param state - The NetworkController state to verify.
  * @throws if the state is invalid in some way.
  */
-function validateNetworkControllerState(state) {
+function validateInitialState(state) {
     const networkConfigurationEntries = Object.entries(state.networkConfigurationsByChainId);
     const networkClientIds = getAvailableNetworkClientIds(getNetworkConfigurations(state));
     if (networkConfigurationEntries.length === 0) {
@@ -300,12 +301,27 @@ function validateNetworkControllerState(state) {
     if ([...new Set(networkClientIds)].length < networkClientIds.length) {
         throw new Error('NetworkController state has invalid `networkConfigurationsByChainId`: Every RPC endpoint across all network configurations must have a unique `networkClientId`');
     }
-    if (!networkClientIds.includes(state.selectedNetworkClientId)) {
-        throw new Error(
-        // This ESLint rule mistakenly produces an error.
-        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
-        `NetworkController state is invalid: \`selectedNetworkClientId\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration`);
-    }
+}
+/**
+ * Checks that the given initial NetworkController state is internally
+ * consistent similar to `validateInitialState`, but if an anomaly is detected,
+ * it does its best to correct the state and logs an error to Sentry.
+ *
+ * @param state - The NetworkController state to verify.
+ * @param messenger - The NetworkController messenger.
+ * @returns The corrected state.
+ */
+function correctInitialState(state, messenger) {
+    const networkConfigurationsSortedByChainId = getNetworkConfigurations(state).sort((a, b) => a.chainId.localeCompare(b.chainId));
+    const networkClientIds = getAvailableNetworkClientIds(networkConfigurationsSortedByChainId);
+    return produce(state, (newState) => {
+        if (!networkClientIds.includes(state.selectedNetworkClientId)) {
+            const firstNetworkConfiguration = networkConfigurationsSortedByChainId[0];
+            const newSelectedNetworkClientId = firstNetworkConfiguration.rpcEndpoints[firstNetworkConfiguration.defaultRpcEndpointIndex].networkClientId;
+            messenger.call('ErrorReportingService:captureException', new Error(`\`selectedNetworkClientId\` '${state.selectedNetworkClientId}' does not refer to an RPC endpoint within a network configuration; correcting to '${newSelectedNetworkClientId}'`));
+            newState.selectedNetworkClientId = newSelectedNetworkClientId;
+        }
+    });
 }
 /**
  * Transforms a map of chain ID to network configuration to a map of network
@@ -337,7 +353,8 @@ export class NetworkController extends BaseController {
             ...getDefaultNetworkControllerState(additionalDefaultNetworks),
             ...state,
         };
-        validateNetworkControllerState(initialState);
+        validateInitialState(initialState);
+        const correctedInitialState = correctInitialState(initialState, messenger);
         if (!infuraProjectId || typeof infuraProjectId !== 'string') {
             throw new Error('Invalid Infura project ID');
         }
@@ -358,7 +375,7 @@ export class NetworkController extends BaseController {
                 },
             },
             messenger,
-            state: initialState,
+            state: correctedInitialState,
         });
         _NetworkController_instances.add(this);
         _NetworkController_ethQuery.set(this, void 0);
@@ -525,7 +542,6 @@ export class NetworkController extends BaseController {
      */
     async initializeProvider() {
         __classPrivateFieldGet(this, _NetworkController_instances, "m", _NetworkController_applyNetworkSelection).call(this, this.state.selectedNetworkClientId);
-        await this.lookupNetwork();
     }
     /**
      * Refreshes the network meta with EIP-1559 support and the network status
