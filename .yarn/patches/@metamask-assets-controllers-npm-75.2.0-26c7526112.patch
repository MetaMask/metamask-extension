diff --git a/dist/NftController.cjs b/dist/NftController.cjs
index 3c779a50c9de7317867137aaf6f8e27f2d189764..4b65ed7ff2458acf5bb607c773184224232d1c2a 100644
--- a/dist/NftController.cjs
+++ b/dist/NftController.cjs
@@ -13,7 +13,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _NftController_instances, _NftController_mutex, _NftController_selectedAccountId, _NftController_ipfsGateway, _NftController_openSeaEnabled, _NftController_useIpfsSubdomains, _NftController_isIpfsGatewayEnabled, _NftController_onNftAdded, _NftController_onPreferencesControllerStateChange, _NftController_onSelectedAccountChange, _NftController_updateNestedNftState, _NftController_getNftCollectionApi, _NftController_getNftInformationFromApi, _NftController_getNftInformationFromTokenURI, _NftController_getNftURIAndStandard, _NftController_getNftInformation, _NftController_getNftContractInformationFromContract, _NftController_getNftContractInformation, _NftController_addIndividualNft, _NftController_addNftContract, _NftController_removeAndIgnoreIndividualNft, _NftController_removeIndividualNft, _NftController_removeNftContract, _NftController_validateWatchNft, _NftController_getAddressOrSelectedAddress, _NftController_updateNftUpdateForAccount, _NftController_bulkSanitizeNftMetadata, _NftController_sanitizeNftMetadata;
+var _NftController_instances, _NftController_mutex, _NftController_selectedAccountId, _NftController_ipfsGateway, _NftController_displayNftMedia, _NftController_useIpfsSubdomains, _NftController_isIpfsGatewayEnabled, _NftController_onNftAdded, _NftController_onPreferencesControllerStateChange, _NftController_onSelectedAccountChange, _NftController_updateNestedNftState, _NftController_getNftCollectionApi, _NftController_getNftInformationFromApi, _NftController_getNftInformationFromTokenURI, _NftController_getNftURIAndStandard, _NftController_getNftInformation, _NftController_getNftContractInformationFromContract, _NftController_getNftContractInformation, _NftController_addIndividualNft, _NftController_addNftContract, _NftController_removeAndIgnoreIndividualNft, _NftController_removeIndividualNft, _NftController_removeNftContract, _NftController_validateWatchNft, _NftController_getAddressOrSelectedAddress, _NftController_updateNftUpdateForAccount, _NftController_bulkSanitizeNftMetadata, _NftController_sanitizeNftMetadata;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.NftController = exports.getDefaultNftControllerState = void 0;
 const address_1 = require("@ethersproject/address");
@@ -69,7 +69,7 @@ class NftController extends base_controller_1.BaseController {
      *
      * @param options - The controller options.
      * @param options.ipfsGateway - The configured IPFS gateway.
-     * @param options.openSeaEnabled - Controls whether the OpenSea API is used.
+     * @param options.displayNftMedia - Controls whether the NFT API is used.
      * @param options.useIpfsSubdomains - Controls whether IPFS subdomains are used.
      * @param options.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.
      * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data
@@ -77,7 +77,7 @@ class NftController extends base_controller_1.BaseController {
      * @param options.messenger - The messenger.
      * @param options.state - Initial state to set on this controller.
      */
-    constructor({ ipfsGateway = controller_utils_1.IPFS_DEFAULT_GATEWAY_URL, openSeaEnabled = false, useIpfsSubdomains = true, isIpfsGatewayEnabled = true, onNftAdded, messenger, state = {}, }) {
+    constructor({ ipfsGateway = controller_utils_1.IPFS_DEFAULT_GATEWAY_URL, displayNftMedia = false, useIpfsSubdomains = true, isIpfsGatewayEnabled = true, onNftAdded, messenger, state = {}, }) {
         super({
             name: controllerName,
             metadata: nftControllerMetadata,
@@ -91,28 +91,20 @@ class NftController extends base_controller_1.BaseController {
         _NftController_mutex.set(this, new async_mutex_1.Mutex());
         _NftController_selectedAccountId.set(this, void 0);
         _NftController_ipfsGateway.set(this, void 0);
-        _NftController_openSeaEnabled.set(this, void 0);
+        _NftController_displayNftMedia.set(this, void 0);
         _NftController_useIpfsSubdomains.set(this, void 0);
         _NftController_isIpfsGatewayEnabled.set(this, void 0);
         _NftController_onNftAdded.set(this, void 0);
         __classPrivateFieldSet(this, _NftController_selectedAccountId, this.messagingSystem.call('AccountsController:getSelectedAccount').id, "f");
         __classPrivateFieldSet(this, _NftController_ipfsGateway, ipfsGateway, "f");
-        __classPrivateFieldSet(this, _NftController_openSeaEnabled, openSeaEnabled, "f");
+        __classPrivateFieldSet(this, _NftController_displayNftMedia, displayNftMedia, "f");
         __classPrivateFieldSet(this, _NftController_useIpfsSubdomains, useIpfsSubdomains, "f");
         __classPrivateFieldSet(this, _NftController_isIpfsGatewayEnabled, isIpfsGatewayEnabled, "f");
         __classPrivateFieldSet(this, _NftController_onNftAdded, onNftAdded, "f");
-        this.messagingSystem.subscribe('PreferencesController:stateChange', 
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/no-misused-promises
-        __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_onPreferencesControllerStateChange).bind(this));
-        this.messagingSystem.subscribe('AccountsController:selectedEvmAccountChange', 
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/no-misused-promises
-        __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_onSelectedAccountChange).bind(this));
+        this.messagingSystem.subscribe('PreferencesController:stateChange', __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_onPreferencesControllerStateChange).bind(this));
+        this.messagingSystem.subscribe('AccountsController:selectedEvmAccountChange', __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_onSelectedAccountChange).bind(this));
     }
     getNftApi() {
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
         return `${controller_utils_1.NFT_API_BASE_URL}/tokens`;
     }
     /**
@@ -166,14 +158,6 @@ class NftController extends base_controller_1.BaseController {
             source: constants_1.Source.Dapp,
         });
     }
-    /**
-     * Sets an OpenSea API key to retrieve NFT information.
-     *
-     * @param openSeaApiKey - OpenSea API key.
-     */
-    setApiKey(openSeaApiKey) {
-        this.openSeaApiKey = openSeaApiKey;
-    }
     /**
      * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.
      *
@@ -188,7 +172,6 @@ class NftController extends base_controller_1.BaseController {
         try {
             const owner = await this.messagingSystem.call('AssetsContractController:getERC721OwnerOf', nftAddress, tokenId, networkClientId);
             return ownerAddress.toLowerCase() === owner.toLowerCase();
-            // eslint-disable-next-line no-empty
         }
         catch {
             // Ignore ERC-721 contract error
@@ -197,7 +180,6 @@ class NftController extends base_controller_1.BaseController {
         try {
             const balance = await this.messagingSystem.call('AssetsContractController:getERC1155BalanceOf', ownerAddress, nftAddress, tokenId, networkClientId);
             return !balance.isZero();
-            // eslint-disable-next-line no-empty
         }
         catch {
             // Ignore ERC-1155 contract error
@@ -630,26 +612,33 @@ class NftController extends base_controller_1.BaseController {
     }
 }
 exports.NftController = NftController;
-_NftController_mutex = new WeakMap(), _NftController_selectedAccountId = new WeakMap(), _NftController_ipfsGateway = new WeakMap(), _NftController_openSeaEnabled = new WeakMap(), _NftController_useIpfsSubdomains = new WeakMap(), _NftController_isIpfsGatewayEnabled = new WeakMap(), _NftController_onNftAdded = new WeakMap(), _NftController_instances = new WeakSet(), _NftController_onPreferencesControllerStateChange = 
+_NftController_mutex = new WeakMap(), _NftController_selectedAccountId = new WeakMap(), _NftController_ipfsGateway = new WeakMap(), _NftController_displayNftMedia = new WeakMap(), _NftController_useIpfsSubdomains = new WeakMap(), _NftController_isIpfsGatewayEnabled = new WeakMap(), _NftController_onNftAdded = new WeakMap(), _NftController_instances = new WeakSet(), _NftController_onPreferencesControllerStateChange = 
 /**
  * Handles the state change of the preference controller.
  *
  * @param preferencesState - The new state of the preference controller.
  * @param preferencesState.ipfsGateway - The configured IPFS gateway.
- * @param preferencesState.openSeaEnabled - Controls whether the OpenSea API is used.
  * @param preferencesState.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.
+ * @param preferencesState.displayNftMedia - Controls whether the NFT API is used (mobile).
+ * @param preferencesState.openSeaEnabled - Controls whether the NFT API is used (extension).
  */
-async function _NftController_onPreferencesControllerStateChange({ ipfsGateway, openSeaEnabled, isIpfsGatewayEnabled, }) {
+async function _NftController_onPreferencesControllerStateChange({ ipfsGateway, isIpfsGatewayEnabled, displayNftMedia, openSeaEnabled, }) {
     const selectedAccount = this.messagingSystem.call('AccountsController:getSelectedAccount');
     __classPrivateFieldSet(this, _NftController_selectedAccountId, selectedAccount.id, "f");
+    const newDisplayNftMedia = Boolean(displayNftMedia || openSeaEnabled);
+    console.log('AAAAAAKJHADGHKJADJKADK onPreferencesControllerStateChange', {
+        displayNftMedia,
+        openSeaEnabled,
+        newDisplayNftMedia,
+    });
     // Get current state values
     if (__classPrivateFieldGet(this, _NftController_ipfsGateway, "f") !== ipfsGateway ||
-        __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f") !== openSeaEnabled ||
+        __classPrivateFieldGet(this, _NftController_displayNftMedia, "f") !== newDisplayNftMedia ||
         __classPrivateFieldGet(this, _NftController_isIpfsGatewayEnabled, "f") !== isIpfsGatewayEnabled) {
         __classPrivateFieldSet(this, _NftController_ipfsGateway, ipfsGateway, "f");
-        __classPrivateFieldSet(this, _NftController_openSeaEnabled, openSeaEnabled, "f");
+        __classPrivateFieldSet(this, _NftController_displayNftMedia, newDisplayNftMedia, "f");
         __classPrivateFieldSet(this, _NftController_isIpfsGatewayEnabled, isIpfsGatewayEnabled, "f");
-        const needsUpdateNftMetadata = (isIpfsGatewayEnabled && ipfsGateway !== '') || openSeaEnabled;
+        const needsUpdateNftMetadata = (isIpfsGatewayEnabled && ipfsGateway !== '') || newDisplayNftMedia;
         if (needsUpdateNftMetadata && selectedAccount) {
             await __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_updateNftUpdateForAccount).call(this, selectedAccount);
         }
@@ -664,7 +653,7 @@ async function _NftController_onSelectedAccountChange(internalAccount) {
     const oldSelectedAccountId = __classPrivateFieldGet(this, _NftController_selectedAccountId, "f");
     __classPrivateFieldSet(this, _NftController_selectedAccountId, internalAccount.id, "f");
     const needsUpdateNftMetadata = ((__classPrivateFieldGet(this, _NftController_isIpfsGatewayEnabled, "f") && __classPrivateFieldGet(this, _NftController_ipfsGateway, "f") !== '') ||
-        __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f")) &&
+        __classPrivateFieldGet(this, _NftController_displayNftMedia, "f")) &&
         oldSelectedAccountId !== internalAccount.id;
     if (needsUpdateNftMetadata) {
         await __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_updateNftUpdateForAccount).call(this, internalAccount);
@@ -689,7 +678,6 @@ async function _NftController_onSelectedAccountChange(internalAccount) {
     });
 }, _NftController_getNftCollectionApi = function _NftController_getNftCollectionApi() {
     // False negative.
-    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
     return `${controller_utils_1.NFT_API_BASE_URL}/collections`;
 }, _NftController_getNftInformationFromApi = 
 /**
@@ -783,7 +771,7 @@ async function _NftController_getNftInformationFromTokenURI(contractAddress, tok
             tokenURI: tokenURI ?? null,
         };
     }
-    const isDisplayNFTMediaToggleEnabled = __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f");
+    const isDisplayNFTMediaToggleEnabled = __classPrivateFieldGet(this, _NftController_displayNftMedia, "f");
     if (!hasIpfsTokenURI && !isDisplayNFTMediaToggleEnabled) {
         return {
             image: null,
@@ -883,7 +871,7 @@ async function _NftController_getNftInformation(contractAddress, tokenId, networ
     const { configuration: { chainId }, } = this.messagingSystem.call('NetworkController:getNetworkClientById', networkClientId);
     const [blockchainMetadata, nftApiMetadata] = await Promise.all([
         (0, controller_utils_1.safelyExecute)(() => __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_getNftInformationFromTokenURI).call(this, contractAddress, tokenId, networkClientId)),
-        __classPrivateFieldGet(this, _NftController_openSeaEnabled, "f") && chainId === '0x1'
+        __classPrivateFieldGet(this, _NftController_displayNftMedia, "f") && chainId === '0x1'
             ? (0, controller_utils_1.safelyExecute)(() => __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_getNftInformationFromApi).call(this, contractAddress, tokenId))
             : undefined,
     ]);
@@ -933,13 +921,9 @@ async function _NftController_getNftContractInformation(contractAddress, nftMeta
         return {
             address: contractAddress,
             ...blockchainContractData,
-            // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-            // eslint-disable-next-line @typescript-eslint/naming-convention
             schema_name: nftMetadataFromApi?.standard ?? null,
             collection: {
                 name: null,
-                // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-                // eslint-disable-next-line @typescript-eslint/naming-convention
                 image_url: nftMetadataFromApi?.collection?.image ??
                     nftMetadataFromApi?.collection?.imageUrl ??
                     null,
@@ -952,25 +936,13 @@ async function _NftController_getNftContractInformation(contractAddress, nftMeta
     /* istanbul ignore next */
     return {
         address: contractAddress,
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/naming-convention
         asset_contract_type: null,
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/naming-convention
         created_date: null,
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/naming-convention
         schema_name: null,
         symbol: null,
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/naming-convention
         total_supply: null,
         description: null,
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/naming-convention
         external_link: null,
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/naming-convention
         collection: { name: null, image_url: null },
     };
 }, _NftController_addIndividualNft = 
@@ -1066,22 +1038,7 @@ async function _NftController_addNftContract(networkClientId, { tokenAddress, us
         // will be fixed once detection uses networkClientIds
         // get name and symbol if ERC721 then put together the metadata
         const contractInformation = await __classPrivateFieldGet(this, _NftController_instances, "m", _NftController_getNftContractInformation).call(this, checksumHexAddress, nftMetadata, networkClientId);
-        const { 
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/naming-convention
-        asset_contract_type, 
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/naming-convention
-        created_date, symbol, description, 
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/naming-convention
-        external_link, 
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/naming-convention
-        schema_name, 
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
-        // eslint-disable-next-line @typescript-eslint/naming-convention
-        collection: { name, image_url, tokenCount }, } = contractInformation;
+        const { asset_contract_type, created_date, symbol, description, external_link, schema_name, collection: { name, image_url, tokenCount }, } = contractInformation;
         // If the nft is auto-detected we want some valid metadata to be present
         if (source === constants_1.Source.Detected &&
             'address' in contractInformation &&
@@ -1157,7 +1114,6 @@ async function _NftController_addNftContract(networkClientId, { tokenAddress, us
     }
     if (type !== controller_utils_1.ERC721 && type !== controller_utils_1.ERC1155) {
         throw rpc_errors_1.rpcErrors.invalidParams(
-        // TODO: Either fix this lint violation or explain why it's necessary to ignore.
         // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
         `Non NFT asset type ${type} not supported by watchNft`);
     }
diff --git a/dist/NftController.d.cts b/dist/NftController.d.cts
index 4a81bbc26bde41be6f6455eba128ac2b86257f5c..d6fd1f515ee2a0262c4d80bb4b3ae503b2a89312 100644
--- a/dist/NftController.d.cts
+++ b/dist/NftController.d.cts
@@ -23,25 +23,35 @@ type SuggestedNftMeta = {
     origin: string;
 };
 /**
- * @type Nft
+ * Nft
  *
  * NFT representation
- * @property address - Hex address of a ERC721 contract
- * @property description - The NFT description
- * @property image - URI of custom NFT image associated with this tokenId
- * @property name - Name associated with this tokenId and contract address
- * @property tokenId - The NFT identifier
- * @property numberOfSales - Number of sales
- * @property backgroundColor - The background color to be displayed with the item
- * @property imagePreview - URI of a smaller image associated with this NFT
- * @property imageThumbnail - URI of a thumbnail image associated with this NFT
- * @property imageOriginal - URI of the original image associated with this NFT
- * @property animation - URI of a animation associated with this NFT
- * @property animationOriginal - URI of the original animation associated with this NFT
- * @property externalLink - External link containing additional information
- * @property creator - The NFT owner information object
- * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT
- * @property transactionId - Transaction Id associated with the NFT
+ *
+ * address - Hex address of a ERC721 contract
+ *
+ * description - The NFT description
+ *
+ * image - URI of custom NFT image associated with this tokenId
+ *
+ * name - Name associated with this tokenId and contract address
+ *
+ * tokenId - The NFT identifier
+ *
+ * numberOfSales - Number of sales
+ *
+ * backgroundColor - The background color to be displayed with the item
+ *
+ * imagePreview - URI of a smaller image associated with this NFT
+ *
+ * imageThumbnail - URI of a thumbnail image associated with this NFT
+ *
+ * imageOriginal - URI of the original image associated with this NFT
+ * animation - URI of a animation associated with this NFT
+ * animationOriginal - URI of the original animation associated with this NFT
+ * externalLink - External link containing additional information
+ * creator - The NFT owner information object
+ * isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT
+ * transactionId - Transaction Id associated with the NFT
  */
 export type Nft = {
     tokenId: string;
@@ -49,19 +59,29 @@ export type Nft = {
     isCurrentlyOwned?: boolean;
 } & NftMetadata;
 /**
- * @type NftContract
+ * NftContract
  *
  * NFT contract information representation
- * @property name - Contract name
- * @property logo - Contract logo
- * @property address - Contract address
- * @property symbol - Contract symbol
- * @property description - Contract description
- * @property totalSupply - Total supply of NFTs
- * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`
- * @property createdDate - Creation date
- * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`
- * @property externalLink - External link containing additional information
+ *
+ * name - Contract name
+ *
+ * logo - Contract logo
+ *
+ * address - Contract address
+ *
+ * symbol - Contract symbol
+ *
+ * description - Contract description
+ *
+ * totalSupply - Total supply of NFTs
+ *
+ * assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`
+ *
+ * createdDate - Creation date
+ *
+ * schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`
+ *
+ * externalLink - External link containing additional information
  */
 export type NftContract = {
     name?: string;
@@ -76,22 +96,32 @@ export type NftContract = {
     externalLink?: string;
 };
 /**
- * @type NftMetadata
+ * NftMetadata
  *
  * NFT custom information
- * @property name - NFT custom name
- * @property description - The NFT description
- * @property numberOfSales - Number of sales
- * @property backgroundColor - The background color to be displayed with the item
- * @property image - Image custom image URI
- * @property imagePreview - URI of a smaller image associated with this NFT
- * @property imageThumbnail - URI of a thumbnail image associated with this NFT
- * @property imageOriginal - URI of the original image associated with this NFT
- * @property animation - URI of a animation associated with this NFT
- * @property animationOriginal - URI of the original animation associated with this NFT
- * @property externalLink - External link containing additional information
- * @property creator - The NFT owner information object
- * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155
+ *
+ * name - NFT custom name
+ *
+ * description - The NFT description
+ *
+ * numberOfSales - Number of sales
+ *
+ * backgroundColor - The background color to be displayed with the item
+ *
+ * image - Image custom image URI
+ *
+ * imagePreview - URI of a smaller image associated with this NFT
+ *
+ * imageThumbnail - URI of a thumbnail image associated with this NFT
+ *
+ * imageOriginal - URI of the original image associated with this NFT
+ *
+ * animation - URI of a animation associated with this NFT
+ *
+ * animationOriginal - URI of the original animation associated with this NFT
+ * externalLink - External link containing additional information
+ * creator - The NFT owner information object
+ * standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155
  */
 export type NftMetadata = {
     name: string | null;
@@ -119,12 +149,15 @@ export type NftMetadata = {
     chainId?: number;
 };
 /**
- * @type NftControllerState
+ * NftControllerState
  *
  * NFT controller state
- * @property allNftContracts - Object containing NFT contract information
- * @property allNfts - Object containing NFTs per account and network
- * @property ignoredNfts - List of NFTs that should be ignored
+ *
+ * allNftContracts - Object containing NFT contract information
+ *
+ * allNfts - Object containing NFTs per account and network
+ *
+ * ignoredNfts - List of NFTs that should be ignored
  */
 export type NftControllerState = {
     allNftContracts: {
@@ -166,16 +199,12 @@ export declare const getDefaultNftControllerState: () => NftControllerState;
  */
 export declare class NftController extends BaseController<typeof controllerName, NftControllerState, NftControllerMessenger> {
     #private;
-    /**
-     * Optional API key to use with opensea
-     */
-    openSeaApiKey?: string;
     /**
      * Creates an NftController instance.
      *
      * @param options - The controller options.
      * @param options.ipfsGateway - The configured IPFS gateway.
-     * @param options.openSeaEnabled - Controls whether the OpenSea API is used.
+     * @param options.displayNftMedia - Controls whether the NFT API is used.
      * @param options.useIpfsSubdomains - Controls whether IPFS subdomains are used.
      * @param options.isIpfsGatewayEnabled - Controls whether IPFS is enabled or not.
      * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data
@@ -183,9 +212,9 @@ export declare class NftController extends BaseController<typeof controllerName,
      * @param options.messenger - The messenger.
      * @param options.state - Initial state to set on this controller.
      */
-    constructor({ ipfsGateway, openSeaEnabled, useIpfsSubdomains, isIpfsGatewayEnabled, onNftAdded, messenger, state, }: {
+    constructor({ ipfsGateway, displayNftMedia, useIpfsSubdomains, isIpfsGatewayEnabled, onNftAdded, messenger, state, }: {
         ipfsGateway?: string;
-        openSeaEnabled?: boolean;
+        displayNftMedia?: boolean;
         useIpfsSubdomains?: boolean;
         isIpfsGatewayEnabled?: boolean;
         onNftAdded?: (data: {
@@ -216,12 +245,6 @@ export declare class NftController extends BaseController<typeof controllerName,
     watchNft(asset: NftAsset, type: NFTStandardType, origin: string, networkClientId: NetworkClientId, { userAddress, }?: {
         userAddress?: string;
     }): Promise<void>;
-    /**
-     * Sets an OpenSea API key to retrieve NFT information.
-     *
-     * @param openSeaApiKey - OpenSea API key.
-     */
-    setApiKey(openSeaApiKey: string): void;
     /**
      * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.
      *
diff --git a/dist/assetsUtil.cjs b/dist/assetsUtil.cjs
index b3db76c39d78362273ff081d8c8efe30040ffc28..ef98127ba971298200bd2fff5d4b1de2f75a6e85 100644
--- a/dist/assetsUtil.cjs
+++ b/dist/assetsUtil.cjs
@@ -3,6 +3,7 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
 Object.defineProperty(exports, "__esModule", { value: true });
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }
 exports.accountAddressToCaipReference = exports.getKeyByValue = exports.fetchTokenContractExchangeRates = exports.reduceInBatchesSerially = exports.divideIntoBatches = exports.ethersBigNumberToBN = exports.addUrlProtocolPrefix = exports.getFormattedIpfsUrl = exports.getIpfsCIDv1AndPath = exports.removeIpfsProtocolPrefix = exports.isTokenListSupportedForNetwork = exports.isTokenDetectionSupportedForNetwork = exports.SupportedStakedBalanceNetworks = exports.SupportedTokenDetectionNetworks = exports.formatIconUrlWithProxy = exports.formatAggregatorNames = exports.hasNewCollectionFields = exports.compareNftMetadata = exports.TOKEN_PRICES_BATCH_SIZE = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
 const utils_1 = require("@metamask/utils");
@@ -240,7 +241,7 @@ async function getIpfsCIDv1AndPath(ipfsUrl) {
     const index = url.indexOf('/');
     const cid = index !== -1 ? url.substring(0, index) : url;
     const path = index !== -1 ? url.substring(index) : undefined;
-    const { CID } = await import("multiformats");
+    const { CID } = _interopRequireWildcard(require("multiformats"));
     // We want to ensure that the CID is v1 (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats)
     // because most cid v0s appear to be incompatible with IPFS subdomains
     return {
